import { defineComponent as l1, useAttrs as oF, computed as Bp, resolveComponent as sF, createBlock as lF, openBlock as Ra, mergeProps as uF, unref as Hi, withCtx as cF, renderSlot as fF, ref as Rr, onMounted as Lg, onUnmounted as sI, createElementBlock as Do, normalizeStyle as Zu, createCommentVNode as lv, createElementVNode as Sr, reactive as hF, watch as Vp, nextTick as dF, withModifiers as pF, toDisplayString as Mn, normalizeClass as vF, onBeforeUnmount as gF } from "vue";
const mF = /* @__PURE__ */ l1({
  name: "WyButton",
  __name: "Button",
  setup(r) {
    const t = oF(), e = Bp(() => ["wy-button"]), n = (i) => {
      var a;
      typeof t.onClick == "function" && t.onClick(i), console.log("[Button Click]", {
        type: t.type,
        text: (a = i.target.textContent) == null ? void 0 : a.trim()
      });
    };
    return (i, a) => {
      const o = sF("ElButton");
      return Ra(), lF(o, uF(Hi(t), {
        class: [Hi(t).class, e.value],
        onClick: n
      }), {
        default: cF(() => [
          fF(i.$slots, "default", {}, void 0, !0)
        ]),
        _: 3
      }, 16, ["class"]);
    };
  }
}), Rg = (r, t) => {
  const e = r.__vccOpts || r;
  for (const [n, i] of t)
    e[n] = i;
  return e;
}, yF = /* @__PURE__ */ Rg(mF, [["__scopeId", "data-v-1a19201c"]]), Ch = (r) => (r.install = (t) => {
  const e = r.name;
  e && t.component(e, r);
}, r), _F = Ch(yF);
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const u1 = "164", $ut = { ROTATE: 0, DOLLY: 1, PAN: 2 }, Zut = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, xF = 0, Hw = 1, SF = 2, lI = 1, bF = 2, ba = 3, Vo = 0, Sn = 1, Ta = 2, Lo = 0, zu = 1, Ww = 2, Xw = 3, Yw = 4, wF = 5, zs = 100, MF = 101, TF = 102, AF = 103, EF = 104, CF = 200, DF = 201, LF = 202, RF = 203, F_ = 204, z_ = 205, IF = 206, PF = 207, NF = 208, OF = 209, kF = 210, BF = 211, VF = 212, FF = 213, zF = 214, UF = 0, GF = 1, HF = 2, uv = 3, WF = 4, XF = 5, YF = 6, $F = 7, uI = 0, ZF = 1, qF = 2, Ro = 0, KF = 1, jF = 2, JF = 3, QF = 4, tz = 5, ez = 6, rz = 7, cI = 300, qu = 301, Ku = 302, U_ = 303, G_ = 304, Ig = 306, H_ = 1e3, Ys = 1001, W_ = 1002, xn = 1003, nz = 1004, Jh = 1005, pi = 1006, Dm = 1007, $s = 1008, Fo = 1009, iz = 1010, az = 1011, fI = 1012, hI = 1013, ju = 1014, Ea = 1015, Pg = 1016, dI = 1017, pI = 1018, Dh = 1020, oz = 35902, sz = 1021, lz = 1022, Wi = 1023, uz = 1024, cz = 1025, Uu = 1026, Qf = 1027, vI = 1028, gI = 1029, fz = 1030, mI = 1031, yI = 1033, Lm = 33776, Rm = 33777, Im = 33778, Pm = 33779, $w = 35840, Zw = 35841, qw = 35842, Kw = 35843, jw = 36196, Jw = 37492, Qw = 37496, tM = 37808, eM = 37809, rM = 37810, nM = 37811, iM = 37812, aM = 37813, oM = 37814, sM = 37815, lM = 37816, uM = 37817, cM = 37818, fM = 37819, hM = 37820, dM = 37821, Nm = 36492, pM = 36494, vM = 36495, hz = 36283, gM = 36284, mM = 36285, yM = 36286, dz = 3200, pz = 3201, vz = 0, gz = 1, _o = "", Bi = "srgb", Zo = "srgb-linear", c1 = "display-p3", Ng = "display-p3-linear", cv = "linear", Ze = "srgb", fv = "rec709", hv = "p3", Nl = 7680, _M = 519, mz = 512, yz = 513, _z = 514, _I = 515, xz = 516, Sz = 517, bz = 518, wz = 519, xM = 35044, SM = "300 es", Ca = 2e3, dv = 2001;
class vc {
  addEventListener(t, e) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[t] === void 0 && (n[t] = []), n[t].indexOf(e) === -1 && n[t].push(e);
  }
  hasEventListener(t, e) {
    if (this._listeners === void 0)
      return !1;
    const n = this._listeners;
    return n[t] !== void 0 && n[t].indexOf(e) !== -1;
  }
  removeEventListener(t, e) {
    if (this._listeners === void 0)
      return;
    const i = this._listeners[t];
    if (i !== void 0) {
      const a = i.indexOf(e);
      a !== -1 && i.splice(a, 1);
    }
  }
  dispatchEvent(t) {
    if (this._listeners === void 0)
      return;
    const n = this._listeners[t.type];
    if (n !== void 0) {
      t.target = this;
      const i = n.slice(0);
      for (let a = 0, o = i.length; a < o; a++)
        i[a].call(this, t);
      t.target = null;
    }
  }
}
const Xr = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"], Fp = Math.PI / 180, X_ = 180 / Math.PI;
function Lh() {
  const r = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
  return (Xr[r & 255] + Xr[r >> 8 & 255] + Xr[r >> 16 & 255] + Xr[r >> 24 & 255] + "-" + Xr[t & 255] + Xr[t >> 8 & 255] + "-" + Xr[t >> 16 & 15 | 64] + Xr[t >> 24 & 255] + "-" + Xr[e & 63 | 128] + Xr[e >> 8 & 255] + "-" + Xr[e >> 16 & 255] + Xr[e >> 24 & 255] + Xr[n & 255] + Xr[n >> 8 & 255] + Xr[n >> 16 & 255] + Xr[n >> 24 & 255]).toLowerCase();
}
function an(r, t, e) {
  return Math.max(t, Math.min(e, r));
}
function Mz(r, t) {
  return (r % t + t) % t;
}
function Om(r, t, e) {
  return (1 - e) * r + e * t;
}
function Bc(r, t) {
  switch (t.constructor) {
    case Float32Array:
      return r;
    case Uint32Array:
      return r / 4294967295;
    case Uint16Array:
      return r / 65535;
    case Uint8Array:
      return r / 255;
    case Int32Array:
      return Math.max(r / 2147483647, -1);
    case Int16Array:
      return Math.max(r / 32767, -1);
    case Int8Array:
      return Math.max(r / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function pn(r, t) {
  switch (t.constructor) {
    case Float32Array:
      return r;
    case Uint32Array:
      return Math.round(r * 4294967295);
    case Uint16Array:
      return Math.round(r * 65535);
    case Uint8Array:
      return Math.round(r * 255);
    case Int32Array:
      return Math.round(r * 2147483647);
    case Int16Array:
      return Math.round(r * 32767);
    case Int8Array:
      return Math.round(r * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const qut = {
  DEG2RAD: Fp
};
class Ce {
  constructor(t = 0, e = 0) {
    Ce.prototype.isVector2 = !0, this.x = t, this.y = e;
  }
  get width() {
    return this.x;
  }
  set width(t) {
    this.x = t;
  }
  get height() {
    return this.y;
  }
  set height(t) {
    this.y = t;
  }
  set(t, e) {
    return this.x = t, this.y = e, this;
  }
  setScalar(t) {
    return this.x = t, this.y = t, this;
  }
  setX(t) {
    return this.x = t, this;
  }
  setY(t) {
    return this.y = t, this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(t) {
    return this.x = t.x, this.y = t.y, this;
  }
  add(t) {
    return this.x += t.x, this.y += t.y, this;
  }
  addScalar(t) {
    return this.x += t, this.y += t, this;
  }
  addVectors(t, e) {
    return this.x = t.x + e.x, this.y = t.y + e.y, this;
  }
  addScaledVector(t, e) {
    return this.x += t.x * e, this.y += t.y * e, this;
  }
  sub(t) {
    return this.x -= t.x, this.y -= t.y, this;
  }
  subScalar(t) {
    return this.x -= t, this.y -= t, this;
  }
  subVectors(t, e) {
    return this.x = t.x - e.x, this.y = t.y - e.y, this;
  }
  multiply(t) {
    return this.x *= t.x, this.y *= t.y, this;
  }
  multiplyScalar(t) {
    return this.x *= t, this.y *= t, this;
  }
  divide(t) {
    return this.x /= t.x, this.y /= t.y, this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  applyMatrix3(t) {
    const e = this.x, n = this.y, i = t.elements;
    return this.x = i[0] * e + i[3] * n + i[6], this.y = i[1] * e + i[4] * n + i[7], this;
  }
  min(t) {
    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this;
  }
  max(t) {
    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this;
  }
  clamp(t, e) {
    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this;
  }
  clampScalar(t, e) {
    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this;
  }
  clampLength(t, e) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y;
  }
  cross(t) {
    return this.x * t.y - this.y * t.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(t) {
    const e = Math.sqrt(this.lengthSq() * t.lengthSq());
    if (e === 0)
      return Math.PI / 2;
    const n = this.dot(t) / e;
    return Math.acos(an(n, -1, 1));
  }
  distanceTo(t) {
    return Math.sqrt(this.distanceToSquared(t));
  }
  distanceToSquared(t) {
    const e = this.x - t.x, n = this.y - t.y;
    return e * e + n * n;
  }
  manhattanDistanceTo(t) {
    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this;
  }
  lerpVectors(t, e, n) {
    return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this;
  }
  equals(t) {
    return t.x === this.x && t.y === this.y;
  }
  fromArray(t, e = 0) {
    return this.x = t[e], this.y = t[e + 1], this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this.x, t[e + 1] = this.y, t;
  }
  fromBufferAttribute(t, e) {
    return this.x = t.getX(e), this.y = t.getY(e), this;
  }
  rotateAround(t, e) {
    const n = Math.cos(e), i = Math.sin(e), a = this.x - t.x, o = this.y - t.y;
    return this.x = a * n - o * i + t.x, this.y = a * i + o * n + t.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class ye {
  constructor(t, e, n, i, a, o, s, l, u) {
    ye.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], t !== void 0 && this.set(t, e, n, i, a, o, s, l, u);
  }
  set(t, e, n, i, a, o, s, l, u) {
    const c = this.elements;
    return c[0] = t, c[1] = i, c[2] = s, c[3] = e, c[4] = a, c[5] = l, c[6] = n, c[7] = o, c[8] = u, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(t) {
    const e = this.elements, n = t.elements;
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this;
  }
  extractBasis(t, e, n) {
    return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(t) {
    const e = t.elements;
    return this.set(
      e[0],
      e[4],
      e[8],
      e[1],
      e[5],
      e[9],
      e[2],
      e[6],
      e[10]
    ), this;
  }
  multiply(t) {
    return this.multiplyMatrices(this, t);
  }
  premultiply(t) {
    return this.multiplyMatrices(t, this);
  }
  multiplyMatrices(t, e) {
    const n = t.elements, i = e.elements, a = this.elements, o = n[0], s = n[3], l = n[6], u = n[1], c = n[4], f = n[7], h = n[2], d = n[5], p = n[8], g = i[0], v = i[3], m = i[6], y = i[1], _ = i[4], x = i[7], b = i[2], S = i[5], w = i[8];
    return a[0] = o * g + s * y + l * b, a[3] = o * v + s * _ + l * S, a[6] = o * m + s * x + l * w, a[1] = u * g + c * y + f * b, a[4] = u * v + c * _ + f * S, a[7] = u * m + c * x + f * w, a[2] = h * g + d * y + p * b, a[5] = h * v + d * _ + p * S, a[8] = h * m + d * x + p * w, this;
  }
  multiplyScalar(t) {
    const e = this.elements;
    return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this;
  }
  determinant() {
    const t = this.elements, e = t[0], n = t[1], i = t[2], a = t[3], o = t[4], s = t[5], l = t[6], u = t[7], c = t[8];
    return e * o * c - e * s * u - n * a * c + n * s * l + i * a * u - i * o * l;
  }
  invert() {
    const t = this.elements, e = t[0], n = t[1], i = t[2], a = t[3], o = t[4], s = t[5], l = t[6], u = t[7], c = t[8], f = c * o - s * u, h = s * l - c * a, d = u * a - o * l, p = e * f + n * h + i * d;
    if (p === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const g = 1 / p;
    return t[0] = f * g, t[1] = (i * u - c * n) * g, t[2] = (s * n - i * o) * g, t[3] = h * g, t[4] = (c * e - i * l) * g, t[5] = (i * a - s * e) * g, t[6] = d * g, t[7] = (n * l - u * e) * g, t[8] = (o * e - n * a) * g, this;
  }
  transpose() {
    let t;
    const e = this.elements;
    return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this;
  }
  getNormalMatrix(t) {
    return this.setFromMatrix4(t).invert().transpose();
  }
  transposeIntoArray(t) {
    const e = this.elements;
    return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this;
  }
  setUvTransform(t, e, n, i, a, o, s) {
    const l = Math.cos(a), u = Math.sin(a);
    return this.set(
      n * l,
      n * u,
      -n * (l * o + u * s) + o + t,
      -i * u,
      i * l,
      -i * (-u * o + l * s) + s + e,
      0,
      0,
      1
    ), this;
  }
  //
  scale(t, e) {
    return this.premultiply(km.makeScale(t, e)), this;
  }
  rotate(t) {
    return this.premultiply(km.makeRotation(-t)), this;
  }
  translate(t, e) {
    return this.premultiply(km.makeTranslation(t, e)), this;
  }
  // for 2D Transforms
  makeTranslation(t, e) {
    return t.isVector2 ? this.set(
      1,
      0,
      t.x,
      0,
      1,
      t.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      t,
      0,
      1,
      e,
      0,
      0,
      1
    ), this;
  }
  makeRotation(t) {
    const e = Math.cos(t), n = Math.sin(t);
    return this.set(
      e,
      -n,
      0,
      n,
      e,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(t, e) {
    return this.set(
      t,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(t) {
    const e = this.elements, n = t.elements;
    for (let i = 0; i < 9; i++)
      if (e[i] !== n[i])
        return !1;
    return !0;
  }
  fromArray(t, e = 0) {
    for (let n = 0; n < 9; n++)
      this.elements[n] = t[n + e];
    return this;
  }
  toArray(t = [], e = 0) {
    const n = this.elements;
    return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const km = /* @__PURE__ */ new ye();
function xI(r) {
  for (let t = r.length - 1; t >= 0; --t)
    if (r[t] >= 65535)
      return !0;
  return !1;
}
function pv(r) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", r);
}
function Tz() {
  const r = pv("canvas");
  return r.style.display = "block", r;
}
const bM = {};
function Az(r) {
  r in bM || (bM[r] = !0, console.warn(r));
}
const wM = /* @__PURE__ */ new ye().set(
  0.8224621,
  0.177538,
  0,
  0.0331941,
  0.9668058,
  0,
  0.0170827,
  0.0723974,
  0.9105199
), MM = /* @__PURE__ */ new ye().set(
  1.2249401,
  -0.2249404,
  0,
  -0.0420569,
  1.0420571,
  0,
  -0.0196376,
  -0.0786361,
  1.0982735
), Qh = {
  [Zo]: {
    transfer: cv,
    primaries: fv,
    toReference: (r) => r,
    fromReference: (r) => r
  },
  [Bi]: {
    transfer: Ze,
    primaries: fv,
    toReference: (r) => r.convertSRGBToLinear(),
    fromReference: (r) => r.convertLinearToSRGB()
  },
  [Ng]: {
    transfer: cv,
    primaries: hv,
    toReference: (r) => r.applyMatrix3(MM),
    fromReference: (r) => r.applyMatrix3(wM)
  },
  [c1]: {
    transfer: Ze,
    primaries: hv,
    toReference: (r) => r.convertSRGBToLinear().applyMatrix3(MM),
    fromReference: (r) => r.applyMatrix3(wM).convertLinearToSRGB()
  }
}, Ez = /* @__PURE__ */ new Set([Zo, Ng]), Fe = {
  enabled: !0,
  _workingColorSpace: Zo,
  get workingColorSpace() {
    return this._workingColorSpace;
  },
  set workingColorSpace(r) {
    if (!Ez.has(r))
      throw new Error(`Unsupported working color space, "${r}".`);
    this._workingColorSpace = r;
  },
  convert: function(r, t, e) {
    if (this.enabled === !1 || t === e || !t || !e)
      return r;
    const n = Qh[t].toReference, i = Qh[e].fromReference;
    return i(n(r));
  },
  fromWorkingColorSpace: function(r, t) {
    return this.convert(r, this._workingColorSpace, t);
  },
  toWorkingColorSpace: function(r, t) {
    return this.convert(r, t, this._workingColorSpace);
  },
  getPrimaries: function(r) {
    return Qh[r].primaries;
  },
  getTransfer: function(r) {
    return r === _o ? cv : Qh[r].transfer;
  }
};
function Gu(r) {
  return r < 0.04045 ? r * 0.0773993808 : Math.pow(r * 0.9478672986 + 0.0521327014, 2.4);
}
function Bm(r) {
  return r < 31308e-7 ? r * 12.92 : 1.055 * Math.pow(r, 0.41666) - 0.055;
}
let Ol;
class Cz {
  static getDataURL(t) {
    if (/^data:/i.test(t.src) || typeof HTMLCanvasElement > "u")
      return t.src;
    let e;
    if (t instanceof HTMLCanvasElement)
      e = t;
    else {
      Ol === void 0 && (Ol = pv("canvas")), Ol.width = t.width, Ol.height = t.height;
      const n = Ol.getContext("2d");
      t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = Ol;
    }
    return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", 0.6)) : e.toDataURL("image/png");
  }
  static sRGBToLinear(t) {
    if (typeof HTMLImageElement < "u" && t instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && t instanceof ImageBitmap) {
      const e = pv("canvas");
      e.width = t.width, e.height = t.height;
      const n = e.getContext("2d");
      n.drawImage(t, 0, 0, t.width, t.height);
      const i = n.getImageData(0, 0, t.width, t.height), a = i.data;
      for (let o = 0; o < a.length; o++)
        a[o] = Gu(a[o] / 255) * 255;
      return n.putImageData(i, 0, 0), e;
    } else if (t.data) {
      const e = t.data.slice(0);
      for (let n = 0; n < e.length; n++)
        e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[n] = Math.floor(Gu(e[n] / 255) * 255) : e[n] = Gu(e[n]);
      return {
        data: e,
        width: t.width,
        height: t.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), t;
  }
}
let Dz = 0;
class SI {
  constructor(t = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: Dz++ }), this.uuid = Lh(), this.data = t, this.dataReady = !0, this.version = 0;
  }
  set needsUpdate(t) {
    t === !0 && this.version++;
  }
  toJSON(t) {
    const e = t === void 0 || typeof t == "string";
    if (!e && t.images[this.uuid] !== void 0)
      return t.images[this.uuid];
    const n = {
      uuid: this.uuid,
      url: ""
    }, i = this.data;
    if (i !== null) {
      let a;
      if (Array.isArray(i)) {
        a = [];
        for (let o = 0, s = i.length; o < s; o++)
          i[o].isDataTexture ? a.push(Vm(i[o].image)) : a.push(Vm(i[o]));
      } else
        a = Vm(i);
      n.url = a;
    }
    return e || (t.images[this.uuid] = n), n;
  }
}
function Vm(r) {
  return typeof HTMLImageElement < "u" && r instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && r instanceof ImageBitmap ? Cz.getDataURL(r) : r.data ? {
    data: Array.from(r.data),
    width: r.width,
    height: r.height,
    type: r.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let Lz = 0;
class sn extends vc {
  constructor(t = sn.DEFAULT_IMAGE, e = sn.DEFAULT_MAPPING, n = Ys, i = Ys, a = pi, o = $s, s = Wi, l = Fo, u = sn.DEFAULT_ANISOTROPY, c = _o) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: Lz++ }), this.uuid = Lh(), this.name = "", this.source = new SI(t), this.mipmaps = [], this.mapping = e, this.channel = 0, this.wrapS = n, this.wrapT = i, this.magFilter = a, this.minFilter = o, this.anisotropy = u, this.format = s, this.internalFormat = null, this.type = l, this.offset = new Ce(0, 0), this.repeat = new Ce(1, 1), this.center = new Ce(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new ye(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = c, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0;
  }
  get image() {
    return this.source.data;
  }
  set image(t = null) {
    this.source.data = t;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return this.name = t.name, this.source = t.source, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.channel = t.channel, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.colorSpace = t.colorSpace, this.userData = JSON.parse(JSON.stringify(t.userData)), this.needsUpdate = !0, this;
  }
  toJSON(t) {
    const e = t === void 0 || typeof t == "string";
    if (!e && t.textures[this.uuid] !== void 0)
      return t.textures[this.uuid];
    const n = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(t).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (n.userData = this.userData), e || (t.textures[this.uuid] = n), n;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(t) {
    if (this.mapping !== cI)
      return t;
    if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1)
      switch (this.wrapS) {
        case H_:
          t.x = t.x - Math.floor(t.x);
          break;
        case Ys:
          t.x = t.x < 0 ? 0 : 1;
          break;
        case W_:
          Math.abs(Math.floor(t.x) % 2) === 1 ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x);
          break;
      }
    if (t.y < 0 || t.y > 1)
      switch (this.wrapT) {
        case H_:
          t.y = t.y - Math.floor(t.y);
          break;
        case Ys:
          t.y = t.y < 0 ? 0 : 1;
          break;
        case W_:
          Math.abs(Math.floor(t.y) % 2) === 1 ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y);
          break;
      }
    return this.flipY && (t.y = 1 - t.y), t;
  }
  set needsUpdate(t) {
    t === !0 && (this.version++, this.source.needsUpdate = !0);
  }
  set needsPMREMUpdate(t) {
    t === !0 && this.pmremVersion++;
  }
}
sn.DEFAULT_IMAGE = null;
sn.DEFAULT_MAPPING = cI;
sn.DEFAULT_ANISOTROPY = 1;
class Pr {
  constructor(t = 0, e = 0, n = 0, i = 1) {
    Pr.prototype.isVector4 = !0, this.x = t, this.y = e, this.z = n, this.w = i;
  }
  get width() {
    return this.z;
  }
  set width(t) {
    this.z = t;
  }
  get height() {
    return this.w;
  }
  set height(t) {
    this.w = t;
  }
  set(t, e, n, i) {
    return this.x = t, this.y = e, this.z = n, this.w = i, this;
  }
  setScalar(t) {
    return this.x = t, this.y = t, this.z = t, this.w = t, this;
  }
  setX(t) {
    return this.x = t, this;
  }
  setY(t) {
    return this.y = t, this;
  }
  setZ(t) {
    return this.z = t, this;
  }
  setW(t) {
    return this.w = t, this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      case 2:
        this.z = e;
        break;
      case 3:
        this.w = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(t) {
    return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w !== void 0 ? t.w : 1, this;
  }
  add(t) {
    return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this;
  }
  addScalar(t) {
    return this.x += t, this.y += t, this.z += t, this.w += t, this;
  }
  addVectors(t, e) {
    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this;
  }
  addScaledVector(t, e) {
    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this;
  }
  sub(t) {
    return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this;
  }
  subScalar(t) {
    return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this;
  }
  subVectors(t, e) {
    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this;
  }
  multiply(t) {
    return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this;
  }
  multiplyScalar(t) {
    return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this;
  }
  applyMatrix4(t) {
    const e = this.x, n = this.y, i = this.z, a = this.w, o = t.elements;
    return this.x = o[0] * e + o[4] * n + o[8] * i + o[12] * a, this.y = o[1] * e + o[5] * n + o[9] * i + o[13] * a, this.z = o[2] * e + o[6] * n + o[10] * i + o[14] * a, this.w = o[3] * e + o[7] * n + o[11] * i + o[15] * a, this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  setAxisAngleFromQuaternion(t) {
    this.w = 2 * Math.acos(t.w);
    const e = Math.sqrt(1 - t.w * t.w);
    return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this;
  }
  setAxisAngleFromRotationMatrix(t) {
    let e, n, i, a;
    const l = t.elements, u = l[0], c = l[4], f = l[8], h = l[1], d = l[5], p = l[9], g = l[2], v = l[6], m = l[10];
    if (Math.abs(c - h) < 0.01 && Math.abs(f - g) < 0.01 && Math.abs(p - v) < 0.01) {
      if (Math.abs(c + h) < 0.1 && Math.abs(f + g) < 0.1 && Math.abs(p + v) < 0.1 && Math.abs(u + d + m - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      e = Math.PI;
      const _ = (u + 1) / 2, x = (d + 1) / 2, b = (m + 1) / 2, S = (c + h) / 4, w = (f + g) / 4, A = (p + v) / 4;
      return _ > x && _ > b ? _ < 0.01 ? (n = 0, i = 0.707106781, a = 0.707106781) : (n = Math.sqrt(_), i = S / n, a = w / n) : x > b ? x < 0.01 ? (n = 0.707106781, i = 0, a = 0.707106781) : (i = Math.sqrt(x), n = S / i, a = A / i) : b < 0.01 ? (n = 0.707106781, i = 0.707106781, a = 0) : (a = Math.sqrt(b), n = w / a, i = A / a), this.set(n, i, a, e), this;
    }
    let y = Math.sqrt((v - p) * (v - p) + (f - g) * (f - g) + (h - c) * (h - c));
    return Math.abs(y) < 1e-3 && (y = 1), this.x = (v - p) / y, this.y = (f - g) / y, this.z = (h - c) / y, this.w = Math.acos((u + d + m - 1) / 2), this;
  }
  min(t) {
    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this;
  }
  max(t) {
    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this;
  }
  clamp(t, e) {
    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this;
  }
  clampScalar(t, e) {
    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this;
  }
  clampLength(t, e) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this;
  }
  lerpVectors(t, e, n) {
    return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this;
  }
  equals(t) {
    return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
  }
  fromArray(t, e = 0) {
    return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t;
  }
  fromBufferAttribute(t, e) {
    return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class Rz extends vc {
  constructor(t = 1, e = 1, n = {}) {
    super(), this.isRenderTarget = !0, this.width = t, this.height = e, this.depth = 1, this.scissor = new Pr(0, 0, t, e), this.scissorTest = !1, this.viewport = new Pr(0, 0, t, e);
    const i = { width: t, height: e, depth: 1 };
    n = Object.assign({
      generateMipmaps: !1,
      internalFormat: null,
      minFilter: pi,
      depthBuffer: !0,
      stencilBuffer: !1,
      resolveDepthBuffer: !0,
      resolveStencilBuffer: !0,
      depthTexture: null,
      samples: 0,
      count: 1
    }, n);
    const a = new sn(i, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace);
    a.flipY = !1, a.generateMipmaps = n.generateMipmaps, a.internalFormat = n.internalFormat, this.textures = [];
    const o = n.count;
    for (let s = 0; s < o; s++)
      this.textures[s] = a.clone(), this.textures[s].isRenderTargetTexture = !0;
    this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.resolveDepthBuffer = n.resolveDepthBuffer, this.resolveStencilBuffer = n.resolveStencilBuffer, this.depthTexture = n.depthTexture, this.samples = n.samples;
  }
  get texture() {
    return this.textures[0];
  }
  set texture(t) {
    this.textures[0] = t;
  }
  setSize(t, e, n = 1) {
    if (this.width !== t || this.height !== e || this.depth !== n) {
      this.width = t, this.height = e, this.depth = n;
      for (let i = 0, a = this.textures.length; i < a; i++)
        this.textures[i].image.width = t, this.textures[i].image.height = e, this.textures[i].image.depth = n;
      this.dispose();
    }
    this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    this.width = t.width, this.height = t.height, this.depth = t.depth, this.scissor.copy(t.scissor), this.scissorTest = t.scissorTest, this.viewport.copy(t.viewport), this.textures.length = 0;
    for (let n = 0, i = t.textures.length; n < i; n++)
      this.textures[n] = t.textures[n].clone(), this.textures[n].isRenderTargetTexture = !0;
    const e = Object.assign({}, t.texture.image);
    return this.texture.source = new SI(e), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.resolveDepthBuffer = t.resolveDepthBuffer, this.resolveStencilBuffer = t.resolveStencilBuffer, t.depthTexture !== null && (this.depthTexture = t.depthTexture.clone()), this.samples = t.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class cl extends Rz {
  constructor(t = 1, e = 1, n = {}) {
    super(t, e, n), this.isWebGLRenderTarget = !0;
  }
}
class bI extends sn {
  constructor(t = null, e = 1, n = 1, i = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: t, width: e, height: n, depth: i }, this.magFilter = xn, this.minFilter = xn, this.wrapR = Ys, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class Iz extends sn {
  constructor(t = null, e = 1, n = 1, i = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: t, width: e, height: n, depth: i }, this.magFilter = xn, this.minFilter = xn, this.wrapR = Ys, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class Rh {
  constructor(t = 0, e = 0, n = 0, i = 1) {
    this.isQuaternion = !0, this._x = t, this._y = e, this._z = n, this._w = i;
  }
  static slerpFlat(t, e, n, i, a, o, s) {
    let l = n[i + 0], u = n[i + 1], c = n[i + 2], f = n[i + 3];
    const h = a[o + 0], d = a[o + 1], p = a[o + 2], g = a[o + 3];
    if (s === 0) {
      t[e + 0] = l, t[e + 1] = u, t[e + 2] = c, t[e + 3] = f;
      return;
    }
    if (s === 1) {
      t[e + 0] = h, t[e + 1] = d, t[e + 2] = p, t[e + 3] = g;
      return;
    }
    if (f !== g || l !== h || u !== d || c !== p) {
      let v = 1 - s;
      const m = l * h + u * d + c * p + f * g, y = m >= 0 ? 1 : -1, _ = 1 - m * m;
      if (_ > Number.EPSILON) {
        const b = Math.sqrt(_), S = Math.atan2(b, m * y);
        v = Math.sin(v * S) / b, s = Math.sin(s * S) / b;
      }
      const x = s * y;
      if (l = l * v + h * x, u = u * v + d * x, c = c * v + p * x, f = f * v + g * x, v === 1 - s) {
        const b = 1 / Math.sqrt(l * l + u * u + c * c + f * f);
        l *= b, u *= b, c *= b, f *= b;
      }
    }
    t[e] = l, t[e + 1] = u, t[e + 2] = c, t[e + 3] = f;
  }
  static multiplyQuaternionsFlat(t, e, n, i, a, o) {
    const s = n[i], l = n[i + 1], u = n[i + 2], c = n[i + 3], f = a[o], h = a[o + 1], d = a[o + 2], p = a[o + 3];
    return t[e] = s * p + c * f + l * d - u * h, t[e + 1] = l * p + c * h + u * f - s * d, t[e + 2] = u * p + c * d + s * h - l * f, t[e + 3] = c * p - s * f - l * h - u * d, t;
  }
  get x() {
    return this._x;
  }
  set x(t) {
    this._x = t, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(t) {
    this._y = t, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(t) {
    this._z = t, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(t) {
    this._w = t, this._onChangeCallback();
  }
  set(t, e, n, i) {
    return this._x = t, this._y = e, this._z = n, this._w = i, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(t) {
    return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this;
  }
  setFromEuler(t, e = !0) {
    const n = t._x, i = t._y, a = t._z, o = t._order, s = Math.cos, l = Math.sin, u = s(n / 2), c = s(i / 2), f = s(a / 2), h = l(n / 2), d = l(i / 2), p = l(a / 2);
    switch (o) {
      case "XYZ":
        this._x = h * c * f + u * d * p, this._y = u * d * f - h * c * p, this._z = u * c * p + h * d * f, this._w = u * c * f - h * d * p;
        break;
      case "YXZ":
        this._x = h * c * f + u * d * p, this._y = u * d * f - h * c * p, this._z = u * c * p - h * d * f, this._w = u * c * f + h * d * p;
        break;
      case "ZXY":
        this._x = h * c * f - u * d * p, this._y = u * d * f + h * c * p, this._z = u * c * p + h * d * f, this._w = u * c * f - h * d * p;
        break;
      case "ZYX":
        this._x = h * c * f - u * d * p, this._y = u * d * f + h * c * p, this._z = u * c * p - h * d * f, this._w = u * c * f + h * d * p;
        break;
      case "YZX":
        this._x = h * c * f + u * d * p, this._y = u * d * f + h * c * p, this._z = u * c * p - h * d * f, this._w = u * c * f - h * d * p;
        break;
      case "XZY":
        this._x = h * c * f - u * d * p, this._y = u * d * f - h * c * p, this._z = u * c * p + h * d * f, this._w = u * c * f + h * d * p;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o);
    }
    return e === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(t, e) {
    const n = e / 2, i = Math.sin(n);
    return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(n), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(t) {
    const e = t.elements, n = e[0], i = e[4], a = e[8], o = e[1], s = e[5], l = e[9], u = e[2], c = e[6], f = e[10], h = n + s + f;
    if (h > 0) {
      const d = 0.5 / Math.sqrt(h + 1);
      this._w = 0.25 / d, this._x = (c - l) * d, this._y = (a - u) * d, this._z = (o - i) * d;
    } else if (n > s && n > f) {
      const d = 2 * Math.sqrt(1 + n - s - f);
      this._w = (c - l) / d, this._x = 0.25 * d, this._y = (i + o) / d, this._z = (a + u) / d;
    } else if (s > f) {
      const d = 2 * Math.sqrt(1 + s - n - f);
      this._w = (a - u) / d, this._x = (i + o) / d, this._y = 0.25 * d, this._z = (l + c) / d;
    } else {
      const d = 2 * Math.sqrt(1 + f - n - s);
      this._w = (o - i) / d, this._x = (a + u) / d, this._y = (l + c) / d, this._z = 0.25 * d;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(t, e) {
    let n = t.dot(e) + 1;
    return n < Number.EPSILON ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize();
  }
  angleTo(t) {
    return 2 * Math.acos(Math.abs(an(this.dot(t), -1, 1)));
  }
  rotateTowards(t, e) {
    const n = this.angleTo(t);
    if (n === 0)
      return this;
    const i = Math.min(1, e / n);
    return this.slerp(t, i), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(t) {
    return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let t = this.length();
    return t === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this;
  }
  multiply(t) {
    return this.multiplyQuaternions(this, t);
  }
  premultiply(t) {
    return this.multiplyQuaternions(t, this);
  }
  multiplyQuaternions(t, e) {
    const n = t._x, i = t._y, a = t._z, o = t._w, s = e._x, l = e._y, u = e._z, c = e._w;
    return this._x = n * c + o * s + i * u - a * l, this._y = i * c + o * l + a * s - n * u, this._z = a * c + o * u + n * l - i * s, this._w = o * c - n * s - i * l - a * u, this._onChangeCallback(), this;
  }
  slerp(t, e) {
    if (e === 0)
      return this;
    if (e === 1)
      return this.copy(t);
    const n = this._x, i = this._y, a = this._z, o = this._w;
    let s = o * t._w + n * t._x + i * t._y + a * t._z;
    if (s < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, s = -s) : this.copy(t), s >= 1)
      return this._w = o, this._x = n, this._y = i, this._z = a, this;
    const l = 1 - s * s;
    if (l <= Number.EPSILON) {
      const d = 1 - e;
      return this._w = d * o + e * this._w, this._x = d * n + e * this._x, this._y = d * i + e * this._y, this._z = d * a + e * this._z, this.normalize(), this;
    }
    const u = Math.sqrt(l), c = Math.atan2(u, s), f = Math.sin((1 - e) * c) / u, h = Math.sin(e * c) / u;
    return this._w = o * f + this._w * h, this._x = n * f + this._x * h, this._y = i * f + this._y * h, this._z = a * f + this._z * h, this._onChangeCallback(), this;
  }
  slerpQuaternions(t, e, n) {
    return this.copy(t).slerp(e, n);
  }
  random() {
    const t = 2 * Math.PI * Math.random(), e = 2 * Math.PI * Math.random(), n = Math.random(), i = Math.sqrt(1 - n), a = Math.sqrt(n);
    return this.set(
      i * Math.sin(t),
      i * Math.cos(t),
      a * Math.sin(e),
      a * Math.cos(e)
    );
  }
  equals(t) {
    return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w;
  }
  fromArray(t, e = 0) {
    return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t;
  }
  fromBufferAttribute(t, e) {
    return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this._onChangeCallback(), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(t) {
    return this._onChangeCallback = t, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class j {
  constructor(t = 0, e = 0, n = 0) {
    j.prototype.isVector3 = !0, this.x = t, this.y = e, this.z = n;
  }
  set(t, e, n) {
    return n === void 0 && (n = this.z), this.x = t, this.y = e, this.z = n, this;
  }
  setScalar(t) {
    return this.x = t, this.y = t, this.z = t, this;
  }
  setX(t) {
    return this.x = t, this;
  }
  setY(t) {
    return this.y = t, this;
  }
  setZ(t) {
    return this.z = t, this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      case 2:
        this.z = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(t) {
    return this.x = t.x, this.y = t.y, this.z = t.z, this;
  }
  add(t) {
    return this.x += t.x, this.y += t.y, this.z += t.z, this;
  }
  addScalar(t) {
    return this.x += t, this.y += t, this.z += t, this;
  }
  addVectors(t, e) {
    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this;
  }
  addScaledVector(t, e) {
    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this;
  }
  sub(t) {
    return this.x -= t.x, this.y -= t.y, this.z -= t.z, this;
  }
  subScalar(t) {
    return this.x -= t, this.y -= t, this.z -= t, this;
  }
  subVectors(t, e) {
    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this;
  }
  multiply(t) {
    return this.x *= t.x, this.y *= t.y, this.z *= t.z, this;
  }
  multiplyScalar(t) {
    return this.x *= t, this.y *= t, this.z *= t, this;
  }
  multiplyVectors(t, e) {
    return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this;
  }
  applyEuler(t) {
    return this.applyQuaternion(TM.setFromEuler(t));
  }
  applyAxisAngle(t, e) {
    return this.applyQuaternion(TM.setFromAxisAngle(t, e));
  }
  applyMatrix3(t) {
    const e = this.x, n = this.y, i = this.z, a = t.elements;
    return this.x = a[0] * e + a[3] * n + a[6] * i, this.y = a[1] * e + a[4] * n + a[7] * i, this.z = a[2] * e + a[5] * n + a[8] * i, this;
  }
  applyNormalMatrix(t) {
    return this.applyMatrix3(t).normalize();
  }
  applyMatrix4(t) {
    const e = this.x, n = this.y, i = this.z, a = t.elements, o = 1 / (a[3] * e + a[7] * n + a[11] * i + a[15]);
    return this.x = (a[0] * e + a[4] * n + a[8] * i + a[12]) * o, this.y = (a[1] * e + a[5] * n + a[9] * i + a[13]) * o, this.z = (a[2] * e + a[6] * n + a[10] * i + a[14]) * o, this;
  }
  applyQuaternion(t) {
    const e = this.x, n = this.y, i = this.z, a = t.x, o = t.y, s = t.z, l = t.w, u = 2 * (o * i - s * n), c = 2 * (s * e - a * i), f = 2 * (a * n - o * e);
    return this.x = e + l * u + o * f - s * c, this.y = n + l * c + s * u - a * f, this.z = i + l * f + a * c - o * u, this;
  }
  project(t) {
    return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix);
  }
  unproject(t) {
    return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld);
  }
  transformDirection(t) {
    const e = this.x, n = this.y, i = this.z, a = t.elements;
    return this.x = a[0] * e + a[4] * n + a[8] * i, this.y = a[1] * e + a[5] * n + a[9] * i, this.z = a[2] * e + a[6] * n + a[10] * i, this.normalize();
  }
  divide(t) {
    return this.x /= t.x, this.y /= t.y, this.z /= t.z, this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  min(t) {
    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this;
  }
  max(t) {
    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this;
  }
  clamp(t, e) {
    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this;
  }
  clampScalar(t, e) {
    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this;
  }
  clampLength(t, e) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this;
  }
  lerpVectors(t, e, n) {
    return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this;
  }
  cross(t) {
    return this.crossVectors(this, t);
  }
  crossVectors(t, e) {
    const n = t.x, i = t.y, a = t.z, o = e.x, s = e.y, l = e.z;
    return this.x = i * l - a * s, this.y = a * o - n * l, this.z = n * s - i * o, this;
  }
  projectOnVector(t) {
    const e = t.lengthSq();
    if (e === 0)
      return this.set(0, 0, 0);
    const n = t.dot(this) / e;
    return this.copy(t).multiplyScalar(n);
  }
  projectOnPlane(t) {
    return Fm.copy(this).projectOnVector(t), this.sub(Fm);
  }
  reflect(t) {
    return this.sub(Fm.copy(t).multiplyScalar(2 * this.dot(t)));
  }
  angleTo(t) {
    const e = Math.sqrt(this.lengthSq() * t.lengthSq());
    if (e === 0)
      return Math.PI / 2;
    const n = this.dot(t) / e;
    return Math.acos(an(n, -1, 1));
  }
  distanceTo(t) {
    return Math.sqrt(this.distanceToSquared(t));
  }
  distanceToSquared(t) {
    const e = this.x - t.x, n = this.y - t.y, i = this.z - t.z;
    return e * e + n * n + i * i;
  }
  manhattanDistanceTo(t) {
    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z);
  }
  setFromSpherical(t) {
    return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
  }
  setFromSphericalCoords(t, e, n) {
    const i = Math.sin(e) * t;
    return this.x = i * Math.sin(n), this.y = Math.cos(e) * t, this.z = i * Math.cos(n), this;
  }
  setFromCylindrical(t) {
    return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
  }
  setFromCylindricalCoords(t, e, n) {
    return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this;
  }
  setFromMatrixPosition(t) {
    const e = t.elements;
    return this.x = e[12], this.y = e[13], this.z = e[14], this;
  }
  setFromMatrixScale(t) {
    const e = this.setFromMatrixColumn(t, 0).length(), n = this.setFromMatrixColumn(t, 1).length(), i = this.setFromMatrixColumn(t, 2).length();
    return this.x = e, this.y = n, this.z = i, this;
  }
  setFromMatrixColumn(t, e) {
    return this.fromArray(t.elements, e * 4);
  }
  setFromMatrix3Column(t, e) {
    return this.fromArray(t.elements, e * 3);
  }
  setFromEuler(t) {
    return this.x = t._x, this.y = t._y, this.z = t._z, this;
  }
  setFromColor(t) {
    return this.x = t.r, this.y = t.g, this.z = t.b, this;
  }
  equals(t) {
    return t.x === this.x && t.y === this.y && t.z === this.z;
  }
  fromArray(t, e = 0) {
    return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t;
  }
  fromBufferAttribute(t, e) {
    return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const t = Math.random() * Math.PI * 2, e = Math.random() * 2 - 1, n = Math.sqrt(1 - e * e);
    return this.x = n * Math.cos(t), this.y = e, this.z = n * Math.sin(t), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const Fm = /* @__PURE__ */ new j(), TM = /* @__PURE__ */ new Rh();
class Sl {
  constructor(t = new j(1 / 0, 1 / 0, 1 / 0), e = new j(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = t, this.max = e;
  }
  set(t, e) {
    return this.min.copy(t), this.max.copy(e), this;
  }
  setFromArray(t) {
    this.makeEmpty();
    for (let e = 0, n = t.length; e < n; e += 3)
      this.expandByPoint(si.fromArray(t, e));
    return this;
  }
  setFromBufferAttribute(t) {
    this.makeEmpty();
    for (let e = 0, n = t.count; e < n; e++)
      this.expandByPoint(si.fromBufferAttribute(t, e));
    return this;
  }
  setFromPoints(t) {
    this.makeEmpty();
    for (let e = 0, n = t.length; e < n; e++)
      this.expandByPoint(t[e]);
    return this;
  }
  setFromCenterAndSize(t, e) {
    const n = si.copy(e).multiplyScalar(0.5);
    return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
  }
  setFromObject(t, e = !1) {
    return this.makeEmpty(), this.expandByObject(t, e);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return this.min.copy(t.min), this.max.copy(t.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(t) {
    return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(t) {
    return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min);
  }
  expandByPoint(t) {
    return this.min.min(t), this.max.max(t), this;
  }
  expandByVector(t) {
    return this.min.sub(t), this.max.add(t), this;
  }
  expandByScalar(t) {
    return this.min.addScalar(-t), this.max.addScalar(t), this;
  }
  expandByObject(t, e = !1) {
    t.updateWorldMatrix(!1, !1);
    const n = t.geometry;
    if (n !== void 0) {
      const a = n.getAttribute("position");
      if (e === !0 && a !== void 0 && t.isInstancedMesh !== !0)
        for (let o = 0, s = a.count; o < s; o++)
          t.isMesh === !0 ? t.getVertexPosition(o, si) : si.fromBufferAttribute(a, o), si.applyMatrix4(t.matrixWorld), this.expandByPoint(si);
      else
        t.boundingBox !== void 0 ? (t.boundingBox === null && t.computeBoundingBox(), td.copy(t.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(), td.copy(n.boundingBox)), td.applyMatrix4(t.matrixWorld), this.union(td);
    }
    const i = t.children;
    for (let a = 0, o = i.length; a < o; a++)
      this.expandByObject(i[a], e);
    return this;
  }
  containsPoint(t) {
    return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z);
  }
  containsBox(t) {
    return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z;
  }
  getParameter(t, e) {
    return e.set(
      (t.x - this.min.x) / (this.max.x - this.min.x),
      (t.y - this.min.y) / (this.max.y - this.min.y),
      (t.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(t) {
    return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z);
  }
  intersectsSphere(t) {
    return this.clampPoint(t.center, si), si.distanceToSquared(t.center) <= t.radius * t.radius;
  }
  intersectsPlane(t) {
    let e, n;
    return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant;
  }
  intersectsTriangle(t) {
    if (this.isEmpty())
      return !1;
    this.getCenter(Vc), ed.subVectors(this.max, Vc), kl.subVectors(t.a, Vc), Bl.subVectors(t.b, Vc), Vl.subVectors(t.c, Vc), Qa.subVectors(Bl, kl), to.subVectors(Vl, Bl), ts.subVectors(kl, Vl);
    let e = [
      0,
      -Qa.z,
      Qa.y,
      0,
      -to.z,
      to.y,
      0,
      -ts.z,
      ts.y,
      Qa.z,
      0,
      -Qa.x,
      to.z,
      0,
      -to.x,
      ts.z,
      0,
      -ts.x,
      -Qa.y,
      Qa.x,
      0,
      -to.y,
      to.x,
      0,
      -ts.y,
      ts.x,
      0
    ];
    return !zm(e, kl, Bl, Vl, ed) || (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !zm(e, kl, Bl, Vl, ed)) ? !1 : (rd.crossVectors(Qa, to), e = [rd.x, rd.y, rd.z], zm(e, kl, Bl, Vl, ed));
  }
  clampPoint(t, e) {
    return e.copy(t).clamp(this.min, this.max);
  }
  distanceToPoint(t) {
    return this.clampPoint(t, si).distanceTo(t);
  }
  getBoundingSphere(t) {
    return this.isEmpty() ? t.makeEmpty() : (this.getCenter(t.center), t.radius = this.getSize(si).length() * 0.5), t;
  }
  intersect(t) {
    return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(t) {
    return this.min.min(t.min), this.max.max(t.max), this;
  }
  applyMatrix4(t) {
    return this.isEmpty() ? this : (ha[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), ha[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), ha[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), ha[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), ha[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), ha[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), ha[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), ha[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(ha), this);
  }
  translate(t) {
    return this.min.add(t), this.max.add(t), this;
  }
  equals(t) {
    return t.min.equals(this.min) && t.max.equals(this.max);
  }
}
const ha = [
  /* @__PURE__ */ new j(),
  /* @__PURE__ */ new j(),
  /* @__PURE__ */ new j(),
  /* @__PURE__ */ new j(),
  /* @__PURE__ */ new j(),
  /* @__PURE__ */ new j(),
  /* @__PURE__ */ new j(),
  /* @__PURE__ */ new j()
], si = /* @__PURE__ */ new j(), td = /* @__PURE__ */ new Sl(), kl = /* @__PURE__ */ new j(), Bl = /* @__PURE__ */ new j(), Vl = /* @__PURE__ */ new j(), Qa = /* @__PURE__ */ new j(), to = /* @__PURE__ */ new j(), ts = /* @__PURE__ */ new j(), Vc = /* @__PURE__ */ new j(), ed = /* @__PURE__ */ new j(), rd = /* @__PURE__ */ new j(), es = /* @__PURE__ */ new j();
function zm(r, t, e, n, i) {
  for (let a = 0, o = r.length - 3; a <= o; a += 3) {
    es.fromArray(r, a);
    const s = i.x * Math.abs(es.x) + i.y * Math.abs(es.y) + i.z * Math.abs(es.z), l = t.dot(es), u = e.dot(es), c = n.dot(es);
    if (Math.max(-Math.max(l, u, c), Math.min(l, u, c)) > s)
      return !1;
  }
  return !0;
}
const Pz = /* @__PURE__ */ new Sl(), Fc = /* @__PURE__ */ new j(), Um = /* @__PURE__ */ new j();
class gc {
  constructor(t = new j(), e = -1) {
    this.isSphere = !0, this.center = t, this.radius = e;
  }
  set(t, e) {
    return this.center.copy(t), this.radius = e, this;
  }
  setFromPoints(t, e) {
    const n = this.center;
    e !== void 0 ? n.copy(e) : Pz.setFromPoints(t).getCenter(n);
    let i = 0;
    for (let a = 0, o = t.length; a < o; a++)
      i = Math.max(i, n.distanceToSquared(t[a]));
    return this.radius = Math.sqrt(i), this;
  }
  copy(t) {
    return this.center.copy(t.center), this.radius = t.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(t) {
    return t.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(t) {
    return t.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(t) {
    const e = this.radius + t.radius;
    return t.center.distanceToSquared(this.center) <= e * e;
  }
  intersectsBox(t) {
    return t.intersectsSphere(this);
  }
  intersectsPlane(t) {
    return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(t, e) {
    const n = this.center.distanceToSquared(t);
    return e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e;
  }
  getBoundingBox(t) {
    return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t);
  }
  applyMatrix4(t) {
    return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this;
  }
  translate(t) {
    return this.center.add(t), this;
  }
  expandByPoint(t) {
    if (this.isEmpty())
      return this.center.copy(t), this.radius = 0, this;
    Fc.subVectors(t, this.center);
    const e = Fc.lengthSq();
    if (e > this.radius * this.radius) {
      const n = Math.sqrt(e), i = (n - this.radius) * 0.5;
      this.center.addScaledVector(Fc, i / n), this.radius += i;
    }
    return this;
  }
  union(t) {
    return t.isEmpty() ? this : this.isEmpty() ? (this.copy(t), this) : (this.center.equals(t.center) === !0 ? this.radius = Math.max(this.radius, t.radius) : (Um.subVectors(t.center, this.center).setLength(t.radius), this.expandByPoint(Fc.copy(t.center).add(Um)), this.expandByPoint(Fc.copy(t.center).sub(Um))), this);
  }
  equals(t) {
    return t.center.equals(this.center) && t.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const da = /* @__PURE__ */ new j(), Gm = /* @__PURE__ */ new j(), nd = /* @__PURE__ */ new j(), eo = /* @__PURE__ */ new j(), Hm = /* @__PURE__ */ new j(), id = /* @__PURE__ */ new j(), Wm = /* @__PURE__ */ new j();
class f1 {
  constructor(t = new j(), e = new j(0, 0, -1)) {
    this.origin = t, this.direction = e;
  }
  set(t, e) {
    return this.origin.copy(t), this.direction.copy(e), this;
  }
  copy(t) {
    return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
  }
  at(t, e) {
    return e.copy(this.origin).addScaledVector(this.direction, t);
  }
  lookAt(t) {
    return this.direction.copy(t).sub(this.origin).normalize(), this;
  }
  recast(t) {
    return this.origin.copy(this.at(t, da)), this;
  }
  closestPointToPoint(t, e) {
    e.subVectors(t, this.origin);
    const n = e.dot(this.direction);
    return n < 0 ? e.copy(this.origin) : e.copy(this.origin).addScaledVector(this.direction, n);
  }
  distanceToPoint(t) {
    return Math.sqrt(this.distanceSqToPoint(t));
  }
  distanceSqToPoint(t) {
    const e = da.subVectors(t, this.origin).dot(this.direction);
    return e < 0 ? this.origin.distanceToSquared(t) : (da.copy(this.origin).addScaledVector(this.direction, e), da.distanceToSquared(t));
  }
  distanceSqToSegment(t, e, n, i) {
    Gm.copy(t).add(e).multiplyScalar(0.5), nd.copy(e).sub(t).normalize(), eo.copy(this.origin).sub(Gm);
    const a = t.distanceTo(e) * 0.5, o = -this.direction.dot(nd), s = eo.dot(this.direction), l = -eo.dot(nd), u = eo.lengthSq(), c = Math.abs(1 - o * o);
    let f, h, d, p;
    if (c > 0)
      if (f = o * l - s, h = o * s - l, p = a * c, f >= 0)
        if (h >= -p)
          if (h <= p) {
            const g = 1 / c;
            f *= g, h *= g, d = f * (f + o * h + 2 * s) + h * (o * f + h + 2 * l) + u;
          } else
            h = a, f = Math.max(0, -(o * h + s)), d = -f * f + h * (h + 2 * l) + u;
        else
          h = -a, f = Math.max(0, -(o * h + s)), d = -f * f + h * (h + 2 * l) + u;
      else
        h <= -p ? (f = Math.max(0, -(-o * a + s)), h = f > 0 ? -a : Math.min(Math.max(-a, -l), a), d = -f * f + h * (h + 2 * l) + u) : h <= p ? (f = 0, h = Math.min(Math.max(-a, -l), a), d = h * (h + 2 * l) + u) : (f = Math.max(0, -(o * a + s)), h = f > 0 ? a : Math.min(Math.max(-a, -l), a), d = -f * f + h * (h + 2 * l) + u);
    else
      h = o > 0 ? -a : a, f = Math.max(0, -(o * h + s)), d = -f * f + h * (h + 2 * l) + u;
    return n && n.copy(this.origin).addScaledVector(this.direction, f), i && i.copy(Gm).addScaledVector(nd, h), d;
  }
  intersectSphere(t, e) {
    da.subVectors(t.center, this.origin);
    const n = da.dot(this.direction), i = da.dot(da) - n * n, a = t.radius * t.radius;
    if (i > a)
      return null;
    const o = Math.sqrt(a - i), s = n - o, l = n + o;
    return l < 0 ? null : s < 0 ? this.at(l, e) : this.at(s, e);
  }
  intersectsSphere(t) {
    return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
  }
  distanceToPlane(t) {
    const e = t.normal.dot(this.direction);
    if (e === 0)
      return t.distanceToPoint(this.origin) === 0 ? 0 : null;
    const n = -(this.origin.dot(t.normal) + t.constant) / e;
    return n >= 0 ? n : null;
  }
  intersectPlane(t, e) {
    const n = this.distanceToPlane(t);
    return n === null ? null : this.at(n, e);
  }
  intersectsPlane(t) {
    const e = t.distanceToPoint(this.origin);
    return e === 0 || t.normal.dot(this.direction) * e < 0;
  }
  intersectBox(t, e) {
    let n, i, a, o, s, l;
    const u = 1 / this.direction.x, c = 1 / this.direction.y, f = 1 / this.direction.z, h = this.origin;
    return u >= 0 ? (n = (t.min.x - h.x) * u, i = (t.max.x - h.x) * u) : (n = (t.max.x - h.x) * u, i = (t.min.x - h.x) * u), c >= 0 ? (a = (t.min.y - h.y) * c, o = (t.max.y - h.y) * c) : (a = (t.max.y - h.y) * c, o = (t.min.y - h.y) * c), n > o || a > i || ((a > n || isNaN(n)) && (n = a), (o < i || isNaN(i)) && (i = o), f >= 0 ? (s = (t.min.z - h.z) * f, l = (t.max.z - h.z) * f) : (s = (t.max.z - h.z) * f, l = (t.min.z - h.z) * f), n > l || s > i) || ((s > n || n !== n) && (n = s), (l < i || i !== i) && (i = l), i < 0) ? null : this.at(n >= 0 ? n : i, e);
  }
  intersectsBox(t) {
    return this.intersectBox(t, da) !== null;
  }
  intersectTriangle(t, e, n, i, a) {
    Hm.subVectors(e, t), id.subVectors(n, t), Wm.crossVectors(Hm, id);
    let o = this.direction.dot(Wm), s;
    if (o > 0) {
      if (i)
        return null;
      s = 1;
    } else if (o < 0)
      s = -1, o = -o;
    else
      return null;
    eo.subVectors(this.origin, t);
    const l = s * this.direction.dot(id.crossVectors(eo, id));
    if (l < 0)
      return null;
    const u = s * this.direction.dot(Hm.cross(eo));
    if (u < 0 || l + u > o)
      return null;
    const c = -s * eo.dot(Wm);
    return c < 0 ? null : this.at(c / o, a);
  }
  applyMatrix4(t) {
    return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this;
  }
  equals(t) {
    return t.origin.equals(this.origin) && t.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Ye {
  constructor(t, e, n, i, a, o, s, l, u, c, f, h, d, p, g, v) {
    Ye.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], t !== void 0 && this.set(t, e, n, i, a, o, s, l, u, c, f, h, d, p, g, v);
  }
  set(t, e, n, i, a, o, s, l, u, c, f, h, d, p, g, v) {
    const m = this.elements;
    return m[0] = t, m[4] = e, m[8] = n, m[12] = i, m[1] = a, m[5] = o, m[9] = s, m[13] = l, m[2] = u, m[6] = c, m[10] = f, m[14] = h, m[3] = d, m[7] = p, m[11] = g, m[15] = v, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new Ye().fromArray(this.elements);
  }
  copy(t) {
    const e = this.elements, n = t.elements;
    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this;
  }
  copyPosition(t) {
    const e = this.elements, n = t.elements;
    return e[12] = n[12], e[13] = n[13], e[14] = n[14], this;
  }
  setFromMatrix3(t) {
    const e = t.elements;
    return this.set(
      e[0],
      e[3],
      e[6],
      0,
      e[1],
      e[4],
      e[7],
      0,
      e[2],
      e[5],
      e[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(t, e, n) {
    return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(t, e, n) {
    return this.set(
      t.x,
      e.x,
      n.x,
      0,
      t.y,
      e.y,
      n.y,
      0,
      t.z,
      e.z,
      n.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(t) {
    const e = this.elements, n = t.elements, i = 1 / Fl.setFromMatrixColumn(t, 0).length(), a = 1 / Fl.setFromMatrixColumn(t, 1).length(), o = 1 / Fl.setFromMatrixColumn(t, 2).length();
    return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = 0, e[4] = n[4] * a, e[5] = n[5] * a, e[6] = n[6] * a, e[7] = 0, e[8] = n[8] * o, e[9] = n[9] * o, e[10] = n[10] * o, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
  }
  makeRotationFromEuler(t) {
    const e = this.elements, n = t.x, i = t.y, a = t.z, o = Math.cos(n), s = Math.sin(n), l = Math.cos(i), u = Math.sin(i), c = Math.cos(a), f = Math.sin(a);
    if (t.order === "XYZ") {
      const h = o * c, d = o * f, p = s * c, g = s * f;
      e[0] = l * c, e[4] = -l * f, e[8] = u, e[1] = d + p * u, e[5] = h - g * u, e[9] = -s * l, e[2] = g - h * u, e[6] = p + d * u, e[10] = o * l;
    } else if (t.order === "YXZ") {
      const h = l * c, d = l * f, p = u * c, g = u * f;
      e[0] = h + g * s, e[4] = p * s - d, e[8] = o * u, e[1] = o * f, e[5] = o * c, e[9] = -s, e[2] = d * s - p, e[6] = g + h * s, e[10] = o * l;
    } else if (t.order === "ZXY") {
      const h = l * c, d = l * f, p = u * c, g = u * f;
      e[0] = h - g * s, e[4] = -o * f, e[8] = p + d * s, e[1] = d + p * s, e[5] = o * c, e[9] = g - h * s, e[2] = -o * u, e[6] = s, e[10] = o * l;
    } else if (t.order === "ZYX") {
      const h = o * c, d = o * f, p = s * c, g = s * f;
      e[0] = l * c, e[4] = p * u - d, e[8] = h * u + g, e[1] = l * f, e[5] = g * u + h, e[9] = d * u - p, e[2] = -u, e[6] = s * l, e[10] = o * l;
    } else if (t.order === "YZX") {
      const h = o * l, d = o * u, p = s * l, g = s * u;
      e[0] = l * c, e[4] = g - h * f, e[8] = p * f + d, e[1] = f, e[5] = o * c, e[9] = -s * c, e[2] = -u * c, e[6] = d * f + p, e[10] = h - g * f;
    } else if (t.order === "XZY") {
      const h = o * l, d = o * u, p = s * l, g = s * u;
      e[0] = l * c, e[4] = -f, e[8] = u * c, e[1] = h * f + g, e[5] = o * c, e[9] = d * f - p, e[2] = p * f - d, e[6] = s * c, e[10] = g * f + h;
    }
    return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
  }
  makeRotationFromQuaternion(t) {
    return this.compose(Nz, t, Oz);
  }
  lookAt(t, e, n) {
    const i = this.elements;
    return Tn.subVectors(t, e), Tn.lengthSq() === 0 && (Tn.z = 1), Tn.normalize(), ro.crossVectors(n, Tn), ro.lengthSq() === 0 && (Math.abs(n.z) === 1 ? Tn.x += 1e-4 : Tn.z += 1e-4, Tn.normalize(), ro.crossVectors(n, Tn)), ro.normalize(), ad.crossVectors(Tn, ro), i[0] = ro.x, i[4] = ad.x, i[8] = Tn.x, i[1] = ro.y, i[5] = ad.y, i[9] = Tn.y, i[2] = ro.z, i[6] = ad.z, i[10] = Tn.z, this;
  }
  multiply(t) {
    return this.multiplyMatrices(this, t);
  }
  premultiply(t) {
    return this.multiplyMatrices(t, this);
  }
  multiplyMatrices(t, e) {
    const n = t.elements, i = e.elements, a = this.elements, o = n[0], s = n[4], l = n[8], u = n[12], c = n[1], f = n[5], h = n[9], d = n[13], p = n[2], g = n[6], v = n[10], m = n[14], y = n[3], _ = n[7], x = n[11], b = n[15], S = i[0], w = i[4], A = i[8], T = i[12], M = i[1], E = i[5], R = i[9], C = i[13], D = i[2], I = i[6], P = i[10], O = i[14], N = i[3], B = i[7], F = i[11], G = i[15];
    return a[0] = o * S + s * M + l * D + u * N, a[4] = o * w + s * E + l * I + u * B, a[8] = o * A + s * R + l * P + u * F, a[12] = o * T + s * C + l * O + u * G, a[1] = c * S + f * M + h * D + d * N, a[5] = c * w + f * E + h * I + d * B, a[9] = c * A + f * R + h * P + d * F, a[13] = c * T + f * C + h * O + d * G, a[2] = p * S + g * M + v * D + m * N, a[6] = p * w + g * E + v * I + m * B, a[10] = p * A + g * R + v * P + m * F, a[14] = p * T + g * C + v * O + m * G, a[3] = y * S + _ * M + x * D + b * N, a[7] = y * w + _ * E + x * I + b * B, a[11] = y * A + _ * R + x * P + b * F, a[15] = y * T + _ * C + x * O + b * G, this;
  }
  multiplyScalar(t) {
    const e = this.elements;
    return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this;
  }
  determinant() {
    const t = this.elements, e = t[0], n = t[4], i = t[8], a = t[12], o = t[1], s = t[5], l = t[9], u = t[13], c = t[2], f = t[6], h = t[10], d = t[14], p = t[3], g = t[7], v = t[11], m = t[15];
    return p * (+a * l * f - i * u * f - a * s * h + n * u * h + i * s * d - n * l * d) + g * (+e * l * d - e * u * h + a * o * h - i * o * d + i * u * c - a * l * c) + v * (+e * u * f - e * s * d - a * o * f + n * o * d + a * s * c - n * u * c) + m * (-i * s * c - e * l * f + e * s * h + i * o * f - n * o * h + n * l * c);
  }
  transpose() {
    const t = this.elements;
    let e;
    return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this;
  }
  setPosition(t, e, n) {
    const i = this.elements;
    return t.isVector3 ? (i[12] = t.x, i[13] = t.y, i[14] = t.z) : (i[12] = t, i[13] = e, i[14] = n), this;
  }
  invert() {
    const t = this.elements, e = t[0], n = t[1], i = t[2], a = t[3], o = t[4], s = t[5], l = t[6], u = t[7], c = t[8], f = t[9], h = t[10], d = t[11], p = t[12], g = t[13], v = t[14], m = t[15], y = f * v * u - g * h * u + g * l * d - s * v * d - f * l * m + s * h * m, _ = p * h * u - c * v * u - p * l * d + o * v * d + c * l * m - o * h * m, x = c * g * u - p * f * u + p * s * d - o * g * d - c * s * m + o * f * m, b = p * f * l - c * g * l - p * s * h + o * g * h + c * s * v - o * f * v, S = e * y + n * _ + i * x + a * b;
    if (S === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const w = 1 / S;
    return t[0] = y * w, t[1] = (g * h * a - f * v * a - g * i * d + n * v * d + f * i * m - n * h * m) * w, t[2] = (s * v * a - g * l * a + g * i * u - n * v * u - s * i * m + n * l * m) * w, t[3] = (f * l * a - s * h * a - f * i * u + n * h * u + s * i * d - n * l * d) * w, t[4] = _ * w, t[5] = (c * v * a - p * h * a + p * i * d - e * v * d - c * i * m + e * h * m) * w, t[6] = (p * l * a - o * v * a - p * i * u + e * v * u + o * i * m - e * l * m) * w, t[7] = (o * h * a - c * l * a + c * i * u - e * h * u - o * i * d + e * l * d) * w, t[8] = x * w, t[9] = (p * f * a - c * g * a - p * n * d + e * g * d + c * n * m - e * f * m) * w, t[10] = (o * g * a - p * s * a + p * n * u - e * g * u - o * n * m + e * s * m) * w, t[11] = (c * s * a - o * f * a - c * n * u + e * f * u + o * n * d - e * s * d) * w, t[12] = b * w, t[13] = (c * g * i - p * f * i + p * n * h - e * g * h - c * n * v + e * f * v) * w, t[14] = (p * s * i - o * g * i - p * n * l + e * g * l + o * n * v - e * s * v) * w, t[15] = (o * f * i - c * s * i + c * n * l - e * f * l - o * n * h + e * s * h) * w, this;
  }
  scale(t) {
    const e = this.elements, n = t.x, i = t.y, a = t.z;
    return e[0] *= n, e[4] *= i, e[8] *= a, e[1] *= n, e[5] *= i, e[9] *= a, e[2] *= n, e[6] *= i, e[10] *= a, e[3] *= n, e[7] *= i, e[11] *= a, this;
  }
  getMaxScaleOnAxis() {
    const t = this.elements, e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2], n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6], i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
    return Math.sqrt(Math.max(e, n, i));
  }
  makeTranslation(t, e, n) {
    return t.isVector3 ? this.set(
      1,
      0,
      0,
      t.x,
      0,
      1,
      0,
      t.y,
      0,
      0,
      1,
      t.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      t,
      0,
      1,
      0,
      e,
      0,
      0,
      1,
      n,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(t) {
    const e = Math.cos(t), n = Math.sin(t);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      e,
      -n,
      0,
      0,
      n,
      e,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(t) {
    const e = Math.cos(t), n = Math.sin(t);
    return this.set(
      e,
      0,
      n,
      0,
      0,
      1,
      0,
      0,
      -n,
      0,
      e,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(t) {
    const e = Math.cos(t), n = Math.sin(t);
    return this.set(
      e,
      -n,
      0,
      0,
      n,
      e,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(t, e) {
    const n = Math.cos(e), i = Math.sin(e), a = 1 - n, o = t.x, s = t.y, l = t.z, u = a * o, c = a * s;
    return this.set(
      u * o + n,
      u * s - i * l,
      u * l + i * s,
      0,
      u * s + i * l,
      c * s + n,
      c * l - i * o,
      0,
      u * l - i * s,
      c * l + i * o,
      a * l * l + n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(t, e, n) {
    return this.set(
      t,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(t, e, n, i, a, o) {
    return this.set(
      1,
      n,
      a,
      0,
      t,
      1,
      o,
      0,
      e,
      i,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(t, e, n) {
    const i = this.elements, a = e._x, o = e._y, s = e._z, l = e._w, u = a + a, c = o + o, f = s + s, h = a * u, d = a * c, p = a * f, g = o * c, v = o * f, m = s * f, y = l * u, _ = l * c, x = l * f, b = n.x, S = n.y, w = n.z;
    return i[0] = (1 - (g + m)) * b, i[1] = (d + x) * b, i[2] = (p - _) * b, i[3] = 0, i[4] = (d - x) * S, i[5] = (1 - (h + m)) * S, i[6] = (v + y) * S, i[7] = 0, i[8] = (p + _) * w, i[9] = (v - y) * w, i[10] = (1 - (h + g)) * w, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this;
  }
  decompose(t, e, n) {
    const i = this.elements;
    let a = Fl.set(i[0], i[1], i[2]).length();
    const o = Fl.set(i[4], i[5], i[6]).length(), s = Fl.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (a = -a), t.x = i[12], t.y = i[13], t.z = i[14], li.copy(this);
    const u = 1 / a, c = 1 / o, f = 1 / s;
    return li.elements[0] *= u, li.elements[1] *= u, li.elements[2] *= u, li.elements[4] *= c, li.elements[5] *= c, li.elements[6] *= c, li.elements[8] *= f, li.elements[9] *= f, li.elements[10] *= f, e.setFromRotationMatrix(li), n.x = a, n.y = o, n.z = s, this;
  }
  makePerspective(t, e, n, i, a, o, s = Ca) {
    const l = this.elements, u = 2 * a / (e - t), c = 2 * a / (n - i), f = (e + t) / (e - t), h = (n + i) / (n - i);
    let d, p;
    if (s === Ca)
      d = -(o + a) / (o - a), p = -2 * o * a / (o - a);
    else if (s === dv)
      d = -o / (o - a), p = -o * a / (o - a);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + s);
    return l[0] = u, l[4] = 0, l[8] = f, l[12] = 0, l[1] = 0, l[5] = c, l[9] = h, l[13] = 0, l[2] = 0, l[6] = 0, l[10] = d, l[14] = p, l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this;
  }
  makeOrthographic(t, e, n, i, a, o, s = Ca) {
    const l = this.elements, u = 1 / (e - t), c = 1 / (n - i), f = 1 / (o - a), h = (e + t) * u, d = (n + i) * c;
    let p, g;
    if (s === Ca)
      p = (o + a) * f, g = -2 * f;
    else if (s === dv)
      p = a * f, g = -1 * f;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + s);
    return l[0] = 2 * u, l[4] = 0, l[8] = 0, l[12] = -h, l[1] = 0, l[5] = 2 * c, l[9] = 0, l[13] = -d, l[2] = 0, l[6] = 0, l[10] = g, l[14] = -p, l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this;
  }
  equals(t) {
    const e = this.elements, n = t.elements;
    for (let i = 0; i < 16; i++)
      if (e[i] !== n[i])
        return !1;
    return !0;
  }
  fromArray(t, e = 0) {
    for (let n = 0; n < 16; n++)
      this.elements[n] = t[n + e];
    return this;
  }
  toArray(t = [], e = 0) {
    const n = this.elements;
    return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t;
  }
}
const Fl = /* @__PURE__ */ new j(), li = /* @__PURE__ */ new Ye(), Nz = /* @__PURE__ */ new j(0, 0, 0), Oz = /* @__PURE__ */ new j(1, 1, 1), ro = /* @__PURE__ */ new j(), ad = /* @__PURE__ */ new j(), Tn = /* @__PURE__ */ new j(), AM = /* @__PURE__ */ new Ye(), EM = /* @__PURE__ */ new Rh();
class Va {
  constructor(t = 0, e = 0, n = 0, i = Va.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = t, this._y = e, this._z = n, this._order = i;
  }
  get x() {
    return this._x;
  }
  set x(t) {
    this._x = t, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(t) {
    this._y = t, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(t) {
    this._z = t, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(t) {
    this._order = t, this._onChangeCallback();
  }
  set(t, e, n, i = this._order) {
    return this._x = t, this._y = e, this._z = n, this._order = i, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(t) {
    return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(t, e = this._order, n = !0) {
    const i = t.elements, a = i[0], o = i[4], s = i[8], l = i[1], u = i[5], c = i[9], f = i[2], h = i[6], d = i[10];
    switch (e) {
      case "XYZ":
        this._y = Math.asin(an(s, -1, 1)), Math.abs(s) < 0.9999999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-o, a)) : (this._x = Math.atan2(h, u), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-an(c, -1, 1)), Math.abs(c) < 0.9999999 ? (this._y = Math.atan2(s, d), this._z = Math.atan2(l, u)) : (this._y = Math.atan2(-f, a), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(an(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._y = Math.atan2(-f, d), this._z = Math.atan2(-o, u)) : (this._y = 0, this._z = Math.atan2(l, a));
        break;
      case "ZYX":
        this._y = Math.asin(-an(f, -1, 1)), Math.abs(f) < 0.9999999 ? (this._x = Math.atan2(h, d), this._z = Math.atan2(l, a)) : (this._x = 0, this._z = Math.atan2(-o, u));
        break;
      case "YZX":
        this._z = Math.asin(an(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-c, u), this._y = Math.atan2(-f, a)) : (this._x = 0, this._y = Math.atan2(s, d));
        break;
      case "XZY":
        this._z = Math.asin(-an(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(h, u), this._y = Math.atan2(s, a)) : (this._x = Math.atan2(-c, d), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e);
    }
    return this._order = e, n === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(t, e, n) {
    return AM.makeRotationFromQuaternion(t), this.setFromRotationMatrix(AM, e, n);
  }
  setFromVector3(t, e = this._order) {
    return this.set(t.x, t.y, t.z, e);
  }
  reorder(t) {
    return EM.setFromEuler(this), this.setFromQuaternion(EM, t);
  }
  equals(t) {
    return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order;
  }
  fromArray(t) {
    return this._x = t[0], this._y = t[1], this._z = t[2], t[3] !== void 0 && (this._order = t[3]), this._onChangeCallback(), this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t;
  }
  _onChange(t) {
    return this._onChangeCallback = t, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
Va.DEFAULT_ORDER = "XYZ";
class h1 {
  constructor() {
    this.mask = 1;
  }
  set(t) {
    this.mask = (1 << t | 0) >>> 0;
  }
  enable(t) {
    this.mask |= 1 << t | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(t) {
    this.mask ^= 1 << t | 0;
  }
  disable(t) {
    this.mask &= ~(1 << t | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(t) {
    return (this.mask & t.mask) !== 0;
  }
  isEnabled(t) {
    return (this.mask & (1 << t | 0)) !== 0;
  }
}
let kz = 0;
const CM = /* @__PURE__ */ new j(), zl = /* @__PURE__ */ new Rh(), pa = /* @__PURE__ */ new Ye(), od = /* @__PURE__ */ new j(), zc = /* @__PURE__ */ new j(), Bz = /* @__PURE__ */ new j(), Vz = /* @__PURE__ */ new Rh(), DM = /* @__PURE__ */ new j(1, 0, 0), LM = /* @__PURE__ */ new j(0, 1, 0), RM = /* @__PURE__ */ new j(0, 0, 1), IM = { type: "added" }, Fz = { type: "removed" }, Ul = { type: "childadded", child: null }, Xm = { type: "childremoved", child: null };
class Nr extends vc {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: kz++ }), this.uuid = Lh(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Nr.DEFAULT_UP.clone();
    const t = new j(), e = new Va(), n = new Rh(), i = new j(1, 1, 1);
    function a() {
      n.setFromEuler(e, !1);
    }
    function o() {
      e.setFromQuaternion(n, void 0, !1);
    }
    e._onChange(a), n._onChange(o), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: t
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      modelViewMatrix: {
        value: new Ye()
      },
      normalMatrix: {
        value: new ye()
      }
    }), this.matrix = new Ye(), this.matrixWorld = new Ye(), this.matrixAutoUpdate = Nr.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = Nr.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new h1(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(t) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(t) {
    return this.quaternion.premultiply(t), this;
  }
  setRotationFromAxisAngle(t, e) {
    this.quaternion.setFromAxisAngle(t, e);
  }
  setRotationFromEuler(t) {
    this.quaternion.setFromEuler(t, !0);
  }
  setRotationFromMatrix(t) {
    this.quaternion.setFromRotationMatrix(t);
  }
  setRotationFromQuaternion(t) {
    this.quaternion.copy(t);
  }
  rotateOnAxis(t, e) {
    return zl.setFromAxisAngle(t, e), this.quaternion.multiply(zl), this;
  }
  rotateOnWorldAxis(t, e) {
    return zl.setFromAxisAngle(t, e), this.quaternion.premultiply(zl), this;
  }
  rotateX(t) {
    return this.rotateOnAxis(DM, t);
  }
  rotateY(t) {
    return this.rotateOnAxis(LM, t);
  }
  rotateZ(t) {
    return this.rotateOnAxis(RM, t);
  }
  translateOnAxis(t, e) {
    return CM.copy(t).applyQuaternion(this.quaternion), this.position.add(CM.multiplyScalar(e)), this;
  }
  translateX(t) {
    return this.translateOnAxis(DM, t);
  }
  translateY(t) {
    return this.translateOnAxis(LM, t);
  }
  translateZ(t) {
    return this.translateOnAxis(RM, t);
  }
  localToWorld(t) {
    return this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(t) {
    return this.updateWorldMatrix(!0, !1), t.applyMatrix4(pa.copy(this.matrixWorld).invert());
  }
  lookAt(t, e, n) {
    t.isVector3 ? od.copy(t) : od.set(t, e, n);
    const i = this.parent;
    this.updateWorldMatrix(!0, !1), zc.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? pa.lookAt(zc, od, this.up) : pa.lookAt(od, zc, this.up), this.quaternion.setFromRotationMatrix(pa), i && (pa.extractRotation(i.matrixWorld), zl.setFromRotationMatrix(pa), this.quaternion.premultiply(zl.invert()));
  }
  add(t) {
    if (arguments.length > 1) {
      for (let e = 0; e < arguments.length; e++)
        this.add(arguments[e]);
      return this;
    }
    return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (t.removeFromParent(), t.parent = this, this.children.push(t), t.dispatchEvent(IM), Ul.child = t, this.dispatchEvent(Ul), Ul.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this);
  }
  remove(t) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++)
        this.remove(arguments[n]);
      return this;
    }
    const e = this.children.indexOf(t);
    return e !== -1 && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(Fz), Xm.child = t, this.dispatchEvent(Xm), Xm.child = null), this;
  }
  removeFromParent() {
    const t = this.parent;
    return t !== null && t.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(t) {
    return this.updateWorldMatrix(!0, !1), pa.copy(this.matrixWorld).invert(), t.parent !== null && (t.parent.updateWorldMatrix(!0, !1), pa.multiply(t.parent.matrixWorld)), t.applyMatrix4(pa), t.removeFromParent(), t.parent = this, this.children.push(t), t.updateWorldMatrix(!1, !0), t.dispatchEvent(IM), Ul.child = t, this.dispatchEvent(Ul), Ul.child = null, this;
  }
  getObjectById(t) {
    return this.getObjectByProperty("id", t);
  }
  getObjectByName(t) {
    return this.getObjectByProperty("name", t);
  }
  getObjectByProperty(t, e) {
    if (this[t] === e)
      return this;
    for (let n = 0, i = this.children.length; n < i; n++) {
      const o = this.children[n].getObjectByProperty(t, e);
      if (o !== void 0)
        return o;
    }
  }
  getObjectsByProperty(t, e, n = []) {
    this[t] === e && n.push(this);
    const i = this.children;
    for (let a = 0, o = i.length; a < o; a++)
      i[a].getObjectsByProperty(t, e, n);
    return n;
  }
  getWorldPosition(t) {
    return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(t) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(zc, t, Bz), t;
  }
  getWorldScale(t) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(zc, Vz, t), t;
  }
  getWorldDirection(t) {
    this.updateWorldMatrix(!0, !1);
    const e = this.matrixWorld.elements;
    return t.set(e[8], e[9], e[10]).normalize();
  }
  raycast() {
  }
  traverse(t) {
    t(this);
    const e = this.children;
    for (let n = 0, i = e.length; n < i; n++)
      e[n].traverse(t);
  }
  traverseVisible(t) {
    if (this.visible === !1)
      return;
    t(this);
    const e = this.children;
    for (let n = 0, i = e.length; n < i; n++)
      e[n].traverseVisible(t);
  }
  traverseAncestors(t) {
    const e = this.parent;
    e !== null && (t(e), e.traverseAncestors(t));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(t) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
    const e = this.children;
    for (let n = 0, i = e.length; n < i; n++) {
      const a = e[n];
      (a.matrixWorldAutoUpdate === !0 || t === !0) && a.updateMatrixWorld(t);
    }
  }
  updateWorldMatrix(t, e) {
    const n = this.parent;
    if (t === !0 && n !== null && n.matrixWorldAutoUpdate === !0 && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), e === !0) {
      const i = this.children;
      for (let a = 0, o = i.length; a < o; a++) {
        const s = i[a];
        s.matrixWorldAutoUpdate === !0 && s.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(t) {
    const e = t === void 0 || typeof t == "string", n = {};
    e && (t = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, n.metadata = {
      version: 4.6,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const i = {};
    i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.castShadow === !0 && (i.castShadow = !0), this.receiveShadow === !0 && (i.receiveShadow = !0), this.visible === !1 && (i.visible = !1), this.frustumCulled === !1 && (i.frustumCulled = !1), this.renderOrder !== 0 && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), i.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (i.type = "BatchedMesh", i.perObjectFrustumCulled = this.perObjectFrustumCulled, i.sortObjects = this.sortObjects, i.drawRanges = this._drawRanges, i.reservedRanges = this._reservedRanges, i.visibility = this._visibility, i.active = this._active, i.bounds = this._bounds.map((s) => ({
      boxInitialized: s.boxInitialized,
      boxMin: s.box.min.toArray(),
      boxMax: s.box.max.toArray(),
      sphereInitialized: s.sphereInitialized,
      sphereRadius: s.sphere.radius,
      sphereCenter: s.sphere.center.toArray()
    })), i.maxGeometryCount = this._maxGeometryCount, i.maxVertexCount = this._maxVertexCount, i.maxIndexCount = this._maxIndexCount, i.geometryInitialized = this._geometryInitialized, i.geometryCount = this._geometryCount, i.matricesTexture = this._matricesTexture.toJSON(t), this.boundingSphere !== null && (i.boundingSphere = {
      center: i.boundingSphere.center.toArray(),
      radius: i.boundingSphere.radius
    }), this.boundingBox !== null && (i.boundingBox = {
      min: i.boundingBox.min.toArray(),
      max: i.boundingBox.max.toArray()
    }));
    function a(s, l) {
      return s[l.uuid] === void 0 && (s[l.uuid] = l.toJSON(t)), l.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (i.environment = this.environment.toJSON(t).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = a(t.geometries, this.geometry);
      const s = this.geometry.parameters;
      if (s !== void 0 && s.shapes !== void 0) {
        const l = s.shapes;
        if (Array.isArray(l))
          for (let u = 0, c = l.length; u < c; u++) {
            const f = l[u];
            a(t.shapes, f);
          }
        else
          a(t.shapes, l);
      }
    }
    if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (a(t.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const s = [];
        for (let l = 0, u = this.material.length; l < u; l++)
          s.push(a(t.materials, this.material[l]));
        i.material = s;
      } else
        i.material = a(t.materials, this.material);
    if (this.children.length > 0) {
      i.children = [];
      for (let s = 0; s < this.children.length; s++)
        i.children.push(this.children[s].toJSON(t).object);
    }
    if (this.animations.length > 0) {
      i.animations = [];
      for (let s = 0; s < this.animations.length; s++) {
        const l = this.animations[s];
        i.animations.push(a(t.animations, l));
      }
    }
    if (e) {
      const s = o(t.geometries), l = o(t.materials), u = o(t.textures), c = o(t.images), f = o(t.shapes), h = o(t.skeletons), d = o(t.animations), p = o(t.nodes);
      s.length > 0 && (n.geometries = s), l.length > 0 && (n.materials = l), u.length > 0 && (n.textures = u), c.length > 0 && (n.images = c), f.length > 0 && (n.shapes = f), h.length > 0 && (n.skeletons = h), d.length > 0 && (n.animations = d), p.length > 0 && (n.nodes = p);
    }
    return n.object = i, n;
    function o(s) {
      const l = [];
      for (const u in s) {
        const c = s[u];
        delete c.metadata, l.push(c);
      }
      return l;
    }
  }
  clone(t) {
    return new this.constructor().copy(this, t);
  }
  copy(t, e = !0) {
    if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.animations = t.animations.slice(), this.userData = JSON.parse(JSON.stringify(t.userData)), e === !0)
      for (let n = 0; n < t.children.length; n++) {
        const i = t.children[n];
        this.add(i.clone());
      }
    return this;
  }
}
Nr.DEFAULT_UP = /* @__PURE__ */ new j(0, 1, 0);
Nr.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Nr.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const ui = /* @__PURE__ */ new j(), va = /* @__PURE__ */ new j(), Ym = /* @__PURE__ */ new j(), ga = /* @__PURE__ */ new j(), Gl = /* @__PURE__ */ new j(), Hl = /* @__PURE__ */ new j(), PM = /* @__PURE__ */ new j(), $m = /* @__PURE__ */ new j(), Zm = /* @__PURE__ */ new j(), qm = /* @__PURE__ */ new j();
let sd = class Au {
  constructor(t = new j(), e = new j(), n = new j()) {
    this.a = t, this.b = e, this.c = n;
  }
  static getNormal(t, e, n, i) {
    i.subVectors(n, e), ui.subVectors(t, e), i.cross(ui);
    const a = i.lengthSq();
    return a > 0 ? i.multiplyScalar(1 / Math.sqrt(a)) : i.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(t, e, n, i, a) {
    ui.subVectors(i, e), va.subVectors(n, e), Ym.subVectors(t, e);
    const o = ui.dot(ui), s = ui.dot(va), l = ui.dot(Ym), u = va.dot(va), c = va.dot(Ym), f = o * u - s * s;
    if (f === 0)
      return a.set(0, 0, 0), null;
    const h = 1 / f, d = (u * l - s * c) * h, p = (o * c - s * l) * h;
    return a.set(1 - d - p, p, d);
  }
  static containsPoint(t, e, n, i) {
    return this.getBarycoord(t, e, n, i, ga) === null ? !1 : ga.x >= 0 && ga.y >= 0 && ga.x + ga.y <= 1;
  }
  static getInterpolation(t, e, n, i, a, o, s, l) {
    return this.getBarycoord(t, e, n, i, ga) === null ? (l.x = 0, l.y = 0, "z" in l && (l.z = 0), "w" in l && (l.w = 0), null) : (l.setScalar(0), l.addScaledVector(a, ga.x), l.addScaledVector(o, ga.y), l.addScaledVector(s, ga.z), l);
  }
  static isFrontFacing(t, e, n, i) {
    return ui.subVectors(n, e), va.subVectors(t, e), ui.cross(va).dot(i) < 0;
  }
  set(t, e, n) {
    return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
  }
  setFromPointsAndIndices(t, e, n, i) {
    return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this;
  }
  setFromAttributeAndIndices(t, e, n, i) {
    return this.a.fromBufferAttribute(t, e), this.b.fromBufferAttribute(t, n), this.c.fromBufferAttribute(t, i), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
  }
  getArea() {
    return ui.subVectors(this.c, this.b), va.subVectors(this.a, this.b), ui.cross(va).length() * 0.5;
  }
  getMidpoint(t) {
    return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(t) {
    return Au.getNormal(this.a, this.b, this.c, t);
  }
  getPlane(t) {
    return t.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(t, e) {
    return Au.getBarycoord(t, this.a, this.b, this.c, e);
  }
  getInterpolation(t, e, n, i, a) {
    return Au.getInterpolation(t, this.a, this.b, this.c, e, n, i, a);
  }
  containsPoint(t) {
    return Au.containsPoint(t, this.a, this.b, this.c);
  }
  isFrontFacing(t) {
    return Au.isFrontFacing(this.a, this.b, this.c, t);
  }
  intersectsBox(t) {
    return t.intersectsTriangle(this);
  }
  closestPointToPoint(t, e) {
    const n = this.a, i = this.b, a = this.c;
    let o, s;
    Gl.subVectors(i, n), Hl.subVectors(a, n), $m.subVectors(t, n);
    const l = Gl.dot($m), u = Hl.dot($m);
    if (l <= 0 && u <= 0)
      return e.copy(n);
    Zm.subVectors(t, i);
    const c = Gl.dot(Zm), f = Hl.dot(Zm);
    if (c >= 0 && f <= c)
      return e.copy(i);
    const h = l * f - c * u;
    if (h <= 0 && l >= 0 && c <= 0)
      return o = l / (l - c), e.copy(n).addScaledVector(Gl, o);
    qm.subVectors(t, a);
    const d = Gl.dot(qm), p = Hl.dot(qm);
    if (p >= 0 && d <= p)
      return e.copy(a);
    const g = d * u - l * p;
    if (g <= 0 && u >= 0 && p <= 0)
      return s = u / (u - p), e.copy(n).addScaledVector(Hl, s);
    const v = c * p - d * f;
    if (v <= 0 && f - c >= 0 && d - p >= 0)
      return PM.subVectors(a, i), s = (f - c) / (f - c + (d - p)), e.copy(i).addScaledVector(PM, s);
    const m = 1 / (v + g + h);
    return o = g * m, s = h * m, e.copy(n).addScaledVector(Gl, o).addScaledVector(Hl, s);
  }
  equals(t) {
    return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
  }
};
const wI = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, no = { h: 0, s: 0, l: 0 }, ld = { h: 0, s: 0, l: 0 };
function Km(r, t, e) {
  return e < 0 && (e += 1), e > 1 && (e -= 1), e < 1 / 6 ? r + (t - r) * 6 * e : e < 1 / 2 ? t : e < 2 / 3 ? r + (t - r) * 6 * (2 / 3 - e) : r;
}
class le {
  constructor(t, e, n) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(t, e, n);
  }
  set(t, e, n) {
    if (e === void 0 && n === void 0) {
      const i = t;
      i && i.isColor ? this.copy(i) : typeof i == "number" ? this.setHex(i) : typeof i == "string" && this.setStyle(i);
    } else
      this.setRGB(t, e, n);
    return this;
  }
  setScalar(t) {
    return this.r = t, this.g = t, this.b = t, this;
  }
  setHex(t, e = Bi) {
    return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (t & 255) / 255, Fe.toWorkingColorSpace(this, e), this;
  }
  setRGB(t, e, n, i = Fe.workingColorSpace) {
    return this.r = t, this.g = e, this.b = n, Fe.toWorkingColorSpace(this, i), this;
  }
  setHSL(t, e, n, i = Fe.workingColorSpace) {
    if (t = Mz(t, 1), e = an(e, 0, 1), n = an(n, 0, 1), e === 0)
      this.r = this.g = this.b = n;
    else {
      const a = n <= 0.5 ? n * (1 + e) : n + e - n * e, o = 2 * n - a;
      this.r = Km(o, a, t + 1 / 3), this.g = Km(o, a, t), this.b = Km(o, a, t - 1 / 3);
    }
    return Fe.toWorkingColorSpace(this, i), this;
  }
  setStyle(t, e = Bi) {
    function n(a) {
      a !== void 0 && parseFloat(a) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.");
    }
    let i;
    if (i = /^(\w+)\(([^\)]*)\)/.exec(t)) {
      let a;
      const o = i[1], s = i[2];
      switch (o) {
        case "rgb":
        case "rgba":
          if (a = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))
            return n(a[4]), this.setRGB(
              Math.min(255, parseInt(a[1], 10)) / 255,
              Math.min(255, parseInt(a[2], 10)) / 255,
              Math.min(255, parseInt(a[3], 10)) / 255,
              e
            );
          if (a = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))
            return n(a[4]), this.setRGB(
              Math.min(100, parseInt(a[1], 10)) / 100,
              Math.min(100, parseInt(a[2], 10)) / 100,
              Math.min(100, parseInt(a[3], 10)) / 100,
              e
            );
          break;
        case "hsl":
        case "hsla":
          if (a = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))
            return n(a[4]), this.setHSL(
              parseFloat(a[1]) / 360,
              parseFloat(a[2]) / 100,
              parseFloat(a[3]) / 100,
              e
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + t);
      }
    } else if (i = /^\#([A-Fa-f\d]+)$/.exec(t)) {
      const a = i[1], o = a.length;
      if (o === 3)
        return this.setRGB(
          parseInt(a.charAt(0), 16) / 15,
          parseInt(a.charAt(1), 16) / 15,
          parseInt(a.charAt(2), 16) / 15,
          e
        );
      if (o === 6)
        return this.setHex(parseInt(a, 16), e);
      console.warn("THREE.Color: Invalid hex color " + t);
    } else if (t && t.length > 0)
      return this.setColorName(t, e);
    return this;
  }
  setColorName(t, e = Bi) {
    const n = wI[t.toLowerCase()];
    return n !== void 0 ? this.setHex(n, e) : console.warn("THREE.Color: Unknown color " + t), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(t) {
    return this.r = t.r, this.g = t.g, this.b = t.b, this;
  }
  copySRGBToLinear(t) {
    return this.r = Gu(t.r), this.g = Gu(t.g), this.b = Gu(t.b), this;
  }
  copyLinearToSRGB(t) {
    return this.r = Bm(t.r), this.g = Bm(t.g), this.b = Bm(t.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(t = Bi) {
    return Fe.fromWorkingColorSpace(Yr.copy(this), t), Math.round(an(Yr.r * 255, 0, 255)) * 65536 + Math.round(an(Yr.g * 255, 0, 255)) * 256 + Math.round(an(Yr.b * 255, 0, 255));
  }
  getHexString(t = Bi) {
    return ("000000" + this.getHex(t).toString(16)).slice(-6);
  }
  getHSL(t, e = Fe.workingColorSpace) {
    Fe.fromWorkingColorSpace(Yr.copy(this), e);
    const n = Yr.r, i = Yr.g, a = Yr.b, o = Math.max(n, i, a), s = Math.min(n, i, a);
    let l, u;
    const c = (s + o) / 2;
    if (s === o)
      l = 0, u = 0;
    else {
      const f = o - s;
      switch (u = c <= 0.5 ? f / (o + s) : f / (2 - o - s), o) {
        case n:
          l = (i - a) / f + (i < a ? 6 : 0);
          break;
        case i:
          l = (a - n) / f + 2;
          break;
        case a:
          l = (n - i) / f + 4;
          break;
      }
      l /= 6;
    }
    return t.h = l, t.s = u, t.l = c, t;
  }
  getRGB(t, e = Fe.workingColorSpace) {
    return Fe.fromWorkingColorSpace(Yr.copy(this), e), t.r = Yr.r, t.g = Yr.g, t.b = Yr.b, t;
  }
  getStyle(t = Bi) {
    Fe.fromWorkingColorSpace(Yr.copy(this), t);
    const e = Yr.r, n = Yr.g, i = Yr.b;
    return t !== Bi ? `color(${t} ${e.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(e * 255)},${Math.round(n * 255)},${Math.round(i * 255)})`;
  }
  offsetHSL(t, e, n) {
    return this.getHSL(no), this.setHSL(no.h + t, no.s + e, no.l + n);
  }
  add(t) {
    return this.r += t.r, this.g += t.g, this.b += t.b, this;
  }
  addColors(t, e) {
    return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this;
  }
  addScalar(t) {
    return this.r += t, this.g += t, this.b += t, this;
  }
  sub(t) {
    return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this;
  }
  multiply(t) {
    return this.r *= t.r, this.g *= t.g, this.b *= t.b, this;
  }
  multiplyScalar(t) {
    return this.r *= t, this.g *= t, this.b *= t, this;
  }
  lerp(t, e) {
    return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this;
  }
  lerpColors(t, e, n) {
    return this.r = t.r + (e.r - t.r) * n, this.g = t.g + (e.g - t.g) * n, this.b = t.b + (e.b - t.b) * n, this;
  }
  lerpHSL(t, e) {
    this.getHSL(no), t.getHSL(ld);
    const n = Om(no.h, ld.h, e), i = Om(no.s, ld.s, e), a = Om(no.l, ld.l, e);
    return this.setHSL(n, i, a), this;
  }
  setFromVector3(t) {
    return this.r = t.x, this.g = t.y, this.b = t.z, this;
  }
  applyMatrix3(t) {
    const e = this.r, n = this.g, i = this.b, a = t.elements;
    return this.r = a[0] * e + a[3] * n + a[6] * i, this.g = a[1] * e + a[4] * n + a[7] * i, this.b = a[2] * e + a[5] * n + a[8] * i, this;
  }
  equals(t) {
    return t.r === this.r && t.g === this.g && t.b === this.b;
  }
  fromArray(t, e = 0) {
    return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t;
  }
  fromBufferAttribute(t, e) {
    return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const Yr = /* @__PURE__ */ new le();
le.NAMES = wI;
let zz = 0;
class Ih extends vc {
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: zz++ }), this.uuid = Lh(), this.name = "", this.type = "Material", this.blending = zu, this.side = Vo, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = F_, this.blendDst = z_, this.blendEquation = zs, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new le(0, 0, 0), this.blendAlpha = 0, this.depthFunc = uv, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = _M, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Nl, this.stencilZFail = Nl, this.stencilZPass = Nl, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(t) {
    this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(t) {
    if (t !== void 0)
      for (const e in t) {
        const n = t[e];
        if (n === void 0) {
          console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);
          continue;
        }
        const i = this[e];
        if (i === void 0) {
          console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`);
          continue;
        }
        i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = n;
      }
  }
  toJSON(t) {
    const e = t === void 0 || typeof t == "string";
    e && (t = {
      textures: {},
      images: {}
    });
    const n = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (n.dispersion = this.dispersion), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(t).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(t).uuid), this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(t).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapRotation !== void 0 && (n.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== zu && (n.blending = this.blending), this.side !== Vo && (n.side = this.side), this.vertexColors === !0 && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = !0), this.blendSrc !== F_ && (n.blendSrc = this.blendSrc), this.blendDst !== z_ && (n.blendDst = this.blendDst), this.blendEquation !== zs && (n.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha), this.depthFunc !== uv && (n.depthFunc = this.depthFunc), this.depthTest === !1 && (n.depthTest = this.depthTest), this.depthWrite === !1 && (n.depthWrite = this.depthWrite), this.colorWrite === !1 && (n.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== _M && (n.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (n.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== Nl && (n.stencilFail = this.stencilFail), this.stencilZFail !== Nl && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== Nl && (n.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaHash === !0 && (n.alphaHash = !0), this.alphaToCoverage === !0 && (n.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0), this.forceSinglePass === !0 && (n.forceSinglePass = !0), this.wireframe === !0 && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (n.flatShading = !0), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), this.fog === !1 && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData);
    function i(a) {
      const o = [];
      for (const s in a) {
        const l = a[s];
        delete l.metadata, o.push(l);
      }
      return o;
    }
    if (e) {
      const a = i(t.textures), o = i(t.images);
      a.length > 0 && (n.textures = a), o.length > 0 && (n.images = o);
    }
    return n;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    this.name = t.name, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.blendColor.copy(t.blendColor), this.blendAlpha = t.blendAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
    const e = t.clippingPlanes;
    let n = null;
    if (e !== null) {
      const i = e.length;
      n = new Array(i);
      for (let a = 0; a !== i; ++a)
        n[a] = e[a].clone();
    }
    return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaHash = t.alphaHash, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.forceSinglePass = t.forceSinglePass, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(t) {
    t === !0 && this.version++;
  }
}
class d1 extends Ih {
  constructor(t) {
    super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new le(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Va(), this.combine = uI, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.fog = t.fog, this;
  }
}
const pr = /* @__PURE__ */ new j(), ud = /* @__PURE__ */ new Ce();
class ri {
  constructor(t, e, n = !1) {
    if (Array.isArray(t))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = t, this.itemSize = e, this.count = t !== void 0 ? t.length / e : 0, this.normalized = n, this.usage = xM, this._updateRange = { offset: 0, count: -1 }, this.updateRanges = [], this.gpuType = Ea, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(t) {
    t === !0 && this.version++;
  }
  get updateRange() {
    return Az("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange;
  }
  setUsage(t) {
    return this.usage = t, this;
  }
  addUpdateRange(t, e) {
    this.updateRanges.push({ start: t, count: e });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(t) {
    return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this.gpuType = t.gpuType, this;
  }
  copyAt(t, e, n) {
    t *= this.itemSize, n *= e.itemSize;
    for (let i = 0, a = this.itemSize; i < a; i++)
      this.array[t + i] = e.array[n + i];
    return this;
  }
  copyArray(t) {
    return this.array.set(t), this;
  }
  applyMatrix3(t) {
    if (this.itemSize === 2)
      for (let e = 0, n = this.count; e < n; e++)
        ud.fromBufferAttribute(this, e), ud.applyMatrix3(t), this.setXY(e, ud.x, ud.y);
    else if (this.itemSize === 3)
      for (let e = 0, n = this.count; e < n; e++)
        pr.fromBufferAttribute(this, e), pr.applyMatrix3(t), this.setXYZ(e, pr.x, pr.y, pr.z);
    return this;
  }
  applyMatrix4(t) {
    for (let e = 0, n = this.count; e < n; e++)
      pr.fromBufferAttribute(this, e), pr.applyMatrix4(t), this.setXYZ(e, pr.x, pr.y, pr.z);
    return this;
  }
  applyNormalMatrix(t) {
    for (let e = 0, n = this.count; e < n; e++)
      pr.fromBufferAttribute(this, e), pr.applyNormalMatrix(t), this.setXYZ(e, pr.x, pr.y, pr.z);
    return this;
  }
  transformDirection(t) {
    for (let e = 0, n = this.count; e < n; e++)
      pr.fromBufferAttribute(this, e), pr.transformDirection(t), this.setXYZ(e, pr.x, pr.y, pr.z);
    return this;
  }
  set(t, e = 0) {
    return this.array.set(t, e), this;
  }
  getComponent(t, e) {
    let n = this.array[t * this.itemSize + e];
    return this.normalized && (n = Bc(n, this.array)), n;
  }
  setComponent(t, e, n) {
    return this.normalized && (n = pn(n, this.array)), this.array[t * this.itemSize + e] = n, this;
  }
  getX(t) {
    let e = this.array[t * this.itemSize];
    return this.normalized && (e = Bc(e, this.array)), e;
  }
  setX(t, e) {
    return this.normalized && (e = pn(e, this.array)), this.array[t * this.itemSize] = e, this;
  }
  getY(t) {
    let e = this.array[t * this.itemSize + 1];
    return this.normalized && (e = Bc(e, this.array)), e;
  }
  setY(t, e) {
    return this.normalized && (e = pn(e, this.array)), this.array[t * this.itemSize + 1] = e, this;
  }
  getZ(t) {
    let e = this.array[t * this.itemSize + 2];
    return this.normalized && (e = Bc(e, this.array)), e;
  }
  setZ(t, e) {
    return this.normalized && (e = pn(e, this.array)), this.array[t * this.itemSize + 2] = e, this;
  }
  getW(t) {
    let e = this.array[t * this.itemSize + 3];
    return this.normalized && (e = Bc(e, this.array)), e;
  }
  setW(t, e) {
    return this.normalized && (e = pn(e, this.array)), this.array[t * this.itemSize + 3] = e, this;
  }
  setXY(t, e, n) {
    return t *= this.itemSize, this.normalized && (e = pn(e, this.array), n = pn(n, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this;
  }
  setXYZ(t, e, n, i) {
    return t *= this.itemSize, this.normalized && (e = pn(e, this.array), n = pn(n, this.array), i = pn(i, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this;
  }
  setXYZW(t, e, n, i, a) {
    return t *= this.itemSize, this.normalized && (e = pn(e, this.array), n = pn(n, this.array), i = pn(i, this.array), a = pn(a, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this.array[t + 3] = a, this;
  }
  onUpload(t) {
    return this.onUploadCallback = t, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const t = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (t.name = this.name), this.usage !== xM && (t.usage = this.usage), t;
  }
}
class MI extends ri {
  constructor(t, e, n) {
    super(new Uint16Array(t), e, n);
  }
}
class TI extends ri {
  constructor(t, e, n) {
    super(new Uint32Array(t), e, n);
  }
}
class On extends ri {
  constructor(t, e, n) {
    super(new Float32Array(t), e, n);
  }
}
let Uz = 0;
const zn = /* @__PURE__ */ new Ye(), jm = /* @__PURE__ */ new Nr(), Wl = /* @__PURE__ */ new j(), An = /* @__PURE__ */ new Sl(), Uc = /* @__PURE__ */ new Sl(), Cr = /* @__PURE__ */ new j();
class ua extends vc {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: Uz++ }), this.uuid = Lh(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(t) {
    return Array.isArray(t) ? this.index = new (xI(t) ? TI : MI)(t, 1) : this.index = t, this;
  }
  getAttribute(t) {
    return this.attributes[t];
  }
  setAttribute(t, e) {
    return this.attributes[t] = e, this;
  }
  deleteAttribute(t) {
    return delete this.attributes[t], this;
  }
  hasAttribute(t) {
    return this.attributes[t] !== void 0;
  }
  addGroup(t, e, n = 0) {
    this.groups.push({
      start: t,
      count: e,
      materialIndex: n
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(t, e) {
    this.drawRange.start = t, this.drawRange.count = e;
  }
  applyMatrix4(t) {
    const e = this.attributes.position;
    e !== void 0 && (e.applyMatrix4(t), e.needsUpdate = !0);
    const n = this.attributes.normal;
    if (n !== void 0) {
      const a = new ye().getNormalMatrix(t);
      n.applyNormalMatrix(a), n.needsUpdate = !0;
    }
    const i = this.attributes.tangent;
    return i !== void 0 && (i.transformDirection(t), i.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(t) {
    return zn.makeRotationFromQuaternion(t), this.applyMatrix4(zn), this;
  }
  rotateX(t) {
    return zn.makeRotationX(t), this.applyMatrix4(zn), this;
  }
  rotateY(t) {
    return zn.makeRotationY(t), this.applyMatrix4(zn), this;
  }
  rotateZ(t) {
    return zn.makeRotationZ(t), this.applyMatrix4(zn), this;
  }
  translate(t, e, n) {
    return zn.makeTranslation(t, e, n), this.applyMatrix4(zn), this;
  }
  scale(t, e, n) {
    return zn.makeScale(t, e, n), this.applyMatrix4(zn), this;
  }
  lookAt(t) {
    return jm.lookAt(t), jm.updateMatrix(), this.applyMatrix4(jm.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(Wl).negate(), this.translate(Wl.x, Wl.y, Wl.z), this;
  }
  setFromPoints(t) {
    const e = [];
    for (let n = 0, i = t.length; n < i; n++) {
      const a = t[n];
      e.push(a.x, a.y, a.z || 0);
    }
    return this.setAttribute("position", new On(e, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Sl());
    const t = this.attributes.position, e = this.morphAttributes.position;
    if (t && t.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(
        new j(-1 / 0, -1 / 0, -1 / 0),
        new j(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (t !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(t), e)
        for (let n = 0, i = e.length; n < i; n++) {
          const a = e[n];
          An.setFromBufferAttribute(a), this.morphTargetsRelative ? (Cr.addVectors(this.boundingBox.min, An.min), this.boundingBox.expandByPoint(Cr), Cr.addVectors(this.boundingBox.max, An.max), this.boundingBox.expandByPoint(Cr)) : (this.boundingBox.expandByPoint(An.min), this.boundingBox.expandByPoint(An.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new gc());
    const t = this.attributes.position, e = this.morphAttributes.position;
    if (t && t.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new j(), 1 / 0);
      return;
    }
    if (t) {
      const n = this.boundingSphere.center;
      if (An.setFromBufferAttribute(t), e)
        for (let a = 0, o = e.length; a < o; a++) {
          const s = e[a];
          Uc.setFromBufferAttribute(s), this.morphTargetsRelative ? (Cr.addVectors(An.min, Uc.min), An.expandByPoint(Cr), Cr.addVectors(An.max, Uc.max), An.expandByPoint(Cr)) : (An.expandByPoint(Uc.min), An.expandByPoint(Uc.max));
        }
      An.getCenter(n);
      let i = 0;
      for (let a = 0, o = t.count; a < o; a++)
        Cr.fromBufferAttribute(t, a), i = Math.max(i, n.distanceToSquared(Cr));
      if (e)
        for (let a = 0, o = e.length; a < o; a++) {
          const s = e[a], l = this.morphTargetsRelative;
          for (let u = 0, c = s.count; u < c; u++)
            Cr.fromBufferAttribute(s, u), l && (Wl.fromBufferAttribute(t, u), Cr.add(Wl)), i = Math.max(i, n.distanceToSquared(Cr));
        }
      this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const t = this.index, e = this.attributes;
    if (t === null || e.position === void 0 || e.normal === void 0 || e.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const n = e.position, i = e.normal, a = e.uv;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new ri(new Float32Array(4 * n.count), 4));
    const o = this.getAttribute("tangent"), s = [], l = [];
    for (let A = 0; A < n.count; A++)
      s[A] = new j(), l[A] = new j();
    const u = new j(), c = new j(), f = new j(), h = new Ce(), d = new Ce(), p = new Ce(), g = new j(), v = new j();
    function m(A, T, M) {
      u.fromBufferAttribute(n, A), c.fromBufferAttribute(n, T), f.fromBufferAttribute(n, M), h.fromBufferAttribute(a, A), d.fromBufferAttribute(a, T), p.fromBufferAttribute(a, M), c.sub(u), f.sub(u), d.sub(h), p.sub(h);
      const E = 1 / (d.x * p.y - p.x * d.y);
      isFinite(E) && (g.copy(c).multiplyScalar(p.y).addScaledVector(f, -d.y).multiplyScalar(E), v.copy(f).multiplyScalar(d.x).addScaledVector(c, -p.x).multiplyScalar(E), s[A].add(g), s[T].add(g), s[M].add(g), l[A].add(v), l[T].add(v), l[M].add(v));
    }
    let y = this.groups;
    y.length === 0 && (y = [{
      start: 0,
      count: t.count
    }]);
    for (let A = 0, T = y.length; A < T; ++A) {
      const M = y[A], E = M.start, R = M.count;
      for (let C = E, D = E + R; C < D; C += 3)
        m(
          t.getX(C + 0),
          t.getX(C + 1),
          t.getX(C + 2)
        );
    }
    const _ = new j(), x = new j(), b = new j(), S = new j();
    function w(A) {
      b.fromBufferAttribute(i, A), S.copy(b);
      const T = s[A];
      _.copy(T), _.sub(b.multiplyScalar(b.dot(T))).normalize(), x.crossVectors(S, T);
      const E = x.dot(l[A]) < 0 ? -1 : 1;
      o.setXYZW(A, _.x, _.y, _.z, E);
    }
    for (let A = 0, T = y.length; A < T; ++A) {
      const M = y[A], E = M.start, R = M.count;
      for (let C = E, D = E + R; C < D; C += 3)
        w(t.getX(C + 0)), w(t.getX(C + 1)), w(t.getX(C + 2));
    }
  }
  computeVertexNormals() {
    const t = this.index, e = this.getAttribute("position");
    if (e !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        n = new ri(new Float32Array(e.count * 3), 3), this.setAttribute("normal", n);
      else
        for (let h = 0, d = n.count; h < d; h++)
          n.setXYZ(h, 0, 0, 0);
      const i = new j(), a = new j(), o = new j(), s = new j(), l = new j(), u = new j(), c = new j(), f = new j();
      if (t)
        for (let h = 0, d = t.count; h < d; h += 3) {
          const p = t.getX(h + 0), g = t.getX(h + 1), v = t.getX(h + 2);
          i.fromBufferAttribute(e, p), a.fromBufferAttribute(e, g), o.fromBufferAttribute(e, v), c.subVectors(o, a), f.subVectors(i, a), c.cross(f), s.fromBufferAttribute(n, p), l.fromBufferAttribute(n, g), u.fromBufferAttribute(n, v), s.add(c), l.add(c), u.add(c), n.setXYZ(p, s.x, s.y, s.z), n.setXYZ(g, l.x, l.y, l.z), n.setXYZ(v, u.x, u.y, u.z);
        }
      else
        for (let h = 0, d = e.count; h < d; h += 3)
          i.fromBufferAttribute(e, h + 0), a.fromBufferAttribute(e, h + 1), o.fromBufferAttribute(e, h + 2), c.subVectors(o, a), f.subVectors(i, a), c.cross(f), n.setXYZ(h + 0, c.x, c.y, c.z), n.setXYZ(h + 1, c.x, c.y, c.z), n.setXYZ(h + 2, c.x, c.y, c.z);
      this.normalizeNormals(), n.needsUpdate = !0;
    }
  }
  normalizeNormals() {
    const t = this.attributes.normal;
    for (let e = 0, n = t.count; e < n; e++)
      Cr.fromBufferAttribute(t, e), Cr.normalize(), t.setXYZ(e, Cr.x, Cr.y, Cr.z);
  }
  toNonIndexed() {
    function t(s, l) {
      const u = s.array, c = s.itemSize, f = s.normalized, h = new u.constructor(l.length * c);
      let d = 0, p = 0;
      for (let g = 0, v = l.length; g < v; g++) {
        s.isInterleavedBufferAttribute ? d = l[g] * s.data.stride + s.offset : d = l[g] * c;
        for (let m = 0; m < c; m++)
          h[p++] = u[d++];
      }
      return new ri(h, c, f);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const e = new ua(), n = this.index.array, i = this.attributes;
    for (const s in i) {
      const l = i[s], u = t(l, n);
      e.setAttribute(s, u);
    }
    const a = this.morphAttributes;
    for (const s in a) {
      const l = [], u = a[s];
      for (let c = 0, f = u.length; c < f; c++) {
        const h = u[c], d = t(h, n);
        l.push(d);
      }
      e.morphAttributes[s] = l;
    }
    e.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let s = 0, l = o.length; s < l; s++) {
      const u = o[s];
      e.addGroup(u.start, u.count, u.materialIndex);
    }
    return e;
  }
  toJSON() {
    const t = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (t.uuid = this.uuid, t.type = this.type, this.name !== "" && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), this.parameters !== void 0) {
      const l = this.parameters;
      for (const u in l)
        l[u] !== void 0 && (t[u] = l[u]);
      return t;
    }
    t.data = { attributes: {} };
    const e = this.index;
    e !== null && (t.data.index = {
      type: e.array.constructor.name,
      array: Array.prototype.slice.call(e.array)
    });
    const n = this.attributes;
    for (const l in n) {
      const u = n[l];
      t.data.attributes[l] = u.toJSON(t.data);
    }
    const i = {};
    let a = !1;
    for (const l in this.morphAttributes) {
      const u = this.morphAttributes[l], c = [];
      for (let f = 0, h = u.length; f < h; f++) {
        const d = u[f];
        c.push(d.toJSON(t.data));
      }
      c.length > 0 && (i[l] = c, a = !0);
    }
    a && (t.data.morphAttributes = i, t.data.morphTargetsRelative = this.morphTargetsRelative);
    const o = this.groups;
    o.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(o)));
    const s = this.boundingSphere;
    return s !== null && (t.data.boundingSphere = {
      center: s.center.toArray(),
      radius: s.radius
    }), t;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const e = {};
    this.name = t.name;
    const n = t.index;
    n !== null && this.setIndex(n.clone(e));
    const i = t.attributes;
    for (const u in i) {
      const c = i[u];
      this.setAttribute(u, c.clone(e));
    }
    const a = t.morphAttributes;
    for (const u in a) {
      const c = [], f = a[u];
      for (let h = 0, d = f.length; h < d; h++)
        c.push(f[h].clone(e));
      this.morphAttributes[u] = c;
    }
    this.morphTargetsRelative = t.morphTargetsRelative;
    const o = t.groups;
    for (let u = 0, c = o.length; u < c; u++) {
      const f = o[u];
      this.addGroup(f.start, f.count, f.materialIndex);
    }
    const s = t.boundingBox;
    s !== null && (this.boundingBox = s.clone());
    const l = t.boundingSphere;
    return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const NM = /* @__PURE__ */ new Ye(), rs = /* @__PURE__ */ new f1(), cd = /* @__PURE__ */ new gc(), OM = /* @__PURE__ */ new j(), Xl = /* @__PURE__ */ new j(), Yl = /* @__PURE__ */ new j(), $l = /* @__PURE__ */ new j(), Jm = /* @__PURE__ */ new j(), fd = /* @__PURE__ */ new j(), hd = /* @__PURE__ */ new Ce(), dd = /* @__PURE__ */ new Ce(), pd = /* @__PURE__ */ new Ce(), kM = /* @__PURE__ */ new j(), BM = /* @__PURE__ */ new j(), VM = /* @__PURE__ */ new j(), vd = /* @__PURE__ */ new j(), gd = /* @__PURE__ */ new j();
class In extends Nr {
  constructor(t = new ua(), e = new d1()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets();
  }
  copy(t, e) {
    return super.copy(t, e), t.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), t.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this;
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes, n = Object.keys(e);
    if (n.length > 0) {
      const i = e[n[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let a = 0, o = i.length; a < o; a++) {
          const s = i[a].name || String(a);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[s] = a;
        }
      }
    }
  }
  getVertexPosition(t, e) {
    const n = this.geometry, i = n.attributes.position, a = n.morphAttributes.position, o = n.morphTargetsRelative;
    e.fromBufferAttribute(i, t);
    const s = this.morphTargetInfluences;
    if (a && s) {
      fd.set(0, 0, 0);
      for (let l = 0, u = a.length; l < u; l++) {
        const c = s[l], f = a[l];
        c !== 0 && (Jm.fromBufferAttribute(f, t), o ? fd.addScaledVector(Jm, c) : fd.addScaledVector(Jm.sub(e), c));
      }
      e.add(fd);
    }
    return e;
  }
  raycast(t, e) {
    const n = this.geometry, i = this.material, a = this.matrixWorld;
    i !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(), cd.copy(n.boundingSphere), cd.applyMatrix4(a), rs.copy(t.ray).recast(t.near), !(cd.containsPoint(rs.origin) === !1 && (rs.intersectSphere(cd, OM) === null || rs.origin.distanceToSquared(OM) > (t.far - t.near) ** 2)) && (NM.copy(a).invert(), rs.copy(t.ray).applyMatrix4(NM), !(n.boundingBox !== null && rs.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(t, e, rs)));
  }
  _computeIntersections(t, e, n) {
    let i;
    const a = this.geometry, o = this.material, s = a.index, l = a.attributes.position, u = a.attributes.uv, c = a.attributes.uv1, f = a.attributes.normal, h = a.groups, d = a.drawRange;
    if (s !== null)
      if (Array.isArray(o))
        for (let p = 0, g = h.length; p < g; p++) {
          const v = h[p], m = o[v.materialIndex], y = Math.max(v.start, d.start), _ = Math.min(s.count, Math.min(v.start + v.count, d.start + d.count));
          for (let x = y, b = _; x < b; x += 3) {
            const S = s.getX(x), w = s.getX(x + 1), A = s.getX(x + 2);
            i = md(this, m, t, n, u, c, f, S, w, A), i && (i.faceIndex = Math.floor(x / 3), i.face.materialIndex = v.materialIndex, e.push(i));
          }
        }
      else {
        const p = Math.max(0, d.start), g = Math.min(s.count, d.start + d.count);
        for (let v = p, m = g; v < m; v += 3) {
          const y = s.getX(v), _ = s.getX(v + 1), x = s.getX(v + 2);
          i = md(this, o, t, n, u, c, f, y, _, x), i && (i.faceIndex = Math.floor(v / 3), e.push(i));
        }
      }
    else if (l !== void 0)
      if (Array.isArray(o))
        for (let p = 0, g = h.length; p < g; p++) {
          const v = h[p], m = o[v.materialIndex], y = Math.max(v.start, d.start), _ = Math.min(l.count, Math.min(v.start + v.count, d.start + d.count));
          for (let x = y, b = _; x < b; x += 3) {
            const S = x, w = x + 1, A = x + 2;
            i = md(this, m, t, n, u, c, f, S, w, A), i && (i.faceIndex = Math.floor(x / 3), i.face.materialIndex = v.materialIndex, e.push(i));
          }
        }
      else {
        const p = Math.max(0, d.start), g = Math.min(l.count, d.start + d.count);
        for (let v = p, m = g; v < m; v += 3) {
          const y = v, _ = v + 1, x = v + 2;
          i = md(this, o, t, n, u, c, f, y, _, x), i && (i.faceIndex = Math.floor(v / 3), e.push(i));
        }
      }
  }
}
function Gz(r, t, e, n, i, a, o, s) {
  let l;
  if (t.side === Sn ? l = n.intersectTriangle(o, a, i, !0, s) : l = n.intersectTriangle(i, a, o, t.side === Vo, s), l === null)
    return null;
  gd.copy(s), gd.applyMatrix4(r.matrixWorld);
  const u = e.ray.origin.distanceTo(gd);
  return u < e.near || u > e.far ? null : {
    distance: u,
    point: gd.clone(),
    object: r
  };
}
function md(r, t, e, n, i, a, o, s, l, u) {
  r.getVertexPosition(s, Xl), r.getVertexPosition(l, Yl), r.getVertexPosition(u, $l);
  const c = Gz(r, t, e, n, Xl, Yl, $l, vd);
  if (c) {
    i && (hd.fromBufferAttribute(i, s), dd.fromBufferAttribute(i, l), pd.fromBufferAttribute(i, u), c.uv = sd.getInterpolation(vd, Xl, Yl, $l, hd, dd, pd, new Ce())), a && (hd.fromBufferAttribute(a, s), dd.fromBufferAttribute(a, l), pd.fromBufferAttribute(a, u), c.uv1 = sd.getInterpolation(vd, Xl, Yl, $l, hd, dd, pd, new Ce())), o && (kM.fromBufferAttribute(o, s), BM.fromBufferAttribute(o, l), VM.fromBufferAttribute(o, u), c.normal = sd.getInterpolation(vd, Xl, Yl, $l, kM, BM, VM, new j()), c.normal.dot(n.direction) > 0 && c.normal.multiplyScalar(-1));
    const f = {
      a: s,
      b: l,
      c: u,
      normal: new j(),
      materialIndex: 0
    };
    sd.getNormal(Xl, Yl, $l, f.normal), c.face = f;
  }
  return c;
}
class bl extends ua {
  constructor(t = 1, e = 1, n = 1, i = 1, a = 1, o = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: t,
      height: e,
      depth: n,
      widthSegments: i,
      heightSegments: a,
      depthSegments: o
    };
    const s = this;
    i = Math.floor(i), a = Math.floor(a), o = Math.floor(o);
    const l = [], u = [], c = [], f = [];
    let h = 0, d = 0;
    p("z", "y", "x", -1, -1, n, e, t, o, a, 0), p("z", "y", "x", 1, -1, n, e, -t, o, a, 1), p("x", "z", "y", 1, 1, t, n, e, i, o, 2), p("x", "z", "y", 1, -1, t, n, -e, i, o, 3), p("x", "y", "z", 1, -1, t, e, n, i, a, 4), p("x", "y", "z", -1, -1, t, e, -n, i, a, 5), this.setIndex(l), this.setAttribute("position", new On(u, 3)), this.setAttribute("normal", new On(c, 3)), this.setAttribute("uv", new On(f, 2));
    function p(g, v, m, y, _, x, b, S, w, A, T) {
      const M = x / w, E = b / A, R = x / 2, C = b / 2, D = S / 2, I = w + 1, P = A + 1;
      let O = 0, N = 0;
      const B = new j();
      for (let F = 0; F < P; F++) {
        const G = F * E - C;
        for (let X = 0; X < I; X++) {
          const K = X * M - R;
          B[g] = K * y, B[v] = G * _, B[m] = D, u.push(B.x, B.y, B.z), B[g] = 0, B[v] = 0, B[m] = S > 0 ? 1 : -1, c.push(B.x, B.y, B.z), f.push(X / w), f.push(1 - F / A), O += 1;
        }
      }
      for (let F = 0; F < A; F++)
        for (let G = 0; G < w; G++) {
          const X = h + G + I * F, K = h + G + I * (F + 1), U = h + (G + 1) + I * (F + 1), $ = h + (G + 1) + I * F;
          l.push(X, K, $), l.push(K, U, $), N += 6;
        }
      s.addGroup(d, N, T), d += N, h += O;
    }
  }
  copy(t) {
    return super.copy(t), this.parameters = Object.assign({}, t.parameters), this;
  }
  static fromJSON(t) {
    return new bl(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments);
  }
}
function Ju(r) {
  const t = {};
  for (const e in r) {
    t[e] = {};
    for (const n in r[e]) {
      const i = r[e][n];
      i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), t[e][n] = null) : t[e][n] = i.clone() : Array.isArray(i) ? t[e][n] = i.slice() : t[e][n] = i;
    }
  }
  return t;
}
function tn(r) {
  const t = {};
  for (let e = 0; e < r.length; e++) {
    const n = Ju(r[e]);
    for (const i in n)
      t[i] = n[i];
  }
  return t;
}
function Hz(r) {
  const t = [];
  for (let e = 0; e < r.length; e++)
    t.push(r[e].clone());
  return t;
}
function AI(r) {
  const t = r.getRenderTarget();
  return t === null ? r.outputColorSpace : t.isXRRenderTarget === !0 ? t.texture.colorSpace : Fe.workingColorSpace;
}
const Wz = { clone: Ju, merge: tn };
var Xz = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, Yz = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Fa extends Ih {
  constructor(t) {
    super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = Xz, this.fragmentShader = Yz, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
      clipCullDistance: !1,
      // set to use vertex shader clipping
      multiDraw: !1
      // set to use vertex shader multi_draw / enable gl_DrawID
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, t !== void 0 && this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Ju(t.uniforms), this.uniformsGroups = Hz(t.uniformsGroups), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.fog = t.fog, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this;
  }
  toJSON(t) {
    const e = super.toJSON(t);
    e.glslVersion = this.glslVersion, e.uniforms = {};
    for (const i in this.uniforms) {
      const o = this.uniforms[i].value;
      o && o.isTexture ? e.uniforms[i] = {
        type: "t",
        value: o.toJSON(t).uuid
      } : o && o.isColor ? e.uniforms[i] = {
        type: "c",
        value: o.getHex()
      } : o && o.isVector2 ? e.uniforms[i] = {
        type: "v2",
        value: o.toArray()
      } : o && o.isVector3 ? e.uniforms[i] = {
        type: "v3",
        value: o.toArray()
      } : o && o.isVector4 ? e.uniforms[i] = {
        type: "v4",
        value: o.toArray()
      } : o && o.isMatrix3 ? e.uniforms[i] = {
        type: "m3",
        value: o.toArray()
      } : o && o.isMatrix4 ? e.uniforms[i] = {
        type: "m4",
        value: o.toArray()
      } : e.uniforms[i] = {
        value: o
      };
    }
    Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e.lights = this.lights, e.clipping = this.clipping;
    const n = {};
    for (const i in this.extensions)
      this.extensions[i] === !0 && (n[i] = !0);
    return Object.keys(n).length > 0 && (e.extensions = n), e;
  }
}
class EI extends Nr {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Ye(), this.projectionMatrix = new Ye(), this.projectionMatrixInverse = new Ye(), this.coordinateSystem = Ca;
  }
  copy(t, e) {
    return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this.coordinateSystem = t.coordinateSystem, this;
  }
  getWorldDirection(t) {
    return super.getWorldDirection(t).negate();
  }
  updateMatrixWorld(t) {
    super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(t, e) {
    super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const io = /* @__PURE__ */ new j(), FM = /* @__PURE__ */ new Ce(), zM = /* @__PURE__ */ new Ce();
class Ln extends EI {
  constructor(t = 50, e = 1, n = 0.1, i = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(t, e) {
    return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = t.view === null ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(t) {
    const e = 0.5 * this.getFilmHeight() / t;
    this.fov = X_ * 2 * Math.atan(e), this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const t = Math.tan(Fp * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / t;
  }
  getEffectiveFOV() {
    return X_ * 2 * Math.atan(
      Math.tan(Fp * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
   * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
   */
  getViewBounds(t, e, n) {
    io.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), e.set(io.x, io.y).multiplyScalar(-t / io.z), io.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), n.set(io.x, io.y).multiplyScalar(-t / io.z);
  }
  /**
   * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
   * Copies the result into the target Vector2, where x is width and y is height.
   */
  getViewSize(t, e) {
    return this.getViewBounds(t, FM, zM), e.subVectors(zM, FM);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(t, e, n, i, a, o) {
    this.aspect = t / e, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = a, this.view.height = o, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const t = this.near;
    let e = t * Math.tan(Fp * 0.5 * this.fov) / this.zoom, n = 2 * e, i = this.aspect * n, a = -0.5 * i;
    const o = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = o.fullWidth, u = o.fullHeight;
      a += o.offsetX * i / l, e -= o.offsetY * n / u, i *= o.width / l, n *= o.height / u;
    }
    const s = this.filmOffset;
    s !== 0 && (a += t * s / this.getFilmWidth()), this.projectionMatrix.makePerspective(a, a + i, e, e - n, t, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, this.view !== null && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e;
  }
}
const Zl = -90, ql = 1;
class $z extends Nr {
  constructor(t, e, n) {
    super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const i = new Ln(Zl, ql, t, e);
    i.layers = this.layers, this.add(i);
    const a = new Ln(Zl, ql, t, e);
    a.layers = this.layers, this.add(a);
    const o = new Ln(Zl, ql, t, e);
    o.layers = this.layers, this.add(o);
    const s = new Ln(Zl, ql, t, e);
    s.layers = this.layers, this.add(s);
    const l = new Ln(Zl, ql, t, e);
    l.layers = this.layers, this.add(l);
    const u = new Ln(Zl, ql, t, e);
    u.layers = this.layers, this.add(u);
  }
  updateCoordinateSystem() {
    const t = this.coordinateSystem, e = this.children.concat(), [n, i, a, o, s, l] = e;
    for (const u of e)
      this.remove(u);
    if (t === Ca)
      n.up.set(0, 1, 0), n.lookAt(1, 0, 0), i.up.set(0, 1, 0), i.lookAt(-1, 0, 0), a.up.set(0, 0, -1), a.lookAt(0, 1, 0), o.up.set(0, 0, 1), o.lookAt(0, -1, 0), s.up.set(0, 1, 0), s.lookAt(0, 0, 1), l.up.set(0, 1, 0), l.lookAt(0, 0, -1);
    else if (t === dv)
      n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), i.up.set(0, -1, 0), i.lookAt(1, 0, 0), a.up.set(0, 0, 1), a.lookAt(0, 1, 0), o.up.set(0, 0, -1), o.lookAt(0, -1, 0), s.up.set(0, -1, 0), s.lookAt(0, 0, 1), l.up.set(0, -1, 0), l.lookAt(0, 0, -1);
    else
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + t);
    for (const u of e)
      this.add(u), u.updateMatrixWorld();
  }
  update(t, e) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: n, activeMipmapLevel: i } = this;
    this.coordinateSystem !== t.coordinateSystem && (this.coordinateSystem = t.coordinateSystem, this.updateCoordinateSystem());
    const [a, o, s, l, u, c] = this.children, f = t.getRenderTarget(), h = t.getActiveCubeFace(), d = t.getActiveMipmapLevel(), p = t.xr.enabled;
    t.xr.enabled = !1;
    const g = n.texture.generateMipmaps;
    n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0, i), t.render(e, a), t.setRenderTarget(n, 1, i), t.render(e, o), t.setRenderTarget(n, 2, i), t.render(e, s), t.setRenderTarget(n, 3, i), t.render(e, l), t.setRenderTarget(n, 4, i), t.render(e, u), n.texture.generateMipmaps = g, t.setRenderTarget(n, 5, i), t.render(e, c), t.setRenderTarget(f, h, d), t.xr.enabled = p, n.texture.needsPMREMUpdate = !0;
  }
}
class CI extends sn {
  constructor(t, e, n, i, a, o, s, l, u, c) {
    t = t !== void 0 ? t : [], e = e !== void 0 ? e : qu, super(t, e, n, i, a, o, s, l, u, c), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(t) {
    this.image = t;
  }
}
class Zz extends cl {
  constructor(t = 1, e = {}) {
    super(t, t, e), this.isWebGLCubeRenderTarget = !0;
    const n = { width: t, height: t, depth: 1 }, i = [n, n, n, n, n, n];
    this.texture = new CI(i, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = e.generateMipmaps !== void 0 ? e.generateMipmaps : !1, this.texture.minFilter = e.minFilter !== void 0 ? e.minFilter : pi;
  }
  fromEquirectangularTexture(t, e) {
    this.texture.type = e.type, this.texture.colorSpace = e.colorSpace, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
    const n = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, i = new bl(5, 5, 5), a = new Fa({
      name: "CubemapFromEquirect",
      uniforms: Ju(n.uniforms),
      vertexShader: n.vertexShader,
      fragmentShader: n.fragmentShader,
      side: Sn,
      blending: Lo
    });
    a.uniforms.tEquirect.value = e;
    const o = new In(i, a), s = e.minFilter;
    return e.minFilter === $s && (e.minFilter = pi), new $z(1, 10, this).update(t, o), e.minFilter = s, o.geometry.dispose(), o.material.dispose(), this;
  }
  clear(t, e, n, i) {
    const a = t.getRenderTarget();
    for (let o = 0; o < 6; o++)
      t.setRenderTarget(this, o), t.clear(e, n, i);
    t.setRenderTarget(a);
  }
}
const Qm = /* @__PURE__ */ new j(), qz = /* @__PURE__ */ new j(), Kz = /* @__PURE__ */ new ye();
class Is {
  constructor(t = new j(1, 0, 0), e = 0) {
    this.isPlane = !0, this.normal = t, this.constant = e;
  }
  set(t, e) {
    return this.normal.copy(t), this.constant = e, this;
  }
  setComponents(t, e, n, i) {
    return this.normal.set(t, e, n), this.constant = i, this;
  }
  setFromNormalAndCoplanarPoint(t, e) {
    return this.normal.copy(t), this.constant = -e.dot(this.normal), this;
  }
  setFromCoplanarPoints(t, e, n) {
    const i = Qm.subVectors(n, e).cross(qz.subVectors(t, e)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, t), this;
  }
  copy(t) {
    return this.normal.copy(t.normal), this.constant = t.constant, this;
  }
  normalize() {
    const t = 1 / this.normal.length();
    return this.normal.multiplyScalar(t), this.constant *= t, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(t) {
    return this.normal.dot(t) + this.constant;
  }
  distanceToSphere(t) {
    return this.distanceToPoint(t.center) - t.radius;
  }
  projectPoint(t, e) {
    return e.copy(t).addScaledVector(this.normal, -this.distanceToPoint(t));
  }
  intersectLine(t, e) {
    const n = t.delta(Qm), i = this.normal.dot(n);
    if (i === 0)
      return this.distanceToPoint(t.start) === 0 ? e.copy(t.start) : null;
    const a = -(t.start.dot(this.normal) + this.constant) / i;
    return a < 0 || a > 1 ? null : e.copy(t.start).addScaledVector(n, a);
  }
  intersectsLine(t) {
    const e = this.distanceToPoint(t.start), n = this.distanceToPoint(t.end);
    return e < 0 && n > 0 || n < 0 && e > 0;
  }
  intersectsBox(t) {
    return t.intersectsPlane(this);
  }
  intersectsSphere(t) {
    return t.intersectsPlane(this);
  }
  coplanarPoint(t) {
    return t.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(t, e) {
    const n = e || Kz.getNormalMatrix(t), i = this.coplanarPoint(Qm).applyMatrix4(t), a = this.normal.applyMatrix3(n).normalize();
    return this.constant = -i.dot(a), this;
  }
  translate(t) {
    return this.constant -= t.dot(this.normal), this;
  }
  equals(t) {
    return t.normal.equals(this.normal) && t.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const ns = /* @__PURE__ */ new gc(), yd = /* @__PURE__ */ new j();
class p1 {
  constructor(t = new Is(), e = new Is(), n = new Is(), i = new Is(), a = new Is(), o = new Is()) {
    this.planes = [t, e, n, i, a, o];
  }
  set(t, e, n, i, a, o) {
    const s = this.planes;
    return s[0].copy(t), s[1].copy(e), s[2].copy(n), s[3].copy(i), s[4].copy(a), s[5].copy(o), this;
  }
  copy(t) {
    const e = this.planes;
    for (let n = 0; n < 6; n++)
      e[n].copy(t.planes[n]);
    return this;
  }
  setFromProjectionMatrix(t, e = Ca) {
    const n = this.planes, i = t.elements, a = i[0], o = i[1], s = i[2], l = i[3], u = i[4], c = i[5], f = i[6], h = i[7], d = i[8], p = i[9], g = i[10], v = i[11], m = i[12], y = i[13], _ = i[14], x = i[15];
    if (n[0].setComponents(l - a, h - u, v - d, x - m).normalize(), n[1].setComponents(l + a, h + u, v + d, x + m).normalize(), n[2].setComponents(l + o, h + c, v + p, x + y).normalize(), n[3].setComponents(l - o, h - c, v - p, x - y).normalize(), n[4].setComponents(l - s, h - f, v - g, x - _).normalize(), e === Ca)
      n[5].setComponents(l + s, h + f, v + g, x + _).normalize();
    else if (e === dv)
      n[5].setComponents(s, f, g, _).normalize();
    else
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + e);
    return this;
  }
  intersectsObject(t) {
    if (t.boundingSphere !== void 0)
      t.boundingSphere === null && t.computeBoundingSphere(), ns.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);
    else {
      const e = t.geometry;
      e.boundingSphere === null && e.computeBoundingSphere(), ns.copy(e.boundingSphere).applyMatrix4(t.matrixWorld);
    }
    return this.intersectsSphere(ns);
  }
  intersectsSprite(t) {
    return ns.center.set(0, 0, 0), ns.radius = 0.7071067811865476, ns.applyMatrix4(t.matrixWorld), this.intersectsSphere(ns);
  }
  intersectsSphere(t) {
    const e = this.planes, n = t.center, i = -t.radius;
    for (let a = 0; a < 6; a++)
      if (e[a].distanceToPoint(n) < i)
        return !1;
    return !0;
  }
  intersectsBox(t) {
    const e = this.planes;
    for (let n = 0; n < 6; n++) {
      const i = e[n];
      if (yd.x = i.normal.x > 0 ? t.max.x : t.min.x, yd.y = i.normal.y > 0 ? t.max.y : t.min.y, yd.z = i.normal.z > 0 ? t.max.z : t.min.z, i.distanceToPoint(yd) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(t) {
    const e = this.planes;
    for (let n = 0; n < 6; n++)
      if (e[n].distanceToPoint(t) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function DI() {
  let r = null, t = !1, e = null, n = null;
  function i(a, o) {
    e(a, o), n = r.requestAnimationFrame(i);
  }
  return {
    start: function() {
      t !== !0 && e !== null && (n = r.requestAnimationFrame(i), t = !0);
    },
    stop: function() {
      r.cancelAnimationFrame(n), t = !1;
    },
    setAnimationLoop: function(a) {
      e = a;
    },
    setContext: function(a) {
      r = a;
    }
  };
}
function jz(r) {
  const t = /* @__PURE__ */ new WeakMap();
  function e(s, l) {
    const u = s.array, c = s.usage, f = u.byteLength, h = r.createBuffer();
    r.bindBuffer(l, h), r.bufferData(l, u, c), s.onUploadCallback();
    let d;
    if (u instanceof Float32Array)
      d = r.FLOAT;
    else if (u instanceof Uint16Array)
      s.isFloat16BufferAttribute ? d = r.HALF_FLOAT : d = r.UNSIGNED_SHORT;
    else if (u instanceof Int16Array)
      d = r.SHORT;
    else if (u instanceof Uint32Array)
      d = r.UNSIGNED_INT;
    else if (u instanceof Int32Array)
      d = r.INT;
    else if (u instanceof Int8Array)
      d = r.BYTE;
    else if (u instanceof Uint8Array)
      d = r.UNSIGNED_BYTE;
    else if (u instanceof Uint8ClampedArray)
      d = r.UNSIGNED_BYTE;
    else
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + u);
    return {
      buffer: h,
      type: d,
      bytesPerElement: u.BYTES_PER_ELEMENT,
      version: s.version,
      size: f
    };
  }
  function n(s, l, u) {
    const c = l.array, f = l._updateRange, h = l.updateRanges;
    if (r.bindBuffer(u, s), f.count === -1 && h.length === 0 && r.bufferSubData(u, 0, c), h.length !== 0) {
      for (let d = 0, p = h.length; d < p; d++) {
        const g = h[d];
        r.bufferSubData(
          u,
          g.start * c.BYTES_PER_ELEMENT,
          c,
          g.start,
          g.count
        );
      }
      l.clearUpdateRanges();
    }
    f.count !== -1 && (r.bufferSubData(
      u,
      f.offset * c.BYTES_PER_ELEMENT,
      c,
      f.offset,
      f.count
    ), f.count = -1), l.onUploadCallback();
  }
  function i(s) {
    return s.isInterleavedBufferAttribute && (s = s.data), t.get(s);
  }
  function a(s) {
    s.isInterleavedBufferAttribute && (s = s.data);
    const l = t.get(s);
    l && (r.deleteBuffer(l.buffer), t.delete(s));
  }
  function o(s, l) {
    if (s.isGLBufferAttribute) {
      const c = t.get(s);
      (!c || c.version < s.version) && t.set(s, {
        buffer: s.buffer,
        type: s.type,
        bytesPerElement: s.elementSize,
        version: s.version
      });
      return;
    }
    s.isInterleavedBufferAttribute && (s = s.data);
    const u = t.get(s);
    if (u === void 0)
      t.set(s, e(s, l));
    else if (u.version < s.version) {
      if (u.size !== s.array.byteLength)
        throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
      n(u.buffer, s, l), u.version = s.version;
    }
  }
  return {
    get: i,
    remove: a,
    update: o
  };
}
class Og extends ua {
  constructor(t = 1, e = 1, n = 1, i = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: t,
      height: e,
      widthSegments: n,
      heightSegments: i
    };
    const a = t / 2, o = e / 2, s = Math.floor(n), l = Math.floor(i), u = s + 1, c = l + 1, f = t / s, h = e / l, d = [], p = [], g = [], v = [];
    for (let m = 0; m < c; m++) {
      const y = m * h - o;
      for (let _ = 0; _ < u; _++) {
        const x = _ * f - a;
        p.push(x, -y, 0), g.push(0, 0, 1), v.push(_ / s), v.push(1 - m / l);
      }
    }
    for (let m = 0; m < l; m++)
      for (let y = 0; y < s; y++) {
        const _ = y + u * m, x = y + u * (m + 1), b = y + 1 + u * (m + 1), S = y + 1 + u * m;
        d.push(_, x, S), d.push(x, b, S);
      }
    this.setIndex(d), this.setAttribute("position", new On(p, 3)), this.setAttribute("normal", new On(g, 3)), this.setAttribute("uv", new On(v, 2));
  }
  copy(t) {
    return super.copy(t), this.parameters = Object.assign({}, t.parameters), this;
  }
  static fromJSON(t) {
    return new Og(t.width, t.height, t.widthSegments, t.heightSegments);
  }
}
var Jz = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, Qz = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, tU = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, eU = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, rU = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, nU = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, iU = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, aU = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, oU = `#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, sU = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`, lU = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, uU = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, cU = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, fU = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, hU = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, dU = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, pU = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, vU = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, gU = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, mU = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, yU = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, _U = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, xU = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, SU = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, bU = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, wU = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, MU = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, TU = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, AU = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, EU = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, CU = "gl_FragColor = linearToOutputTexel( gl_FragColor );", DU = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`, LU = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, RU = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, IU = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, PU = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, NU = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, OU = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, kU = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, BU = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, VU = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, FU = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, zU = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, UU = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, GU = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, HU = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, WU = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, XU = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, YU = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, $U = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, ZU = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, qU = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, KU = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, jU = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, JU = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, QU = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, tG = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, eG = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, rG = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, nG = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, iG = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, aG = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, oG = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, sG = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, lG = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, uG = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, cG = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[MORPHTARGETS_COUNT];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, fG = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, hG = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, dG = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
	#endif
	#ifdef MORPHTARGETS_TEXTURE
		#ifndef USE_INSTANCING_MORPH
			uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		#endif
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, pG = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, vG = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, gG = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, mG = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, yG = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, _G = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, xG = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, SG = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, bG = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, wG = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, MG = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, TG = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, AG = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, EG = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, CG = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, DG = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, LG = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, RG = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, IG = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, PG = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return shadow;
	}
#endif`, NG = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, OG = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, kG = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, BG = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, VG = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, FG = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, zG = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, UG = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, GG = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, HG = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, WG = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, XG = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, YG = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, $G = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, ZG = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, qG = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, KG = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const jG = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, JG = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, QG = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, t5 = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, e5 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, r5 = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, n5 = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, i5 = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, a5 = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, o5 = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, s5 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, l5 = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, u5 = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, c5 = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, f5 = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, h5 = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, d5 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, p5 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, v5 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, g5 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, m5 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, y5 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, _5 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, x5 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, S5 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, b5 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, w5 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, M5 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, T5 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, A5 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, E5 = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, C5 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, D5 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, L5 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, me = {
  alphahash_fragment: Jz,
  alphahash_pars_fragment: Qz,
  alphamap_fragment: tU,
  alphamap_pars_fragment: eU,
  alphatest_fragment: rU,
  alphatest_pars_fragment: nU,
  aomap_fragment: iU,
  aomap_pars_fragment: aU,
  batching_pars_vertex: oU,
  batching_vertex: sU,
  begin_vertex: lU,
  beginnormal_vertex: uU,
  bsdfs: cU,
  iridescence_fragment: fU,
  bumpmap_pars_fragment: hU,
  clipping_planes_fragment: dU,
  clipping_planes_pars_fragment: pU,
  clipping_planes_pars_vertex: vU,
  clipping_planes_vertex: gU,
  color_fragment: mU,
  color_pars_fragment: yU,
  color_pars_vertex: _U,
  color_vertex: xU,
  common: SU,
  cube_uv_reflection_fragment: bU,
  defaultnormal_vertex: wU,
  displacementmap_pars_vertex: MU,
  displacementmap_vertex: TU,
  emissivemap_fragment: AU,
  emissivemap_pars_fragment: EU,
  colorspace_fragment: CU,
  colorspace_pars_fragment: DU,
  envmap_fragment: LU,
  envmap_common_pars_fragment: RU,
  envmap_pars_fragment: IU,
  envmap_pars_vertex: PU,
  envmap_physical_pars_fragment: WU,
  envmap_vertex: NU,
  fog_vertex: OU,
  fog_pars_vertex: kU,
  fog_fragment: BU,
  fog_pars_fragment: VU,
  gradientmap_pars_fragment: FU,
  lightmap_pars_fragment: zU,
  lights_lambert_fragment: UU,
  lights_lambert_pars_fragment: GU,
  lights_pars_begin: HU,
  lights_toon_fragment: XU,
  lights_toon_pars_fragment: YU,
  lights_phong_fragment: $U,
  lights_phong_pars_fragment: ZU,
  lights_physical_fragment: qU,
  lights_physical_pars_fragment: KU,
  lights_fragment_begin: jU,
  lights_fragment_maps: JU,
  lights_fragment_end: QU,
  logdepthbuf_fragment: tG,
  logdepthbuf_pars_fragment: eG,
  logdepthbuf_pars_vertex: rG,
  logdepthbuf_vertex: nG,
  map_fragment: iG,
  map_pars_fragment: aG,
  map_particle_fragment: oG,
  map_particle_pars_fragment: sG,
  metalnessmap_fragment: lG,
  metalnessmap_pars_fragment: uG,
  morphinstance_vertex: cG,
  morphcolor_vertex: fG,
  morphnormal_vertex: hG,
  morphtarget_pars_vertex: dG,
  morphtarget_vertex: pG,
  normal_fragment_begin: vG,
  normal_fragment_maps: gG,
  normal_pars_fragment: mG,
  normal_pars_vertex: yG,
  normal_vertex: _G,
  normalmap_pars_fragment: xG,
  clearcoat_normal_fragment_begin: SG,
  clearcoat_normal_fragment_maps: bG,
  clearcoat_pars_fragment: wG,
  iridescence_pars_fragment: MG,
  opaque_fragment: TG,
  packing: AG,
  premultiplied_alpha_fragment: EG,
  project_vertex: CG,
  dithering_fragment: DG,
  dithering_pars_fragment: LG,
  roughnessmap_fragment: RG,
  roughnessmap_pars_fragment: IG,
  shadowmap_pars_fragment: PG,
  shadowmap_pars_vertex: NG,
  shadowmap_vertex: OG,
  shadowmask_pars_fragment: kG,
  skinbase_vertex: BG,
  skinning_pars_vertex: VG,
  skinning_vertex: FG,
  skinnormal_vertex: zG,
  specularmap_fragment: UG,
  specularmap_pars_fragment: GG,
  tonemapping_fragment: HG,
  tonemapping_pars_fragment: WG,
  transmission_fragment: XG,
  transmission_pars_fragment: YG,
  uv_pars_fragment: $G,
  uv_pars_vertex: ZG,
  uv_vertex: qG,
  worldpos_vertex: KG,
  background_vert: jG,
  background_frag: JG,
  backgroundCube_vert: QG,
  backgroundCube_frag: t5,
  cube_vert: e5,
  cube_frag: r5,
  depth_vert: n5,
  depth_frag: i5,
  distanceRGBA_vert: a5,
  distanceRGBA_frag: o5,
  equirect_vert: s5,
  equirect_frag: l5,
  linedashed_vert: u5,
  linedashed_frag: c5,
  meshbasic_vert: f5,
  meshbasic_frag: h5,
  meshlambert_vert: d5,
  meshlambert_frag: p5,
  meshmatcap_vert: v5,
  meshmatcap_frag: g5,
  meshnormal_vert: m5,
  meshnormal_frag: y5,
  meshphong_vert: _5,
  meshphong_frag: x5,
  meshphysical_vert: S5,
  meshphysical_frag: b5,
  meshtoon_vert: w5,
  meshtoon_frag: M5,
  points_vert: T5,
  points_frag: A5,
  shadow_vert: E5,
  shadow_frag: C5,
  sprite_vert: D5,
  sprite_frag: L5
}, At = {
  common: {
    diffuse: { value: /* @__PURE__ */ new le(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new ye() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new ye() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: /* @__PURE__ */ new ye() }
  },
  envmap: {
    envMap: { value: null },
    envMapRotation: { value: /* @__PURE__ */ new ye() },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: /* @__PURE__ */ new ye() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: /* @__PURE__ */ new ye() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: /* @__PURE__ */ new ye() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: /* @__PURE__ */ new ye() },
    normalScale: { value: /* @__PURE__ */ new Ce(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: /* @__PURE__ */ new ye() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: /* @__PURE__ */ new ye() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: /* @__PURE__ */ new ye() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: /* @__PURE__ */ new ye() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new le(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new le(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new ye() },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new ye() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new le(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new Ce(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new ye() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new ye() },
    alphaTest: { value: 0 }
  }
}, Fi = {
  basic: {
    uniforms: /* @__PURE__ */ tn([
      At.common,
      At.specularmap,
      At.envmap,
      At.aomap,
      At.lightmap,
      At.fog
    ]),
    vertexShader: me.meshbasic_vert,
    fragmentShader: me.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ tn([
      At.common,
      At.specularmap,
      At.envmap,
      At.aomap,
      At.lightmap,
      At.emissivemap,
      At.bumpmap,
      At.normalmap,
      At.displacementmap,
      At.fog,
      At.lights,
      {
        emissive: { value: /* @__PURE__ */ new le(0) }
      }
    ]),
    vertexShader: me.meshlambert_vert,
    fragmentShader: me.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ tn([
      At.common,
      At.specularmap,
      At.envmap,
      At.aomap,
      At.lightmap,
      At.emissivemap,
      At.bumpmap,
      At.normalmap,
      At.displacementmap,
      At.fog,
      At.lights,
      {
        emissive: { value: /* @__PURE__ */ new le(0) },
        specular: { value: /* @__PURE__ */ new le(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: me.meshphong_vert,
    fragmentShader: me.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ tn([
      At.common,
      At.envmap,
      At.aomap,
      At.lightmap,
      At.emissivemap,
      At.bumpmap,
      At.normalmap,
      At.displacementmap,
      At.roughnessmap,
      At.metalnessmap,
      At.fog,
      At.lights,
      {
        emissive: { value: /* @__PURE__ */ new le(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
      }
    ]),
    vertexShader: me.meshphysical_vert,
    fragmentShader: me.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ tn([
      At.common,
      At.aomap,
      At.lightmap,
      At.emissivemap,
      At.bumpmap,
      At.normalmap,
      At.displacementmap,
      At.gradientmap,
      At.fog,
      At.lights,
      {
        emissive: { value: /* @__PURE__ */ new le(0) }
      }
    ]),
    vertexShader: me.meshtoon_vert,
    fragmentShader: me.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ tn([
      At.common,
      At.bumpmap,
      At.normalmap,
      At.displacementmap,
      At.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: me.meshmatcap_vert,
    fragmentShader: me.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ tn([
      At.points,
      At.fog
    ]),
    vertexShader: me.points_vert,
    fragmentShader: me.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ tn([
      At.common,
      At.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: me.linedashed_vert,
    fragmentShader: me.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ tn([
      At.common,
      At.displacementmap
    ]),
    vertexShader: me.depth_vert,
    fragmentShader: me.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ tn([
      At.common,
      At.bumpmap,
      At.normalmap,
      At.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: me.meshnormal_vert,
    fragmentShader: me.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ tn([
      At.sprite,
      At.fog
    ]),
    vertexShader: me.sprite_vert,
    fragmentShader: me.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new ye() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: me.background_vert,
    fragmentShader: me.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 },
      backgroundRotation: { value: /* @__PURE__ */ new ye() }
    },
    vertexShader: me.backgroundCube_vert,
    fragmentShader: me.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: me.cube_vert,
    fragmentShader: me.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: me.equirect_vert,
    fragmentShader: me.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ tn([
      At.common,
      At.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new j() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: me.distanceRGBA_vert,
    fragmentShader: me.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ tn([
      At.lights,
      At.fog,
      {
        color: { value: /* @__PURE__ */ new le(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: me.shadow_vert,
    fragmentShader: me.shadow_frag
  }
};
Fi.physical = {
  uniforms: /* @__PURE__ */ tn([
    Fi.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: /* @__PURE__ */ new ye() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: /* @__PURE__ */ new ye() },
      clearcoatNormalScale: { value: /* @__PURE__ */ new Ce(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new ye() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: /* @__PURE__ */ new ye() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new ye() },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new le(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: /* @__PURE__ */ new ye() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new ye() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: /* @__PURE__ */ new ye() },
      transmissionSamplerSize: { value: /* @__PURE__ */ new Ce() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: /* @__PURE__ */ new ye() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new le(0) },
      specularColor: { value: /* @__PURE__ */ new le(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: /* @__PURE__ */ new ye() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: /* @__PURE__ */ new ye() },
      anisotropyVector: { value: /* @__PURE__ */ new Ce() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: /* @__PURE__ */ new ye() }
    }
  ]),
  vertexShader: me.meshphysical_vert,
  fragmentShader: me.meshphysical_frag
};
const _d = { r: 0, b: 0, g: 0 }, is = /* @__PURE__ */ new Va(), R5 = /* @__PURE__ */ new Ye();
function I5(r, t, e, n, i, a, o) {
  const s = new le(0);
  let l = a === !0 ? 0 : 1, u, c, f = null, h = 0, d = null;
  function p(y) {
    let _ = y.isScene === !0 ? y.background : null;
    return _ && _.isTexture && (_ = (y.backgroundBlurriness > 0 ? e : t).get(_)), _;
  }
  function g(y) {
    let _ = !1;
    const x = p(y);
    x === null ? m(s, l) : x && x.isColor && (m(x, 1), _ = !0);
    const b = r.xr.getEnvironmentBlendMode();
    b === "additive" ? n.buffers.color.setClear(0, 0, 0, 1, o) : b === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, o), (r.autoClear || _) && r.clear(r.autoClearColor, r.autoClearDepth, r.autoClearStencil);
  }
  function v(y, _) {
    const x = p(_);
    x && (x.isCubeTexture || x.mapping === Ig) ? (c === void 0 && (c = new In(
      new bl(1, 1, 1),
      new Fa({
        name: "BackgroundCubeMaterial",
        uniforms: Ju(Fi.backgroundCube.uniforms),
        vertexShader: Fi.backgroundCube.vertexShader,
        fragmentShader: Fi.backgroundCube.fragmentShader,
        side: Sn,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), c.geometry.deleteAttribute("normal"), c.geometry.deleteAttribute("uv"), c.onBeforeRender = function(b, S, w) {
      this.matrixWorld.copyPosition(w.matrixWorld);
    }, Object.defineProperty(c.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), i.update(c)), is.copy(_.backgroundRotation), is.x *= -1, is.y *= -1, is.z *= -1, x.isCubeTexture && x.isRenderTargetTexture === !1 && (is.y *= -1, is.z *= -1), c.material.uniforms.envMap.value = x, c.material.uniforms.flipEnvMap.value = x.isCubeTexture && x.isRenderTargetTexture === !1 ? -1 : 1, c.material.uniforms.backgroundBlurriness.value = _.backgroundBlurriness, c.material.uniforms.backgroundIntensity.value = _.backgroundIntensity, c.material.uniforms.backgroundRotation.value.setFromMatrix4(R5.makeRotationFromEuler(is)), c.material.toneMapped = Fe.getTransfer(x.colorSpace) !== Ze, (f !== x || h !== x.version || d !== r.toneMapping) && (c.material.needsUpdate = !0, f = x, h = x.version, d = r.toneMapping), c.layers.enableAll(), y.unshift(c, c.geometry, c.material, 0, 0, null)) : x && x.isTexture && (u === void 0 && (u = new In(
      new Og(2, 2),
      new Fa({
        name: "BackgroundMaterial",
        uniforms: Ju(Fi.background.uniforms),
        vertexShader: Fi.background.vertexShader,
        fragmentShader: Fi.background.fragmentShader,
        side: Vo,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), u.geometry.deleteAttribute("normal"), Object.defineProperty(u.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), i.update(u)), u.material.uniforms.t2D.value = x, u.material.uniforms.backgroundIntensity.value = _.backgroundIntensity, u.material.toneMapped = Fe.getTransfer(x.colorSpace) !== Ze, x.matrixAutoUpdate === !0 && x.updateMatrix(), u.material.uniforms.uvTransform.value.copy(x.matrix), (f !== x || h !== x.version || d !== r.toneMapping) && (u.material.needsUpdate = !0, f = x, h = x.version, d = r.toneMapping), u.layers.enableAll(), y.unshift(u, u.geometry, u.material, 0, 0, null));
  }
  function m(y, _) {
    y.getRGB(_d, AI(r)), n.buffers.color.setClear(_d.r, _d.g, _d.b, _, o);
  }
  return {
    getClearColor: function() {
      return s;
    },
    setClearColor: function(y, _ = 1) {
      s.set(y), l = _, m(s, l);
    },
    getClearAlpha: function() {
      return l;
    },
    setClearAlpha: function(y) {
      l = y, m(s, l);
    },
    render: g,
    addToRenderList: v
  };
}
function P5(r, t) {
  const e = r.getParameter(r.MAX_VERTEX_ATTRIBS), n = {}, i = h(null);
  let a = i, o = !1;
  function s(M, E, R, C, D) {
    let I = !1;
    const P = f(C, R, E);
    a !== P && (a = P, u(a.object)), I = d(M, C, R, D), I && p(M, C, R, D), D !== null && t.update(D, r.ELEMENT_ARRAY_BUFFER), (I || o) && (o = !1, x(M, E, R, C), D !== null && r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, t.get(D).buffer));
  }
  function l() {
    return r.createVertexArray();
  }
  function u(M) {
    return r.bindVertexArray(M);
  }
  function c(M) {
    return r.deleteVertexArray(M);
  }
  function f(M, E, R) {
    const C = R.wireframe === !0;
    let D = n[M.id];
    D === void 0 && (D = {}, n[M.id] = D);
    let I = D[E.id];
    I === void 0 && (I = {}, D[E.id] = I);
    let P = I[C];
    return P === void 0 && (P = h(l()), I[C] = P), P;
  }
  function h(M) {
    const E = [], R = [], C = [];
    for (let D = 0; D < e; D++)
      E[D] = 0, R[D] = 0, C[D] = 0;
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: E,
      enabledAttributes: R,
      attributeDivisors: C,
      object: M,
      attributes: {},
      index: null
    };
  }
  function d(M, E, R, C) {
    const D = a.attributes, I = E.attributes;
    let P = 0;
    const O = R.getAttributes();
    for (const N in O)
      if (O[N].location >= 0) {
        const F = D[N];
        let G = I[N];
        if (G === void 0 && (N === "instanceMatrix" && M.instanceMatrix && (G = M.instanceMatrix), N === "instanceColor" && M.instanceColor && (G = M.instanceColor)), F === void 0 || F.attribute !== G || G && F.data !== G.data)
          return !0;
        P++;
      }
    return a.attributesNum !== P || a.index !== C;
  }
  function p(M, E, R, C) {
    const D = {}, I = E.attributes;
    let P = 0;
    const O = R.getAttributes();
    for (const N in O)
      if (O[N].location >= 0) {
        let F = I[N];
        F === void 0 && (N === "instanceMatrix" && M.instanceMatrix && (F = M.instanceMatrix), N === "instanceColor" && M.instanceColor && (F = M.instanceColor));
        const G = {};
        G.attribute = F, F && F.data && (G.data = F.data), D[N] = G, P++;
      }
    a.attributes = D, a.attributesNum = P, a.index = C;
  }
  function g() {
    const M = a.newAttributes;
    for (let E = 0, R = M.length; E < R; E++)
      M[E] = 0;
  }
  function v(M) {
    m(M, 0);
  }
  function m(M, E) {
    const R = a.newAttributes, C = a.enabledAttributes, D = a.attributeDivisors;
    R[M] = 1, C[M] === 0 && (r.enableVertexAttribArray(M), C[M] = 1), D[M] !== E && (r.vertexAttribDivisor(M, E), D[M] = E);
  }
  function y() {
    const M = a.newAttributes, E = a.enabledAttributes;
    for (let R = 0, C = E.length; R < C; R++)
      E[R] !== M[R] && (r.disableVertexAttribArray(R), E[R] = 0);
  }
  function _(M, E, R, C, D, I, P) {
    P === !0 ? r.vertexAttribIPointer(M, E, R, D, I) : r.vertexAttribPointer(M, E, R, C, D, I);
  }
  function x(M, E, R, C) {
    g();
    const D = C.attributes, I = R.getAttributes(), P = E.defaultAttributeValues;
    for (const O in I) {
      const N = I[O];
      if (N.location >= 0) {
        let B = D[O];
        if (B === void 0 && (O === "instanceMatrix" && M.instanceMatrix && (B = M.instanceMatrix), O === "instanceColor" && M.instanceColor && (B = M.instanceColor)), B !== void 0) {
          const F = B.normalized, G = B.itemSize, X = t.get(B);
          if (X === void 0)
            continue;
          const K = X.buffer, U = X.type, $ = X.bytesPerElement, ct = U === r.INT || U === r.UNSIGNED_INT || B.gpuType === hI;
          if (B.isInterleavedBufferAttribute) {
            const at = B.data, lt = at.stride, ot = B.offset;
            if (at.isInstancedInterleavedBuffer) {
              for (let H = 0; H < N.locationSize; H++)
                m(N.location + H, at.meshPerAttribute);
              M.isInstancedMesh !== !0 && C._maxInstanceCount === void 0 && (C._maxInstanceCount = at.meshPerAttribute * at.count);
            } else
              for (let H = 0; H < N.locationSize; H++)
                v(N.location + H);
            r.bindBuffer(r.ARRAY_BUFFER, K);
            for (let H = 0; H < N.locationSize; H++)
              _(
                N.location + H,
                G / N.locationSize,
                U,
                F,
                lt * $,
                (ot + G / N.locationSize * H) * $,
                ct
              );
          } else {
            if (B.isInstancedBufferAttribute) {
              for (let at = 0; at < N.locationSize; at++)
                m(N.location + at, B.meshPerAttribute);
              M.isInstancedMesh !== !0 && C._maxInstanceCount === void 0 && (C._maxInstanceCount = B.meshPerAttribute * B.count);
            } else
              for (let at = 0; at < N.locationSize; at++)
                v(N.location + at);
            r.bindBuffer(r.ARRAY_BUFFER, K);
            for (let at = 0; at < N.locationSize; at++)
              _(
                N.location + at,
                G / N.locationSize,
                U,
                F,
                G * $,
                G / N.locationSize * at * $,
                ct
              );
          }
        } else if (P !== void 0) {
          const F = P[O];
          if (F !== void 0)
            switch (F.length) {
              case 2:
                r.vertexAttrib2fv(N.location, F);
                break;
              case 3:
                r.vertexAttrib3fv(N.location, F);
                break;
              case 4:
                r.vertexAttrib4fv(N.location, F);
                break;
              default:
                r.vertexAttrib1fv(N.location, F);
            }
        }
      }
    }
    y();
  }
  function b() {
    A();
    for (const M in n) {
      const E = n[M];
      for (const R in E) {
        const C = E[R];
        for (const D in C)
          c(C[D].object), delete C[D];
        delete E[R];
      }
      delete n[M];
    }
  }
  function S(M) {
    if (n[M.id] === void 0)
      return;
    const E = n[M.id];
    for (const R in E) {
      const C = E[R];
      for (const D in C)
        c(C[D].object), delete C[D];
      delete E[R];
    }
    delete n[M.id];
  }
  function w(M) {
    for (const E in n) {
      const R = n[E];
      if (R[M.id] === void 0)
        continue;
      const C = R[M.id];
      for (const D in C)
        c(C[D].object), delete C[D];
      delete R[M.id];
    }
  }
  function A() {
    T(), o = !0, a !== i && (a = i, u(a.object));
  }
  function T() {
    i.geometry = null, i.program = null, i.wireframe = !1;
  }
  return {
    setup: s,
    reset: A,
    resetDefaultState: T,
    dispose: b,
    releaseStatesOfGeometry: S,
    releaseStatesOfProgram: w,
    initAttributes: g,
    enableAttribute: v,
    disableUnusedAttributes: y
  };
}
function N5(r, t, e) {
  let n;
  function i(u) {
    n = u;
  }
  function a(u, c) {
    r.drawArrays(n, u, c), e.update(c, n, 1);
  }
  function o(u, c, f) {
    f !== 0 && (r.drawArraysInstanced(n, u, c, f), e.update(c, n, f));
  }
  function s(u, c, f) {
    if (f === 0)
      return;
    const h = t.get("WEBGL_multi_draw");
    if (h === null)
      for (let d = 0; d < f; d++)
        this.render(u[d], c[d]);
    else {
      h.multiDrawArraysWEBGL(n, u, 0, c, 0, f);
      let d = 0;
      for (let p = 0; p < f; p++)
        d += c[p];
      e.update(d, n, 1);
    }
  }
  function l(u, c, f, h) {
    if (f === 0)
      return;
    const d = t.get("WEBGL_multi_draw");
    if (d === null)
      for (let p = 0; p < u.length; p++)
        o(u[p], c[p], h[p]);
    else {
      d.multiDrawArraysInstancedWEBGL(n, u, 0, c, 0, h, 0, f);
      let p = 0;
      for (let g = 0; g < f; g++)
        p += c[g];
      for (let g = 0; g < h.length; g++)
        e.update(p, n, h[g]);
    }
  }
  this.setMode = i, this.render = a, this.renderInstances = o, this.renderMultiDraw = s, this.renderMultiDrawInstances = l;
}
function O5(r, t, e, n) {
  let i;
  function a() {
    if (i !== void 0)
      return i;
    if (t.has("EXT_texture_filter_anisotropic") === !0) {
      const S = t.get("EXT_texture_filter_anisotropic");
      i = r.getParameter(S.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      i = 0;
    return i;
  }
  function o(S) {
    return !(S !== Wi && n.convert(S) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_FORMAT));
  }
  function s(S) {
    const w = S === Pg && (t.has("EXT_color_buffer_half_float") || t.has("EXT_color_buffer_float"));
    return !(S !== Fo && n.convert(S) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
    S !== Ea && !w);
  }
  function l(S) {
    if (S === "highp") {
      if (r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.HIGH_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.HIGH_FLOAT).precision > 0)
        return "highp";
      S = "mediump";
    }
    return S === "mediump" && r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.MEDIUM_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  let u = e.precision !== void 0 ? e.precision : "highp";
  const c = l(u);
  c !== u && (console.warn("THREE.WebGLRenderer:", u, "not supported, using", c, "instead."), u = c);
  const f = e.logarithmicDepthBuffer === !0, h = r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS), d = r.getParameter(r.MAX_VERTEX_TEXTURE_IMAGE_UNITS), p = r.getParameter(r.MAX_TEXTURE_SIZE), g = r.getParameter(r.MAX_CUBE_MAP_TEXTURE_SIZE), v = r.getParameter(r.MAX_VERTEX_ATTRIBS), m = r.getParameter(r.MAX_VERTEX_UNIFORM_VECTORS), y = r.getParameter(r.MAX_VARYING_VECTORS), _ = r.getParameter(r.MAX_FRAGMENT_UNIFORM_VECTORS), x = d > 0, b = r.getParameter(r.MAX_SAMPLES);
  return {
    isWebGL2: !0,
    // keeping this for backwards compatibility
    getMaxAnisotropy: a,
    getMaxPrecision: l,
    textureFormatReadable: o,
    textureTypeReadable: s,
    precision: u,
    logarithmicDepthBuffer: f,
    maxTextures: h,
    maxVertexTextures: d,
    maxTextureSize: p,
    maxCubemapSize: g,
    maxAttributes: v,
    maxVertexUniforms: m,
    maxVaryings: y,
    maxFragmentUniforms: _,
    vertexTextures: x,
    maxSamples: b
  };
}
function k5(r) {
  const t = this;
  let e = null, n = 0, i = !1, a = !1;
  const o = new Is(), s = new ye(), l = { value: null, needsUpdate: !1 };
  this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(f, h) {
    const d = f.length !== 0 || h || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    n !== 0 || i;
    return i = h, n = f.length, d;
  }, this.beginShadows = function() {
    a = !0, c(null);
  }, this.endShadows = function() {
    a = !1;
  }, this.setGlobalState = function(f, h) {
    e = c(f, h, 0);
  }, this.setState = function(f, h, d) {
    const p = f.clippingPlanes, g = f.clipIntersection, v = f.clipShadows, m = r.get(f);
    if (!i || p === null || p.length === 0 || a && !v)
      a ? c(null) : u();
    else {
      const y = a ? 0 : n, _ = y * 4;
      let x = m.clippingState || null;
      l.value = x, x = c(p, h, _, d);
      for (let b = 0; b !== _; ++b)
        x[b] = e[b];
      m.clippingState = x, this.numIntersection = g ? this.numPlanes : 0, this.numPlanes += y;
    }
  };
  function u() {
    l.value !== e && (l.value = e, l.needsUpdate = n > 0), t.numPlanes = n, t.numIntersection = 0;
  }
  function c(f, h, d, p) {
    const g = f !== null ? f.length : 0;
    let v = null;
    if (g !== 0) {
      if (v = l.value, p !== !0 || v === null) {
        const m = d + g * 4, y = h.matrixWorldInverse;
        s.getNormalMatrix(y), (v === null || v.length < m) && (v = new Float32Array(m));
        for (let _ = 0, x = d; _ !== g; ++_, x += 4)
          o.copy(f[_]).applyMatrix4(y, s), o.normal.toArray(v, x), v[x + 3] = o.constant;
      }
      l.value = v, l.needsUpdate = !0;
    }
    return t.numPlanes = g, t.numIntersection = 0, v;
  }
}
function B5(r) {
  let t = /* @__PURE__ */ new WeakMap();
  function e(o, s) {
    return s === U_ ? o.mapping = qu : s === G_ && (o.mapping = Ku), o;
  }
  function n(o) {
    if (o && o.isTexture) {
      const s = o.mapping;
      if (s === U_ || s === G_)
        if (t.has(o)) {
          const l = t.get(o).texture;
          return e(l, o.mapping);
        } else {
          const l = o.image;
          if (l && l.height > 0) {
            const u = new Zz(l.height);
            return u.fromEquirectangularTexture(r, o), t.set(o, u), o.addEventListener("dispose", i), e(u.texture, o.mapping);
          } else
            return null;
        }
    }
    return o;
  }
  function i(o) {
    const s = o.target;
    s.removeEventListener("dispose", i);
    const l = t.get(s);
    l !== void 0 && (t.delete(s), l.dispose());
  }
  function a() {
    t = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: n,
    dispose: a
  };
}
class LI extends EI {
  constructor(t = -1, e = 1, n = 1, i = -1, a = 0.1, o = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = i, this.near = a, this.far = o, this.updateProjectionMatrix();
  }
  copy(t, e) {
    return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = t.view === null ? null : Object.assign({}, t.view), this;
  }
  setViewOffset(t, e, n, i, a, o) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = a, this.view.height = o, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2;
    let a = n - t, o = n + t, s = i + e, l = i - e;
    if (this.view !== null && this.view.enabled) {
      const u = (this.right - this.left) / this.view.fullWidth / this.zoom, c = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      a += u * this.view.offsetX, o = a + u * this.view.width, s -= c * this.view.offsetY, l = s - c * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(a, o, s, l, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, this.view !== null && (e.object.view = Object.assign({}, this.view)), e;
  }
}
const Ru = 4, UM = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], Us = 20, ty = /* @__PURE__ */ new LI(), GM = /* @__PURE__ */ new le();
let ey = null, ry = 0, ny = 0, iy = !1;
const Ps = (1 + Math.sqrt(5)) / 2, Kl = 1 / Ps, HM = [
  /* @__PURE__ */ new j(-Ps, Kl, 0),
  /* @__PURE__ */ new j(Ps, Kl, 0),
  /* @__PURE__ */ new j(-Kl, 0, Ps),
  /* @__PURE__ */ new j(Kl, 0, Ps),
  /* @__PURE__ */ new j(0, Ps, -Kl),
  /* @__PURE__ */ new j(0, Ps, Kl),
  /* @__PURE__ */ new j(-1, 1, -1),
  /* @__PURE__ */ new j(1, 1, -1),
  /* @__PURE__ */ new j(-1, 1, 1),
  /* @__PURE__ */ new j(1, 1, 1)
];
class WM {
  constructor(t) {
    this._renderer = t, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(t, e = 0, n = 0.1, i = 100) {
    ey = this._renderer.getRenderTarget(), ry = this._renderer.getActiveCubeFace(), ny = this._renderer.getActiveMipmapLevel(), iy = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(256);
    const a = this._allocateTargets();
    return a.depthBuffer = !0, this._sceneToCubeUV(t, n, i, a), e > 0 && this._blur(a, 0, 0, e), this._applyPMREM(a), this._cleanup(a), a;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported equirectangular image size is 64 x 32.
   */
  fromEquirectangular(t, e = null) {
    return this._fromTexture(t, e);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported cube size is 16 x 16.
   */
  fromCubemap(t, e = null) {
    return this._fromTexture(t, e);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = $M(), this._compileMaterial(this._cubemapMaterial));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = YM(), this._compileMaterial(this._equirectMaterial));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(t) {
    this._lodMax = Math.floor(Math.log2(t)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let t = 0; t < this._lodPlanes.length; t++)
      this._lodPlanes[t].dispose();
  }
  _cleanup(t) {
    this._renderer.setRenderTarget(ey, ry, ny), this._renderer.xr.enabled = iy, t.scissorTest = !1, xd(t, 0, 0, t.width, t.height);
  }
  _fromTexture(t, e) {
    t.mapping === qu || t.mapping === Ku ? this._setSize(t.image.length === 0 ? 16 : t.image[0].width || t.image[0].image.width) : this._setSize(t.image.width / 4), ey = this._renderer.getRenderTarget(), ry = this._renderer.getActiveCubeFace(), ny = this._renderer.getActiveMipmapLevel(), iy = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
    const n = e || this._allocateTargets();
    return this._textureToCubeUV(t, n), this._applyPMREM(n), this._cleanup(n), n;
  }
  _allocateTargets() {
    const t = 3 * Math.max(this._cubeSize, 112), e = 4 * this._cubeSize, n = {
      magFilter: pi,
      minFilter: pi,
      generateMipmaps: !1,
      type: Pg,
      format: Wi,
      colorSpace: Zo,
      depthBuffer: !1
    }, i = XM(t, e, n);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== t || this._pingPongRenderTarget.height !== e) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = XM(t, e, n);
      const { _lodMax: a } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = V5(a)), this._blurMaterial = F5(a, t, e);
    }
    return i;
  }
  _compileMaterial(t) {
    const e = new In(this._lodPlanes[0], t);
    this._renderer.compile(e, ty);
  }
  _sceneToCubeUV(t, e, n, i) {
    const s = new Ln(90, 1, e, n), l = [1, -1, 1, 1, 1, 1], u = [1, 1, 1, -1, -1, -1], c = this._renderer, f = c.autoClear, h = c.toneMapping;
    c.getClearColor(GM), c.toneMapping = Ro, c.autoClear = !1;
    const d = new d1({
      name: "PMREM.Background",
      side: Sn,
      depthWrite: !1,
      depthTest: !1
    }), p = new In(new bl(), d);
    let g = !1;
    const v = t.background;
    v ? v.isColor && (d.color.copy(v), t.background = null, g = !0) : (d.color.copy(GM), g = !0);
    for (let m = 0; m < 6; m++) {
      const y = m % 3;
      y === 0 ? (s.up.set(0, l[m], 0), s.lookAt(u[m], 0, 0)) : y === 1 ? (s.up.set(0, 0, l[m]), s.lookAt(0, u[m], 0)) : (s.up.set(0, l[m], 0), s.lookAt(0, 0, u[m]));
      const _ = this._cubeSize;
      xd(i, y * _, m > 2 ? _ : 0, _, _), c.setRenderTarget(i), g && c.render(p, s), c.render(t, s);
    }
    p.geometry.dispose(), p.material.dispose(), c.toneMapping = h, c.autoClear = f, t.background = v;
  }
  _textureToCubeUV(t, e) {
    const n = this._renderer, i = t.mapping === qu || t.mapping === Ku;
    i ? (this._cubemapMaterial === null && (this._cubemapMaterial = $M()), this._cubemapMaterial.uniforms.flipEnvMap.value = t.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = YM());
    const a = i ? this._cubemapMaterial : this._equirectMaterial, o = new In(this._lodPlanes[0], a), s = a.uniforms;
    s.envMap.value = t;
    const l = this._cubeSize;
    xd(e, 0, 0, 3 * l, 2 * l), n.setRenderTarget(e), n.render(o, ty);
  }
  _applyPMREM(t) {
    const e = this._renderer, n = e.autoClear;
    e.autoClear = !1;
    const i = this._lodPlanes.length;
    for (let a = 1; a < i; a++) {
      const o = Math.sqrt(this._sigmas[a] * this._sigmas[a] - this._sigmas[a - 1] * this._sigmas[a - 1]), s = HM[(i - a - 1) % HM.length];
      this._blur(t, a - 1, a, o, s);
    }
    e.autoClear = n;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(t, e, n, i, a) {
    const o = this._pingPongRenderTarget;
    this._halfBlur(
      t,
      o,
      e,
      n,
      i,
      "latitudinal",
      a
    ), this._halfBlur(
      o,
      t,
      n,
      n,
      i,
      "longitudinal",
      a
    );
  }
  _halfBlur(t, e, n, i, a, o, s) {
    const l = this._renderer, u = this._blurMaterial;
    o !== "latitudinal" && o !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const c = 3, f = new In(this._lodPlanes[i], u), h = u.uniforms, d = this._sizeLods[n] - 1, p = isFinite(a) ? Math.PI / (2 * d) : 2 * Math.PI / (2 * Us - 1), g = a / p, v = isFinite(a) ? 1 + Math.floor(c * g) : Us;
    v > Us && console.warn(`sigmaRadians, ${a}, is too large and will clip, as it requested ${v} samples when the maximum is set to ${Us}`);
    const m = [];
    let y = 0;
    for (let w = 0; w < Us; ++w) {
      const A = w / g, T = Math.exp(-A * A / 2);
      m.push(T), w === 0 ? y += T : w < v && (y += 2 * T);
    }
    for (let w = 0; w < m.length; w++)
      m[w] = m[w] / y;
    h.envMap.value = t.texture, h.samples.value = v, h.weights.value = m, h.latitudinal.value = o === "latitudinal", s && (h.poleAxis.value = s);
    const { _lodMax: _ } = this;
    h.dTheta.value = p, h.mipInt.value = _ - n;
    const x = this._sizeLods[i], b = 3 * x * (i > _ - Ru ? i - _ + Ru : 0), S = 4 * (this._cubeSize - x);
    xd(e, b, S, 3 * x, 2 * x), l.setRenderTarget(e), l.render(f, ty);
  }
}
function V5(r) {
  const t = [], e = [], n = [];
  let i = r;
  const a = r - Ru + 1 + UM.length;
  for (let o = 0; o < a; o++) {
    const s = Math.pow(2, i);
    e.push(s);
    let l = 1 / s;
    o > r - Ru ? l = UM[o - r + Ru - 1] : o === 0 && (l = 0), n.push(l);
    const u = 1 / (s - 2), c = -u, f = 1 + u, h = [c, c, f, c, f, f, c, c, f, f, c, f], d = 6, p = 6, g = 3, v = 2, m = 1, y = new Float32Array(g * p * d), _ = new Float32Array(v * p * d), x = new Float32Array(m * p * d);
    for (let S = 0; S < d; S++) {
      const w = S % 3 * 2 / 3 - 1, A = S > 2 ? 0 : -1, T = [
        w,
        A,
        0,
        w + 2 / 3,
        A,
        0,
        w + 2 / 3,
        A + 1,
        0,
        w,
        A,
        0,
        w + 2 / 3,
        A + 1,
        0,
        w,
        A + 1,
        0
      ];
      y.set(T, g * p * S), _.set(h, v * p * S);
      const M = [S, S, S, S, S, S];
      x.set(M, m * p * S);
    }
    const b = new ua();
    b.setAttribute("position", new ri(y, g)), b.setAttribute("uv", new ri(_, v)), b.setAttribute("faceIndex", new ri(x, m)), t.push(b), i > Ru && i--;
  }
  return { lodPlanes: t, sizeLods: e, sigmas: n };
}
function XM(r, t, e) {
  const n = new cl(r, t, e);
  return n.texture.mapping = Ig, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n;
}
function xd(r, t, e, n, i) {
  r.viewport.set(t, e, n, i), r.scissor.set(t, e, n, i);
}
function F5(r, t, e) {
  const n = new Float32Array(Us), i = new j(0, 1, 0);
  return new Fa({
    name: "SphericalGaussianBlur",
    defines: {
      n: Us,
      CUBEUV_TEXEL_WIDTH: 1 / t,
      CUBEUV_TEXEL_HEIGHT: 1 / e,
      CUBEUV_MAX_MIP: `${r}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: n },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: i }
    },
    vertexShader: v1(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: Lo,
    depthTest: !1,
    depthWrite: !1
  });
}
function YM() {
  return new Fa({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null }
    },
    vertexShader: v1(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: Lo,
    depthTest: !1,
    depthWrite: !1
  });
}
function $M() {
  return new Fa({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 }
    },
    vertexShader: v1(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: Lo,
    depthTest: !1,
    depthWrite: !1
  });
}
function v1() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function z5(r) {
  let t = /* @__PURE__ */ new WeakMap(), e = null;
  function n(s) {
    if (s && s.isTexture) {
      const l = s.mapping, u = l === U_ || l === G_, c = l === qu || l === Ku;
      if (u || c) {
        let f = t.get(s);
        const h = f !== void 0 ? f.texture.pmremVersion : 0;
        if (s.isRenderTargetTexture && s.pmremVersion !== h)
          return e === null && (e = new WM(r)), f = u ? e.fromEquirectangular(s, f) : e.fromCubemap(s, f), f.texture.pmremVersion = s.pmremVersion, t.set(s, f), f.texture;
        if (f !== void 0)
          return f.texture;
        {
          const d = s.image;
          return u && d && d.height > 0 || c && d && i(d) ? (e === null && (e = new WM(r)), f = u ? e.fromEquirectangular(s) : e.fromCubemap(s), f.texture.pmremVersion = s.pmremVersion, t.set(s, f), s.addEventListener("dispose", a), f.texture) : null;
        }
      }
    }
    return s;
  }
  function i(s) {
    let l = 0;
    const u = 6;
    for (let c = 0; c < u; c++)
      s[c] !== void 0 && l++;
    return l === u;
  }
  function a(s) {
    const l = s.target;
    l.removeEventListener("dispose", a);
    const u = t.get(l);
    u !== void 0 && (t.delete(l), u.dispose());
  }
  function o() {
    t = /* @__PURE__ */ new WeakMap(), e !== null && (e.dispose(), e = null);
  }
  return {
    get: n,
    dispose: o
  };
}
function U5(r) {
  const t = {};
  function e(n) {
    if (t[n] !== void 0)
      return t[n];
    let i;
    switch (n) {
      case "WEBGL_depth_texture":
        i = r.getExtension("WEBGL_depth_texture") || r.getExtension("MOZ_WEBGL_depth_texture") || r.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        i = r.getExtension("EXT_texture_filter_anisotropic") || r.getExtension("MOZ_EXT_texture_filter_anisotropic") || r.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        i = r.getExtension("WEBGL_compressed_texture_s3tc") || r.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        i = r.getExtension("WEBGL_compressed_texture_pvrtc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        i = r.getExtension(n);
    }
    return t[n] = i, i;
  }
  return {
    has: function(n) {
      return e(n) !== null;
    },
    init: function() {
      e("EXT_color_buffer_float"), e("WEBGL_clip_cull_distance"), e("OES_texture_float_linear"), e("EXT_color_buffer_half_float"), e("WEBGL_multisampled_render_to_texture"), e("WEBGL_render_shared_exponent");
    },
    get: function(n) {
      const i = e(n);
      return i === null && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), i;
    }
  };
}
function G5(r, t, e, n) {
  const i = {}, a = /* @__PURE__ */ new WeakMap();
  function o(f) {
    const h = f.target;
    h.index !== null && t.remove(h.index);
    for (const p in h.attributes)
      t.remove(h.attributes[p]);
    for (const p in h.morphAttributes) {
      const g = h.morphAttributes[p];
      for (let v = 0, m = g.length; v < m; v++)
        t.remove(g[v]);
    }
    h.removeEventListener("dispose", o), delete i[h.id];
    const d = a.get(h);
    d && (t.remove(d), a.delete(h)), n.releaseStatesOfGeometry(h), h.isInstancedBufferGeometry === !0 && delete h._maxInstanceCount, e.memory.geometries--;
  }
  function s(f, h) {
    return i[h.id] === !0 || (h.addEventListener("dispose", o), i[h.id] = !0, e.memory.geometries++), h;
  }
  function l(f) {
    const h = f.attributes;
    for (const p in h)
      t.update(h[p], r.ARRAY_BUFFER);
    const d = f.morphAttributes;
    for (const p in d) {
      const g = d[p];
      for (let v = 0, m = g.length; v < m; v++)
        t.update(g[v], r.ARRAY_BUFFER);
    }
  }
  function u(f) {
    const h = [], d = f.index, p = f.attributes.position;
    let g = 0;
    if (d !== null) {
      const y = d.array;
      g = d.version;
      for (let _ = 0, x = y.length; _ < x; _ += 3) {
        const b = y[_ + 0], S = y[_ + 1], w = y[_ + 2];
        h.push(b, S, S, w, w, b);
      }
    } else if (p !== void 0) {
      const y = p.array;
      g = p.version;
      for (let _ = 0, x = y.length / 3 - 1; _ < x; _ += 3) {
        const b = _ + 0, S = _ + 1, w = _ + 2;
        h.push(b, S, S, w, w, b);
      }
    } else
      return;
    const v = new (xI(h) ? TI : MI)(h, 1);
    v.version = g;
    const m = a.get(f);
    m && t.remove(m), a.set(f, v);
  }
  function c(f) {
    const h = a.get(f);
    if (h) {
      const d = f.index;
      d !== null && h.version < d.version && u(f);
    } else
      u(f);
    return a.get(f);
  }
  return {
    get: s,
    update: l,
    getWireframeAttribute: c
  };
}
function H5(r, t, e) {
  let n;
  function i(h) {
    n = h;
  }
  let a, o;
  function s(h) {
    a = h.type, o = h.bytesPerElement;
  }
  function l(h, d) {
    r.drawElements(n, d, a, h * o), e.update(d, n, 1);
  }
  function u(h, d, p) {
    p !== 0 && (r.drawElementsInstanced(n, d, a, h * o, p), e.update(d, n, p));
  }
  function c(h, d, p) {
    if (p === 0)
      return;
    const g = t.get("WEBGL_multi_draw");
    if (g === null)
      for (let v = 0; v < p; v++)
        this.render(h[v] / o, d[v]);
    else {
      g.multiDrawElementsWEBGL(n, d, 0, a, h, 0, p);
      let v = 0;
      for (let m = 0; m < p; m++)
        v += d[m];
      e.update(v, n, 1);
    }
  }
  function f(h, d, p, g) {
    if (p === 0)
      return;
    const v = t.get("WEBGL_multi_draw");
    if (v === null)
      for (let m = 0; m < h.length; m++)
        u(h[m] / o, d[m], g[m]);
    else {
      v.multiDrawElementsInstancedWEBGL(n, d, 0, a, h, 0, g, 0, p);
      let m = 0;
      for (let y = 0; y < p; y++)
        m += d[y];
      for (let y = 0; y < g.length; y++)
        e.update(m, n, g[y]);
    }
  }
  this.setMode = i, this.setIndex = s, this.render = l, this.renderInstances = u, this.renderMultiDraw = c, this.renderMultiDrawInstances = f;
}
function W5(r) {
  const t = {
    geometries: 0,
    textures: 0
  }, e = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function n(a, o, s) {
    switch (e.calls++, o) {
      case r.TRIANGLES:
        e.triangles += s * (a / 3);
        break;
      case r.LINES:
        e.lines += s * (a / 2);
        break;
      case r.LINE_STRIP:
        e.lines += s * (a - 1);
        break;
      case r.LINE_LOOP:
        e.lines += s * a;
        break;
      case r.POINTS:
        e.points += s * a;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", o);
        break;
    }
  }
  function i() {
    e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0;
  }
  return {
    memory: t,
    render: e,
    programs: null,
    autoReset: !0,
    reset: i,
    update: n
  };
}
function X5(r, t, e) {
  const n = /* @__PURE__ */ new WeakMap(), i = new Pr();
  function a(o, s, l) {
    const u = o.morphTargetInfluences, c = s.morphAttributes.position || s.morphAttributes.normal || s.morphAttributes.color, f = c !== void 0 ? c.length : 0;
    let h = n.get(s);
    if (h === void 0 || h.count !== f) {
      let T = function() {
        w.dispose(), n.delete(s), s.removeEventListener("dispose", T);
      };
      h !== void 0 && h.texture.dispose();
      const d = s.morphAttributes.position !== void 0, p = s.morphAttributes.normal !== void 0, g = s.morphAttributes.color !== void 0, v = s.morphAttributes.position || [], m = s.morphAttributes.normal || [], y = s.morphAttributes.color || [];
      let _ = 0;
      d === !0 && (_ = 1), p === !0 && (_ = 2), g === !0 && (_ = 3);
      let x = s.attributes.position.count * _, b = 1;
      x > t.maxTextureSize && (b = Math.ceil(x / t.maxTextureSize), x = t.maxTextureSize);
      const S = new Float32Array(x * b * 4 * f), w = new bI(S, x, b, f);
      w.type = Ea, w.needsUpdate = !0;
      const A = _ * 4;
      for (let M = 0; M < f; M++) {
        const E = v[M], R = m[M], C = y[M], D = x * b * 4 * M;
        for (let I = 0; I < E.count; I++) {
          const P = I * A;
          d === !0 && (i.fromBufferAttribute(E, I), S[D + P + 0] = i.x, S[D + P + 1] = i.y, S[D + P + 2] = i.z, S[D + P + 3] = 0), p === !0 && (i.fromBufferAttribute(R, I), S[D + P + 4] = i.x, S[D + P + 5] = i.y, S[D + P + 6] = i.z, S[D + P + 7] = 0), g === !0 && (i.fromBufferAttribute(C, I), S[D + P + 8] = i.x, S[D + P + 9] = i.y, S[D + P + 10] = i.z, S[D + P + 11] = C.itemSize === 4 ? i.w : 1);
        }
      }
      h = {
        count: f,
        texture: w,
        size: new Ce(x, b)
      }, n.set(s, h), s.addEventListener("dispose", T);
    }
    if (o.isInstancedMesh === !0 && o.morphTexture !== null)
      l.getUniforms().setValue(r, "morphTexture", o.morphTexture, e);
    else {
      let d = 0;
      for (let g = 0; g < u.length; g++)
        d += u[g];
      const p = s.morphTargetsRelative ? 1 : 1 - d;
      l.getUniforms().setValue(r, "morphTargetBaseInfluence", p), l.getUniforms().setValue(r, "morphTargetInfluences", u);
    }
    l.getUniforms().setValue(r, "morphTargetsTexture", h.texture, e), l.getUniforms().setValue(r, "morphTargetsTextureSize", h.size);
  }
  return {
    update: a
  };
}
function Y5(r, t, e, n) {
  let i = /* @__PURE__ */ new WeakMap();
  function a(l) {
    const u = n.render.frame, c = l.geometry, f = t.get(l, c);
    if (i.get(f) !== u && (t.update(f), i.set(f, u)), l.isInstancedMesh && (l.hasEventListener("dispose", s) === !1 && l.addEventListener("dispose", s), i.get(l) !== u && (e.update(l.instanceMatrix, r.ARRAY_BUFFER), l.instanceColor !== null && e.update(l.instanceColor, r.ARRAY_BUFFER), i.set(l, u))), l.isSkinnedMesh) {
      const h = l.skeleton;
      i.get(h) !== u && (h.update(), i.set(h, u));
    }
    return f;
  }
  function o() {
    i = /* @__PURE__ */ new WeakMap();
  }
  function s(l) {
    const u = l.target;
    u.removeEventListener("dispose", s), e.remove(u.instanceMatrix), u.instanceColor !== null && e.remove(u.instanceColor);
  }
  return {
    update: a,
    dispose: o
  };
}
class RI extends sn {
  constructor(t, e, n, i, a, o, s, l, u, c) {
    if (c = c !== void 0 ? c : Uu, c !== Uu && c !== Qf)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    n === void 0 && c === Uu && (n = ju), n === void 0 && c === Qf && (n = Dh), super(null, i, a, o, s, l, c, n, u), this.isDepthTexture = !0, this.image = { width: t, height: e }, this.magFilter = s !== void 0 ? s : xn, this.minFilter = l !== void 0 ? l : xn, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(t) {
    return super.copy(t), this.compareFunction = t.compareFunction, this;
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return this.compareFunction !== null && (e.compareFunction = this.compareFunction), e;
  }
}
const II = /* @__PURE__ */ new sn(), PI = /* @__PURE__ */ new RI(1, 1);
PI.compareFunction = _I;
const NI = /* @__PURE__ */ new bI(), OI = /* @__PURE__ */ new Iz(), kI = /* @__PURE__ */ new CI(), ZM = [], qM = [], KM = new Float32Array(16), jM = new Float32Array(9), JM = new Float32Array(4);
function mc(r, t, e) {
  const n = r[0];
  if (n <= 0 || n > 0)
    return r;
  const i = t * e;
  let a = ZM[i];
  if (a === void 0 && (a = new Float32Array(i), ZM[i] = a), t !== 0) {
    n.toArray(a, 0);
    for (let o = 1, s = 0; o !== t; ++o)
      s += e, r[o].toArray(a, s);
  }
  return a;
}
function Tr(r, t) {
  if (r.length !== t.length)
    return !1;
  for (let e = 0, n = r.length; e < n; e++)
    if (r[e] !== t[e])
      return !1;
  return !0;
}
function Ar(r, t) {
  for (let e = 0, n = t.length; e < n; e++)
    r[e] = t[e];
}
function kg(r, t) {
  let e = qM[t];
  e === void 0 && (e = new Int32Array(t), qM[t] = e);
  for (let n = 0; n !== t; ++n)
    e[n] = r.allocateTextureUnit();
  return e;
}
function $5(r, t) {
  const e = this.cache;
  e[0] !== t && (r.uniform1f(this.addr, t), e[0] = t);
}
function Z5(r, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y) && (r.uniform2f(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y);
  else {
    if (Tr(e, t))
      return;
    r.uniform2fv(this.addr, t), Ar(e, t);
  }
}
function q5(r, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (r.uniform3f(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z);
  else if (t.r !== void 0)
    (e[0] !== t.r || e[1] !== t.g || e[2] !== t.b) && (r.uniform3f(this.addr, t.r, t.g, t.b), e[0] = t.r, e[1] = t.g, e[2] = t.b);
  else {
    if (Tr(e, t))
      return;
    r.uniform3fv(this.addr, t), Ar(e, t);
  }
}
function K5(r, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (r.uniform4f(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w);
  else {
    if (Tr(e, t))
      return;
    r.uniform4fv(this.addr, t), Ar(e, t);
  }
}
function j5(r, t) {
  const e = this.cache, n = t.elements;
  if (n === void 0) {
    if (Tr(e, t))
      return;
    r.uniformMatrix2fv(this.addr, !1, t), Ar(e, t);
  } else {
    if (Tr(e, n))
      return;
    JM.set(n), r.uniformMatrix2fv(this.addr, !1, JM), Ar(e, n);
  }
}
function J5(r, t) {
  const e = this.cache, n = t.elements;
  if (n === void 0) {
    if (Tr(e, t))
      return;
    r.uniformMatrix3fv(this.addr, !1, t), Ar(e, t);
  } else {
    if (Tr(e, n))
      return;
    jM.set(n), r.uniformMatrix3fv(this.addr, !1, jM), Ar(e, n);
  }
}
function Q5(r, t) {
  const e = this.cache, n = t.elements;
  if (n === void 0) {
    if (Tr(e, t))
      return;
    r.uniformMatrix4fv(this.addr, !1, t), Ar(e, t);
  } else {
    if (Tr(e, n))
      return;
    KM.set(n), r.uniformMatrix4fv(this.addr, !1, KM), Ar(e, n);
  }
}
function tH(r, t) {
  const e = this.cache;
  e[0] !== t && (r.uniform1i(this.addr, t), e[0] = t);
}
function eH(r, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y) && (r.uniform2i(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y);
  else {
    if (Tr(e, t))
      return;
    r.uniform2iv(this.addr, t), Ar(e, t);
  }
}
function rH(r, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (r.uniform3i(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z);
  else {
    if (Tr(e, t))
      return;
    r.uniform3iv(this.addr, t), Ar(e, t);
  }
}
function nH(r, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (r.uniform4i(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w);
  else {
    if (Tr(e, t))
      return;
    r.uniform4iv(this.addr, t), Ar(e, t);
  }
}
function iH(r, t) {
  const e = this.cache;
  e[0] !== t && (r.uniform1ui(this.addr, t), e[0] = t);
}
function aH(r, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y) && (r.uniform2ui(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y);
  else {
    if (Tr(e, t))
      return;
    r.uniform2uiv(this.addr, t), Ar(e, t);
  }
}
function oH(r, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (r.uniform3ui(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z);
  else {
    if (Tr(e, t))
      return;
    r.uniform3uiv(this.addr, t), Ar(e, t);
  }
}
function sH(r, t) {
  const e = this.cache;
  if (t.x !== void 0)
    (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (r.uniform4ui(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w);
  else {
    if (Tr(e, t))
      return;
    r.uniform4uiv(this.addr, t), Ar(e, t);
  }
}
function lH(r, t, e) {
  const n = this.cache, i = e.allocateTextureUnit();
  n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i);
  const a = this.type === r.SAMPLER_2D_SHADOW ? PI : II;
  e.setTexture2D(t || a, i);
}
function uH(r, t, e) {
  const n = this.cache, i = e.allocateTextureUnit();
  n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i), e.setTexture3D(t || OI, i);
}
function cH(r, t, e) {
  const n = this.cache, i = e.allocateTextureUnit();
  n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i), e.setTextureCube(t || kI, i);
}
function fH(r, t, e) {
  const n = this.cache, i = e.allocateTextureUnit();
  n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i), e.setTexture2DArray(t || NI, i);
}
function hH(r) {
  switch (r) {
    case 5126:
      return $5;
    case 35664:
      return Z5;
    case 35665:
      return q5;
    case 35666:
      return K5;
    case 35674:
      return j5;
    case 35675:
      return J5;
    case 35676:
      return Q5;
    case 5124:
    case 35670:
      return tH;
    case 35667:
    case 35671:
      return eH;
    case 35668:
    case 35672:
      return rH;
    case 35669:
    case 35673:
      return nH;
    case 5125:
      return iH;
    case 36294:
      return aH;
    case 36295:
      return oH;
    case 36296:
      return sH;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return lH;
    case 35679:
    case 36299:
    case 36307:
      return uH;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return cH;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return fH;
  }
}
function dH(r, t) {
  r.uniform1fv(this.addr, t);
}
function pH(r, t) {
  const e = mc(t, this.size, 2);
  r.uniform2fv(this.addr, e);
}
function vH(r, t) {
  const e = mc(t, this.size, 3);
  r.uniform3fv(this.addr, e);
}
function gH(r, t) {
  const e = mc(t, this.size, 4);
  r.uniform4fv(this.addr, e);
}
function mH(r, t) {
  const e = mc(t, this.size, 4);
  r.uniformMatrix2fv(this.addr, !1, e);
}
function yH(r, t) {
  const e = mc(t, this.size, 9);
  r.uniformMatrix3fv(this.addr, !1, e);
}
function _H(r, t) {
  const e = mc(t, this.size, 16);
  r.uniformMatrix4fv(this.addr, !1, e);
}
function xH(r, t) {
  r.uniform1iv(this.addr, t);
}
function SH(r, t) {
  r.uniform2iv(this.addr, t);
}
function bH(r, t) {
  r.uniform3iv(this.addr, t);
}
function wH(r, t) {
  r.uniform4iv(this.addr, t);
}
function MH(r, t) {
  r.uniform1uiv(this.addr, t);
}
function TH(r, t) {
  r.uniform2uiv(this.addr, t);
}
function AH(r, t) {
  r.uniform3uiv(this.addr, t);
}
function EH(r, t) {
  r.uniform4uiv(this.addr, t);
}
function CH(r, t, e) {
  const n = this.cache, i = t.length, a = kg(e, i);
  Tr(n, a) || (r.uniform1iv(this.addr, a), Ar(n, a));
  for (let o = 0; o !== i; ++o)
    e.setTexture2D(t[o] || II, a[o]);
}
function DH(r, t, e) {
  const n = this.cache, i = t.length, a = kg(e, i);
  Tr(n, a) || (r.uniform1iv(this.addr, a), Ar(n, a));
  for (let o = 0; o !== i; ++o)
    e.setTexture3D(t[o] || OI, a[o]);
}
function LH(r, t, e) {
  const n = this.cache, i = t.length, a = kg(e, i);
  Tr(n, a) || (r.uniform1iv(this.addr, a), Ar(n, a));
  for (let o = 0; o !== i; ++o)
    e.setTextureCube(t[o] || kI, a[o]);
}
function RH(r, t, e) {
  const n = this.cache, i = t.length, a = kg(e, i);
  Tr(n, a) || (r.uniform1iv(this.addr, a), Ar(n, a));
  for (let o = 0; o !== i; ++o)
    e.setTexture2DArray(t[o] || NI, a[o]);
}
function IH(r) {
  switch (r) {
    case 5126:
      return dH;
    case 35664:
      return pH;
    case 35665:
      return vH;
    case 35666:
      return gH;
    case 35674:
      return mH;
    case 35675:
      return yH;
    case 35676:
      return _H;
    case 5124:
    case 35670:
      return xH;
    case 35667:
    case 35671:
      return SH;
    case 35668:
    case 35672:
      return bH;
    case 35669:
    case 35673:
      return wH;
    case 5125:
      return MH;
    case 36294:
      return TH;
    case 36295:
      return AH;
    case 36296:
      return EH;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return CH;
    case 35679:
    case 36299:
    case 36307:
      return DH;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return LH;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return RH;
  }
}
class PH {
  constructor(t, e, n) {
    this.id = t, this.addr = n, this.cache = [], this.type = e.type, this.setValue = hH(e.type);
  }
}
class NH {
  constructor(t, e, n) {
    this.id = t, this.addr = n, this.cache = [], this.type = e.type, this.size = e.size, this.setValue = IH(e.type);
  }
}
class OH {
  constructor(t) {
    this.id = t, this.seq = [], this.map = {};
  }
  setValue(t, e, n) {
    const i = this.seq;
    for (let a = 0, o = i.length; a !== o; ++a) {
      const s = i[a];
      s.setValue(t, e[s.id], n);
    }
  }
}
const ay = /(\w+)(\])?(\[|\.)?/g;
function QM(r, t) {
  r.seq.push(t), r.map[t.id] = t;
}
function kH(r, t, e) {
  const n = r.name, i = n.length;
  for (ay.lastIndex = 0; ; ) {
    const a = ay.exec(n), o = ay.lastIndex;
    let s = a[1];
    const l = a[2] === "]", u = a[3];
    if (l && (s = s | 0), u === void 0 || u === "[" && o + 2 === i) {
      QM(e, u === void 0 ? new PH(s, r, t) : new NH(s, r, t));
      break;
    } else {
      let f = e.map[s];
      f === void 0 && (f = new OH(s), QM(e, f)), e = f;
    }
  }
}
class zp {
  constructor(t, e) {
    this.seq = [], this.map = {};
    const n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
    for (let i = 0; i < n; ++i) {
      const a = t.getActiveUniform(e, i), o = t.getUniformLocation(e, a.name);
      kH(a, o, this);
    }
  }
  setValue(t, e, n, i) {
    const a = this.map[e];
    a !== void 0 && a.setValue(t, n, i);
  }
  setOptional(t, e, n) {
    const i = e[n];
    i !== void 0 && this.setValue(t, n, i);
  }
  static upload(t, e, n, i) {
    for (let a = 0, o = e.length; a !== o; ++a) {
      const s = e[a], l = n[s.id];
      l.needsUpdate !== !1 && s.setValue(t, l.value, i);
    }
  }
  static seqWithValue(t, e) {
    const n = [];
    for (let i = 0, a = t.length; i !== a; ++i) {
      const o = t[i];
      o.id in e && n.push(o);
    }
    return n;
  }
}
function tT(r, t, e) {
  const n = r.createShader(t);
  return r.shaderSource(n, e), r.compileShader(n), n;
}
const BH = 37297;
let VH = 0;
function FH(r, t) {
  const e = r.split(`
`), n = [], i = Math.max(t - 6, 0), a = Math.min(t + 6, e.length);
  for (let o = i; o < a; o++) {
    const s = o + 1;
    n.push(`${s === t ? ">" : " "} ${s}: ${e[o]}`);
  }
  return n.join(`
`);
}
function zH(r) {
  const t = Fe.getPrimaries(Fe.workingColorSpace), e = Fe.getPrimaries(r);
  let n;
  switch (t === e ? n = "" : t === hv && e === fv ? n = "LinearDisplayP3ToLinearSRGB" : t === fv && e === hv && (n = "LinearSRGBToLinearDisplayP3"), r) {
    case Zo:
    case Ng:
      return [n, "LinearTransferOETF"];
    case Bi:
    case c1:
      return [n, "sRGBTransferOETF"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported color space:", r), [n, "LinearTransferOETF"];
  }
}
function eT(r, t, e) {
  const n = r.getShaderParameter(t, r.COMPILE_STATUS), i = r.getShaderInfoLog(t).trim();
  if (n && i === "")
    return "";
  const a = /ERROR: 0:(\d+)/.exec(i);
  if (a) {
    const o = parseInt(a[1]);
    return e.toUpperCase() + `

` + i + `

` + FH(r.getShaderSource(t), o);
  } else
    return i;
}
function UH(r, t) {
  const e = zH(t);
  return `vec4 ${r}( vec4 value ) { return ${e[0]}( ${e[1]}( value ) ); }`;
}
function GH(r, t) {
  let e;
  switch (t) {
    case KF:
      e = "Linear";
      break;
    case jF:
      e = "Reinhard";
      break;
    case JF:
      e = "OptimizedCineon";
      break;
    case QF:
      e = "ACESFilmic";
      break;
    case ez:
      e = "AgX";
      break;
    case rz:
      e = "Neutral";
      break;
    case tz:
      e = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), e = "Linear";
  }
  return "vec3 " + r + "( vec3 color ) { return " + e + "ToneMapping( color ); }";
}
function HH(r) {
  return [
    r.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
    r.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
  ].filter(Mf).join(`
`);
}
function WH(r) {
  const t = [];
  for (const e in r) {
    const n = r[e];
    n !== !1 && t.push("#define " + e + " " + n);
  }
  return t.join(`
`);
}
function XH(r, t) {
  const e = {}, n = r.getProgramParameter(t, r.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < n; i++) {
    const a = r.getActiveAttrib(t, i), o = a.name;
    let s = 1;
    a.type === r.FLOAT_MAT2 && (s = 2), a.type === r.FLOAT_MAT3 && (s = 3), a.type === r.FLOAT_MAT4 && (s = 4), e[o] = {
      type: a.type,
      location: r.getAttribLocation(t, o),
      locationSize: s
    };
  }
  return e;
}
function Mf(r) {
  return r !== "";
}
function rT(r, t) {
  const e = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
  return r.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, e).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows);
}
function nT(r, t) {
  return r.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection);
}
const YH = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Y_(r) {
  return r.replace(YH, ZH);
}
const $H = /* @__PURE__ */ new Map();
function ZH(r, t) {
  let e = me[t];
  if (e === void 0) {
    const n = $H.get(t);
    if (n !== void 0)
      e = me[n], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', t, n);
    else
      throw new Error("Can not resolve #include <" + t + ">");
  }
  return Y_(e);
}
const qH = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function iT(r) {
  return r.replace(qH, KH);
}
function KH(r, t, e, n) {
  let i = "";
  for (let a = parseInt(t); a < parseInt(e); a++)
    i += n.replace(/\[\s*i\s*\]/g, "[ " + a + " ]").replace(/UNROLLED_LOOP_INDEX/g, a);
  return i;
}
function aT(r) {
  let t = `precision ${r.precision} float;
	precision ${r.precision} int;
	precision ${r.precision} sampler2D;
	precision ${r.precision} samplerCube;
	precision ${r.precision} sampler3D;
	precision ${r.precision} sampler2DArray;
	precision ${r.precision} sampler2DShadow;
	precision ${r.precision} samplerCubeShadow;
	precision ${r.precision} sampler2DArrayShadow;
	precision ${r.precision} isampler2D;
	precision ${r.precision} isampler3D;
	precision ${r.precision} isamplerCube;
	precision ${r.precision} isampler2DArray;
	precision ${r.precision} usampler2D;
	precision ${r.precision} usampler3D;
	precision ${r.precision} usamplerCube;
	precision ${r.precision} usampler2DArray;
	`;
  return r.precision === "highp" ? t += `
#define HIGH_PRECISION` : r.precision === "mediump" ? t += `
#define MEDIUM_PRECISION` : r.precision === "lowp" && (t += `
#define LOW_PRECISION`), t;
}
function jH(r) {
  let t = "SHADOWMAP_TYPE_BASIC";
  return r.shadowMapType === lI ? t = "SHADOWMAP_TYPE_PCF" : r.shadowMapType === bF ? t = "SHADOWMAP_TYPE_PCF_SOFT" : r.shadowMapType === ba && (t = "SHADOWMAP_TYPE_VSM"), t;
}
function JH(r) {
  let t = "ENVMAP_TYPE_CUBE";
  if (r.envMap)
    switch (r.envMapMode) {
      case qu:
      case Ku:
        t = "ENVMAP_TYPE_CUBE";
        break;
      case Ig:
        t = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return t;
}
function QH(r) {
  let t = "ENVMAP_MODE_REFLECTION";
  if (r.envMap)
    switch (r.envMapMode) {
      case Ku:
        t = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return t;
}
function t4(r) {
  let t = "ENVMAP_BLENDING_NONE";
  if (r.envMap)
    switch (r.combine) {
      case uI:
        t = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case ZF:
        t = "ENVMAP_BLENDING_MIX";
        break;
      case qF:
        t = "ENVMAP_BLENDING_ADD";
        break;
    }
  return t;
}
function e4(r) {
  const t = r.envMapCubeUVHeight;
  if (t === null)
    return null;
  const e = Math.log2(t) - 2, n = 1 / t;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, e), 7 * 16)), texelHeight: n, maxMip: e };
}
function r4(r, t, e, n) {
  const i = r.getContext(), a = e.defines;
  let o = e.vertexShader, s = e.fragmentShader;
  const l = jH(e), u = JH(e), c = QH(e), f = t4(e), h = e4(e), d = HH(e), p = WH(a), g = i.createProgram();
  let v, m, y = e.glslVersion ? "#version " + e.glslVersion + `
` : "";
  e.isRawShaderMaterial ? (v = [
    "#define SHADER_TYPE " + e.shaderType,
    "#define SHADER_NAME " + e.shaderName,
    p
  ].filter(Mf).join(`
`), v.length > 0 && (v += `
`), m = [
    "#define SHADER_TYPE " + e.shaderType,
    "#define SHADER_NAME " + e.shaderName,
    p
  ].filter(Mf).join(`
`), m.length > 0 && (m += `
`)) : (v = [
    aT(e),
    "#define SHADER_TYPE " + e.shaderType,
    "#define SHADER_NAME " + e.shaderName,
    p,
    e.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
    e.batching ? "#define USE_BATCHING" : "",
    e.instancing ? "#define USE_INSTANCING" : "",
    e.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    e.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
    e.useFog && e.fog ? "#define USE_FOG" : "",
    e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "",
    e.map ? "#define USE_MAP" : "",
    e.envMap ? "#define USE_ENVMAP" : "",
    e.envMap ? "#define " + c : "",
    e.lightMap ? "#define USE_LIGHTMAP" : "",
    e.aoMap ? "#define USE_AOMAP" : "",
    e.bumpMap ? "#define USE_BUMPMAP" : "",
    e.normalMap ? "#define USE_NORMALMAP" : "",
    e.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    e.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    e.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
    e.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    e.anisotropy ? "#define USE_ANISOTROPY" : "",
    e.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    e.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    e.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    e.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    e.specularMap ? "#define USE_SPECULARMAP" : "",
    e.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    e.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    e.metalnessMap ? "#define USE_METALNESSMAP" : "",
    e.alphaMap ? "#define USE_ALPHAMAP" : "",
    e.alphaHash ? "#define USE_ALPHAHASH" : "",
    e.transmission ? "#define USE_TRANSMISSION" : "",
    e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    e.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    e.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    e.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    //
    e.mapUv ? "#define MAP_UV " + e.mapUv : "",
    e.alphaMapUv ? "#define ALPHAMAP_UV " + e.alphaMapUv : "",
    e.lightMapUv ? "#define LIGHTMAP_UV " + e.lightMapUv : "",
    e.aoMapUv ? "#define AOMAP_UV " + e.aoMapUv : "",
    e.emissiveMapUv ? "#define EMISSIVEMAP_UV " + e.emissiveMapUv : "",
    e.bumpMapUv ? "#define BUMPMAP_UV " + e.bumpMapUv : "",
    e.normalMapUv ? "#define NORMALMAP_UV " + e.normalMapUv : "",
    e.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + e.displacementMapUv : "",
    e.metalnessMapUv ? "#define METALNESSMAP_UV " + e.metalnessMapUv : "",
    e.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + e.roughnessMapUv : "",
    e.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + e.anisotropyMapUv : "",
    e.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + e.clearcoatMapUv : "",
    e.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + e.clearcoatNormalMapUv : "",
    e.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + e.clearcoatRoughnessMapUv : "",
    e.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + e.iridescenceMapUv : "",
    e.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + e.iridescenceThicknessMapUv : "",
    e.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + e.sheenColorMapUv : "",
    e.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + e.sheenRoughnessMapUv : "",
    e.specularMapUv ? "#define SPECULARMAP_UV " + e.specularMapUv : "",
    e.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + e.specularColorMapUv : "",
    e.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + e.specularIntensityMapUv : "",
    e.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + e.transmissionMapUv : "",
    e.thicknessMapUv ? "#define THICKNESSMAP_UV " + e.thicknessMapUv : "",
    //
    e.vertexTangents && e.flatShading === !1 ? "#define USE_TANGENT" : "",
    e.vertexColors ? "#define USE_COLOR" : "",
    e.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    e.vertexUv1s ? "#define USE_UV1" : "",
    e.vertexUv2s ? "#define USE_UV2" : "",
    e.vertexUv3s ? "#define USE_UV3" : "",
    e.pointsUvs ? "#define USE_POINTS_UV" : "",
    e.flatShading ? "#define FLAT_SHADED" : "",
    e.skinning ? "#define USE_SKINNING" : "",
    e.morphTargets ? "#define USE_MORPHTARGETS" : "",
    e.morphNormals && e.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    e.morphColors ? "#define USE_MORPHCOLORS" : "",
    e.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE" : "",
    e.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + e.morphTextureStride : "",
    e.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + e.morphTargetsCount : "",
    e.doubleSided ? "#define DOUBLE_SIDED" : "",
    e.flipSided ? "#define FLIP_SIDED" : "",
    e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    e.shadowMapEnabled ? "#define " + l : "",
    e.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    e.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    e.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
    e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "#ifdef USE_INSTANCING_MORPH",
    "	uniform sampler2D morphTexture;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_UV1",
    "	attribute vec2 uv1;",
    "#endif",
    "#ifdef USE_UV2",
    "	attribute vec2 uv2;",
    "#endif",
    "#ifdef USE_UV3",
    "	attribute vec2 uv3;",
    "#endif",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
    "	attribute vec3 morphTarget0;",
    "	attribute vec3 morphTarget1;",
    "	attribute vec3 morphTarget2;",
    "	attribute vec3 morphTarget3;",
    "	#ifdef USE_MORPHNORMALS",
    "		attribute vec3 morphNormal0;",
    "		attribute vec3 morphNormal1;",
    "		attribute vec3 morphNormal2;",
    "		attribute vec3 morphNormal3;",
    "	#else",
    "		attribute vec3 morphTarget4;",
    "		attribute vec3 morphTarget5;",
    "		attribute vec3 morphTarget6;",
    "		attribute vec3 morphTarget7;",
    "	#endif",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(Mf).join(`
`), m = [
    aT(e),
    "#define SHADER_TYPE " + e.shaderType,
    "#define SHADER_NAME " + e.shaderName,
    p,
    e.useFog && e.fog ? "#define USE_FOG" : "",
    e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "",
    e.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
    e.map ? "#define USE_MAP" : "",
    e.matcap ? "#define USE_MATCAP" : "",
    e.envMap ? "#define USE_ENVMAP" : "",
    e.envMap ? "#define " + u : "",
    e.envMap ? "#define " + c : "",
    e.envMap ? "#define " + f : "",
    h ? "#define CUBEUV_TEXEL_WIDTH " + h.texelWidth : "",
    h ? "#define CUBEUV_TEXEL_HEIGHT " + h.texelHeight : "",
    h ? "#define CUBEUV_MAX_MIP " + h.maxMip + ".0" : "",
    e.lightMap ? "#define USE_LIGHTMAP" : "",
    e.aoMap ? "#define USE_AOMAP" : "",
    e.bumpMap ? "#define USE_BUMPMAP" : "",
    e.normalMap ? "#define USE_NORMALMAP" : "",
    e.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    e.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    e.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    e.anisotropy ? "#define USE_ANISOTROPY" : "",
    e.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    e.clearcoat ? "#define USE_CLEARCOAT" : "",
    e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    e.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    e.dispersion ? "#define USE_DISPERSION" : "",
    e.iridescence ? "#define USE_IRIDESCENCE" : "",
    e.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    e.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    e.specularMap ? "#define USE_SPECULARMAP" : "",
    e.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    e.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    e.metalnessMap ? "#define USE_METALNESSMAP" : "",
    e.alphaMap ? "#define USE_ALPHAMAP" : "",
    e.alphaTest ? "#define USE_ALPHATEST" : "",
    e.alphaHash ? "#define USE_ALPHAHASH" : "",
    e.sheen ? "#define USE_SHEEN" : "",
    e.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    e.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    e.transmission ? "#define USE_TRANSMISSION" : "",
    e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    e.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    e.vertexTangents && e.flatShading === !1 ? "#define USE_TANGENT" : "",
    e.vertexColors || e.instancingColor ? "#define USE_COLOR" : "",
    e.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    e.vertexUv1s ? "#define USE_UV1" : "",
    e.vertexUv2s ? "#define USE_UV2" : "",
    e.vertexUv3s ? "#define USE_UV3" : "",
    e.pointsUvs ? "#define USE_POINTS_UV" : "",
    e.gradientMap ? "#define USE_GRADIENTMAP" : "",
    e.flatShading ? "#define FLAT_SHADED" : "",
    e.doubleSided ? "#define DOUBLE_SIDED" : "",
    e.flipSided ? "#define FLIP_SIDED" : "",
    e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    e.shadowMapEnabled ? "#define " + l : "",
    e.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    e.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    e.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
    e.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
    e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    e.toneMapping !== Ro ? "#define TONE_MAPPING" : "",
    e.toneMapping !== Ro ? me.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    e.toneMapping !== Ro ? GH("toneMapping", e.toneMapping) : "",
    e.dithering ? "#define DITHERING" : "",
    e.opaque ? "#define OPAQUE" : "",
    me.colorspace_pars_fragment,
    // this code is required here because it is used by the various encoding/decoding function defined below
    UH("linearToOutputTexel", e.outputColorSpace),
    e.useDepthPacking ? "#define DEPTH_PACKING " + e.depthPacking : "",
    `
`
  ].filter(Mf).join(`
`)), o = Y_(o), o = rT(o, e), o = nT(o, e), s = Y_(s), s = rT(s, e), s = nT(s, e), o = iT(o), s = iT(s), e.isRawShaderMaterial !== !0 && (y = `#version 300 es
`, v = [
    d,
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + v, m = [
    "#define varying in",
    e.glslVersion === SM ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
    e.glslVersion === SM ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + m);
  const _ = y + v + o, x = y + m + s, b = tT(i, i.VERTEX_SHADER, _), S = tT(i, i.FRAGMENT_SHADER, x);
  i.attachShader(g, b), i.attachShader(g, S), e.index0AttributeName !== void 0 ? i.bindAttribLocation(g, 0, e.index0AttributeName) : e.morphTargets === !0 && i.bindAttribLocation(g, 0, "position"), i.linkProgram(g);
  function w(E) {
    if (r.debug.checkShaderErrors) {
      const R = i.getProgramInfoLog(g).trim(), C = i.getShaderInfoLog(b).trim(), D = i.getShaderInfoLog(S).trim();
      let I = !0, P = !0;
      if (i.getProgramParameter(g, i.LINK_STATUS) === !1)
        if (I = !1, typeof r.debug.onShaderError == "function")
          r.debug.onShaderError(i, g, b, S);
        else {
          const O = eT(i, b, "vertex"), N = eT(i, S, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(g, i.VALIDATE_STATUS) + `

Material Name: ` + E.name + `
Material Type: ` + E.type + `

Program Info Log: ` + R + `
` + O + `
` + N
          );
        }
      else
        R !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", R) : (C === "" || D === "") && (P = !1);
      P && (E.diagnostics = {
        runnable: I,
        programLog: R,
        vertexShader: {
          log: C,
          prefix: v
        },
        fragmentShader: {
          log: D,
          prefix: m
        }
      });
    }
    i.deleteShader(b), i.deleteShader(S), A = new zp(i, g), T = XH(i, g);
  }
  let A;
  this.getUniforms = function() {
    return A === void 0 && w(this), A;
  };
  let T;
  this.getAttributes = function() {
    return T === void 0 && w(this), T;
  };
  let M = e.rendererExtensionParallelShaderCompile === !1;
  return this.isReady = function() {
    return M === !1 && (M = i.getProgramParameter(g, BH)), M;
  }, this.destroy = function() {
    n.releaseStatesOfProgram(this), i.deleteProgram(g), this.program = void 0;
  }, this.type = e.shaderType, this.name = e.shaderName, this.id = VH++, this.cacheKey = t, this.usedTimes = 1, this.program = g, this.vertexShader = b, this.fragmentShader = S, this;
}
let n4 = 0;
class i4 {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(t) {
    const e = t.vertexShader, n = t.fragmentShader, i = this._getShaderStage(e), a = this._getShaderStage(n), o = this._getShaderCacheForMaterial(t);
    return o.has(i) === !1 && (o.add(i), i.usedTimes++), o.has(a) === !1 && (o.add(a), a.usedTimes++), this;
  }
  remove(t) {
    const e = this.materialCache.get(t);
    for (const n of e)
      n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
    return this.materialCache.delete(t), this;
  }
  getVertexShaderID(t) {
    return this._getShaderStage(t.vertexShader).id;
  }
  getFragmentShaderID(t) {
    return this._getShaderStage(t.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(t) {
    const e = this.materialCache;
    let n = e.get(t);
    return n === void 0 && (n = /* @__PURE__ */ new Set(), e.set(t, n)), n;
  }
  _getShaderStage(t) {
    const e = this.shaderCache;
    let n = e.get(t);
    return n === void 0 && (n = new a4(t), e.set(t, n)), n;
  }
}
class a4 {
  constructor(t) {
    this.id = n4++, this.code = t, this.usedTimes = 0;
  }
}
function o4(r, t, e, n, i, a, o) {
  const s = new h1(), l = new i4(), u = /* @__PURE__ */ new Set(), c = [], f = i.logarithmicDepthBuffer, h = i.vertexTextures;
  let d = i.precision;
  const p = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function g(T) {
    return u.add(T), T === 0 ? "uv" : `uv${T}`;
  }
  function v(T, M, E, R, C) {
    const D = R.fog, I = C.geometry, P = T.isMeshStandardMaterial ? R.environment : null, O = (T.isMeshStandardMaterial ? e : t).get(T.envMap || P), N = O && O.mapping === Ig ? O.image.height : null, B = p[T.type];
    T.precision !== null && (d = i.getMaxPrecision(T.precision), d !== T.precision && console.warn("THREE.WebGLProgram.getParameters:", T.precision, "not supported, using", d, "instead."));
    const F = I.morphAttributes.position || I.morphAttributes.normal || I.morphAttributes.color, G = F !== void 0 ? F.length : 0;
    let X = 0;
    I.morphAttributes.position !== void 0 && (X = 1), I.morphAttributes.normal !== void 0 && (X = 2), I.morphAttributes.color !== void 0 && (X = 3);
    let K, U, $, ct;
    if (B) {
      const Be = Fi[B];
      K = Be.vertexShader, U = Be.fragmentShader;
    } else
      K = T.vertexShader, U = T.fragmentShader, l.update(T), $ = l.getVertexShaderID(T), ct = l.getFragmentShaderID(T);
    const at = r.getRenderTarget(), lt = C.isInstancedMesh === !0, ot = C.isBatchedMesh === !0, H = !!T.map, st = !!T.matcap, ut = !!O, Gt = !!T.aoMap, gt = !!T.lightMap, Lt = !!T.bumpMap, Vt = !!T.normalMap, Kt = !!T.displacementMap, Ae = !!T.emissiveMap, z = !!T.metalnessMap, k = !!T.roughnessMap, nt = T.anisotropy > 0, ht = T.clearcoat > 0, yt = T.dispersion > 0, xt = T.iridescence > 0, Qt = T.sheen > 0, Ft = T.transmission > 0, Ot = nt && !!T.anisotropyMap, _e = ht && !!T.clearcoatMap, Mt = ht && !!T.clearcoatNormalMap, Jt = ht && !!T.clearcoatRoughnessMap, De = xt && !!T.iridescenceMap, ie = xt && !!T.iridescenceThicknessMap, Ht = Qt && !!T.sheenColorMap, xe = Qt && !!T.sheenRoughnessMap, Ee = !!T.specularMap, nr = !!T.specularColorMap, Se = !!T.specularIntensityMap, Z = Ft && !!T.transmissionMap, vt = Ft && !!T.thicknessMap, ft = !!T.gradientMap, Rt = !!T.alphaMap, Ut = T.alphaTest > 0, Le = !!T.alphaHash, $e = !!T.extensions;
    let je = Ro;
    T.toneMapped && (at === null || at.isXRRenderTarget === !0) && (je = r.toneMapping);
    const Gr = {
      shaderID: B,
      shaderType: T.type,
      shaderName: T.name,
      vertexShader: K,
      fragmentShader: U,
      defines: T.defines,
      customVertexShaderID: $,
      customFragmentShaderID: ct,
      isRawShaderMaterial: T.isRawShaderMaterial === !0,
      glslVersion: T.glslVersion,
      precision: d,
      batching: ot,
      instancing: lt,
      instancingColor: lt && C.instanceColor !== null,
      instancingMorph: lt && C.morphTexture !== null,
      supportsVertexTextures: h,
      outputColorSpace: at === null ? r.outputColorSpace : at.isXRRenderTarget === !0 ? at.texture.colorSpace : Zo,
      alphaToCoverage: !!T.alphaToCoverage,
      map: H,
      matcap: st,
      envMap: ut,
      envMapMode: ut && O.mapping,
      envMapCubeUVHeight: N,
      aoMap: Gt,
      lightMap: gt,
      bumpMap: Lt,
      normalMap: Vt,
      displacementMap: h && Kt,
      emissiveMap: Ae,
      normalMapObjectSpace: Vt && T.normalMapType === gz,
      normalMapTangentSpace: Vt && T.normalMapType === vz,
      metalnessMap: z,
      roughnessMap: k,
      anisotropy: nt,
      anisotropyMap: Ot,
      clearcoat: ht,
      clearcoatMap: _e,
      clearcoatNormalMap: Mt,
      clearcoatRoughnessMap: Jt,
      dispersion: yt,
      iridescence: xt,
      iridescenceMap: De,
      iridescenceThicknessMap: ie,
      sheen: Qt,
      sheenColorMap: Ht,
      sheenRoughnessMap: xe,
      specularMap: Ee,
      specularColorMap: nr,
      specularIntensityMap: Se,
      transmission: Ft,
      transmissionMap: Z,
      thicknessMap: vt,
      gradientMap: ft,
      opaque: T.transparent === !1 && T.blending === zu && T.alphaToCoverage === !1,
      alphaMap: Rt,
      alphaTest: Ut,
      alphaHash: Le,
      combine: T.combine,
      //
      mapUv: H && g(T.map.channel),
      aoMapUv: Gt && g(T.aoMap.channel),
      lightMapUv: gt && g(T.lightMap.channel),
      bumpMapUv: Lt && g(T.bumpMap.channel),
      normalMapUv: Vt && g(T.normalMap.channel),
      displacementMapUv: Kt && g(T.displacementMap.channel),
      emissiveMapUv: Ae && g(T.emissiveMap.channel),
      metalnessMapUv: z && g(T.metalnessMap.channel),
      roughnessMapUv: k && g(T.roughnessMap.channel),
      anisotropyMapUv: Ot && g(T.anisotropyMap.channel),
      clearcoatMapUv: _e && g(T.clearcoatMap.channel),
      clearcoatNormalMapUv: Mt && g(T.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: Jt && g(T.clearcoatRoughnessMap.channel),
      iridescenceMapUv: De && g(T.iridescenceMap.channel),
      iridescenceThicknessMapUv: ie && g(T.iridescenceThicknessMap.channel),
      sheenColorMapUv: Ht && g(T.sheenColorMap.channel),
      sheenRoughnessMapUv: xe && g(T.sheenRoughnessMap.channel),
      specularMapUv: Ee && g(T.specularMap.channel),
      specularColorMapUv: nr && g(T.specularColorMap.channel),
      specularIntensityMapUv: Se && g(T.specularIntensityMap.channel),
      transmissionMapUv: Z && g(T.transmissionMap.channel),
      thicknessMapUv: vt && g(T.thicknessMap.channel),
      alphaMapUv: Rt && g(T.alphaMap.channel),
      //
      vertexTangents: !!I.attributes.tangent && (Vt || nt),
      vertexColors: T.vertexColors,
      vertexAlphas: T.vertexColors === !0 && !!I.attributes.color && I.attributes.color.itemSize === 4,
      pointsUvs: C.isPoints === !0 && !!I.attributes.uv && (H || Rt),
      fog: !!D,
      useFog: T.fog === !0,
      fogExp2: !!D && D.isFogExp2,
      flatShading: T.flatShading === !0,
      sizeAttenuation: T.sizeAttenuation === !0,
      logarithmicDepthBuffer: f,
      skinning: C.isSkinnedMesh === !0,
      morphTargets: I.morphAttributes.position !== void 0,
      morphNormals: I.morphAttributes.normal !== void 0,
      morphColors: I.morphAttributes.color !== void 0,
      morphTargetsCount: G,
      morphTextureStride: X,
      numDirLights: M.directional.length,
      numPointLights: M.point.length,
      numSpotLights: M.spot.length,
      numSpotLightMaps: M.spotLightMap.length,
      numRectAreaLights: M.rectArea.length,
      numHemiLights: M.hemi.length,
      numDirLightShadows: M.directionalShadowMap.length,
      numPointLightShadows: M.pointShadowMap.length,
      numSpotLightShadows: M.spotShadowMap.length,
      numSpotLightShadowsWithMaps: M.numSpotLightShadowsWithMaps,
      numLightProbes: M.numLightProbes,
      numClippingPlanes: o.numPlanes,
      numClipIntersection: o.numIntersection,
      dithering: T.dithering,
      shadowMapEnabled: r.shadowMap.enabled && E.length > 0,
      shadowMapType: r.shadowMap.type,
      toneMapping: je,
      useLegacyLights: r._useLegacyLights,
      decodeVideoTexture: H && T.map.isVideoTexture === !0 && Fe.getTransfer(T.map.colorSpace) === Ze,
      premultipliedAlpha: T.premultipliedAlpha,
      doubleSided: T.side === Ta,
      flipSided: T.side === Sn,
      useDepthPacking: T.depthPacking >= 0,
      depthPacking: T.depthPacking || 0,
      index0AttributeName: T.index0AttributeName,
      extensionClipCullDistance: $e && T.extensions.clipCullDistance === !0 && n.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw: $e && T.extensions.multiDraw === !0 && n.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"),
      customProgramCacheKey: T.customProgramCacheKey()
    };
    return Gr.vertexUv1s = u.has(1), Gr.vertexUv2s = u.has(2), Gr.vertexUv3s = u.has(3), u.clear(), Gr;
  }
  function m(T) {
    const M = [];
    if (T.shaderID ? M.push(T.shaderID) : (M.push(T.customVertexShaderID), M.push(T.customFragmentShaderID)), T.defines !== void 0)
      for (const E in T.defines)
        M.push(E), M.push(T.defines[E]);
    return T.isRawShaderMaterial === !1 && (y(M, T), _(M, T), M.push(r.outputColorSpace)), M.push(T.customProgramCacheKey), M.join();
  }
  function y(T, M) {
    T.push(M.precision), T.push(M.outputColorSpace), T.push(M.envMapMode), T.push(M.envMapCubeUVHeight), T.push(M.mapUv), T.push(M.alphaMapUv), T.push(M.lightMapUv), T.push(M.aoMapUv), T.push(M.bumpMapUv), T.push(M.normalMapUv), T.push(M.displacementMapUv), T.push(M.emissiveMapUv), T.push(M.metalnessMapUv), T.push(M.roughnessMapUv), T.push(M.anisotropyMapUv), T.push(M.clearcoatMapUv), T.push(M.clearcoatNormalMapUv), T.push(M.clearcoatRoughnessMapUv), T.push(M.iridescenceMapUv), T.push(M.iridescenceThicknessMapUv), T.push(M.sheenColorMapUv), T.push(M.sheenRoughnessMapUv), T.push(M.specularMapUv), T.push(M.specularColorMapUv), T.push(M.specularIntensityMapUv), T.push(M.transmissionMapUv), T.push(M.thicknessMapUv), T.push(M.combine), T.push(M.fogExp2), T.push(M.sizeAttenuation), T.push(M.morphTargetsCount), T.push(M.morphAttributeCount), T.push(M.numDirLights), T.push(M.numPointLights), T.push(M.numSpotLights), T.push(M.numSpotLightMaps), T.push(M.numHemiLights), T.push(M.numRectAreaLights), T.push(M.numDirLightShadows), T.push(M.numPointLightShadows), T.push(M.numSpotLightShadows), T.push(M.numSpotLightShadowsWithMaps), T.push(M.numLightProbes), T.push(M.shadowMapType), T.push(M.toneMapping), T.push(M.numClippingPlanes), T.push(M.numClipIntersection), T.push(M.depthPacking);
  }
  function _(T, M) {
    s.disableAll(), M.supportsVertexTextures && s.enable(0), M.instancing && s.enable(1), M.instancingColor && s.enable(2), M.instancingMorph && s.enable(3), M.matcap && s.enable(4), M.envMap && s.enable(5), M.normalMapObjectSpace && s.enable(6), M.normalMapTangentSpace && s.enable(7), M.clearcoat && s.enable(8), M.iridescence && s.enable(9), M.alphaTest && s.enable(10), M.vertexColors && s.enable(11), M.vertexAlphas && s.enable(12), M.vertexUv1s && s.enable(13), M.vertexUv2s && s.enable(14), M.vertexUv3s && s.enable(15), M.vertexTangents && s.enable(16), M.anisotropy && s.enable(17), M.alphaHash && s.enable(18), M.batching && s.enable(19), M.dispersion && s.enable(20), T.push(s.mask), s.disableAll(), M.fog && s.enable(0), M.useFog && s.enable(1), M.flatShading && s.enable(2), M.logarithmicDepthBuffer && s.enable(3), M.skinning && s.enable(4), M.morphTargets && s.enable(5), M.morphNormals && s.enable(6), M.morphColors && s.enable(7), M.premultipliedAlpha && s.enable(8), M.shadowMapEnabled && s.enable(9), M.useLegacyLights && s.enable(10), M.doubleSided && s.enable(11), M.flipSided && s.enable(12), M.useDepthPacking && s.enable(13), M.dithering && s.enable(14), M.transmission && s.enable(15), M.sheen && s.enable(16), M.opaque && s.enable(17), M.pointsUvs && s.enable(18), M.decodeVideoTexture && s.enable(19), M.alphaToCoverage && s.enable(20), T.push(s.mask);
  }
  function x(T) {
    const M = p[T.type];
    let E;
    if (M) {
      const R = Fi[M];
      E = Wz.clone(R.uniforms);
    } else
      E = T.uniforms;
    return E;
  }
  function b(T, M) {
    let E;
    for (let R = 0, C = c.length; R < C; R++) {
      const D = c[R];
      if (D.cacheKey === M) {
        E = D, ++E.usedTimes;
        break;
      }
    }
    return E === void 0 && (E = new r4(r, M, T, a), c.push(E)), E;
  }
  function S(T) {
    if (--T.usedTimes === 0) {
      const M = c.indexOf(T);
      c[M] = c[c.length - 1], c.pop(), T.destroy();
    }
  }
  function w(T) {
    l.remove(T);
  }
  function A() {
    l.dispose();
  }
  return {
    getParameters: v,
    getProgramCacheKey: m,
    getUniforms: x,
    acquireProgram: b,
    releaseProgram: S,
    releaseShaderCache: w,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: c,
    dispose: A
  };
}
function s4() {
  let r = /* @__PURE__ */ new WeakMap();
  function t(a) {
    let o = r.get(a);
    return o === void 0 && (o = {}, r.set(a, o)), o;
  }
  function e(a) {
    r.delete(a);
  }
  function n(a, o, s) {
    r.get(a)[o] = s;
  }
  function i() {
    r = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: t,
    remove: e,
    update: n,
    dispose: i
  };
}
function l4(r, t) {
  return r.groupOrder !== t.groupOrder ? r.groupOrder - t.groupOrder : r.renderOrder !== t.renderOrder ? r.renderOrder - t.renderOrder : r.material.id !== t.material.id ? r.material.id - t.material.id : r.z !== t.z ? r.z - t.z : r.id - t.id;
}
function oT(r, t) {
  return r.groupOrder !== t.groupOrder ? r.groupOrder - t.groupOrder : r.renderOrder !== t.renderOrder ? r.renderOrder - t.renderOrder : r.z !== t.z ? t.z - r.z : r.id - t.id;
}
function sT() {
  const r = [];
  let t = 0;
  const e = [], n = [], i = [];
  function a() {
    t = 0, e.length = 0, n.length = 0, i.length = 0;
  }
  function o(f, h, d, p, g, v) {
    let m = r[t];
    return m === void 0 ? (m = {
      id: f.id,
      object: f,
      geometry: h,
      material: d,
      groupOrder: p,
      renderOrder: f.renderOrder,
      z: g,
      group: v
    }, r[t] = m) : (m.id = f.id, m.object = f, m.geometry = h, m.material = d, m.groupOrder = p, m.renderOrder = f.renderOrder, m.z = g, m.group = v), t++, m;
  }
  function s(f, h, d, p, g, v) {
    const m = o(f, h, d, p, g, v);
    d.transmission > 0 ? n.push(m) : d.transparent === !0 ? i.push(m) : e.push(m);
  }
  function l(f, h, d, p, g, v) {
    const m = o(f, h, d, p, g, v);
    d.transmission > 0 ? n.unshift(m) : d.transparent === !0 ? i.unshift(m) : e.unshift(m);
  }
  function u(f, h) {
    e.length > 1 && e.sort(f || l4), n.length > 1 && n.sort(h || oT), i.length > 1 && i.sort(h || oT);
  }
  function c() {
    for (let f = t, h = r.length; f < h; f++) {
      const d = r[f];
      if (d.id === null)
        break;
      d.id = null, d.object = null, d.geometry = null, d.material = null, d.group = null;
    }
  }
  return {
    opaque: e,
    transmissive: n,
    transparent: i,
    init: a,
    push: s,
    unshift: l,
    finish: c,
    sort: u
  };
}
function u4() {
  let r = /* @__PURE__ */ new WeakMap();
  function t(n, i) {
    const a = r.get(n);
    let o;
    return a === void 0 ? (o = new sT(), r.set(n, [o])) : i >= a.length ? (o = new sT(), a.push(o)) : o = a[i], o;
  }
  function e() {
    r = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: t,
    dispose: e
  };
}
function c4() {
  const r = {};
  return {
    get: function(t) {
      if (r[t.id] !== void 0)
        return r[t.id];
      let e;
      switch (t.type) {
        case "DirectionalLight":
          e = {
            direction: new j(),
            color: new le()
          };
          break;
        case "SpotLight":
          e = {
            position: new j(),
            direction: new j(),
            color: new le(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          e = {
            position: new j(),
            color: new le(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          e = {
            direction: new j(),
            skyColor: new le(),
            groundColor: new le()
          };
          break;
        case "RectAreaLight":
          e = {
            color: new le(),
            position: new j(),
            halfWidth: new j(),
            halfHeight: new j()
          };
          break;
      }
      return r[t.id] = e, e;
    }
  };
}
function f4() {
  const r = {};
  return {
    get: function(t) {
      if (r[t.id] !== void 0)
        return r[t.id];
      let e;
      switch (t.type) {
        case "DirectionalLight":
          e = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ce()
          };
          break;
        case "SpotLight":
          e = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ce()
          };
          break;
        case "PointLight":
          e = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ce(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return r[t.id] = e, e;
    }
  };
}
let h4 = 0;
function d4(r, t) {
  return (t.castShadow ? 2 : 0) - (r.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (r.map ? 1 : 0);
}
function p4(r) {
  const t = new c4(), e = f4(), n = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1,
      numLightProbes: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0,
    numLightProbes: 0
  };
  for (let u = 0; u < 9; u++)
    n.probe.push(new j());
  const i = new j(), a = new Ye(), o = new Ye();
  function s(u, c) {
    let f = 0, h = 0, d = 0;
    for (let E = 0; E < 9; E++)
      n.probe[E].set(0, 0, 0);
    let p = 0, g = 0, v = 0, m = 0, y = 0, _ = 0, x = 0, b = 0, S = 0, w = 0, A = 0;
    u.sort(d4);
    const T = c === !0 ? Math.PI : 1;
    for (let E = 0, R = u.length; E < R; E++) {
      const C = u[E], D = C.color, I = C.intensity, P = C.distance, O = C.shadow && C.shadow.map ? C.shadow.map.texture : null;
      if (C.isAmbientLight)
        f += D.r * I * T, h += D.g * I * T, d += D.b * I * T;
      else if (C.isLightProbe) {
        for (let N = 0; N < 9; N++)
          n.probe[N].addScaledVector(C.sh.coefficients[N], I);
        A++;
      } else if (C.isDirectionalLight) {
        const N = t.get(C);
        if (N.color.copy(C.color).multiplyScalar(C.intensity * T), C.castShadow) {
          const B = C.shadow, F = e.get(C);
          F.shadowBias = B.bias, F.shadowNormalBias = B.normalBias, F.shadowRadius = B.radius, F.shadowMapSize = B.mapSize, n.directionalShadow[p] = F, n.directionalShadowMap[p] = O, n.directionalShadowMatrix[p] = C.shadow.matrix, _++;
        }
        n.directional[p] = N, p++;
      } else if (C.isSpotLight) {
        const N = t.get(C);
        N.position.setFromMatrixPosition(C.matrixWorld), N.color.copy(D).multiplyScalar(I * T), N.distance = P, N.coneCos = Math.cos(C.angle), N.penumbraCos = Math.cos(C.angle * (1 - C.penumbra)), N.decay = C.decay, n.spot[v] = N;
        const B = C.shadow;
        if (C.map && (n.spotLightMap[S] = C.map, S++, B.updateMatrices(C), C.castShadow && w++), n.spotLightMatrix[v] = B.matrix, C.castShadow) {
          const F = e.get(C);
          F.shadowBias = B.bias, F.shadowNormalBias = B.normalBias, F.shadowRadius = B.radius, F.shadowMapSize = B.mapSize, n.spotShadow[v] = F, n.spotShadowMap[v] = O, b++;
        }
        v++;
      } else if (C.isRectAreaLight) {
        const N = t.get(C);
        N.color.copy(D).multiplyScalar(I), N.halfWidth.set(C.width * 0.5, 0, 0), N.halfHeight.set(0, C.height * 0.5, 0), n.rectArea[m] = N, m++;
      } else if (C.isPointLight) {
        const N = t.get(C);
        if (N.color.copy(C.color).multiplyScalar(C.intensity * T), N.distance = C.distance, N.decay = C.decay, C.castShadow) {
          const B = C.shadow, F = e.get(C);
          F.shadowBias = B.bias, F.shadowNormalBias = B.normalBias, F.shadowRadius = B.radius, F.shadowMapSize = B.mapSize, F.shadowCameraNear = B.camera.near, F.shadowCameraFar = B.camera.far, n.pointShadow[g] = F, n.pointShadowMap[g] = O, n.pointShadowMatrix[g] = C.shadow.matrix, x++;
        }
        n.point[g] = N, g++;
      } else if (C.isHemisphereLight) {
        const N = t.get(C);
        N.skyColor.copy(C.color).multiplyScalar(I * T), N.groundColor.copy(C.groundColor).multiplyScalar(I * T), n.hemi[y] = N, y++;
      }
    }
    m > 0 && (r.has("OES_texture_float_linear") === !0 ? (n.rectAreaLTC1 = At.LTC_FLOAT_1, n.rectAreaLTC2 = At.LTC_FLOAT_2) : (n.rectAreaLTC1 = At.LTC_HALF_1, n.rectAreaLTC2 = At.LTC_HALF_2)), n.ambient[0] = f, n.ambient[1] = h, n.ambient[2] = d;
    const M = n.hash;
    (M.directionalLength !== p || M.pointLength !== g || M.spotLength !== v || M.rectAreaLength !== m || M.hemiLength !== y || M.numDirectionalShadows !== _ || M.numPointShadows !== x || M.numSpotShadows !== b || M.numSpotMaps !== S || M.numLightProbes !== A) && (n.directional.length = p, n.spot.length = v, n.rectArea.length = m, n.point.length = g, n.hemi.length = y, n.directionalShadow.length = _, n.directionalShadowMap.length = _, n.pointShadow.length = x, n.pointShadowMap.length = x, n.spotShadow.length = b, n.spotShadowMap.length = b, n.directionalShadowMatrix.length = _, n.pointShadowMatrix.length = x, n.spotLightMatrix.length = b + S - w, n.spotLightMap.length = S, n.numSpotLightShadowsWithMaps = w, n.numLightProbes = A, M.directionalLength = p, M.pointLength = g, M.spotLength = v, M.rectAreaLength = m, M.hemiLength = y, M.numDirectionalShadows = _, M.numPointShadows = x, M.numSpotShadows = b, M.numSpotMaps = S, M.numLightProbes = A, n.version = h4++);
  }
  function l(u, c) {
    let f = 0, h = 0, d = 0, p = 0, g = 0;
    const v = c.matrixWorldInverse;
    for (let m = 0, y = u.length; m < y; m++) {
      const _ = u[m];
      if (_.isDirectionalLight) {
        const x = n.directional[f];
        x.direction.setFromMatrixPosition(_.matrixWorld), i.setFromMatrixPosition(_.target.matrixWorld), x.direction.sub(i), x.direction.transformDirection(v), f++;
      } else if (_.isSpotLight) {
        const x = n.spot[d];
        x.position.setFromMatrixPosition(_.matrixWorld), x.position.applyMatrix4(v), x.direction.setFromMatrixPosition(_.matrixWorld), i.setFromMatrixPosition(_.target.matrixWorld), x.direction.sub(i), x.direction.transformDirection(v), d++;
      } else if (_.isRectAreaLight) {
        const x = n.rectArea[p];
        x.position.setFromMatrixPosition(_.matrixWorld), x.position.applyMatrix4(v), o.identity(), a.copy(_.matrixWorld), a.premultiply(v), o.extractRotation(a), x.halfWidth.set(_.width * 0.5, 0, 0), x.halfHeight.set(0, _.height * 0.5, 0), x.halfWidth.applyMatrix4(o), x.halfHeight.applyMatrix4(o), p++;
      } else if (_.isPointLight) {
        const x = n.point[h];
        x.position.setFromMatrixPosition(_.matrixWorld), x.position.applyMatrix4(v), h++;
      } else if (_.isHemisphereLight) {
        const x = n.hemi[g];
        x.direction.setFromMatrixPosition(_.matrixWorld), x.direction.transformDirection(v), g++;
      }
    }
  }
  return {
    setup: s,
    setupView: l,
    state: n
  };
}
function lT(r) {
  const t = new p4(r), e = [], n = [];
  function i(c) {
    u.camera = c, e.length = 0, n.length = 0;
  }
  function a(c) {
    e.push(c);
  }
  function o(c) {
    n.push(c);
  }
  function s(c) {
    t.setup(e, c);
  }
  function l(c) {
    t.setupView(e, c);
  }
  const u = {
    lightsArray: e,
    shadowsArray: n,
    camera: null,
    lights: t,
    transmissionRenderTarget: {}
  };
  return {
    init: i,
    state: u,
    setupLights: s,
    setupLightsView: l,
    pushLight: a,
    pushShadow: o
  };
}
function v4(r) {
  let t = /* @__PURE__ */ new WeakMap();
  function e(i, a = 0) {
    const o = t.get(i);
    let s;
    return o === void 0 ? (s = new lT(r), t.set(i, [s])) : a >= o.length ? (s = new lT(r), o.push(s)) : s = o[a], s;
  }
  function n() {
    t = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    dispose: n
  };
}
class g4 extends Ih {
  constructor(t) {
    super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = dz, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this;
  }
}
class m4 extends Ih {
  constructor(t) {
    super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this;
  }
}
const y4 = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, _4 = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function x4(r, t, e) {
  let n = new p1();
  const i = new Ce(), a = new Ce(), o = new Pr(), s = new g4({ depthPacking: pz }), l = new m4(), u = {}, c = e.maxTextureSize, f = { [Vo]: Sn, [Sn]: Vo, [Ta]: Ta }, h = new Fa({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Ce() },
      radius: { value: 4 }
    },
    vertexShader: y4,
    fragmentShader: _4
  }), d = h.clone();
  d.defines.HORIZONTAL_PASS = 1;
  const p = new ua();
  p.setAttribute(
    "position",
    new ri(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const g = new In(p, h), v = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = lI;
  let m = this.type;
  this.render = function(S, w, A) {
    if (v.enabled === !1 || v.autoUpdate === !1 && v.needsUpdate === !1 || S.length === 0)
      return;
    const T = r.getRenderTarget(), M = r.getActiveCubeFace(), E = r.getActiveMipmapLevel(), R = r.state;
    R.setBlending(Lo), R.buffers.color.setClear(1, 1, 1, 1), R.buffers.depth.setTest(!0), R.setScissorTest(!1);
    const C = m !== ba && this.type === ba, D = m === ba && this.type !== ba;
    for (let I = 0, P = S.length; I < P; I++) {
      const O = S[I], N = O.shadow;
      if (N === void 0) {
        console.warn("THREE.WebGLShadowMap:", O, "has no shadow.");
        continue;
      }
      if (N.autoUpdate === !1 && N.needsUpdate === !1)
        continue;
      i.copy(N.mapSize);
      const B = N.getFrameExtents();
      if (i.multiply(B), a.copy(N.mapSize), (i.x > c || i.y > c) && (i.x > c && (a.x = Math.floor(c / B.x), i.x = a.x * B.x, N.mapSize.x = a.x), i.y > c && (a.y = Math.floor(c / B.y), i.y = a.y * B.y, N.mapSize.y = a.y)), N.map === null || C === !0 || D === !0) {
        const G = this.type !== ba ? { minFilter: xn, magFilter: xn } : {};
        N.map !== null && N.map.dispose(), N.map = new cl(i.x, i.y, G), N.map.texture.name = O.name + ".shadowMap", N.camera.updateProjectionMatrix();
      }
      r.setRenderTarget(N.map), r.clear();
      const F = N.getViewportCount();
      for (let G = 0; G < F; G++) {
        const X = N.getViewport(G);
        o.set(
          a.x * X.x,
          a.y * X.y,
          a.x * X.z,
          a.y * X.w
        ), R.viewport(o), N.updateMatrices(O, G), n = N.getFrustum(), x(w, A, N.camera, O, this.type);
      }
      N.isPointLightShadow !== !0 && this.type === ba && y(N, A), N.needsUpdate = !1;
    }
    m = this.type, v.needsUpdate = !1, r.setRenderTarget(T, M, E);
  };
  function y(S, w) {
    const A = t.update(g);
    h.defines.VSM_SAMPLES !== S.blurSamples && (h.defines.VSM_SAMPLES = S.blurSamples, d.defines.VSM_SAMPLES = S.blurSamples, h.needsUpdate = !0, d.needsUpdate = !0), S.mapPass === null && (S.mapPass = new cl(i.x, i.y)), h.uniforms.shadow_pass.value = S.map.texture, h.uniforms.resolution.value = S.mapSize, h.uniforms.radius.value = S.radius, r.setRenderTarget(S.mapPass), r.clear(), r.renderBufferDirect(w, null, A, h, g, null), d.uniforms.shadow_pass.value = S.mapPass.texture, d.uniforms.resolution.value = S.mapSize, d.uniforms.radius.value = S.radius, r.setRenderTarget(S.map), r.clear(), r.renderBufferDirect(w, null, A, d, g, null);
  }
  function _(S, w, A, T) {
    let M = null;
    const E = A.isPointLight === !0 ? S.customDistanceMaterial : S.customDepthMaterial;
    if (E !== void 0)
      M = E;
    else if (M = A.isPointLight === !0 ? l : s, r.localClippingEnabled && w.clipShadows === !0 && Array.isArray(w.clippingPlanes) && w.clippingPlanes.length !== 0 || w.displacementMap && w.displacementScale !== 0 || w.alphaMap && w.alphaTest > 0 || w.map && w.alphaTest > 0) {
      const R = M.uuid, C = w.uuid;
      let D = u[R];
      D === void 0 && (D = {}, u[R] = D);
      let I = D[C];
      I === void 0 && (I = M.clone(), D[C] = I, w.addEventListener("dispose", b)), M = I;
    }
    if (M.visible = w.visible, M.wireframe = w.wireframe, T === ba ? M.side = w.shadowSide !== null ? w.shadowSide : w.side : M.side = w.shadowSide !== null ? w.shadowSide : f[w.side], M.alphaMap = w.alphaMap, M.alphaTest = w.alphaTest, M.map = w.map, M.clipShadows = w.clipShadows, M.clippingPlanes = w.clippingPlanes, M.clipIntersection = w.clipIntersection, M.displacementMap = w.displacementMap, M.displacementScale = w.displacementScale, M.displacementBias = w.displacementBias, M.wireframeLinewidth = w.wireframeLinewidth, M.linewidth = w.linewidth, A.isPointLight === !0 && M.isMeshDistanceMaterial === !0) {
      const R = r.properties.get(M);
      R.light = A;
    }
    return M;
  }
  function x(S, w, A, T, M) {
    if (S.visible === !1)
      return;
    if (S.layers.test(w.layers) && (S.isMesh || S.isLine || S.isPoints) && (S.castShadow || S.receiveShadow && M === ba) && (!S.frustumCulled || n.intersectsObject(S))) {
      S.modelViewMatrix.multiplyMatrices(A.matrixWorldInverse, S.matrixWorld);
      const C = t.update(S), D = S.material;
      if (Array.isArray(D)) {
        const I = C.groups;
        for (let P = 0, O = I.length; P < O; P++) {
          const N = I[P], B = D[N.materialIndex];
          if (B && B.visible) {
            const F = _(S, B, T, M);
            S.onBeforeShadow(r, S, w, A, C, F, N), r.renderBufferDirect(A, null, C, F, S, N), S.onAfterShadow(r, S, w, A, C, F, N);
          }
        }
      } else if (D.visible) {
        const I = _(S, D, T, M);
        S.onBeforeShadow(r, S, w, A, C, I, null), r.renderBufferDirect(A, null, C, I, S, null), S.onAfterShadow(r, S, w, A, C, I, null);
      }
    }
    const R = S.children;
    for (let C = 0, D = R.length; C < D; C++)
      x(R[C], w, A, T, M);
  }
  function b(S) {
    S.target.removeEventListener("dispose", b);
    for (const A in u) {
      const T = u[A], M = S.target.uuid;
      M in T && (T[M].dispose(), delete T[M]);
    }
  }
}
function S4(r) {
  function t() {
    let Z = !1;
    const vt = new Pr();
    let ft = null;
    const Rt = new Pr(0, 0, 0, 0);
    return {
      setMask: function(Ut) {
        ft !== Ut && !Z && (r.colorMask(Ut, Ut, Ut, Ut), ft = Ut);
      },
      setLocked: function(Ut) {
        Z = Ut;
      },
      setClear: function(Ut, Le, $e, je, Gr) {
        Gr === !0 && (Ut *= je, Le *= je, $e *= je), vt.set(Ut, Le, $e, je), Rt.equals(vt) === !1 && (r.clearColor(Ut, Le, $e, je), Rt.copy(vt));
      },
      reset: function() {
        Z = !1, ft = null, Rt.set(-1, 0, 0, 0);
      }
    };
  }
  function e() {
    let Z = !1, vt = null, ft = null, Rt = null;
    return {
      setTest: function(Ut) {
        Ut ? ct(r.DEPTH_TEST) : at(r.DEPTH_TEST);
      },
      setMask: function(Ut) {
        vt !== Ut && !Z && (r.depthMask(Ut), vt = Ut);
      },
      setFunc: function(Ut) {
        if (ft !== Ut) {
          switch (Ut) {
            case UF:
              r.depthFunc(r.NEVER);
              break;
            case GF:
              r.depthFunc(r.ALWAYS);
              break;
            case HF:
              r.depthFunc(r.LESS);
              break;
            case uv:
              r.depthFunc(r.LEQUAL);
              break;
            case WF:
              r.depthFunc(r.EQUAL);
              break;
            case XF:
              r.depthFunc(r.GEQUAL);
              break;
            case YF:
              r.depthFunc(r.GREATER);
              break;
            case $F:
              r.depthFunc(r.NOTEQUAL);
              break;
            default:
              r.depthFunc(r.LEQUAL);
          }
          ft = Ut;
        }
      },
      setLocked: function(Ut) {
        Z = Ut;
      },
      setClear: function(Ut) {
        Rt !== Ut && (r.clearDepth(Ut), Rt = Ut);
      },
      reset: function() {
        Z = !1, vt = null, ft = null, Rt = null;
      }
    };
  }
  function n() {
    let Z = !1, vt = null, ft = null, Rt = null, Ut = null, Le = null, $e = null, je = null, Gr = null;
    return {
      setTest: function(Be) {
        Z || (Be ? ct(r.STENCIL_TEST) : at(r.STENCIL_TEST));
      },
      setMask: function(Be) {
        vt !== Be && !Z && (r.stencilMask(Be), vt = Be);
      },
      setFunc: function(Be, Ei, Jr) {
        (ft !== Be || Rt !== Ei || Ut !== Jr) && (r.stencilFunc(Be, Ei, Jr), ft = Be, Rt = Ei, Ut = Jr);
      },
      setOp: function(Be, Ei, Jr) {
        (Le !== Be || $e !== Ei || je !== Jr) && (r.stencilOp(Be, Ei, Jr), Le = Be, $e = Ei, je = Jr);
      },
      setLocked: function(Be) {
        Z = Be;
      },
      setClear: function(Be) {
        Gr !== Be && (r.clearStencil(Be), Gr = Be);
      },
      reset: function() {
        Z = !1, vt = null, ft = null, Rt = null, Ut = null, Le = null, $e = null, je = null, Gr = null;
      }
    };
  }
  const i = new t(), a = new e(), o = new n(), s = /* @__PURE__ */ new WeakMap(), l = /* @__PURE__ */ new WeakMap();
  let u = {}, c = {}, f = /* @__PURE__ */ new WeakMap(), h = [], d = null, p = !1, g = null, v = null, m = null, y = null, _ = null, x = null, b = null, S = new le(0, 0, 0), w = 0, A = !1, T = null, M = null, E = null, R = null, C = null;
  const D = r.getParameter(r.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let I = !1, P = 0;
  const O = r.getParameter(r.VERSION);
  O.indexOf("WebGL") !== -1 ? (P = parseFloat(/^WebGL (\d)/.exec(O)[1]), I = P >= 1) : O.indexOf("OpenGL ES") !== -1 && (P = parseFloat(/^OpenGL ES (\d)/.exec(O)[1]), I = P >= 2);
  let N = null, B = {};
  const F = r.getParameter(r.SCISSOR_BOX), G = r.getParameter(r.VIEWPORT), X = new Pr().fromArray(F), K = new Pr().fromArray(G);
  function U(Z, vt, ft, Rt) {
    const Ut = new Uint8Array(4), Le = r.createTexture();
    r.bindTexture(Z, Le), r.texParameteri(Z, r.TEXTURE_MIN_FILTER, r.NEAREST), r.texParameteri(Z, r.TEXTURE_MAG_FILTER, r.NEAREST);
    for (let $e = 0; $e < ft; $e++)
      Z === r.TEXTURE_3D || Z === r.TEXTURE_2D_ARRAY ? r.texImage3D(vt, 0, r.RGBA, 1, 1, Rt, 0, r.RGBA, r.UNSIGNED_BYTE, Ut) : r.texImage2D(vt + $e, 0, r.RGBA, 1, 1, 0, r.RGBA, r.UNSIGNED_BYTE, Ut);
    return Le;
  }
  const $ = {};
  $[r.TEXTURE_2D] = U(r.TEXTURE_2D, r.TEXTURE_2D, 1), $[r.TEXTURE_CUBE_MAP] = U(r.TEXTURE_CUBE_MAP, r.TEXTURE_CUBE_MAP_POSITIVE_X, 6), $[r.TEXTURE_2D_ARRAY] = U(r.TEXTURE_2D_ARRAY, r.TEXTURE_2D_ARRAY, 1, 1), $[r.TEXTURE_3D] = U(r.TEXTURE_3D, r.TEXTURE_3D, 1, 1), i.setClear(0, 0, 0, 1), a.setClear(1), o.setClear(0), ct(r.DEPTH_TEST), a.setFunc(uv), Lt(!1), Vt(Hw), ct(r.CULL_FACE), Gt(Lo);
  function ct(Z) {
    u[Z] !== !0 && (r.enable(Z), u[Z] = !0);
  }
  function at(Z) {
    u[Z] !== !1 && (r.disable(Z), u[Z] = !1);
  }
  function lt(Z, vt) {
    return c[Z] !== vt ? (r.bindFramebuffer(Z, vt), c[Z] = vt, Z === r.DRAW_FRAMEBUFFER && (c[r.FRAMEBUFFER] = vt), Z === r.FRAMEBUFFER && (c[r.DRAW_FRAMEBUFFER] = vt), !0) : !1;
  }
  function ot(Z, vt) {
    let ft = h, Rt = !1;
    if (Z) {
      ft = f.get(vt), ft === void 0 && (ft = [], f.set(vt, ft));
      const Ut = Z.textures;
      if (ft.length !== Ut.length || ft[0] !== r.COLOR_ATTACHMENT0) {
        for (let Le = 0, $e = Ut.length; Le < $e; Le++)
          ft[Le] = r.COLOR_ATTACHMENT0 + Le;
        ft.length = Ut.length, Rt = !0;
      }
    } else
      ft[0] !== r.BACK && (ft[0] = r.BACK, Rt = !0);
    Rt && r.drawBuffers(ft);
  }
  function H(Z) {
    return d !== Z ? (r.useProgram(Z), d = Z, !0) : !1;
  }
  const st = {
    [zs]: r.FUNC_ADD,
    [MF]: r.FUNC_SUBTRACT,
    [TF]: r.FUNC_REVERSE_SUBTRACT
  };
  st[AF] = r.MIN, st[EF] = r.MAX;
  const ut = {
    [CF]: r.ZERO,
    [DF]: r.ONE,
    [LF]: r.SRC_COLOR,
    [F_]: r.SRC_ALPHA,
    [kF]: r.SRC_ALPHA_SATURATE,
    [NF]: r.DST_COLOR,
    [IF]: r.DST_ALPHA,
    [RF]: r.ONE_MINUS_SRC_COLOR,
    [z_]: r.ONE_MINUS_SRC_ALPHA,
    [OF]: r.ONE_MINUS_DST_COLOR,
    [PF]: r.ONE_MINUS_DST_ALPHA,
    [BF]: r.CONSTANT_COLOR,
    [VF]: r.ONE_MINUS_CONSTANT_COLOR,
    [FF]: r.CONSTANT_ALPHA,
    [zF]: r.ONE_MINUS_CONSTANT_ALPHA
  };
  function Gt(Z, vt, ft, Rt, Ut, Le, $e, je, Gr, Be) {
    if (Z === Lo) {
      p === !0 && (at(r.BLEND), p = !1);
      return;
    }
    if (p === !1 && (ct(r.BLEND), p = !0), Z !== wF) {
      if (Z !== g || Be !== A) {
        if ((v !== zs || _ !== zs) && (r.blendEquation(r.FUNC_ADD), v = zs, _ = zs), Be)
          switch (Z) {
            case zu:
              r.blendFuncSeparate(r.ONE, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
              break;
            case Ww:
              r.blendFunc(r.ONE, r.ONE);
              break;
            case Xw:
              r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
              break;
            case Yw:
              r.blendFuncSeparate(r.ZERO, r.SRC_COLOR, r.ZERO, r.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", Z);
              break;
          }
        else
          switch (Z) {
            case zu:
              r.blendFuncSeparate(r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
              break;
            case Ww:
              r.blendFunc(r.SRC_ALPHA, r.ONE);
              break;
            case Xw:
              r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
              break;
            case Yw:
              r.blendFunc(r.ZERO, r.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", Z);
              break;
          }
        m = null, y = null, x = null, b = null, S.set(0, 0, 0), w = 0, g = Z, A = Be;
      }
      return;
    }
    Ut = Ut || vt, Le = Le || ft, $e = $e || Rt, (vt !== v || Ut !== _) && (r.blendEquationSeparate(st[vt], st[Ut]), v = vt, _ = Ut), (ft !== m || Rt !== y || Le !== x || $e !== b) && (r.blendFuncSeparate(ut[ft], ut[Rt], ut[Le], ut[$e]), m = ft, y = Rt, x = Le, b = $e), (je.equals(S) === !1 || Gr !== w) && (r.blendColor(je.r, je.g, je.b, Gr), S.copy(je), w = Gr), g = Z, A = !1;
  }
  function gt(Z, vt) {
    Z.side === Ta ? at(r.CULL_FACE) : ct(r.CULL_FACE);
    let ft = Z.side === Sn;
    vt && (ft = !ft), Lt(ft), Z.blending === zu && Z.transparent === !1 ? Gt(Lo) : Gt(Z.blending, Z.blendEquation, Z.blendSrc, Z.blendDst, Z.blendEquationAlpha, Z.blendSrcAlpha, Z.blendDstAlpha, Z.blendColor, Z.blendAlpha, Z.premultipliedAlpha), a.setFunc(Z.depthFunc), a.setTest(Z.depthTest), a.setMask(Z.depthWrite), i.setMask(Z.colorWrite);
    const Rt = Z.stencilWrite;
    o.setTest(Rt), Rt && (o.setMask(Z.stencilWriteMask), o.setFunc(Z.stencilFunc, Z.stencilRef, Z.stencilFuncMask), o.setOp(Z.stencilFail, Z.stencilZFail, Z.stencilZPass)), Ae(Z.polygonOffset, Z.polygonOffsetFactor, Z.polygonOffsetUnits), Z.alphaToCoverage === !0 ? ct(r.SAMPLE_ALPHA_TO_COVERAGE) : at(r.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function Lt(Z) {
    T !== Z && (Z ? r.frontFace(r.CW) : r.frontFace(r.CCW), T = Z);
  }
  function Vt(Z) {
    Z !== xF ? (ct(r.CULL_FACE), Z !== M && (Z === Hw ? r.cullFace(r.BACK) : Z === SF ? r.cullFace(r.FRONT) : r.cullFace(r.FRONT_AND_BACK))) : at(r.CULL_FACE), M = Z;
  }
  function Kt(Z) {
    Z !== E && (I && r.lineWidth(Z), E = Z);
  }
  function Ae(Z, vt, ft) {
    Z ? (ct(r.POLYGON_OFFSET_FILL), (R !== vt || C !== ft) && (r.polygonOffset(vt, ft), R = vt, C = ft)) : at(r.POLYGON_OFFSET_FILL);
  }
  function z(Z) {
    Z ? ct(r.SCISSOR_TEST) : at(r.SCISSOR_TEST);
  }
  function k(Z) {
    Z === void 0 && (Z = r.TEXTURE0 + D - 1), N !== Z && (r.activeTexture(Z), N = Z);
  }
  function nt(Z, vt, ft) {
    ft === void 0 && (N === null ? ft = r.TEXTURE0 + D - 1 : ft = N);
    let Rt = B[ft];
    Rt === void 0 && (Rt = { type: void 0, texture: void 0 }, B[ft] = Rt), (Rt.type !== Z || Rt.texture !== vt) && (N !== ft && (r.activeTexture(ft), N = ft), r.bindTexture(Z, vt || $[Z]), Rt.type = Z, Rt.texture = vt);
  }
  function ht() {
    const Z = B[N];
    Z !== void 0 && Z.type !== void 0 && (r.bindTexture(Z.type, null), Z.type = void 0, Z.texture = void 0);
  }
  function yt() {
    try {
      r.compressedTexImage2D.apply(r, arguments);
    } catch (Z) {
      console.error("THREE.WebGLState:", Z);
    }
  }
  function xt() {
    try {
      r.compressedTexImage3D.apply(r, arguments);
    } catch (Z) {
      console.error("THREE.WebGLState:", Z);
    }
  }
  function Qt() {
    try {
      r.texSubImage2D.apply(r, arguments);
    } catch (Z) {
      console.error("THREE.WebGLState:", Z);
    }
  }
  function Ft() {
    try {
      r.texSubImage3D.apply(r, arguments);
    } catch (Z) {
      console.error("THREE.WebGLState:", Z);
    }
  }
  function Ot() {
    try {
      r.compressedTexSubImage2D.apply(r, arguments);
    } catch (Z) {
      console.error("THREE.WebGLState:", Z);
    }
  }
  function _e() {
    try {
      r.compressedTexSubImage3D.apply(r, arguments);
    } catch (Z) {
      console.error("THREE.WebGLState:", Z);
    }
  }
  function Mt() {
    try {
      r.texStorage2D.apply(r, arguments);
    } catch (Z) {
      console.error("THREE.WebGLState:", Z);
    }
  }
  function Jt() {
    try {
      r.texStorage3D.apply(r, arguments);
    } catch (Z) {
      console.error("THREE.WebGLState:", Z);
    }
  }
  function De() {
    try {
      r.texImage2D.apply(r, arguments);
    } catch (Z) {
      console.error("THREE.WebGLState:", Z);
    }
  }
  function ie() {
    try {
      r.texImage3D.apply(r, arguments);
    } catch (Z) {
      console.error("THREE.WebGLState:", Z);
    }
  }
  function Ht(Z) {
    X.equals(Z) === !1 && (r.scissor(Z.x, Z.y, Z.z, Z.w), X.copy(Z));
  }
  function xe(Z) {
    K.equals(Z) === !1 && (r.viewport(Z.x, Z.y, Z.z, Z.w), K.copy(Z));
  }
  function Ee(Z, vt) {
    let ft = l.get(vt);
    ft === void 0 && (ft = /* @__PURE__ */ new WeakMap(), l.set(vt, ft));
    let Rt = ft.get(Z);
    Rt === void 0 && (Rt = r.getUniformBlockIndex(vt, Z.name), ft.set(Z, Rt));
  }
  function nr(Z, vt) {
    const Rt = l.get(vt).get(Z);
    s.get(vt) !== Rt && (r.uniformBlockBinding(vt, Rt, Z.__bindingPointIndex), s.set(vt, Rt));
  }
  function Se() {
    r.disable(r.BLEND), r.disable(r.CULL_FACE), r.disable(r.DEPTH_TEST), r.disable(r.POLYGON_OFFSET_FILL), r.disable(r.SCISSOR_TEST), r.disable(r.STENCIL_TEST), r.disable(r.SAMPLE_ALPHA_TO_COVERAGE), r.blendEquation(r.FUNC_ADD), r.blendFunc(r.ONE, r.ZERO), r.blendFuncSeparate(r.ONE, r.ZERO, r.ONE, r.ZERO), r.blendColor(0, 0, 0, 0), r.colorMask(!0, !0, !0, !0), r.clearColor(0, 0, 0, 0), r.depthMask(!0), r.depthFunc(r.LESS), r.clearDepth(1), r.stencilMask(4294967295), r.stencilFunc(r.ALWAYS, 0, 4294967295), r.stencilOp(r.KEEP, r.KEEP, r.KEEP), r.clearStencil(0), r.cullFace(r.BACK), r.frontFace(r.CCW), r.polygonOffset(0, 0), r.activeTexture(r.TEXTURE0), r.bindFramebuffer(r.FRAMEBUFFER, null), r.bindFramebuffer(r.DRAW_FRAMEBUFFER, null), r.bindFramebuffer(r.READ_FRAMEBUFFER, null), r.useProgram(null), r.lineWidth(1), r.scissor(0, 0, r.canvas.width, r.canvas.height), r.viewport(0, 0, r.canvas.width, r.canvas.height), u = {}, N = null, B = {}, c = {}, f = /* @__PURE__ */ new WeakMap(), h = [], d = null, p = !1, g = null, v = null, m = null, y = null, _ = null, x = null, b = null, S = new le(0, 0, 0), w = 0, A = !1, T = null, M = null, E = null, R = null, C = null, X.set(0, 0, r.canvas.width, r.canvas.height), K.set(0, 0, r.canvas.width, r.canvas.height), i.reset(), a.reset(), o.reset();
  }
  return {
    buffers: {
      color: i,
      depth: a,
      stencil: o
    },
    enable: ct,
    disable: at,
    bindFramebuffer: lt,
    drawBuffers: ot,
    useProgram: H,
    setBlending: Gt,
    setMaterial: gt,
    setFlipSided: Lt,
    setCullFace: Vt,
    setLineWidth: Kt,
    setPolygonOffset: Ae,
    setScissorTest: z,
    activeTexture: k,
    bindTexture: nt,
    unbindTexture: ht,
    compressedTexImage2D: yt,
    compressedTexImage3D: xt,
    texImage2D: De,
    texImage3D: ie,
    updateUBOMapping: Ee,
    uniformBlockBinding: nr,
    texStorage2D: Mt,
    texStorage3D: Jt,
    texSubImage2D: Qt,
    texSubImage3D: Ft,
    compressedTexSubImage2D: Ot,
    compressedTexSubImage3D: _e,
    scissor: Ht,
    viewport: xe,
    reset: Se
  };
}
function b4(r, t, e, n, i, a, o) {
  const s = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null, l = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), u = new Ce(), c = /* @__PURE__ */ new WeakMap();
  let f;
  const h = /* @__PURE__ */ new WeakMap();
  let d = !1;
  try {
    d = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function p(z, k) {
    return d ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(z, k)
    ) : pv("canvas");
  }
  function g(z, k, nt) {
    let ht = 1;
    const yt = Ae(z);
    if ((yt.width > nt || yt.height > nt) && (ht = nt / Math.max(yt.width, yt.height)), ht < 1)
      if (typeof HTMLImageElement < "u" && z instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && z instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && z instanceof ImageBitmap || typeof VideoFrame < "u" && z instanceof VideoFrame) {
        const xt = Math.floor(ht * yt.width), Qt = Math.floor(ht * yt.height);
        f === void 0 && (f = p(xt, Qt));
        const Ft = k ? p(xt, Qt) : f;
        return Ft.width = xt, Ft.height = Qt, Ft.getContext("2d").drawImage(z, 0, 0, xt, Qt), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + yt.width + "x" + yt.height + ") to (" + xt + "x" + Qt + ")."), Ft;
      } else
        return "data" in z && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + yt.width + "x" + yt.height + ")."), z;
    return z;
  }
  function v(z) {
    return z.generateMipmaps && z.minFilter !== xn && z.minFilter !== pi;
  }
  function m(z) {
    r.generateMipmap(z);
  }
  function y(z, k, nt, ht, yt = !1) {
    if (z !== null) {
      if (r[z] !== void 0)
        return r[z];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + z + "'");
    }
    let xt = k;
    if (k === r.RED && (nt === r.FLOAT && (xt = r.R32F), nt === r.HALF_FLOAT && (xt = r.R16F), nt === r.UNSIGNED_BYTE && (xt = r.R8)), k === r.RED_INTEGER && (nt === r.UNSIGNED_BYTE && (xt = r.R8UI), nt === r.UNSIGNED_SHORT && (xt = r.R16UI), nt === r.UNSIGNED_INT && (xt = r.R32UI), nt === r.BYTE && (xt = r.R8I), nt === r.SHORT && (xt = r.R16I), nt === r.INT && (xt = r.R32I)), k === r.RG && (nt === r.FLOAT && (xt = r.RG32F), nt === r.HALF_FLOAT && (xt = r.RG16F), nt === r.UNSIGNED_BYTE && (xt = r.RG8)), k === r.RG_INTEGER && (nt === r.UNSIGNED_BYTE && (xt = r.RG8UI), nt === r.UNSIGNED_SHORT && (xt = r.RG16UI), nt === r.UNSIGNED_INT && (xt = r.RG32UI), nt === r.BYTE && (xt = r.RG8I), nt === r.SHORT && (xt = r.RG16I), nt === r.INT && (xt = r.RG32I)), k === r.RGB && nt === r.UNSIGNED_INT_5_9_9_9_REV && (xt = r.RGB9_E5), k === r.RGBA) {
      const Qt = yt ? cv : Fe.getTransfer(ht);
      nt === r.FLOAT && (xt = r.RGBA32F), nt === r.HALF_FLOAT && (xt = r.RGBA16F), nt === r.UNSIGNED_BYTE && (xt = Qt === Ze ? r.SRGB8_ALPHA8 : r.RGBA8), nt === r.UNSIGNED_SHORT_4_4_4_4 && (xt = r.RGBA4), nt === r.UNSIGNED_SHORT_5_5_5_1 && (xt = r.RGB5_A1);
    }
    return (xt === r.R16F || xt === r.R32F || xt === r.RG16F || xt === r.RG32F || xt === r.RGBA16F || xt === r.RGBA32F) && t.get("EXT_color_buffer_float"), xt;
  }
  function _(z, k) {
    return v(z) === !0 || z.isFramebufferTexture && z.minFilter !== xn && z.minFilter !== pi ? Math.log2(Math.max(k.width, k.height)) + 1 : z.mipmaps !== void 0 && z.mipmaps.length > 0 ? z.mipmaps.length : z.isCompressedTexture && Array.isArray(z.image) ? k.mipmaps.length : 1;
  }
  function x(z) {
    const k = z.target;
    k.removeEventListener("dispose", x), S(k), k.isVideoTexture && c.delete(k);
  }
  function b(z) {
    const k = z.target;
    k.removeEventListener("dispose", b), A(k);
  }
  function S(z) {
    const k = n.get(z);
    if (k.__webglInit === void 0)
      return;
    const nt = z.source, ht = h.get(nt);
    if (ht) {
      const yt = ht[k.__cacheKey];
      yt.usedTimes--, yt.usedTimes === 0 && w(z), Object.keys(ht).length === 0 && h.delete(nt);
    }
    n.remove(z);
  }
  function w(z) {
    const k = n.get(z);
    r.deleteTexture(k.__webglTexture);
    const nt = z.source, ht = h.get(nt);
    delete ht[k.__cacheKey], o.memory.textures--;
  }
  function A(z) {
    const k = n.get(z);
    if (z.depthTexture && z.depthTexture.dispose(), z.isWebGLCubeRenderTarget)
      for (let ht = 0; ht < 6; ht++) {
        if (Array.isArray(k.__webglFramebuffer[ht]))
          for (let yt = 0; yt < k.__webglFramebuffer[ht].length; yt++)
            r.deleteFramebuffer(k.__webglFramebuffer[ht][yt]);
        else
          r.deleteFramebuffer(k.__webglFramebuffer[ht]);
        k.__webglDepthbuffer && r.deleteRenderbuffer(k.__webglDepthbuffer[ht]);
      }
    else {
      if (Array.isArray(k.__webglFramebuffer))
        for (let ht = 0; ht < k.__webglFramebuffer.length; ht++)
          r.deleteFramebuffer(k.__webglFramebuffer[ht]);
      else
        r.deleteFramebuffer(k.__webglFramebuffer);
      if (k.__webglDepthbuffer && r.deleteRenderbuffer(k.__webglDepthbuffer), k.__webglMultisampledFramebuffer && r.deleteFramebuffer(k.__webglMultisampledFramebuffer), k.__webglColorRenderbuffer)
        for (let ht = 0; ht < k.__webglColorRenderbuffer.length; ht++)
          k.__webglColorRenderbuffer[ht] && r.deleteRenderbuffer(k.__webglColorRenderbuffer[ht]);
      k.__webglDepthRenderbuffer && r.deleteRenderbuffer(k.__webglDepthRenderbuffer);
    }
    const nt = z.textures;
    for (let ht = 0, yt = nt.length; ht < yt; ht++) {
      const xt = n.get(nt[ht]);
      xt.__webglTexture && (r.deleteTexture(xt.__webglTexture), o.memory.textures--), n.remove(nt[ht]);
    }
    n.remove(z);
  }
  let T = 0;
  function M() {
    T = 0;
  }
  function E() {
    const z = T;
    return z >= i.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + z + " texture units while this GPU supports only " + i.maxTextures), T += 1, z;
  }
  function R(z) {
    const k = [];
    return k.push(z.wrapS), k.push(z.wrapT), k.push(z.wrapR || 0), k.push(z.magFilter), k.push(z.minFilter), k.push(z.anisotropy), k.push(z.internalFormat), k.push(z.format), k.push(z.type), k.push(z.generateMipmaps), k.push(z.premultiplyAlpha), k.push(z.flipY), k.push(z.unpackAlignment), k.push(z.colorSpace), k.join();
  }
  function C(z, k) {
    const nt = n.get(z);
    if (z.isVideoTexture && Vt(z), z.isRenderTargetTexture === !1 && z.version > 0 && nt.__version !== z.version) {
      const ht = z.image;
      if (ht === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (ht.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        X(nt, z, k);
        return;
      }
    }
    e.bindTexture(r.TEXTURE_2D, nt.__webglTexture, r.TEXTURE0 + k);
  }
  function D(z, k) {
    const nt = n.get(z);
    if (z.version > 0 && nt.__version !== z.version) {
      X(nt, z, k);
      return;
    }
    e.bindTexture(r.TEXTURE_2D_ARRAY, nt.__webglTexture, r.TEXTURE0 + k);
  }
  function I(z, k) {
    const nt = n.get(z);
    if (z.version > 0 && nt.__version !== z.version) {
      X(nt, z, k);
      return;
    }
    e.bindTexture(r.TEXTURE_3D, nt.__webglTexture, r.TEXTURE0 + k);
  }
  function P(z, k) {
    const nt = n.get(z);
    if (z.version > 0 && nt.__version !== z.version) {
      K(nt, z, k);
      return;
    }
    e.bindTexture(r.TEXTURE_CUBE_MAP, nt.__webglTexture, r.TEXTURE0 + k);
  }
  const O = {
    [H_]: r.REPEAT,
    [Ys]: r.CLAMP_TO_EDGE,
    [W_]: r.MIRRORED_REPEAT
  }, N = {
    [xn]: r.NEAREST,
    [nz]: r.NEAREST_MIPMAP_NEAREST,
    [Jh]: r.NEAREST_MIPMAP_LINEAR,
    [pi]: r.LINEAR,
    [Dm]: r.LINEAR_MIPMAP_NEAREST,
    [$s]: r.LINEAR_MIPMAP_LINEAR
  }, B = {
    [mz]: r.NEVER,
    [wz]: r.ALWAYS,
    [yz]: r.LESS,
    [_I]: r.LEQUAL,
    [_z]: r.EQUAL,
    [bz]: r.GEQUAL,
    [xz]: r.GREATER,
    [Sz]: r.NOTEQUAL
  };
  function F(z, k) {
    if (k.type === Ea && t.has("OES_texture_float_linear") === !1 && (k.magFilter === pi || k.magFilter === Dm || k.magFilter === Jh || k.magFilter === $s || k.minFilter === pi || k.minFilter === Dm || k.minFilter === Jh || k.minFilter === $s) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), r.texParameteri(z, r.TEXTURE_WRAP_S, O[k.wrapS]), r.texParameteri(z, r.TEXTURE_WRAP_T, O[k.wrapT]), (z === r.TEXTURE_3D || z === r.TEXTURE_2D_ARRAY) && r.texParameteri(z, r.TEXTURE_WRAP_R, O[k.wrapR]), r.texParameteri(z, r.TEXTURE_MAG_FILTER, N[k.magFilter]), r.texParameteri(z, r.TEXTURE_MIN_FILTER, N[k.minFilter]), k.compareFunction && (r.texParameteri(z, r.TEXTURE_COMPARE_MODE, r.COMPARE_REF_TO_TEXTURE), r.texParameteri(z, r.TEXTURE_COMPARE_FUNC, B[k.compareFunction])), t.has("EXT_texture_filter_anisotropic") === !0) {
      if (k.magFilter === xn || k.minFilter !== Jh && k.minFilter !== $s || k.type === Ea && t.has("OES_texture_float_linear") === !1)
        return;
      if (k.anisotropy > 1 || n.get(k).__currentAnisotropy) {
        const nt = t.get("EXT_texture_filter_anisotropic");
        r.texParameterf(z, nt.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(k.anisotropy, i.getMaxAnisotropy())), n.get(k).__currentAnisotropy = k.anisotropy;
      }
    }
  }
  function G(z, k) {
    let nt = !1;
    z.__webglInit === void 0 && (z.__webglInit = !0, k.addEventListener("dispose", x));
    const ht = k.source;
    let yt = h.get(ht);
    yt === void 0 && (yt = {}, h.set(ht, yt));
    const xt = R(k);
    if (xt !== z.__cacheKey) {
      yt[xt] === void 0 && (yt[xt] = {
        texture: r.createTexture(),
        usedTimes: 0
      }, o.memory.textures++, nt = !0), yt[xt].usedTimes++;
      const Qt = yt[z.__cacheKey];
      Qt !== void 0 && (yt[z.__cacheKey].usedTimes--, Qt.usedTimes === 0 && w(k)), z.__cacheKey = xt, z.__webglTexture = yt[xt].texture;
    }
    return nt;
  }
  function X(z, k, nt) {
    let ht = r.TEXTURE_2D;
    (k.isDataArrayTexture || k.isCompressedArrayTexture) && (ht = r.TEXTURE_2D_ARRAY), k.isData3DTexture && (ht = r.TEXTURE_3D);
    const yt = G(z, k), xt = k.source;
    e.bindTexture(ht, z.__webglTexture, r.TEXTURE0 + nt);
    const Qt = n.get(xt);
    if (xt.version !== Qt.__version || yt === !0) {
      e.activeTexture(r.TEXTURE0 + nt);
      const Ft = Fe.getPrimaries(Fe.workingColorSpace), Ot = k.colorSpace === _o ? null : Fe.getPrimaries(k.colorSpace), _e = k.colorSpace === _o || Ft === Ot ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
      r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, k.flipY), r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, k.premultiplyAlpha), r.pixelStorei(r.UNPACK_ALIGNMENT, k.unpackAlignment), r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, _e);
      let Mt = g(k.image, !1, i.maxTextureSize);
      Mt = Kt(k, Mt);
      const Jt = a.convert(k.format, k.colorSpace), De = a.convert(k.type);
      let ie = y(k.internalFormat, Jt, De, k.colorSpace, k.isVideoTexture);
      F(ht, k);
      let Ht;
      const xe = k.mipmaps, Ee = k.isVideoTexture !== !0, nr = Qt.__version === void 0 || yt === !0, Se = xt.dataReady, Z = _(k, Mt);
      if (k.isDepthTexture)
        ie = r.DEPTH_COMPONENT16, k.type === Ea ? ie = r.DEPTH_COMPONENT32F : k.type === ju ? ie = r.DEPTH_COMPONENT24 : k.type === Dh && (ie = r.DEPTH24_STENCIL8), nr && (Ee ? e.texStorage2D(r.TEXTURE_2D, 1, ie, Mt.width, Mt.height) : e.texImage2D(r.TEXTURE_2D, 0, ie, Mt.width, Mt.height, 0, Jt, De, null));
      else if (k.isDataTexture)
        if (xe.length > 0) {
          Ee && nr && e.texStorage2D(r.TEXTURE_2D, Z, ie, xe[0].width, xe[0].height);
          for (let vt = 0, ft = xe.length; vt < ft; vt++)
            Ht = xe[vt], Ee ? Se && e.texSubImage2D(r.TEXTURE_2D, vt, 0, 0, Ht.width, Ht.height, Jt, De, Ht.data) : e.texImage2D(r.TEXTURE_2D, vt, ie, Ht.width, Ht.height, 0, Jt, De, Ht.data);
          k.generateMipmaps = !1;
        } else
          Ee ? (nr && e.texStorage2D(r.TEXTURE_2D, Z, ie, Mt.width, Mt.height), Se && e.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, Mt.width, Mt.height, Jt, De, Mt.data)) : e.texImage2D(r.TEXTURE_2D, 0, ie, Mt.width, Mt.height, 0, Jt, De, Mt.data);
      else if (k.isCompressedTexture)
        if (k.isCompressedArrayTexture) {
          Ee && nr && e.texStorage3D(r.TEXTURE_2D_ARRAY, Z, ie, xe[0].width, xe[0].height, Mt.depth);
          for (let vt = 0, ft = xe.length; vt < ft; vt++)
            Ht = xe[vt], k.format !== Wi ? Jt !== null ? Ee ? Se && e.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY, vt, 0, 0, 0, Ht.width, Ht.height, Mt.depth, Jt, Ht.data, 0, 0) : e.compressedTexImage3D(r.TEXTURE_2D_ARRAY, vt, ie, Ht.width, Ht.height, Mt.depth, 0, Ht.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Ee ? Se && e.texSubImage3D(r.TEXTURE_2D_ARRAY, vt, 0, 0, 0, Ht.width, Ht.height, Mt.depth, Jt, De, Ht.data) : e.texImage3D(r.TEXTURE_2D_ARRAY, vt, ie, Ht.width, Ht.height, Mt.depth, 0, Jt, De, Ht.data);
        } else {
          Ee && nr && e.texStorage2D(r.TEXTURE_2D, Z, ie, xe[0].width, xe[0].height);
          for (let vt = 0, ft = xe.length; vt < ft; vt++)
            Ht = xe[vt], k.format !== Wi ? Jt !== null ? Ee ? Se && e.compressedTexSubImage2D(r.TEXTURE_2D, vt, 0, 0, Ht.width, Ht.height, Jt, Ht.data) : e.compressedTexImage2D(r.TEXTURE_2D, vt, ie, Ht.width, Ht.height, 0, Ht.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Ee ? Se && e.texSubImage2D(r.TEXTURE_2D, vt, 0, 0, Ht.width, Ht.height, Jt, De, Ht.data) : e.texImage2D(r.TEXTURE_2D, vt, ie, Ht.width, Ht.height, 0, Jt, De, Ht.data);
        }
      else if (k.isDataArrayTexture)
        Ee ? (nr && e.texStorage3D(r.TEXTURE_2D_ARRAY, Z, ie, Mt.width, Mt.height, Mt.depth), Se && e.texSubImage3D(r.TEXTURE_2D_ARRAY, 0, 0, 0, 0, Mt.width, Mt.height, Mt.depth, Jt, De, Mt.data)) : e.texImage3D(r.TEXTURE_2D_ARRAY, 0, ie, Mt.width, Mt.height, Mt.depth, 0, Jt, De, Mt.data);
      else if (k.isData3DTexture)
        Ee ? (nr && e.texStorage3D(r.TEXTURE_3D, Z, ie, Mt.width, Mt.height, Mt.depth), Se && e.texSubImage3D(r.TEXTURE_3D, 0, 0, 0, 0, Mt.width, Mt.height, Mt.depth, Jt, De, Mt.data)) : e.texImage3D(r.TEXTURE_3D, 0, ie, Mt.width, Mt.height, Mt.depth, 0, Jt, De, Mt.data);
      else if (k.isFramebufferTexture) {
        if (nr)
          if (Ee)
            e.texStorage2D(r.TEXTURE_2D, Z, ie, Mt.width, Mt.height);
          else {
            let vt = Mt.width, ft = Mt.height;
            for (let Rt = 0; Rt < Z; Rt++)
              e.texImage2D(r.TEXTURE_2D, Rt, ie, vt, ft, 0, Jt, De, null), vt >>= 1, ft >>= 1;
          }
      } else if (xe.length > 0) {
        if (Ee && nr) {
          const vt = Ae(xe[0]);
          e.texStorage2D(r.TEXTURE_2D, Z, ie, vt.width, vt.height);
        }
        for (let vt = 0, ft = xe.length; vt < ft; vt++)
          Ht = xe[vt], Ee ? Se && e.texSubImage2D(r.TEXTURE_2D, vt, 0, 0, Jt, De, Ht) : e.texImage2D(r.TEXTURE_2D, vt, ie, Jt, De, Ht);
        k.generateMipmaps = !1;
      } else if (Ee) {
        if (nr) {
          const vt = Ae(Mt);
          e.texStorage2D(r.TEXTURE_2D, Z, ie, vt.width, vt.height);
        }
        Se && e.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, Jt, De, Mt);
      } else
        e.texImage2D(r.TEXTURE_2D, 0, ie, Jt, De, Mt);
      v(k) && m(ht), Qt.__version = xt.version, k.onUpdate && k.onUpdate(k);
    }
    z.__version = k.version;
  }
  function K(z, k, nt) {
    if (k.image.length !== 6)
      return;
    const ht = G(z, k), yt = k.source;
    e.bindTexture(r.TEXTURE_CUBE_MAP, z.__webglTexture, r.TEXTURE0 + nt);
    const xt = n.get(yt);
    if (yt.version !== xt.__version || ht === !0) {
      e.activeTexture(r.TEXTURE0 + nt);
      const Qt = Fe.getPrimaries(Fe.workingColorSpace), Ft = k.colorSpace === _o ? null : Fe.getPrimaries(k.colorSpace), Ot = k.colorSpace === _o || Qt === Ft ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
      r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, k.flipY), r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, k.premultiplyAlpha), r.pixelStorei(r.UNPACK_ALIGNMENT, k.unpackAlignment), r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ot);
      const _e = k.isCompressedTexture || k.image[0].isCompressedTexture, Mt = k.image[0] && k.image[0].isDataTexture, Jt = [];
      for (let ft = 0; ft < 6; ft++)
        !_e && !Mt ? Jt[ft] = g(k.image[ft], !0, i.maxCubemapSize) : Jt[ft] = Mt ? k.image[ft].image : k.image[ft], Jt[ft] = Kt(k, Jt[ft]);
      const De = Jt[0], ie = a.convert(k.format, k.colorSpace), Ht = a.convert(k.type), xe = y(k.internalFormat, ie, Ht, k.colorSpace), Ee = k.isVideoTexture !== !0, nr = xt.__version === void 0 || ht === !0, Se = yt.dataReady;
      let Z = _(k, De);
      F(r.TEXTURE_CUBE_MAP, k);
      let vt;
      if (_e) {
        Ee && nr && e.texStorage2D(r.TEXTURE_CUBE_MAP, Z, xe, De.width, De.height);
        for (let ft = 0; ft < 6; ft++) {
          vt = Jt[ft].mipmaps;
          for (let Rt = 0; Rt < vt.length; Rt++) {
            const Ut = vt[Rt];
            k.format !== Wi ? ie !== null ? Ee ? Se && e.compressedTexSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ft, Rt, 0, 0, Ut.width, Ut.height, ie, Ut.data) : e.compressedTexImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ft, Rt, xe, Ut.width, Ut.height, 0, Ut.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Ee ? Se && e.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ft, Rt, 0, 0, Ut.width, Ut.height, ie, Ht, Ut.data) : e.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ft, Rt, xe, Ut.width, Ut.height, 0, ie, Ht, Ut.data);
          }
        }
      } else {
        if (vt = k.mipmaps, Ee && nr) {
          vt.length > 0 && Z++;
          const ft = Ae(Jt[0]);
          e.texStorage2D(r.TEXTURE_CUBE_MAP, Z, xe, ft.width, ft.height);
        }
        for (let ft = 0; ft < 6; ft++)
          if (Mt) {
            Ee ? Se && e.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ft, 0, 0, 0, Jt[ft].width, Jt[ft].height, ie, Ht, Jt[ft].data) : e.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ft, 0, xe, Jt[ft].width, Jt[ft].height, 0, ie, Ht, Jt[ft].data);
            for (let Rt = 0; Rt < vt.length; Rt++) {
              const Le = vt[Rt].image[ft].image;
              Ee ? Se && e.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ft, Rt + 1, 0, 0, Le.width, Le.height, ie, Ht, Le.data) : e.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ft, Rt + 1, xe, Le.width, Le.height, 0, ie, Ht, Le.data);
            }
          } else {
            Ee ? Se && e.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ft, 0, 0, 0, ie, Ht, Jt[ft]) : e.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ft, 0, xe, ie, Ht, Jt[ft]);
            for (let Rt = 0; Rt < vt.length; Rt++) {
              const Ut = vt[Rt];
              Ee ? Se && e.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ft, Rt + 1, 0, 0, ie, Ht, Ut.image[ft]) : e.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + ft, Rt + 1, xe, ie, Ht, Ut.image[ft]);
            }
          }
      }
      v(k) && m(r.TEXTURE_CUBE_MAP), xt.__version = yt.version, k.onUpdate && k.onUpdate(k);
    }
    z.__version = k.version;
  }
  function U(z, k, nt, ht, yt, xt) {
    const Qt = a.convert(nt.format, nt.colorSpace), Ft = a.convert(nt.type), Ot = y(nt.internalFormat, Qt, Ft, nt.colorSpace);
    if (!n.get(k).__hasExternalTextures) {
      const Mt = Math.max(1, k.width >> xt), Jt = Math.max(1, k.height >> xt);
      yt === r.TEXTURE_3D || yt === r.TEXTURE_2D_ARRAY ? e.texImage3D(yt, xt, Ot, Mt, Jt, k.depth, 0, Qt, Ft, null) : e.texImage2D(yt, xt, Ot, Mt, Jt, 0, Qt, Ft, null);
    }
    e.bindFramebuffer(r.FRAMEBUFFER, z), Lt(k) ? s.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, ht, yt, n.get(nt).__webglTexture, 0, gt(k)) : (yt === r.TEXTURE_2D || yt >= r.TEXTURE_CUBE_MAP_POSITIVE_X && yt <= r.TEXTURE_CUBE_MAP_NEGATIVE_Z) && r.framebufferTexture2D(r.FRAMEBUFFER, ht, yt, n.get(nt).__webglTexture, xt), e.bindFramebuffer(r.FRAMEBUFFER, null);
  }
  function $(z, k, nt) {
    if (r.bindRenderbuffer(r.RENDERBUFFER, z), k.depthBuffer && !k.stencilBuffer) {
      let ht = r.DEPTH_COMPONENT24;
      if (nt || Lt(k)) {
        const yt = k.depthTexture;
        yt && yt.isDepthTexture && (yt.type === Ea ? ht = r.DEPTH_COMPONENT32F : yt.type === ju && (ht = r.DEPTH_COMPONENT24));
        const xt = gt(k);
        Lt(k) ? s.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, xt, ht, k.width, k.height) : r.renderbufferStorageMultisample(r.RENDERBUFFER, xt, ht, k.width, k.height);
      } else
        r.renderbufferStorage(r.RENDERBUFFER, ht, k.width, k.height);
      r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.RENDERBUFFER, z);
    } else if (k.depthBuffer && k.stencilBuffer) {
      const ht = gt(k);
      nt && Lt(k) === !1 ? r.renderbufferStorageMultisample(r.RENDERBUFFER, ht, r.DEPTH24_STENCIL8, k.width, k.height) : Lt(k) ? s.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, ht, r.DEPTH24_STENCIL8, k.width, k.height) : r.renderbufferStorage(r.RENDERBUFFER, r.DEPTH_STENCIL, k.width, k.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.RENDERBUFFER, z);
    } else {
      const ht = k.textures;
      for (let yt = 0; yt < ht.length; yt++) {
        const xt = ht[yt], Qt = a.convert(xt.format, xt.colorSpace), Ft = a.convert(xt.type), Ot = y(xt.internalFormat, Qt, Ft, xt.colorSpace), _e = gt(k);
        nt && Lt(k) === !1 ? r.renderbufferStorageMultisample(r.RENDERBUFFER, _e, Ot, k.width, k.height) : Lt(k) ? s.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, _e, Ot, k.width, k.height) : r.renderbufferStorage(r.RENDERBUFFER, Ot, k.width, k.height);
      }
    }
    r.bindRenderbuffer(r.RENDERBUFFER, null);
  }
  function ct(z, k) {
    if (k && k.isWebGLCubeRenderTarget)
      throw new Error("Depth Texture with cube render targets is not supported");
    if (e.bindFramebuffer(r.FRAMEBUFFER, z), !(k.depthTexture && k.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    (!n.get(k.depthTexture).__webglTexture || k.depthTexture.image.width !== k.width || k.depthTexture.image.height !== k.height) && (k.depthTexture.image.width = k.width, k.depthTexture.image.height = k.height, k.depthTexture.needsUpdate = !0), C(k.depthTexture, 0);
    const ht = n.get(k.depthTexture).__webglTexture, yt = gt(k);
    if (k.depthTexture.format === Uu)
      Lt(k) ? s.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, ht, 0, yt) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, ht, 0);
    else if (k.depthTexture.format === Qf)
      Lt(k) ? s.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, ht, 0, yt) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, ht, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function at(z) {
    const k = n.get(z), nt = z.isWebGLCubeRenderTarget === !0;
    if (z.depthTexture && !k.__autoAllocateDepthBuffer) {
      if (nt)
        throw new Error("target.depthTexture not supported in Cube render targets");
      ct(k.__webglFramebuffer, z);
    } else if (nt) {
      k.__webglDepthbuffer = [];
      for (let ht = 0; ht < 6; ht++)
        e.bindFramebuffer(r.FRAMEBUFFER, k.__webglFramebuffer[ht]), k.__webglDepthbuffer[ht] = r.createRenderbuffer(), $(k.__webglDepthbuffer[ht], z, !1);
    } else
      e.bindFramebuffer(r.FRAMEBUFFER, k.__webglFramebuffer), k.__webglDepthbuffer = r.createRenderbuffer(), $(k.__webglDepthbuffer, z, !1);
    e.bindFramebuffer(r.FRAMEBUFFER, null);
  }
  function lt(z, k, nt) {
    const ht = n.get(z);
    k !== void 0 && U(ht.__webglFramebuffer, z, z.texture, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, 0), nt !== void 0 && at(z);
  }
  function ot(z) {
    const k = z.texture, nt = n.get(z), ht = n.get(k);
    z.addEventListener("dispose", b);
    const yt = z.textures, xt = z.isWebGLCubeRenderTarget === !0, Qt = yt.length > 1;
    if (Qt || (ht.__webglTexture === void 0 && (ht.__webglTexture = r.createTexture()), ht.__version = k.version, o.memory.textures++), xt) {
      nt.__webglFramebuffer = [];
      for (let Ft = 0; Ft < 6; Ft++)
        if (k.mipmaps && k.mipmaps.length > 0) {
          nt.__webglFramebuffer[Ft] = [];
          for (let Ot = 0; Ot < k.mipmaps.length; Ot++)
            nt.__webglFramebuffer[Ft][Ot] = r.createFramebuffer();
        } else
          nt.__webglFramebuffer[Ft] = r.createFramebuffer();
    } else {
      if (k.mipmaps && k.mipmaps.length > 0) {
        nt.__webglFramebuffer = [];
        for (let Ft = 0; Ft < k.mipmaps.length; Ft++)
          nt.__webglFramebuffer[Ft] = r.createFramebuffer();
      } else
        nt.__webglFramebuffer = r.createFramebuffer();
      if (Qt)
        for (let Ft = 0, Ot = yt.length; Ft < Ot; Ft++) {
          const _e = n.get(yt[Ft]);
          _e.__webglTexture === void 0 && (_e.__webglTexture = r.createTexture(), o.memory.textures++);
        }
      if (z.samples > 0 && Lt(z) === !1) {
        nt.__webglMultisampledFramebuffer = r.createFramebuffer(), nt.__webglColorRenderbuffer = [], e.bindFramebuffer(r.FRAMEBUFFER, nt.__webglMultisampledFramebuffer);
        for (let Ft = 0; Ft < yt.length; Ft++) {
          const Ot = yt[Ft];
          nt.__webglColorRenderbuffer[Ft] = r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, nt.__webglColorRenderbuffer[Ft]);
          const _e = a.convert(Ot.format, Ot.colorSpace), Mt = a.convert(Ot.type), Jt = y(Ot.internalFormat, _e, Mt, Ot.colorSpace, z.isXRRenderTarget === !0), De = gt(z);
          r.renderbufferStorageMultisample(r.RENDERBUFFER, De, Jt, z.width, z.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + Ft, r.RENDERBUFFER, nt.__webglColorRenderbuffer[Ft]);
        }
        r.bindRenderbuffer(r.RENDERBUFFER, null), z.depthBuffer && (nt.__webglDepthRenderbuffer = r.createRenderbuffer(), $(nt.__webglDepthRenderbuffer, z, !0)), e.bindFramebuffer(r.FRAMEBUFFER, null);
      }
    }
    if (xt) {
      e.bindTexture(r.TEXTURE_CUBE_MAP, ht.__webglTexture), F(r.TEXTURE_CUBE_MAP, k);
      for (let Ft = 0; Ft < 6; Ft++)
        if (k.mipmaps && k.mipmaps.length > 0)
          for (let Ot = 0; Ot < k.mipmaps.length; Ot++)
            U(nt.__webglFramebuffer[Ft][Ot], z, k, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + Ft, Ot);
        else
          U(nt.__webglFramebuffer[Ft], z, k, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + Ft, 0);
      v(k) && m(r.TEXTURE_CUBE_MAP), e.unbindTexture();
    } else if (Qt) {
      for (let Ft = 0, Ot = yt.length; Ft < Ot; Ft++) {
        const _e = yt[Ft], Mt = n.get(_e);
        e.bindTexture(r.TEXTURE_2D, Mt.__webglTexture), F(r.TEXTURE_2D, _e), U(nt.__webglFramebuffer, z, _e, r.COLOR_ATTACHMENT0 + Ft, r.TEXTURE_2D, 0), v(_e) && m(r.TEXTURE_2D);
      }
      e.unbindTexture();
    } else {
      let Ft = r.TEXTURE_2D;
      if ((z.isWebGL3DRenderTarget || z.isWebGLArrayRenderTarget) && (Ft = z.isWebGL3DRenderTarget ? r.TEXTURE_3D : r.TEXTURE_2D_ARRAY), e.bindTexture(Ft, ht.__webglTexture), F(Ft, k), k.mipmaps && k.mipmaps.length > 0)
        for (let Ot = 0; Ot < k.mipmaps.length; Ot++)
          U(nt.__webglFramebuffer[Ot], z, k, r.COLOR_ATTACHMENT0, Ft, Ot);
      else
        U(nt.__webglFramebuffer, z, k, r.COLOR_ATTACHMENT0, Ft, 0);
      v(k) && m(Ft), e.unbindTexture();
    }
    z.depthBuffer && at(z);
  }
  function H(z) {
    const k = z.textures;
    for (let nt = 0, ht = k.length; nt < ht; nt++) {
      const yt = k[nt];
      if (v(yt)) {
        const xt = z.isWebGLCubeRenderTarget ? r.TEXTURE_CUBE_MAP : r.TEXTURE_2D, Qt = n.get(yt).__webglTexture;
        e.bindTexture(xt, Qt), m(xt), e.unbindTexture();
      }
    }
  }
  const st = [], ut = [];
  function Gt(z) {
    if (z.samples > 0) {
      if (Lt(z) === !1) {
        const k = z.textures, nt = z.width, ht = z.height;
        let yt = r.COLOR_BUFFER_BIT;
        const xt = z.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT, Qt = n.get(z), Ft = k.length > 1;
        if (Ft)
          for (let Ot = 0; Ot < k.length; Ot++)
            e.bindFramebuffer(r.FRAMEBUFFER, Qt.__webglMultisampledFramebuffer), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + Ot, r.RENDERBUFFER, null), e.bindFramebuffer(r.FRAMEBUFFER, Qt.__webglFramebuffer), r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + Ot, r.TEXTURE_2D, null, 0);
        e.bindFramebuffer(r.READ_FRAMEBUFFER, Qt.__webglMultisampledFramebuffer), e.bindFramebuffer(r.DRAW_FRAMEBUFFER, Qt.__webglFramebuffer);
        for (let Ot = 0; Ot < k.length; Ot++) {
          if (z.resolveDepthBuffer && (z.depthBuffer && (yt |= r.DEPTH_BUFFER_BIT), z.stencilBuffer && z.resolveStencilBuffer && (yt |= r.STENCIL_BUFFER_BIT)), Ft) {
            r.framebufferRenderbuffer(r.READ_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.RENDERBUFFER, Qt.__webglColorRenderbuffer[Ot]);
            const _e = n.get(k[Ot]).__webglTexture;
            r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, _e, 0);
          }
          r.blitFramebuffer(0, 0, nt, ht, 0, 0, nt, ht, yt, r.NEAREST), l === !0 && (st.length = 0, ut.length = 0, st.push(r.COLOR_ATTACHMENT0 + Ot), z.depthBuffer && z.resolveDepthBuffer === !1 && (st.push(xt), ut.push(xt), r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, ut)), r.invalidateFramebuffer(r.READ_FRAMEBUFFER, st));
        }
        if (e.bindFramebuffer(r.READ_FRAMEBUFFER, null), e.bindFramebuffer(r.DRAW_FRAMEBUFFER, null), Ft)
          for (let Ot = 0; Ot < k.length; Ot++) {
            e.bindFramebuffer(r.FRAMEBUFFER, Qt.__webglMultisampledFramebuffer), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + Ot, r.RENDERBUFFER, Qt.__webglColorRenderbuffer[Ot]);
            const _e = n.get(k[Ot]).__webglTexture;
            e.bindFramebuffer(r.FRAMEBUFFER, Qt.__webglFramebuffer), r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + Ot, r.TEXTURE_2D, _e, 0);
          }
        e.bindFramebuffer(r.DRAW_FRAMEBUFFER, Qt.__webglMultisampledFramebuffer);
      } else if (z.depthBuffer && z.resolveDepthBuffer === !1 && l) {
        const k = z.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT;
        r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, [k]);
      }
    }
  }
  function gt(z) {
    return Math.min(i.maxSamples, z.samples);
  }
  function Lt(z) {
    const k = n.get(z);
    return z.samples > 0 && t.has("WEBGL_multisampled_render_to_texture") === !0 && k.__useRenderToTexture !== !1;
  }
  function Vt(z) {
    const k = o.render.frame;
    c.get(z) !== k && (c.set(z, k), z.update());
  }
  function Kt(z, k) {
    const nt = z.colorSpace, ht = z.format, yt = z.type;
    return z.isCompressedTexture === !0 || z.isVideoTexture === !0 || nt !== Zo && nt !== _o && (Fe.getTransfer(nt) === Ze ? (ht !== Wi || yt !== Fo) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", nt)), k;
  }
  function Ae(z) {
    return typeof HTMLImageElement < "u" && z instanceof HTMLImageElement ? (u.width = z.naturalWidth || z.width, u.height = z.naturalHeight || z.height) : typeof VideoFrame < "u" && z instanceof VideoFrame ? (u.width = z.displayWidth, u.height = z.displayHeight) : (u.width = z.width, u.height = z.height), u;
  }
  this.allocateTextureUnit = E, this.resetTextureUnits = M, this.setTexture2D = C, this.setTexture2DArray = D, this.setTexture3D = I, this.setTextureCube = P, this.rebindTextures = lt, this.setupRenderTarget = ot, this.updateRenderTargetMipmap = H, this.updateMultisampleRenderTarget = Gt, this.setupDepthRenderbuffer = at, this.setupFrameBufferTexture = U, this.useMultisampledRTT = Lt;
}
function w4(r, t) {
  function e(n, i = _o) {
    let a;
    const o = Fe.getTransfer(i);
    if (n === Fo)
      return r.UNSIGNED_BYTE;
    if (n === dI)
      return r.UNSIGNED_SHORT_4_4_4_4;
    if (n === pI)
      return r.UNSIGNED_SHORT_5_5_5_1;
    if (n === oz)
      return r.UNSIGNED_INT_5_9_9_9_REV;
    if (n === iz)
      return r.BYTE;
    if (n === az)
      return r.SHORT;
    if (n === fI)
      return r.UNSIGNED_SHORT;
    if (n === hI)
      return r.INT;
    if (n === ju)
      return r.UNSIGNED_INT;
    if (n === Ea)
      return r.FLOAT;
    if (n === Pg)
      return r.HALF_FLOAT;
    if (n === sz)
      return r.ALPHA;
    if (n === lz)
      return r.RGB;
    if (n === Wi)
      return r.RGBA;
    if (n === uz)
      return r.LUMINANCE;
    if (n === cz)
      return r.LUMINANCE_ALPHA;
    if (n === Uu)
      return r.DEPTH_COMPONENT;
    if (n === Qf)
      return r.DEPTH_STENCIL;
    if (n === vI)
      return r.RED;
    if (n === gI)
      return r.RED_INTEGER;
    if (n === fz)
      return r.RG;
    if (n === mI)
      return r.RG_INTEGER;
    if (n === yI)
      return r.RGBA_INTEGER;
    if (n === Lm || n === Rm || n === Im || n === Pm)
      if (o === Ze)
        if (a = t.get("WEBGL_compressed_texture_s3tc_srgb"), a !== null) {
          if (n === Lm)
            return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (n === Rm)
            return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (n === Im)
            return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (n === Pm)
            return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (a = t.get("WEBGL_compressed_texture_s3tc"), a !== null) {
        if (n === Lm)
          return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (n === Rm)
          return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (n === Im)
          return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (n === Pm)
          return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (n === $w || n === Zw || n === qw || n === Kw)
      if (a = t.get("WEBGL_compressed_texture_pvrtc"), a !== null) {
        if (n === $w)
          return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (n === Zw)
          return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (n === qw)
          return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (n === Kw)
          return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (n === jw || n === Jw || n === Qw)
      if (a = t.get("WEBGL_compressed_texture_etc"), a !== null) {
        if (n === jw || n === Jw)
          return o === Ze ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
        if (n === Qw)
          return o === Ze ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (n === tM || n === eM || n === rM || n === nM || n === iM || n === aM || n === oM || n === sM || n === lM || n === uM || n === cM || n === fM || n === hM || n === dM)
      if (a = t.get("WEBGL_compressed_texture_astc"), a !== null) {
        if (n === tM)
          return o === Ze ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (n === eM)
          return o === Ze ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (n === rM)
          return o === Ze ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (n === nM)
          return o === Ze ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (n === iM)
          return o === Ze ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (n === aM)
          return o === Ze ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (n === oM)
          return o === Ze ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (n === sM)
          return o === Ze ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (n === lM)
          return o === Ze ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (n === uM)
          return o === Ze ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (n === cM)
          return o === Ze ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (n === fM)
          return o === Ze ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (n === hM)
          return o === Ze ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (n === dM)
          return o === Ze ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (n === Nm || n === pM || n === vM)
      if (a = t.get("EXT_texture_compression_bptc"), a !== null) {
        if (n === Nm)
          return o === Ze ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (n === pM)
          return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (n === vM)
          return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else
        return null;
    if (n === hz || n === gM || n === mM || n === yM)
      if (a = t.get("EXT_texture_compression_rgtc"), a !== null) {
        if (n === Nm)
          return a.COMPRESSED_RED_RGTC1_EXT;
        if (n === gM)
          return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (n === mM)
          return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (n === yM)
          return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else
        return null;
    return n === Dh ? r.UNSIGNED_INT_24_8 : r[n] !== void 0 ? r[n] : null;
  }
  return { convert: e };
}
class M4 extends Ln {
  constructor(t = []) {
    super(), this.isArrayCamera = !0, this.cameras = t;
  }
}
let Iu = class extends Nr {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
};
const T4 = { type: "move" };
class oy {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new Iu(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new Iu(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new j(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new j()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new Iu(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new j(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new j()), this._grip;
  }
  dispatchEvent(t) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(t), this._grip !== null && this._grip.dispatchEvent(t), this._hand !== null && this._hand.dispatchEvent(t), this;
  }
  connect(t) {
    if (t && t.hand) {
      const e = this._hand;
      if (e)
        for (const n of t.hand.values())
          this._getHandJoint(e, n);
    }
    return this.dispatchEvent({ type: "connected", data: t }), this;
  }
  disconnect(t) {
    return this.dispatchEvent({ type: "disconnected", data: t }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(t, e, n) {
    let i = null, a = null, o = null;
    const s = this._targetRay, l = this._grip, u = this._hand;
    if (t && e.session.visibilityState !== "visible-blurred") {
      if (u && t.hand) {
        o = !0;
        for (const g of t.hand.values()) {
          const v = e.getJointPose(g, n), m = this._getHandJoint(u, g);
          v !== null && (m.matrix.fromArray(v.transform.matrix), m.matrix.decompose(m.position, m.rotation, m.scale), m.matrixWorldNeedsUpdate = !0, m.jointRadius = v.radius), m.visible = v !== null;
        }
        const c = u.joints["index-finger-tip"], f = u.joints["thumb-tip"], h = c.position.distanceTo(f.position), d = 0.02, p = 5e-3;
        u.inputState.pinching && h > d + p ? (u.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: t.handedness,
          target: this
        })) : !u.inputState.pinching && h <= d - p && (u.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: t.handedness,
          target: this
        }));
      } else
        l !== null && t.gripSpace && (a = e.getPose(t.gripSpace, n), a !== null && (l.matrix.fromArray(a.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = !0, a.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(a.linearVelocity)) : l.hasLinearVelocity = !1, a.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(a.angularVelocity)) : l.hasAngularVelocity = !1));
      s !== null && (i = e.getPose(t.targetRaySpace, n), i === null && a !== null && (i = a), i !== null && (s.matrix.fromArray(i.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale), s.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (s.hasLinearVelocity = !0, s.linearVelocity.copy(i.linearVelocity)) : s.hasLinearVelocity = !1, i.angularVelocity ? (s.hasAngularVelocity = !0, s.angularVelocity.copy(i.angularVelocity)) : s.hasAngularVelocity = !1, this.dispatchEvent(T4)));
    }
    return s !== null && (s.visible = i !== null), l !== null && (l.visible = a !== null), u !== null && (u.visible = o !== null), this;
  }
  // private method
  _getHandJoint(t, e) {
    if (t.joints[e.jointName] === void 0) {
      const n = new Iu();
      n.matrixAutoUpdate = !1, n.visible = !1, t.joints[e.jointName] = n, t.add(n);
    }
    return t.joints[e.jointName];
  }
}
const A4 = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, E4 = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class C4 {
  constructor() {
    this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
  }
  init(t, e, n) {
    if (this.texture === null) {
      const i = new sn(), a = t.properties.get(i);
      a.__webglTexture = e.texture, (e.depthNear != n.depthNear || e.depthFar != n.depthFar) && (this.depthNear = e.depthNear, this.depthFar = e.depthFar), this.texture = i;
    }
  }
  render(t, e) {
    if (this.texture !== null) {
      if (this.mesh === null) {
        const n = e.cameras[0].viewport, i = new Fa({
          vertexShader: A4,
          fragmentShader: E4,
          uniforms: {
            depthColor: { value: this.texture },
            depthWidth: { value: n.z },
            depthHeight: { value: n.w }
          }
        });
        this.mesh = new In(new Og(20, 20), i);
      }
      t.render(this.mesh, e);
    }
  }
  reset() {
    this.texture = null, this.mesh = null;
  }
}
class D4 extends vc {
  constructor(t, e) {
    super();
    const n = this;
    let i = null, a = 1, o = null, s = "local-floor", l = 1, u = null, c = null, f = null, h = null, d = null, p = null;
    const g = new C4(), v = e.getContextAttributes();
    let m = null, y = null;
    const _ = [], x = [], b = new Ce();
    let S = null;
    const w = new Ln();
    w.layers.enable(1), w.viewport = new Pr();
    const A = new Ln();
    A.layers.enable(2), A.viewport = new Pr();
    const T = [w, A], M = new M4();
    M.layers.enable(1), M.layers.enable(2);
    let E = null, R = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(U) {
      let $ = _[U];
      return $ === void 0 && ($ = new oy(), _[U] = $), $.getTargetRaySpace();
    }, this.getControllerGrip = function(U) {
      let $ = _[U];
      return $ === void 0 && ($ = new oy(), _[U] = $), $.getGripSpace();
    }, this.getHand = function(U) {
      let $ = _[U];
      return $ === void 0 && ($ = new oy(), _[U] = $), $.getHandSpace();
    };
    function C(U) {
      const $ = x.indexOf(U.inputSource);
      if ($ === -1)
        return;
      const ct = _[$];
      ct !== void 0 && (ct.update(U.inputSource, U.frame, u || o), ct.dispatchEvent({ type: U.type, data: U.inputSource }));
    }
    function D() {
      i.removeEventListener("select", C), i.removeEventListener("selectstart", C), i.removeEventListener("selectend", C), i.removeEventListener("squeeze", C), i.removeEventListener("squeezestart", C), i.removeEventListener("squeezeend", C), i.removeEventListener("end", D), i.removeEventListener("inputsourceschange", I);
      for (let U = 0; U < _.length; U++) {
        const $ = x[U];
        $ !== null && (x[U] = null, _[U].disconnect($));
      }
      E = null, R = null, g.reset(), t.setRenderTarget(m), d = null, h = null, f = null, i = null, y = null, K.stop(), n.isPresenting = !1, t.setPixelRatio(S), t.setSize(b.width, b.height, !1), n.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(U) {
      a = U, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(U) {
      s = U, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return u || o;
    }, this.setReferenceSpace = function(U) {
      u = U;
    }, this.getBaseLayer = function() {
      return h !== null ? h : d;
    }, this.getBinding = function() {
      return f;
    }, this.getFrame = function() {
      return p;
    }, this.getSession = function() {
      return i;
    }, this.setSession = async function(U) {
      if (i = U, i !== null) {
        if (m = t.getRenderTarget(), i.addEventListener("select", C), i.addEventListener("selectstart", C), i.addEventListener("selectend", C), i.addEventListener("squeeze", C), i.addEventListener("squeezestart", C), i.addEventListener("squeezeend", C), i.addEventListener("end", D), i.addEventListener("inputsourceschange", I), v.xrCompatible !== !0 && await e.makeXRCompatible(), S = t.getPixelRatio(), t.getSize(b), i.renderState.layers === void 0) {
          const $ = {
            antialias: v.antialias,
            alpha: !0,
            depth: v.depth,
            stencil: v.stencil,
            framebufferScaleFactor: a
          };
          d = new XRWebGLLayer(i, e, $), i.updateRenderState({ baseLayer: d }), t.setPixelRatio(1), t.setSize(d.framebufferWidth, d.framebufferHeight, !1), y = new cl(
            d.framebufferWidth,
            d.framebufferHeight,
            {
              format: Wi,
              type: Fo,
              colorSpace: t.outputColorSpace,
              stencilBuffer: v.stencil
            }
          );
        } else {
          let $ = null, ct = null, at = null;
          v.depth && (at = v.stencil ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT24, $ = v.stencil ? Qf : Uu, ct = v.stencil ? Dh : ju);
          const lt = {
            colorFormat: e.RGBA8,
            depthFormat: at,
            scaleFactor: a
          };
          f = new XRWebGLBinding(i, e), h = f.createProjectionLayer(lt), i.updateRenderState({ layers: [h] }), t.setPixelRatio(1), t.setSize(h.textureWidth, h.textureHeight, !1), y = new cl(
            h.textureWidth,
            h.textureHeight,
            {
              format: Wi,
              type: Fo,
              depthTexture: new RI(h.textureWidth, h.textureHeight, ct, void 0, void 0, void 0, void 0, void 0, void 0, $),
              stencilBuffer: v.stencil,
              colorSpace: t.outputColorSpace,
              samples: v.antialias ? 4 : 0,
              resolveDepthBuffer: h.ignoreDepthValues === !1
            }
          );
        }
        y.isXRRenderTarget = !0, this.setFoveation(l), u = null, o = await i.requestReferenceSpace(s), K.setContext(i), K.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" });
      }
    }, this.getEnvironmentBlendMode = function() {
      if (i !== null)
        return i.environmentBlendMode;
    };
    function I(U) {
      for (let $ = 0; $ < U.removed.length; $++) {
        const ct = U.removed[$], at = x.indexOf(ct);
        at >= 0 && (x[at] = null, _[at].disconnect(ct));
      }
      for (let $ = 0; $ < U.added.length; $++) {
        const ct = U.added[$];
        let at = x.indexOf(ct);
        if (at === -1) {
          for (let ot = 0; ot < _.length; ot++)
            if (ot >= x.length) {
              x.push(ct), at = ot;
              break;
            } else if (x[ot] === null) {
              x[ot] = ct, at = ot;
              break;
            }
          if (at === -1)
            break;
        }
        const lt = _[at];
        lt && lt.connect(ct);
      }
    }
    const P = new j(), O = new j();
    function N(U, $, ct) {
      P.setFromMatrixPosition($.matrixWorld), O.setFromMatrixPosition(ct.matrixWorld);
      const at = P.distanceTo(O), lt = $.projectionMatrix.elements, ot = ct.projectionMatrix.elements, H = lt[14] / (lt[10] - 1), st = lt[14] / (lt[10] + 1), ut = (lt[9] + 1) / lt[5], Gt = (lt[9] - 1) / lt[5], gt = (lt[8] - 1) / lt[0], Lt = (ot[8] + 1) / ot[0], Vt = H * gt, Kt = H * Lt, Ae = at / (-gt + Lt), z = Ae * -gt;
      $.matrixWorld.decompose(U.position, U.quaternion, U.scale), U.translateX(z), U.translateZ(Ae), U.matrixWorld.compose(U.position, U.quaternion, U.scale), U.matrixWorldInverse.copy(U.matrixWorld).invert();
      const k = H + Ae, nt = st + Ae, ht = Vt - z, yt = Kt + (at - z), xt = ut * st / nt * k, Qt = Gt * st / nt * k;
      U.projectionMatrix.makePerspective(ht, yt, xt, Qt, k, nt), U.projectionMatrixInverse.copy(U.projectionMatrix).invert();
    }
    function B(U, $) {
      $ === null ? U.matrixWorld.copy(U.matrix) : U.matrixWorld.multiplyMatrices($.matrixWorld, U.matrix), U.matrixWorldInverse.copy(U.matrixWorld).invert();
    }
    this.updateCamera = function(U) {
      if (i === null)
        return;
      g.texture !== null && (U.near = g.depthNear, U.far = g.depthFar), M.near = A.near = w.near = U.near, M.far = A.far = w.far = U.far, (E !== M.near || R !== M.far) && (i.updateRenderState({
        depthNear: M.near,
        depthFar: M.far
      }), E = M.near, R = M.far, w.near = E, w.far = R, A.near = E, A.far = R, w.updateProjectionMatrix(), A.updateProjectionMatrix(), U.updateProjectionMatrix());
      const $ = U.parent, ct = M.cameras;
      B(M, $);
      for (let at = 0; at < ct.length; at++)
        B(ct[at], $);
      ct.length === 2 ? N(M, w, A) : M.projectionMatrix.copy(w.projectionMatrix), F(U, M, $);
    };
    function F(U, $, ct) {
      ct === null ? U.matrix.copy($.matrixWorld) : (U.matrix.copy(ct.matrixWorld), U.matrix.invert(), U.matrix.multiply($.matrixWorld)), U.matrix.decompose(U.position, U.quaternion, U.scale), U.updateMatrixWorld(!0), U.projectionMatrix.copy($.projectionMatrix), U.projectionMatrixInverse.copy($.projectionMatrixInverse), U.isPerspectiveCamera && (U.fov = X_ * 2 * Math.atan(1 / U.projectionMatrix.elements[5]), U.zoom = 1);
    }
    this.getCamera = function() {
      return M;
    }, this.getFoveation = function() {
      if (!(h === null && d === null))
        return l;
    }, this.setFoveation = function(U) {
      l = U, h !== null && (h.fixedFoveation = U), d !== null && d.fixedFoveation !== void 0 && (d.fixedFoveation = U);
    }, this.hasDepthSensing = function() {
      return g.texture !== null;
    };
    let G = null;
    function X(U, $) {
      if (c = $.getViewerPose(u || o), p = $, c !== null) {
        const ct = c.views;
        d !== null && (t.setRenderTargetFramebuffer(y, d.framebuffer), t.setRenderTarget(y));
        let at = !1;
        ct.length !== M.cameras.length && (M.cameras.length = 0, at = !0);
        for (let ot = 0; ot < ct.length; ot++) {
          const H = ct[ot];
          let st = null;
          if (d !== null)
            st = d.getViewport(H);
          else {
            const Gt = f.getViewSubImage(h, H);
            st = Gt.viewport, ot === 0 && (t.setRenderTargetTextures(
              y,
              Gt.colorTexture,
              h.ignoreDepthValues ? void 0 : Gt.depthStencilTexture
            ), t.setRenderTarget(y));
          }
          let ut = T[ot];
          ut === void 0 && (ut = new Ln(), ut.layers.enable(ot), ut.viewport = new Pr(), T[ot] = ut), ut.matrix.fromArray(H.transform.matrix), ut.matrix.decompose(ut.position, ut.quaternion, ut.scale), ut.projectionMatrix.fromArray(H.projectionMatrix), ut.projectionMatrixInverse.copy(ut.projectionMatrix).invert(), ut.viewport.set(st.x, st.y, st.width, st.height), ot === 0 && (M.matrix.copy(ut.matrix), M.matrix.decompose(M.position, M.quaternion, M.scale)), at === !0 && M.cameras.push(ut);
        }
        const lt = i.enabledFeatures;
        if (lt && lt.includes("depth-sensing")) {
          const ot = f.getDepthInformation(ct[0]);
          ot && ot.isValid && ot.texture && g.init(t, ot, i.renderState);
        }
      }
      for (let ct = 0; ct < _.length; ct++) {
        const at = x[ct], lt = _[ct];
        at !== null && lt !== void 0 && lt.update(at, $, u || o);
      }
      g.render(t, M), G && G(U, $), $.detectedPlanes && n.dispatchEvent({ type: "planesdetected", data: $ }), p = null;
    }
    const K = new DI();
    K.setAnimationLoop(X), this.setAnimationLoop = function(U) {
      G = U;
    }, this.dispose = function() {
    };
  }
}
const as = /* @__PURE__ */ new Va(), L4 = /* @__PURE__ */ new Ye();
function R4(r, t) {
  function e(v, m) {
    v.matrixAutoUpdate === !0 && v.updateMatrix(), m.value.copy(v.matrix);
  }
  function n(v, m) {
    m.color.getRGB(v.fogColor.value, AI(r)), m.isFog ? (v.fogNear.value = m.near, v.fogFar.value = m.far) : m.isFogExp2 && (v.fogDensity.value = m.density);
  }
  function i(v, m, y, _, x) {
    m.isMeshBasicMaterial || m.isMeshLambertMaterial ? a(v, m) : m.isMeshToonMaterial ? (a(v, m), f(v, m)) : m.isMeshPhongMaterial ? (a(v, m), c(v, m)) : m.isMeshStandardMaterial ? (a(v, m), h(v, m), m.isMeshPhysicalMaterial && d(v, m, x)) : m.isMeshMatcapMaterial ? (a(v, m), p(v, m)) : m.isMeshDepthMaterial ? a(v, m) : m.isMeshDistanceMaterial ? (a(v, m), g(v, m)) : m.isMeshNormalMaterial ? a(v, m) : m.isLineBasicMaterial ? (o(v, m), m.isLineDashedMaterial && s(v, m)) : m.isPointsMaterial ? l(v, m, y, _) : m.isSpriteMaterial ? u(v, m) : m.isShadowMaterial ? (v.color.value.copy(m.color), v.opacity.value = m.opacity) : m.isShaderMaterial && (m.uniformsNeedUpdate = !1);
  }
  function a(v, m) {
    v.opacity.value = m.opacity, m.color && v.diffuse.value.copy(m.color), m.emissive && v.emissive.value.copy(m.emissive).multiplyScalar(m.emissiveIntensity), m.map && (v.map.value = m.map, e(m.map, v.mapTransform)), m.alphaMap && (v.alphaMap.value = m.alphaMap, e(m.alphaMap, v.alphaMapTransform)), m.bumpMap && (v.bumpMap.value = m.bumpMap, e(m.bumpMap, v.bumpMapTransform), v.bumpScale.value = m.bumpScale, m.side === Sn && (v.bumpScale.value *= -1)), m.normalMap && (v.normalMap.value = m.normalMap, e(m.normalMap, v.normalMapTransform), v.normalScale.value.copy(m.normalScale), m.side === Sn && v.normalScale.value.negate()), m.displacementMap && (v.displacementMap.value = m.displacementMap, e(m.displacementMap, v.displacementMapTransform), v.displacementScale.value = m.displacementScale, v.displacementBias.value = m.displacementBias), m.emissiveMap && (v.emissiveMap.value = m.emissiveMap, e(m.emissiveMap, v.emissiveMapTransform)), m.specularMap && (v.specularMap.value = m.specularMap, e(m.specularMap, v.specularMapTransform)), m.alphaTest > 0 && (v.alphaTest.value = m.alphaTest);
    const y = t.get(m), _ = y.envMap, x = y.envMapRotation;
    if (_ && (v.envMap.value = _, as.copy(x), as.x *= -1, as.y *= -1, as.z *= -1, _.isCubeTexture && _.isRenderTargetTexture === !1 && (as.y *= -1, as.z *= -1), v.envMapRotation.value.setFromMatrix4(L4.makeRotationFromEuler(as)), v.flipEnvMap.value = _.isCubeTexture && _.isRenderTargetTexture === !1 ? -1 : 1, v.reflectivity.value = m.reflectivity, v.ior.value = m.ior, v.refractionRatio.value = m.refractionRatio), m.lightMap) {
      v.lightMap.value = m.lightMap;
      const b = r._useLegacyLights === !0 ? Math.PI : 1;
      v.lightMapIntensity.value = m.lightMapIntensity * b, e(m.lightMap, v.lightMapTransform);
    }
    m.aoMap && (v.aoMap.value = m.aoMap, v.aoMapIntensity.value = m.aoMapIntensity, e(m.aoMap, v.aoMapTransform));
  }
  function o(v, m) {
    v.diffuse.value.copy(m.color), v.opacity.value = m.opacity, m.map && (v.map.value = m.map, e(m.map, v.mapTransform));
  }
  function s(v, m) {
    v.dashSize.value = m.dashSize, v.totalSize.value = m.dashSize + m.gapSize, v.scale.value = m.scale;
  }
  function l(v, m, y, _) {
    v.diffuse.value.copy(m.color), v.opacity.value = m.opacity, v.size.value = m.size * y, v.scale.value = _ * 0.5, m.map && (v.map.value = m.map, e(m.map, v.uvTransform)), m.alphaMap && (v.alphaMap.value = m.alphaMap, e(m.alphaMap, v.alphaMapTransform)), m.alphaTest > 0 && (v.alphaTest.value = m.alphaTest);
  }
  function u(v, m) {
    v.diffuse.value.copy(m.color), v.opacity.value = m.opacity, v.rotation.value = m.rotation, m.map && (v.map.value = m.map, e(m.map, v.mapTransform)), m.alphaMap && (v.alphaMap.value = m.alphaMap, e(m.alphaMap, v.alphaMapTransform)), m.alphaTest > 0 && (v.alphaTest.value = m.alphaTest);
  }
  function c(v, m) {
    v.specular.value.copy(m.specular), v.shininess.value = Math.max(m.shininess, 1e-4);
  }
  function f(v, m) {
    m.gradientMap && (v.gradientMap.value = m.gradientMap);
  }
  function h(v, m) {
    v.metalness.value = m.metalness, m.metalnessMap && (v.metalnessMap.value = m.metalnessMap, e(m.metalnessMap, v.metalnessMapTransform)), v.roughness.value = m.roughness, m.roughnessMap && (v.roughnessMap.value = m.roughnessMap, e(m.roughnessMap, v.roughnessMapTransform)), m.envMap && (v.envMapIntensity.value = m.envMapIntensity);
  }
  function d(v, m, y) {
    v.ior.value = m.ior, m.sheen > 0 && (v.sheenColor.value.copy(m.sheenColor).multiplyScalar(m.sheen), v.sheenRoughness.value = m.sheenRoughness, m.sheenColorMap && (v.sheenColorMap.value = m.sheenColorMap, e(m.sheenColorMap, v.sheenColorMapTransform)), m.sheenRoughnessMap && (v.sheenRoughnessMap.value = m.sheenRoughnessMap, e(m.sheenRoughnessMap, v.sheenRoughnessMapTransform))), m.clearcoat > 0 && (v.clearcoat.value = m.clearcoat, v.clearcoatRoughness.value = m.clearcoatRoughness, m.clearcoatMap && (v.clearcoatMap.value = m.clearcoatMap, e(m.clearcoatMap, v.clearcoatMapTransform)), m.clearcoatRoughnessMap && (v.clearcoatRoughnessMap.value = m.clearcoatRoughnessMap, e(m.clearcoatRoughnessMap, v.clearcoatRoughnessMapTransform)), m.clearcoatNormalMap && (v.clearcoatNormalMap.value = m.clearcoatNormalMap, e(m.clearcoatNormalMap, v.clearcoatNormalMapTransform), v.clearcoatNormalScale.value.copy(m.clearcoatNormalScale), m.side === Sn && v.clearcoatNormalScale.value.negate())), m.dispersion > 0 && (v.dispersion.value = m.dispersion), m.iridescence > 0 && (v.iridescence.value = m.iridescence, v.iridescenceIOR.value = m.iridescenceIOR, v.iridescenceThicknessMinimum.value = m.iridescenceThicknessRange[0], v.iridescenceThicknessMaximum.value = m.iridescenceThicknessRange[1], m.iridescenceMap && (v.iridescenceMap.value = m.iridescenceMap, e(m.iridescenceMap, v.iridescenceMapTransform)), m.iridescenceThicknessMap && (v.iridescenceThicknessMap.value = m.iridescenceThicknessMap, e(m.iridescenceThicknessMap, v.iridescenceThicknessMapTransform))), m.transmission > 0 && (v.transmission.value = m.transmission, v.transmissionSamplerMap.value = y.texture, v.transmissionSamplerSize.value.set(y.width, y.height), m.transmissionMap && (v.transmissionMap.value = m.transmissionMap, e(m.transmissionMap, v.transmissionMapTransform)), v.thickness.value = m.thickness, m.thicknessMap && (v.thicknessMap.value = m.thicknessMap, e(m.thicknessMap, v.thicknessMapTransform)), v.attenuationDistance.value = m.attenuationDistance, v.attenuationColor.value.copy(m.attenuationColor)), m.anisotropy > 0 && (v.anisotropyVector.value.set(m.anisotropy * Math.cos(m.anisotropyRotation), m.anisotropy * Math.sin(m.anisotropyRotation)), m.anisotropyMap && (v.anisotropyMap.value = m.anisotropyMap, e(m.anisotropyMap, v.anisotropyMapTransform))), v.specularIntensity.value = m.specularIntensity, v.specularColor.value.copy(m.specularColor), m.specularColorMap && (v.specularColorMap.value = m.specularColorMap, e(m.specularColorMap, v.specularColorMapTransform)), m.specularIntensityMap && (v.specularIntensityMap.value = m.specularIntensityMap, e(m.specularIntensityMap, v.specularIntensityMapTransform));
  }
  function p(v, m) {
    m.matcap && (v.matcap.value = m.matcap);
  }
  function g(v, m) {
    const y = t.get(m).light;
    v.referencePosition.value.setFromMatrixPosition(y.matrixWorld), v.nearDistance.value = y.shadow.camera.near, v.farDistance.value = y.shadow.camera.far;
  }
  return {
    refreshFogUniforms: n,
    refreshMaterialUniforms: i
  };
}
function I4(r, t, e, n) {
  let i = {}, a = {}, o = [];
  const s = r.getParameter(r.MAX_UNIFORM_BUFFER_BINDINGS);
  function l(y, _) {
    const x = _.program;
    n.uniformBlockBinding(y, x);
  }
  function u(y, _) {
    let x = i[y.id];
    x === void 0 && (p(y), x = c(y), i[y.id] = x, y.addEventListener("dispose", v));
    const b = _.program;
    n.updateUBOMapping(y, b);
    const S = t.render.frame;
    a[y.id] !== S && (h(y), a[y.id] = S);
  }
  function c(y) {
    const _ = f();
    y.__bindingPointIndex = _;
    const x = r.createBuffer(), b = y.__size, S = y.usage;
    return r.bindBuffer(r.UNIFORM_BUFFER, x), r.bufferData(r.UNIFORM_BUFFER, b, S), r.bindBuffer(r.UNIFORM_BUFFER, null), r.bindBufferBase(r.UNIFORM_BUFFER, _, x), x;
  }
  function f() {
    for (let y = 0; y < s; y++)
      if (o.indexOf(y) === -1)
        return o.push(y), y;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function h(y) {
    const _ = i[y.id], x = y.uniforms, b = y.__cache;
    r.bindBuffer(r.UNIFORM_BUFFER, _);
    for (let S = 0, w = x.length; S < w; S++) {
      const A = Array.isArray(x[S]) ? x[S] : [x[S]];
      for (let T = 0, M = A.length; T < M; T++) {
        const E = A[T];
        if (d(E, S, T, b) === !0) {
          const R = E.__offset, C = Array.isArray(E.value) ? E.value : [E.value];
          let D = 0;
          for (let I = 0; I < C.length; I++) {
            const P = C[I], O = g(P);
            typeof P == "number" || typeof P == "boolean" ? (E.__data[0] = P, r.bufferSubData(r.UNIFORM_BUFFER, R + D, E.__data)) : P.isMatrix3 ? (E.__data[0] = P.elements[0], E.__data[1] = P.elements[1], E.__data[2] = P.elements[2], E.__data[3] = 0, E.__data[4] = P.elements[3], E.__data[5] = P.elements[4], E.__data[6] = P.elements[5], E.__data[7] = 0, E.__data[8] = P.elements[6], E.__data[9] = P.elements[7], E.__data[10] = P.elements[8], E.__data[11] = 0) : (P.toArray(E.__data, D), D += O.storage / Float32Array.BYTES_PER_ELEMENT);
          }
          r.bufferSubData(r.UNIFORM_BUFFER, R, E.__data);
        }
      }
    }
    r.bindBuffer(r.UNIFORM_BUFFER, null);
  }
  function d(y, _, x, b) {
    const S = y.value, w = _ + "_" + x;
    if (b[w] === void 0)
      return typeof S == "number" || typeof S == "boolean" ? b[w] = S : b[w] = S.clone(), !0;
    {
      const A = b[w];
      if (typeof S == "number" || typeof S == "boolean") {
        if (A !== S)
          return b[w] = S, !0;
      } else if (A.equals(S) === !1)
        return A.copy(S), !0;
    }
    return !1;
  }
  function p(y) {
    const _ = y.uniforms;
    let x = 0;
    const b = 16;
    for (let w = 0, A = _.length; w < A; w++) {
      const T = Array.isArray(_[w]) ? _[w] : [_[w]];
      for (let M = 0, E = T.length; M < E; M++) {
        const R = T[M], C = Array.isArray(R.value) ? R.value : [R.value];
        for (let D = 0, I = C.length; D < I; D++) {
          const P = C[D], O = g(P), N = x % b;
          N !== 0 && b - N < O.boundary && (x += b - N), R.__data = new Float32Array(O.storage / Float32Array.BYTES_PER_ELEMENT), R.__offset = x, x += O.storage;
        }
      }
    }
    const S = x % b;
    return S > 0 && (x += b - S), y.__size = x, y.__cache = {}, this;
  }
  function g(y) {
    const _ = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    return typeof y == "number" || typeof y == "boolean" ? (_.boundary = 4, _.storage = 4) : y.isVector2 ? (_.boundary = 8, _.storage = 8) : y.isVector3 || y.isColor ? (_.boundary = 16, _.storage = 12) : y.isVector4 ? (_.boundary = 16, _.storage = 16) : y.isMatrix3 ? (_.boundary = 48, _.storage = 48) : y.isMatrix4 ? (_.boundary = 64, _.storage = 64) : y.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", y), _;
  }
  function v(y) {
    const _ = y.target;
    _.removeEventListener("dispose", v);
    const x = o.indexOf(_.__bindingPointIndex);
    o.splice(x, 1), r.deleteBuffer(i[_.id]), delete i[_.id], delete a[_.id];
  }
  function m() {
    for (const y in i)
      r.deleteBuffer(i[y]);
    o = [], i = {}, a = {};
  }
  return {
    bind: l,
    update: u,
    dispose: m
  };
}
class BI {
  constructor(t = {}) {
    const {
      canvas: e = Tz(),
      context: n = null,
      depth: i = !0,
      stencil: a = !1,
      alpha: o = !1,
      antialias: s = !1,
      premultipliedAlpha: l = !0,
      preserveDrawingBuffer: u = !1,
      powerPreference: c = "default",
      failIfMajorPerformanceCaveat: f = !1
    } = t;
    this.isWebGLRenderer = !0;
    let h;
    if (n !== null) {
      if (typeof WebGLRenderingContext < "u" && n instanceof WebGLRenderingContext)
        throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
      h = n.getContextAttributes().alpha;
    } else
      h = o;
    const d = new Uint32Array(4), p = new Int32Array(4);
    let g = null, v = null;
    const m = [], y = [];
    this.domElement = e, this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled
       * @type {boolean}
       */
      checkShaderErrors: !0,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = Bi, this._useLegacyLights = !1, this.toneMapping = Ro, this.toneMappingExposure = 1;
    const _ = this;
    let x = !1, b = 0, S = 0, w = null, A = -1, T = null;
    const M = new Pr(), E = new Pr();
    let R = null;
    const C = new le(0);
    let D = 0, I = e.width, P = e.height, O = 1, N = null, B = null;
    const F = new Pr(0, 0, I, P), G = new Pr(0, 0, I, P);
    let X = !1;
    const K = new p1();
    let U = !1, $ = !1;
    const ct = new Ye(), at = new j(), lt = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
    function ot() {
      return w === null ? O : 1;
    }
    let H = n;
    function st(V, q) {
      return e.getContext(V, q);
    }
    try {
      const V = {
        alpha: !0,
        depth: i,
        stencil: a,
        antialias: s,
        premultipliedAlpha: l,
        preserveDrawingBuffer: u,
        powerPreference: c,
        failIfMajorPerformanceCaveat: f
      };
      if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${u1}`), e.addEventListener("webglcontextlost", Z, !1), e.addEventListener("webglcontextrestored", vt, !1), e.addEventListener("webglcontextcreationerror", ft, !1), H === null) {
        const q = "webgl2";
        if (H = st(q, V), H === null)
          throw st(q) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
    } catch (V) {
      throw console.error("THREE.WebGLRenderer: " + V.message), V;
    }
    let ut, Gt, gt, Lt, Vt, Kt, Ae, z, k, nt, ht, yt, xt, Qt, Ft, Ot, _e, Mt, Jt, De, ie, Ht, xe, Ee;
    function nr() {
      ut = new U5(H), ut.init(), Ht = new w4(H, ut), Gt = new O5(H, ut, t, Ht), gt = new S4(H), Lt = new W5(H), Vt = new s4(), Kt = new b4(H, ut, gt, Vt, Gt, Ht, Lt), Ae = new B5(_), z = new z5(_), k = new jz(H), xe = new P5(H, k), nt = new G5(H, k, Lt, xe), ht = new Y5(H, nt, k, Lt), Jt = new X5(H, Gt, Kt), Ot = new k5(Vt), yt = new o4(_, Ae, z, ut, Gt, xe, Ot), xt = new R4(_, Vt), Qt = new u4(), Ft = new v4(ut), Mt = new I5(_, Ae, z, gt, ht, h, l), _e = new x4(_, ht, Gt), Ee = new I4(H, Lt, Gt, gt), De = new N5(H, ut, Lt), ie = new H5(H, ut, Lt), Lt.programs = yt.programs, _.capabilities = Gt, _.extensions = ut, _.properties = Vt, _.renderLists = Qt, _.shadowMap = _e, _.state = gt, _.info = Lt;
    }
    nr();
    const Se = new D4(_, H);
    this.xr = Se, this.getContext = function() {
      return H;
    }, this.getContextAttributes = function() {
      return H.getContextAttributes();
    }, this.forceContextLoss = function() {
      const V = ut.get("WEBGL_lose_context");
      V && V.loseContext();
    }, this.forceContextRestore = function() {
      const V = ut.get("WEBGL_lose_context");
      V && V.restoreContext();
    }, this.getPixelRatio = function() {
      return O;
    }, this.setPixelRatio = function(V) {
      V !== void 0 && (O = V, this.setSize(I, P, !1));
    }, this.getSize = function(V) {
      return V.set(I, P);
    }, this.setSize = function(V, q, it = !0) {
      if (Se.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      I = V, P = q, e.width = Math.floor(V * O), e.height = Math.floor(q * O), it === !0 && (e.style.width = V + "px", e.style.height = q + "px"), this.setViewport(0, 0, V, q);
    }, this.getDrawingBufferSize = function(V) {
      return V.set(I * O, P * O).floor();
    }, this.setDrawingBufferSize = function(V, q, it) {
      I = V, P = q, O = it, e.width = Math.floor(V * it), e.height = Math.floor(q * it), this.setViewport(0, 0, V, q);
    }, this.getCurrentViewport = function(V) {
      return V.copy(M);
    }, this.getViewport = function(V) {
      return V.copy(F);
    }, this.setViewport = function(V, q, it, Q) {
      V.isVector4 ? F.set(V.x, V.y, V.z, V.w) : F.set(V, q, it, Q), gt.viewport(M.copy(F).multiplyScalar(O).round());
    }, this.getScissor = function(V) {
      return V.copy(G);
    }, this.setScissor = function(V, q, it, Q) {
      V.isVector4 ? G.set(V.x, V.y, V.z, V.w) : G.set(V, q, it, Q), gt.scissor(E.copy(G).multiplyScalar(O).round());
    }, this.getScissorTest = function() {
      return X;
    }, this.setScissorTest = function(V) {
      gt.setScissorTest(X = V);
    }, this.setOpaqueSort = function(V) {
      N = V;
    }, this.setTransparentSort = function(V) {
      B = V;
    }, this.getClearColor = function(V) {
      return V.copy(Mt.getClearColor());
    }, this.setClearColor = function() {
      Mt.setClearColor.apply(Mt, arguments);
    }, this.getClearAlpha = function() {
      return Mt.getClearAlpha();
    }, this.setClearAlpha = function() {
      Mt.setClearAlpha.apply(Mt, arguments);
    }, this.clear = function(V = !0, q = !0, it = !0) {
      let Q = 0;
      if (V) {
        let tt = !1;
        if (w !== null) {
          const It = w.texture.format;
          tt = It === yI || It === mI || It === gI;
        }
        if (tt) {
          const It = w.texture.type, Xt = It === Fo || It === ju || It === fI || It === Dh || It === dI || It === pI, $t = Mt.getClearColor(), ae = Mt.getClearAlpha(), he = $t.r, ge = $t.g, be = $t.b;
          Xt ? (d[0] = he, d[1] = ge, d[2] = be, d[3] = ae, H.clearBufferuiv(H.COLOR, 0, d)) : (p[0] = he, p[1] = ge, p[2] = be, p[3] = ae, H.clearBufferiv(H.COLOR, 0, p));
        } else
          Q |= H.COLOR_BUFFER_BIT;
      }
      q && (Q |= H.DEPTH_BUFFER_BIT), it && (Q |= H.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), H.clear(Q);
    }, this.clearColor = function() {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
      this.clear(!1, !1, !0);
    }, this.dispose = function() {
      e.removeEventListener("webglcontextlost", Z, !1), e.removeEventListener("webglcontextrestored", vt, !1), e.removeEventListener("webglcontextcreationerror", ft, !1), Qt.dispose(), Ft.dispose(), Vt.dispose(), Ae.dispose(), z.dispose(), ht.dispose(), xe.dispose(), Ee.dispose(), yt.dispose(), Se.dispose(), Se.removeEventListener("sessionstart", Be), Se.removeEventListener("sessionend", Ei), Jr.stop();
    };
    function Z(V) {
      V.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), x = !0;
    }
    function vt() {
      console.log("THREE.WebGLRenderer: Context Restored."), x = !1;
      const V = Lt.autoReset, q = _e.enabled, it = _e.autoUpdate, Q = _e.needsUpdate, tt = _e.type;
      nr(), Lt.autoReset = V, _e.enabled = q, _e.autoUpdate = it, _e.needsUpdate = Q, _e.type = tt;
    }
    function ft(V) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", V.statusMessage);
    }
    function Rt(V) {
      const q = V.target;
      q.removeEventListener("dispose", Rt), Ut(q);
    }
    function Ut(V) {
      Le(V), Vt.remove(V);
    }
    function Le(V) {
      const q = Vt.get(V).programs;
      q !== void 0 && (q.forEach(function(it) {
        yt.releaseProgram(it);
      }), V.isShaderMaterial && yt.releaseShaderCache(V));
    }
    this.renderBufferDirect = function(V, q, it, Q, tt, It) {
      q === null && (q = lt);
      const Xt = tt.isMesh && tt.matrixWorld.determinant() < 0, $t = rF(V, q, it, Q, tt);
      gt.setMaterial(Q, Xt);
      let ae = it.index, he = 1;
      if (Q.wireframe === !0) {
        if (ae = nt.getWireframeAttribute(it), ae === void 0)
          return;
        he = 2;
      }
      const ge = it.drawRange, be = it.attributes.position;
      let dr = ge.start * he, Hr = (ge.start + ge.count) * he;
      It !== null && (dr = Math.max(dr, It.start * he), Hr = Math.min(Hr, (It.start + It.count) * he)), ae !== null ? (dr = Math.max(dr, 0), Hr = Math.min(Hr, ae.count)) : be != null && (dr = Math.max(dr, 0), Hr = Math.min(Hr, be.count));
      const wn = Hr - dr;
      if (wn < 0 || wn === 1 / 0)
        return;
      xe.setup(tt, Q, $t, it, ae);
      let fa, Pe = De;
      if (ae !== null && (fa = k.get(ae), Pe = ie, Pe.setIndex(fa)), tt.isMesh)
        Q.wireframe === !0 ? (gt.setLineWidth(Q.wireframeLinewidth * ot()), Pe.setMode(H.LINES)) : Pe.setMode(H.TRIANGLES);
      else if (tt.isLine) {
        let de = Q.linewidth;
        de === void 0 && (de = 1), gt.setLineWidth(de * ot()), tt.isLineSegments ? Pe.setMode(H.LINES) : tt.isLineLoop ? Pe.setMode(H.LINE_LOOP) : Pe.setMode(H.LINE_STRIP);
      } else
        tt.isPoints ? Pe.setMode(H.POINTS) : tt.isSprite && Pe.setMode(H.TRIANGLES);
      if (tt.isBatchedMesh)
        tt._multiDrawInstances !== null ? Pe.renderMultiDrawInstances(tt._multiDrawStarts, tt._multiDrawCounts, tt._multiDrawCount, tt._multiDrawInstances) : Pe.renderMultiDraw(tt._multiDrawStarts, tt._multiDrawCounts, tt._multiDrawCount);
      else if (tt.isInstancedMesh)
        Pe.renderInstances(dr, wn, tt.count);
      else if (it.isInstancedBufferGeometry) {
        const de = it._maxInstanceCount !== void 0 ? it._maxInstanceCount : 1 / 0, Oc = Math.min(it.instanceCount, de);
        Pe.renderInstances(dr, wn, Oc);
      } else
        Pe.render(dr, wn);
    };
    function $e(V, q, it) {
      V.transparent === !0 && V.side === Ta && V.forceSinglePass === !1 ? (V.side = Sn, V.needsUpdate = !0, jh(V, q, it), V.side = Vo, V.needsUpdate = !0, jh(V, q, it), V.side = Ta) : jh(V, q, it);
    }
    this.compile = function(V, q, it = null) {
      it === null && (it = V), v = Ft.get(it), v.init(q), y.push(v), it.traverseVisible(function(tt) {
        tt.isLight && tt.layers.test(q.layers) && (v.pushLight(tt), tt.castShadow && v.pushShadow(tt));
      }), V !== it && V.traverseVisible(function(tt) {
        tt.isLight && tt.layers.test(q.layers) && (v.pushLight(tt), tt.castShadow && v.pushShadow(tt));
      }), v.setupLights(_._useLegacyLights);
      const Q = /* @__PURE__ */ new Set();
      return V.traverse(function(tt) {
        const It = tt.material;
        if (It)
          if (Array.isArray(It))
            for (let Xt = 0; Xt < It.length; Xt++) {
              const $t = It[Xt];
              $e($t, it, tt), Q.add($t);
            }
          else
            $e(It, it, tt), Q.add(It);
      }), y.pop(), v = null, Q;
    }, this.compileAsync = function(V, q, it = null) {
      const Q = this.compile(V, q, it);
      return new Promise((tt) => {
        function It() {
          if (Q.forEach(function(Xt) {
            Vt.get(Xt).currentProgram.isReady() && Q.delete(Xt);
          }), Q.size === 0) {
            tt(V);
            return;
          }
          setTimeout(It, 10);
        }
        ut.get("KHR_parallel_shader_compile") !== null ? It() : setTimeout(It, 10);
      });
    };
    let je = null;
    function Gr(V) {
      je && je(V);
    }
    function Be() {
      Jr.stop();
    }
    function Ei() {
      Jr.start();
    }
    const Jr = new DI();
    Jr.setAnimationLoop(Gr), typeof self < "u" && Jr.setContext(self), this.setAnimationLoop = function(V) {
      je = V, Se.setAnimationLoop(V), V === null ? Jr.stop() : Jr.start();
    }, Se.addEventListener("sessionstart", Be), Se.addEventListener("sessionend", Ei), this.render = function(V, q) {
      if (q !== void 0 && q.isCamera !== !0) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (x === !0)
        return;
      V.matrixWorldAutoUpdate === !0 && V.updateMatrixWorld(), q.parent === null && q.matrixWorldAutoUpdate === !0 && q.updateMatrixWorld(), Se.enabled === !0 && Se.isPresenting === !0 && (Se.cameraAutoUpdate === !0 && Se.updateCamera(q), q = Se.getCamera()), V.isScene === !0 && V.onBeforeRender(_, V, q, w), v = Ft.get(V, y.length), v.init(q), y.push(v), ct.multiplyMatrices(q.projectionMatrix, q.matrixWorldInverse), K.setFromProjectionMatrix(ct), $ = this.localClippingEnabled, U = Ot.init(this.clippingPlanes, $), g = Qt.get(V, m.length), g.init(), m.push(g), Ow(V, q, 0, _.sortObjects), g.finish(), _.sortObjects === !0 && g.sort(N, B);
      const it = Se.enabled === !1 || Se.isPresenting === !1 || Se.hasDepthSensing() === !1;
      it && Mt.addToRenderList(g, V), this.info.render.frame++, U === !0 && Ot.beginShadows();
      const Q = v.state.shadowsArray;
      _e.render(Q, V, q), U === !0 && Ot.endShadows(), this.info.autoReset === !0 && this.info.reset();
      const tt = g.opaque, It = g.transmissive;
      if (v.setupLights(_._useLegacyLights), q.isArrayCamera) {
        const Xt = q.cameras;
        if (It.length > 0)
          for (let $t = 0, ae = Xt.length; $t < ae; $t++) {
            const he = Xt[$t];
            Bw(tt, It, V, he);
          }
        it && Mt.render(V);
        for (let $t = 0, ae = Xt.length; $t < ae; $t++) {
          const he = Xt[$t];
          kw(g, V, he, he.viewport);
        }
      } else
        It.length > 0 && Bw(tt, It, V, q), it && Mt.render(V), kw(g, V, q);
      w !== null && (Kt.updateMultisampleRenderTarget(w), Kt.updateRenderTargetMipmap(w)), V.isScene === !0 && V.onAfterRender(_, V, q), xe.resetDefaultState(), A = -1, T = null, y.pop(), y.length > 0 ? (v = y[y.length - 1], U === !0 && Ot.setGlobalState(_.clippingPlanes, v.state.camera)) : v = null, m.pop(), m.length > 0 ? g = m[m.length - 1] : g = null;
    };
    function Ow(V, q, it, Q) {
      if (V.visible === !1)
        return;
      if (V.layers.test(q.layers)) {
        if (V.isGroup)
          it = V.renderOrder;
        else if (V.isLOD)
          V.autoUpdate === !0 && V.update(q);
        else if (V.isLight)
          v.pushLight(V), V.castShadow && v.pushShadow(V);
        else if (V.isSprite) {
          if (!V.frustumCulled || K.intersectsSprite(V)) {
            Q && at.setFromMatrixPosition(V.matrixWorld).applyMatrix4(ct);
            const Xt = ht.update(V), $t = V.material;
            $t.visible && g.push(V, Xt, $t, it, at.z, null);
          }
        } else if ((V.isMesh || V.isLine || V.isPoints) && (!V.frustumCulled || K.intersectsObject(V))) {
          const Xt = ht.update(V), $t = V.material;
          if (Q && (V.boundingSphere !== void 0 ? (V.boundingSphere === null && V.computeBoundingSphere(), at.copy(V.boundingSphere.center)) : (Xt.boundingSphere === null && Xt.computeBoundingSphere(), at.copy(Xt.boundingSphere.center)), at.applyMatrix4(V.matrixWorld).applyMatrix4(ct)), Array.isArray($t)) {
            const ae = Xt.groups;
            for (let he = 0, ge = ae.length; he < ge; he++) {
              const be = ae[he], dr = $t[be.materialIndex];
              dr && dr.visible && g.push(V, Xt, dr, it, at.z, be);
            }
          } else
            $t.visible && g.push(V, Xt, $t, it, at.z, null);
        }
      }
      const It = V.children;
      for (let Xt = 0, $t = It.length; Xt < $t; Xt++)
        Ow(It[Xt], q, it, Q);
    }
    function kw(V, q, it, Q) {
      const tt = V.opaque, It = V.transmissive, Xt = V.transparent;
      v.setupLightsView(it), U === !0 && Ot.setGlobalState(_.clippingPlanes, it), Q && gt.viewport(M.copy(Q)), tt.length > 0 && Kh(tt, q, it), It.length > 0 && Kh(It, q, it), Xt.length > 0 && Kh(Xt, q, it), gt.buffers.depth.setTest(!0), gt.buffers.depth.setMask(!0), gt.buffers.color.setMask(!0), gt.setPolygonOffset(!1);
    }
    function Bw(V, q, it, Q) {
      if ((it.isScene === !0 ? it.overrideMaterial : null) !== null)
        return;
      v.state.transmissionRenderTarget[Q.id] === void 0 && (v.state.transmissionRenderTarget[Q.id] = new cl(1, 1, {
        generateMipmaps: !0,
        type: ut.has("EXT_color_buffer_half_float") || ut.has("EXT_color_buffer_float") ? Pg : Fo,
        minFilter: $s,
        samples: 4,
        stencilBuffer: a,
        resolveDepthBuffer: !1,
        resolveStencilBuffer: !1
      }));
      const It = v.state.transmissionRenderTarget[Q.id], Xt = Q.viewport || M;
      It.setSize(Xt.z, Xt.w);
      const $t = _.getRenderTarget();
      _.setRenderTarget(It), _.getClearColor(C), D = _.getClearAlpha(), D < 1 && _.setClearColor(16777215, 0.5), _.clear();
      const ae = _.toneMapping;
      _.toneMapping = Ro;
      const he = Q.viewport;
      if (Q.viewport !== void 0 && (Q.viewport = void 0), v.setupLightsView(Q), U === !0 && Ot.setGlobalState(_.clippingPlanes, Q), Kh(V, it, Q), Kt.updateMultisampleRenderTarget(It), Kt.updateRenderTargetMipmap(It), ut.has("WEBGL_multisampled_render_to_texture") === !1) {
        let ge = !1;
        for (let be = 0, dr = q.length; be < dr; be++) {
          const Hr = q[be], wn = Hr.object, fa = Hr.geometry, Pe = Hr.material, de = Hr.group;
          if (Pe.side === Ta && wn.layers.test(Q.layers)) {
            const Oc = Pe.side;
            Pe.side = Sn, Pe.needsUpdate = !0, Vw(wn, it, Q, fa, Pe, de), Pe.side = Oc, Pe.needsUpdate = !0, ge = !0;
          }
        }
        ge === !0 && (Kt.updateMultisampleRenderTarget(It), Kt.updateRenderTargetMipmap(It));
      }
      _.setRenderTarget($t), _.setClearColor(C, D), he !== void 0 && (Q.viewport = he), _.toneMapping = ae;
    }
    function Kh(V, q, it) {
      const Q = q.isScene === !0 ? q.overrideMaterial : null;
      for (let tt = 0, It = V.length; tt < It; tt++) {
        const Xt = V[tt], $t = Xt.object, ae = Xt.geometry, he = Q === null ? Xt.material : Q, ge = Xt.group;
        $t.layers.test(it.layers) && Vw($t, q, it, ae, he, ge);
      }
    }
    function Vw(V, q, it, Q, tt, It) {
      V.onBeforeRender(_, q, it, Q, tt, It), V.modelViewMatrix.multiplyMatrices(it.matrixWorldInverse, V.matrixWorld), V.normalMatrix.getNormalMatrix(V.modelViewMatrix), tt.onBeforeRender(_, q, it, Q, V, It), tt.transparent === !0 && tt.side === Ta && tt.forceSinglePass === !1 ? (tt.side = Sn, tt.needsUpdate = !0, _.renderBufferDirect(it, q, Q, tt, V, It), tt.side = Vo, tt.needsUpdate = !0, _.renderBufferDirect(it, q, Q, tt, V, It), tt.side = Ta) : _.renderBufferDirect(it, q, Q, tt, V, It), V.onAfterRender(_, q, it, Q, tt, It);
    }
    function jh(V, q, it) {
      q.isScene !== !0 && (q = lt);
      const Q = Vt.get(V), tt = v.state.lights, It = v.state.shadowsArray, Xt = tt.state.version, $t = yt.getParameters(V, tt.state, It, q, it), ae = yt.getProgramCacheKey($t);
      let he = Q.programs;
      Q.environment = V.isMeshStandardMaterial ? q.environment : null, Q.fog = q.fog, Q.envMap = (V.isMeshStandardMaterial ? z : Ae).get(V.envMap || Q.environment), Q.envMapRotation = Q.environment !== null && V.envMap === null ? q.environmentRotation : V.envMapRotation, he === void 0 && (V.addEventListener("dispose", Rt), he = /* @__PURE__ */ new Map(), Q.programs = he);
      let ge = he.get(ae);
      if (ge !== void 0) {
        if (Q.currentProgram === ge && Q.lightsStateVersion === Xt)
          return zw(V, $t), ge;
      } else
        $t.uniforms = yt.getUniforms(V), V.onBuild(it, $t, _), V.onBeforeCompile($t, _), ge = yt.acquireProgram($t, ae), he.set(ae, ge), Q.uniforms = $t.uniforms;
      const be = Q.uniforms;
      return (!V.isShaderMaterial && !V.isRawShaderMaterial || V.clipping === !0) && (be.clippingPlanes = Ot.uniform), zw(V, $t), Q.needsLights = iF(V), Q.lightsStateVersion = Xt, Q.needsLights && (be.ambientLightColor.value = tt.state.ambient, be.lightProbe.value = tt.state.probe, be.directionalLights.value = tt.state.directional, be.directionalLightShadows.value = tt.state.directionalShadow, be.spotLights.value = tt.state.spot, be.spotLightShadows.value = tt.state.spotShadow, be.rectAreaLights.value = tt.state.rectArea, be.ltc_1.value = tt.state.rectAreaLTC1, be.ltc_2.value = tt.state.rectAreaLTC2, be.pointLights.value = tt.state.point, be.pointLightShadows.value = tt.state.pointShadow, be.hemisphereLights.value = tt.state.hemi, be.directionalShadowMap.value = tt.state.directionalShadowMap, be.directionalShadowMatrix.value = tt.state.directionalShadowMatrix, be.spotShadowMap.value = tt.state.spotShadowMap, be.spotLightMatrix.value = tt.state.spotLightMatrix, be.spotLightMap.value = tt.state.spotLightMap, be.pointShadowMap.value = tt.state.pointShadowMap, be.pointShadowMatrix.value = tt.state.pointShadowMatrix), Q.currentProgram = ge, Q.uniformsList = null, ge;
    }
    function Fw(V) {
      if (V.uniformsList === null) {
        const q = V.currentProgram.getUniforms();
        V.uniformsList = zp.seqWithValue(q.seq, V.uniforms);
      }
      return V.uniformsList;
    }
    function zw(V, q) {
      const it = Vt.get(V);
      it.outputColorSpace = q.outputColorSpace, it.batching = q.batching, it.instancing = q.instancing, it.instancingColor = q.instancingColor, it.instancingMorph = q.instancingMorph, it.skinning = q.skinning, it.morphTargets = q.morphTargets, it.morphNormals = q.morphNormals, it.morphColors = q.morphColors, it.morphTargetsCount = q.morphTargetsCount, it.numClippingPlanes = q.numClippingPlanes, it.numIntersection = q.numClipIntersection, it.vertexAlphas = q.vertexAlphas, it.vertexTangents = q.vertexTangents, it.toneMapping = q.toneMapping;
    }
    function rF(V, q, it, Q, tt) {
      q.isScene !== !0 && (q = lt), Kt.resetTextureUnits();
      const It = q.fog, Xt = Q.isMeshStandardMaterial ? q.environment : null, $t = w === null ? _.outputColorSpace : w.isXRRenderTarget === !0 ? w.texture.colorSpace : Zo, ae = (Q.isMeshStandardMaterial ? z : Ae).get(Q.envMap || Xt), he = Q.vertexColors === !0 && !!it.attributes.color && it.attributes.color.itemSize === 4, ge = !!it.attributes.tangent && (!!Q.normalMap || Q.anisotropy > 0), be = !!it.morphAttributes.position, dr = !!it.morphAttributes.normal, Hr = !!it.morphAttributes.color;
      let wn = Ro;
      Q.toneMapped && (w === null || w.isXRRenderTarget === !0) && (wn = _.toneMapping);
      const fa = it.morphAttributes.position || it.morphAttributes.normal || it.morphAttributes.color, Pe = fa !== void 0 ? fa.length : 0, de = Vt.get(Q), Oc = v.state.lights;
      if (U === !0 && ($ === !0 || V !== T)) {
        const Fn = V === T && Q.id === A;
        Ot.setState(Q, V, Fn);
      }
      let qe = !1;
      Q.version === de.__version ? (de.needsLights && de.lightsStateVersion !== Oc.state.version || de.outputColorSpace !== $t || tt.isBatchedMesh && de.batching === !1 || !tt.isBatchedMesh && de.batching === !0 || tt.isInstancedMesh && de.instancing === !1 || !tt.isInstancedMesh && de.instancing === !0 || tt.isSkinnedMesh && de.skinning === !1 || !tt.isSkinnedMesh && de.skinning === !0 || tt.isInstancedMesh && de.instancingColor === !0 && tt.instanceColor === null || tt.isInstancedMesh && de.instancingColor === !1 && tt.instanceColor !== null || tt.isInstancedMesh && de.instancingMorph === !0 && tt.morphTexture === null || tt.isInstancedMesh && de.instancingMorph === !1 && tt.morphTexture !== null || de.envMap !== ae || Q.fog === !0 && de.fog !== It || de.numClippingPlanes !== void 0 && (de.numClippingPlanes !== Ot.numPlanes || de.numIntersection !== Ot.numIntersection) || de.vertexAlphas !== he || de.vertexTangents !== ge || de.morphTargets !== be || de.morphNormals !== dr || de.morphColors !== Hr || de.toneMapping !== wn || de.morphTargetsCount !== Pe) && (qe = !0) : (qe = !0, de.__version = Q.version);
      let Qo = de.currentProgram;
      qe === !0 && (Qo = jh(Q, q, tt));
      let Uw = !1, kc = !1, Am = !1;
      const Wr = Qo.getUniforms(), Ja = de.uniforms;
      if (gt.useProgram(Qo.program) && (Uw = !0, kc = !0, Am = !0), Q.id !== A && (A = Q.id, kc = !0), Uw || T !== V) {
        Wr.setValue(H, "projectionMatrix", V.projectionMatrix), Wr.setValue(H, "viewMatrix", V.matrixWorldInverse);
        const Fn = Wr.map.cameraPosition;
        Fn !== void 0 && Fn.setValue(H, at.setFromMatrixPosition(V.matrixWorld)), Gt.logarithmicDepthBuffer && Wr.setValue(
          H,
          "logDepthBufFC",
          2 / (Math.log(V.far + 1) / Math.LN2)
        ), (Q.isMeshPhongMaterial || Q.isMeshToonMaterial || Q.isMeshLambertMaterial || Q.isMeshBasicMaterial || Q.isMeshStandardMaterial || Q.isShaderMaterial) && Wr.setValue(H, "isOrthographic", V.isOrthographicCamera === !0), T !== V && (T = V, kc = !0, Am = !0);
      }
      if (tt.isSkinnedMesh) {
        Wr.setOptional(H, tt, "bindMatrix"), Wr.setOptional(H, tt, "bindMatrixInverse");
        const Fn = tt.skeleton;
        Fn && (Fn.boneTexture === null && Fn.computeBoneTexture(), Wr.setValue(H, "boneTexture", Fn.boneTexture, Kt));
      }
      tt.isBatchedMesh && (Wr.setOptional(H, tt, "batchingTexture"), Wr.setValue(H, "batchingTexture", tt._matricesTexture, Kt));
      const Em = it.morphAttributes;
      if ((Em.position !== void 0 || Em.normal !== void 0 || Em.color !== void 0) && Jt.update(tt, it, Qo), (kc || de.receiveShadow !== tt.receiveShadow) && (de.receiveShadow = tt.receiveShadow, Wr.setValue(H, "receiveShadow", tt.receiveShadow)), Q.isMeshGouraudMaterial && Q.envMap !== null && (Ja.envMap.value = ae, Ja.flipEnvMap.value = ae.isCubeTexture && ae.isRenderTargetTexture === !1 ? -1 : 1), Q.isMeshStandardMaterial && Q.envMap === null && q.environment !== null && (Ja.envMapIntensity.value = q.environmentIntensity), kc && (Wr.setValue(H, "toneMappingExposure", _.toneMappingExposure), de.needsLights && nF(Ja, Am), It && Q.fog === !0 && xt.refreshFogUniforms(Ja, It), xt.refreshMaterialUniforms(Ja, Q, O, P, v.state.transmissionRenderTarget[V.id]), zp.upload(H, Fw(de), Ja, Kt)), Q.isShaderMaterial && Q.uniformsNeedUpdate === !0 && (zp.upload(H, Fw(de), Ja, Kt), Q.uniformsNeedUpdate = !1), Q.isSpriteMaterial && Wr.setValue(H, "center", tt.center), Wr.setValue(H, "modelViewMatrix", tt.modelViewMatrix), Wr.setValue(H, "normalMatrix", tt.normalMatrix), Wr.setValue(H, "modelMatrix", tt.matrixWorld), Q.isShaderMaterial || Q.isRawShaderMaterial) {
        const Fn = Q.uniformsGroups;
        for (let Cm = 0, aF = Fn.length; Cm < aF; Cm++) {
          const Gw = Fn[Cm];
          Ee.update(Gw, Qo), Ee.bind(Gw, Qo);
        }
      }
      return Qo;
    }
    function nF(V, q) {
      V.ambientLightColor.needsUpdate = q, V.lightProbe.needsUpdate = q, V.directionalLights.needsUpdate = q, V.directionalLightShadows.needsUpdate = q, V.pointLights.needsUpdate = q, V.pointLightShadows.needsUpdate = q, V.spotLights.needsUpdate = q, V.spotLightShadows.needsUpdate = q, V.rectAreaLights.needsUpdate = q, V.hemisphereLights.needsUpdate = q;
    }
    function iF(V) {
      return V.isMeshLambertMaterial || V.isMeshToonMaterial || V.isMeshPhongMaterial || V.isMeshStandardMaterial || V.isShadowMaterial || V.isShaderMaterial && V.lights === !0;
    }
    this.getActiveCubeFace = function() {
      return b;
    }, this.getActiveMipmapLevel = function() {
      return S;
    }, this.getRenderTarget = function() {
      return w;
    }, this.setRenderTargetTextures = function(V, q, it) {
      Vt.get(V.texture).__webglTexture = q, Vt.get(V.depthTexture).__webglTexture = it;
      const Q = Vt.get(V);
      Q.__hasExternalTextures = !0, Q.__autoAllocateDepthBuffer = it === void 0, Q.__autoAllocateDepthBuffer || ut.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), Q.__useRenderToTexture = !1);
    }, this.setRenderTargetFramebuffer = function(V, q) {
      const it = Vt.get(V);
      it.__webglFramebuffer = q, it.__useDefaultFramebuffer = q === void 0;
    }, this.setRenderTarget = function(V, q = 0, it = 0) {
      w = V, b = q, S = it;
      let Q = !0, tt = null, It = !1, Xt = !1;
      if (V) {
        const ae = Vt.get(V);
        ae.__useDefaultFramebuffer !== void 0 ? (gt.bindFramebuffer(H.FRAMEBUFFER, null), Q = !1) : ae.__webglFramebuffer === void 0 ? Kt.setupRenderTarget(V) : ae.__hasExternalTextures && Kt.rebindTextures(V, Vt.get(V.texture).__webglTexture, Vt.get(V.depthTexture).__webglTexture);
        const he = V.texture;
        (he.isData3DTexture || he.isDataArrayTexture || he.isCompressedArrayTexture) && (Xt = !0);
        const ge = Vt.get(V).__webglFramebuffer;
        V.isWebGLCubeRenderTarget ? (Array.isArray(ge[q]) ? tt = ge[q][it] : tt = ge[q], It = !0) : V.samples > 0 && Kt.useMultisampledRTT(V) === !1 ? tt = Vt.get(V).__webglMultisampledFramebuffer : Array.isArray(ge) ? tt = ge[it] : tt = ge, M.copy(V.viewport), E.copy(V.scissor), R = V.scissorTest;
      } else
        M.copy(F).multiplyScalar(O).floor(), E.copy(G).multiplyScalar(O).floor(), R = X;
      if (gt.bindFramebuffer(H.FRAMEBUFFER, tt) && Q && gt.drawBuffers(V, tt), gt.viewport(M), gt.scissor(E), gt.setScissorTest(R), It) {
        const ae = Vt.get(V.texture);
        H.framebufferTexture2D(H.FRAMEBUFFER, H.COLOR_ATTACHMENT0, H.TEXTURE_CUBE_MAP_POSITIVE_X + q, ae.__webglTexture, it);
      } else if (Xt) {
        const ae = Vt.get(V.texture), he = q || 0;
        H.framebufferTextureLayer(H.FRAMEBUFFER, H.COLOR_ATTACHMENT0, ae.__webglTexture, it || 0, he);
      }
      A = -1;
    }, this.readRenderTargetPixels = function(V, q, it, Q, tt, It, Xt) {
      if (!(V && V.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let $t = Vt.get(V).__webglFramebuffer;
      if (V.isWebGLCubeRenderTarget && Xt !== void 0 && ($t = $t[Xt]), $t) {
        gt.bindFramebuffer(H.FRAMEBUFFER, $t);
        try {
          const ae = V.texture, he = ae.format, ge = ae.type;
          if (!Gt.textureFormatReadable(he)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          if (!Gt.textureTypeReadable(ge)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          q >= 0 && q <= V.width - Q && it >= 0 && it <= V.height - tt && H.readPixels(q, it, Q, tt, Ht.convert(he), Ht.convert(ge), It);
        } finally {
          const ae = w !== null ? Vt.get(w).__webglFramebuffer : null;
          gt.bindFramebuffer(H.FRAMEBUFFER, ae);
        }
      }
    }, this.copyFramebufferToTexture = function(V, q, it = 0) {
      const Q = Math.pow(2, -it), tt = Math.floor(q.image.width * Q), It = Math.floor(q.image.height * Q);
      Kt.setTexture2D(q, 0), H.copyTexSubImage2D(H.TEXTURE_2D, it, 0, 0, V.x, V.y, tt, It), gt.unbindTexture();
    }, this.copyTextureToTexture = function(V, q, it, Q = 0) {
      const tt = q.image.width, It = q.image.height, Xt = Ht.convert(it.format), $t = Ht.convert(it.type);
      Kt.setTexture2D(it, 0), H.pixelStorei(H.UNPACK_FLIP_Y_WEBGL, it.flipY), H.pixelStorei(H.UNPACK_PREMULTIPLY_ALPHA_WEBGL, it.premultiplyAlpha), H.pixelStorei(H.UNPACK_ALIGNMENT, it.unpackAlignment), q.isDataTexture ? H.texSubImage2D(H.TEXTURE_2D, Q, V.x, V.y, tt, It, Xt, $t, q.image.data) : q.isCompressedTexture ? H.compressedTexSubImage2D(H.TEXTURE_2D, Q, V.x, V.y, q.mipmaps[0].width, q.mipmaps[0].height, Xt, q.mipmaps[0].data) : H.texSubImage2D(H.TEXTURE_2D, Q, V.x, V.y, Xt, $t, q.image), Q === 0 && it.generateMipmaps && H.generateMipmap(H.TEXTURE_2D), gt.unbindTexture();
    }, this.copyTextureToTexture3D = function(V, q, it, Q, tt = 0) {
      const It = V.max.x - V.min.x, Xt = V.max.y - V.min.y, $t = V.max.z - V.min.z, ae = Ht.convert(Q.format), he = Ht.convert(Q.type);
      let ge;
      if (Q.isData3DTexture)
        Kt.setTexture3D(Q, 0), ge = H.TEXTURE_3D;
      else if (Q.isDataArrayTexture || Q.isCompressedArrayTexture)
        Kt.setTexture2DArray(Q, 0), ge = H.TEXTURE_2D_ARRAY;
      else {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        return;
      }
      H.pixelStorei(H.UNPACK_FLIP_Y_WEBGL, Q.flipY), H.pixelStorei(H.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Q.premultiplyAlpha), H.pixelStorei(H.UNPACK_ALIGNMENT, Q.unpackAlignment);
      const be = H.getParameter(H.UNPACK_ROW_LENGTH), dr = H.getParameter(H.UNPACK_IMAGE_HEIGHT), Hr = H.getParameter(H.UNPACK_SKIP_PIXELS), wn = H.getParameter(H.UNPACK_SKIP_ROWS), fa = H.getParameter(H.UNPACK_SKIP_IMAGES), Pe = it.isCompressedTexture ? it.mipmaps[tt] : it.image;
      H.pixelStorei(H.UNPACK_ROW_LENGTH, Pe.width), H.pixelStorei(H.UNPACK_IMAGE_HEIGHT, Pe.height), H.pixelStorei(H.UNPACK_SKIP_PIXELS, V.min.x), H.pixelStorei(H.UNPACK_SKIP_ROWS, V.min.y), H.pixelStorei(H.UNPACK_SKIP_IMAGES, V.min.z), it.isDataTexture || it.isData3DTexture ? H.texSubImage3D(ge, tt, q.x, q.y, q.z, It, Xt, $t, ae, he, Pe.data) : Q.isCompressedArrayTexture ? H.compressedTexSubImage3D(ge, tt, q.x, q.y, q.z, It, Xt, $t, ae, Pe.data) : H.texSubImage3D(ge, tt, q.x, q.y, q.z, It, Xt, $t, ae, he, Pe), H.pixelStorei(H.UNPACK_ROW_LENGTH, be), H.pixelStorei(H.UNPACK_IMAGE_HEIGHT, dr), H.pixelStorei(H.UNPACK_SKIP_PIXELS, Hr), H.pixelStorei(H.UNPACK_SKIP_ROWS, wn), H.pixelStorei(H.UNPACK_SKIP_IMAGES, fa), tt === 0 && Q.generateMipmaps && H.generateMipmap(ge), gt.unbindTexture();
    }, this.initTexture = function(V) {
      V.isCubeTexture ? Kt.setTextureCube(V, 0) : V.isData3DTexture ? Kt.setTexture3D(V, 0) : V.isDataArrayTexture || V.isCompressedArrayTexture ? Kt.setTexture2DArray(V, 0) : Kt.setTexture2D(V, 0), gt.unbindTexture();
    }, this.resetState = function() {
      b = 0, S = 0, w = null, gt.reset(), xe.reset();
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  get coordinateSystem() {
    return Ca;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(t) {
    this._outputColorSpace = t;
    const e = this.getContext();
    e.drawingBufferColorSpace = t === c1 ? "display-p3" : "srgb", e.unpackColorSpace = Fe.workingColorSpace === Ng ? "display-p3" : "srgb";
  }
  get useLegacyLights() {
    return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights;
  }
  set useLegacyLights(t) {
    console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights = t;
  }
}
class VI extends Nr {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Va(), this.environmentIntensity = 1, this.environmentRotation = new Va(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(t, e) {
    return super.copy(t, e), t.background !== null && (this.background = t.background.clone()), t.environment !== null && (this.environment = t.environment.clone()), t.fog !== null && (this.fog = t.fog.clone()), this.backgroundBlurriness = t.backgroundBlurriness, this.backgroundIntensity = t.backgroundIntensity, this.backgroundRotation.copy(t.backgroundRotation), this.environmentIntensity = t.environmentIntensity, this.environmentRotation.copy(t.environmentRotation), t.overrideMaterial !== null && (this.overrideMaterial = t.overrideMaterial.clone()), this.matrixAutoUpdate = t.matrixAutoUpdate, this;
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return this.fog !== null && (e.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (e.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (e.object.backgroundIntensity = this.backgroundIntensity), e.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (e.object.environmentIntensity = this.environmentIntensity), e.object.environmentRotation = this.environmentRotation.toArray(), e;
  }
}
class P4 extends sn {
  constructor(t = null, e = 1, n = 1, i, a, o, s, l, u = xn, c = xn, f, h) {
    super(null, o, s, l, u, c, i, a, f, h), this.isDataTexture = !0, this.image = { data: t, width: e, height: n }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class Ff extends ri {
  constructor(t, e, n, i = 1) {
    super(t, e, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = i;
  }
  copy(t) {
    return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this;
  }
  toJSON() {
    const t = super.toJSON();
    return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t;
  }
}
const jl = /* @__PURE__ */ new Ye(), uT = /* @__PURE__ */ new Ye(), Sd = [], cT = /* @__PURE__ */ new Sl(), N4 = /* @__PURE__ */ new Ye(), Gc = /* @__PURE__ */ new In(), Hc = /* @__PURE__ */ new gc();
class O4 extends In {
  constructor(t, e, n) {
    super(t, e), this.isInstancedMesh = !0, this.instanceMatrix = new Ff(new Float32Array(n * 16), 16), this.instanceColor = null, this.morphTexture = null, this.count = n, this.boundingBox = null, this.boundingSphere = null;
    for (let i = 0; i < n; i++)
      this.setMatrixAt(i, N4);
  }
  computeBoundingBox() {
    const t = this.geometry, e = this.count;
    this.boundingBox === null && (this.boundingBox = new Sl()), t.boundingBox === null && t.computeBoundingBox(), this.boundingBox.makeEmpty();
    for (let n = 0; n < e; n++)
      this.getMatrixAt(n, jl), cT.copy(t.boundingBox).applyMatrix4(jl), this.boundingBox.union(cT);
  }
  computeBoundingSphere() {
    const t = this.geometry, e = this.count;
    this.boundingSphere === null && (this.boundingSphere = new gc()), t.boundingSphere === null && t.computeBoundingSphere(), this.boundingSphere.makeEmpty();
    for (let n = 0; n < e; n++)
      this.getMatrixAt(n, jl), Hc.copy(t.boundingSphere).applyMatrix4(jl), this.boundingSphere.union(Hc);
  }
  copy(t, e) {
    return super.copy(t, e), this.instanceMatrix.copy(t.instanceMatrix), t.morphTexture !== null && (this.morphTexture = t.morphTexture.clone()), t.instanceColor !== null && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()), t.boundingSphere !== null && (this.boundingSphere = t.boundingSphere.clone()), this;
  }
  getColorAt(t, e) {
    e.fromArray(this.instanceColor.array, t * 3);
  }
  getMatrixAt(t, e) {
    e.fromArray(this.instanceMatrix.array, t * 16);
  }
  getMorphAt(t, e) {
    const n = e.morphTargetInfluences, i = this.morphTexture.source.data.data, a = n.length + 1, o = t * a + 1;
    for (let s = 0; s < n.length; s++)
      n[s] = i[o + s];
  }
  raycast(t, e) {
    const n = this.matrixWorld, i = this.count;
    if (Gc.geometry = this.geometry, Gc.material = this.material, Gc.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), Hc.copy(this.boundingSphere), Hc.applyMatrix4(n), t.ray.intersectsSphere(Hc) !== !1))
      for (let a = 0; a < i; a++) {
        this.getMatrixAt(a, jl), uT.multiplyMatrices(n, jl), Gc.matrixWorld = uT, Gc.raycast(t, Sd);
        for (let o = 0, s = Sd.length; o < s; o++) {
          const l = Sd[o];
          l.instanceId = a, l.object = this, e.push(l);
        }
        Sd.length = 0;
      }
  }
  setColorAt(t, e) {
    this.instanceColor === null && (this.instanceColor = new Ff(new Float32Array(this.instanceMatrix.count * 3), 3)), e.toArray(this.instanceColor.array, t * 3);
  }
  setMatrixAt(t, e) {
    e.toArray(this.instanceMatrix.array, t * 16);
  }
  setMorphAt(t, e) {
    const n = e.morphTargetInfluences, i = n.length + 1;
    this.morphTexture === null && (this.morphTexture = new P4(new Float32Array(i * this.count), i, this.count, vI, Ea));
    const a = this.morphTexture.source.data.data;
    let o = 0;
    for (let u = 0; u < n.length; u++)
      o += n[u];
    const s = this.geometry.morphTargetsRelative ? 1 : 1 - o, l = i * t;
    a[l] = s, a.set(n, l + 1);
  }
  updateMorphTargets() {
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this.morphTexture !== null && (this.morphTexture.dispose(), this.morphTexture = null), this;
  }
}
class g1 extends Ih {
  constructor(t) {
    super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new le(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.color.copy(t.color), this.map = t.map, this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.fog = t.fog, this;
  }
}
const vv = /* @__PURE__ */ new j(), gv = /* @__PURE__ */ new j(), fT = /* @__PURE__ */ new Ye(), Wc = /* @__PURE__ */ new f1(), bd = /* @__PURE__ */ new gc(), sy = /* @__PURE__ */ new j(), hT = /* @__PURE__ */ new j();
let k4 = class extends Nr {
  constructor(t = new ua(), e = new g1()) {
    super(), this.isLine = !0, this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets();
  }
  copy(t, e) {
    return super.copy(t, e), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this;
  }
  computeLineDistances() {
    const t = this.geometry;
    if (t.index === null) {
      const e = t.attributes.position, n = [0];
      for (let i = 1, a = e.count; i < a; i++)
        vv.fromBufferAttribute(e, i - 1), gv.fromBufferAttribute(e, i), n[i] = n[i - 1], n[i] += vv.distanceTo(gv);
      t.setAttribute("lineDistance", new On(n, 1));
    } else
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(t, e) {
    const n = this.geometry, i = this.matrixWorld, a = t.params.Line.threshold, o = n.drawRange;
    if (n.boundingSphere === null && n.computeBoundingSphere(), bd.copy(n.boundingSphere), bd.applyMatrix4(i), bd.radius += a, t.ray.intersectsSphere(bd) === !1)
      return;
    fT.copy(i).invert(), Wc.copy(t.ray).applyMatrix4(fT);
    const s = a / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = s * s, u = this.isLineSegments ? 2 : 1, c = n.index, h = n.attributes.position;
    if (c !== null) {
      const d = Math.max(0, o.start), p = Math.min(c.count, o.start + o.count);
      for (let g = d, v = p - 1; g < v; g += u) {
        const m = c.getX(g), y = c.getX(g + 1), _ = wd(this, t, Wc, l, m, y);
        _ && e.push(_);
      }
      if (this.isLineLoop) {
        const g = c.getX(p - 1), v = c.getX(d), m = wd(this, t, Wc, l, g, v);
        m && e.push(m);
      }
    } else {
      const d = Math.max(0, o.start), p = Math.min(h.count, o.start + o.count);
      for (let g = d, v = p - 1; g < v; g += u) {
        const m = wd(this, t, Wc, l, g, g + 1);
        m && e.push(m);
      }
      if (this.isLineLoop) {
        const g = wd(this, t, Wc, l, p - 1, d);
        g && e.push(g);
      }
    }
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes, n = Object.keys(e);
    if (n.length > 0) {
      const i = e[n[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let a = 0, o = i.length; a < o; a++) {
          const s = i[a].name || String(a);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[s] = a;
        }
      }
    }
  }
};
function wd(r, t, e, n, i, a) {
  const o = r.geometry.attributes.position;
  if (vv.fromBufferAttribute(o, i), gv.fromBufferAttribute(o, a), e.distanceSqToSegment(vv, gv, sy, hT) > n)
    return;
  sy.applyMatrix4(r.matrixWorld);
  const l = t.ray.origin.distanceTo(sy);
  if (!(l < t.near || l > t.far))
    return {
      distance: l,
      // What do we want? intersection point on the ray or on the segment??
      // point: raycaster.ray.at( distance ),
      point: hT.clone().applyMatrix4(r.matrixWorld),
      index: i,
      face: null,
      faceIndex: null,
      object: r
    };
}
const dT = /* @__PURE__ */ new j(), pT = /* @__PURE__ */ new j();
class FI extends k4 {
  constructor(t, e) {
    super(t, e), this.isLineSegments = !0, this.type = "LineSegments";
  }
  computeLineDistances() {
    const t = this.geometry;
    if (t.index === null) {
      const e = t.attributes.position, n = [];
      for (let i = 0, a = e.count; i < a; i += 2)
        dT.fromBufferAttribute(e, i), pT.fromBufferAttribute(e, i + 1), n[i] = i === 0 ? 0 : n[i - 1], n[i + 1] = n[i] + dT.distanceTo(pT);
      t.setAttribute("lineDistance", new On(n, 1));
    } else
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
}
class zI extends Nr {
  constructor(t, e = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new le(t), this.intensity = e;
  }
  dispose() {
  }
  copy(t, e) {
    return super.copy(t, e), this.color.copy(t.color), this.intensity = t.intensity, this;
  }
  toJSON(t) {
    const e = super.toJSON(t);
    return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, this.groundColor !== void 0 && (e.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (e.object.distance = this.distance), this.angle !== void 0 && (e.object.angle = this.angle), this.decay !== void 0 && (e.object.decay = this.decay), this.penumbra !== void 0 && (e.object.penumbra = this.penumbra), this.shadow !== void 0 && (e.object.shadow = this.shadow.toJSON()), e;
  }
}
const ly = /* @__PURE__ */ new Ye(), vT = /* @__PURE__ */ new j(), gT = /* @__PURE__ */ new j();
class B4 {
  constructor(t) {
    this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Ce(512, 512), this.map = null, this.mapPass = null, this.matrix = new Ye(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new p1(), this._frameExtents = new Ce(1, 1), this._viewportCount = 1, this._viewports = [
      new Pr(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(t) {
    const e = this.camera, n = this.matrix;
    vT.setFromMatrixPosition(t.matrixWorld), e.position.copy(vT), gT.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(gT), e.updateMatrixWorld(), ly.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(ly), n.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), n.multiply(ly);
  }
  getViewport(t) {
    return this._viewports[t];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(t) {
    return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const t = {};
    return this.bias !== 0 && (t.bias = this.bias), this.normalBias !== 0 && (t.normalBias = this.normalBias), this.radius !== 1 && (t.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t;
  }
}
class V4 extends B4 {
  constructor() {
    super(new LI(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}
class UI extends zI {
  constructor(t, e) {
    super(t, e), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Nr.DEFAULT_UP), this.updateMatrix(), this.target = new Nr(), this.shadow = new V4();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(t) {
    return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
  }
}
class GI extends zI {
  constructor(t, e) {
    super(t, e), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
}
const mT = /* @__PURE__ */ new Ye();
class HI {
  constructor(t, e, n = 0, i = 1 / 0) {
    this.ray = new f1(t, e), this.near = n, this.far = i, this.camera = null, this.layers = new h1(), this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(t, e) {
    this.ray.set(t, e);
  }
  setFromCamera(t, e) {
    e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, 0.5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type: " + e.type);
  }
  setFromXRController(t) {
    return mT.identity().extractRotation(t.matrixWorld), this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(mT), this;
  }
  intersectObject(t, e = !0, n = []) {
    return $_(t, this, n, e), n.sort(yT), n;
  }
  intersectObjects(t, e = !0, n = []) {
    for (let i = 0, a = t.length; i < a; i++)
      $_(t[i], this, n, e);
    return n.sort(yT), n;
  }
}
function yT(r, t) {
  return r.distance - t.distance;
}
function $_(r, t, e, n) {
  if (r.layers.test(t.layers) && r.raycast(t, e), n === !0) {
    const i = r.children;
    for (let a = 0, o = i.length; a < o; a++)
      $_(i[a], t, e, !0);
  }
}
class Jut {
  constructor(t = 1, e = 0, n = 0) {
    return this.radius = t, this.phi = e, this.theta = n, this;
  }
  set(t, e, n) {
    return this.radius = t, this.phi = e, this.theta = n, this;
  }
  copy(t) {
    return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this;
  }
  // restrict phi to be between EPS and PI-EPS
  makeSafe() {
    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
  }
  setFromVector3(t) {
    return this.setFromCartesianCoords(t.x, t.y, t.z);
  }
  setFromCartesianCoords(t, e, n) {
    return this.radius = Math.sqrt(t * t + e * e + n * n), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(an(e / this.radius, -1, 1))), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class WI extends FI {
  constructor(t = 10, e = 10, n = 4473924, i = 8947848) {
    n = new le(n), i = new le(i);
    const a = e / 2, o = t / e, s = t / 2, l = [], u = [];
    for (let h = 0, d = 0, p = -s; h <= e; h++, p += o) {
      l.push(-s, 0, p, s, 0, p), l.push(p, 0, -s, p, 0, s);
      const g = h === a ? n : i;
      g.toArray(u, d), d += 3, g.toArray(u, d), d += 3, g.toArray(u, d), d += 3, g.toArray(u, d), d += 3;
    }
    const c = new ua();
    c.setAttribute("position", new On(l, 3)), c.setAttribute("color", new On(u, 3));
    const f = new g1({ vertexColors: !0, toneMapped: !1 });
    super(c, f), this.type = "GridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class XI extends FI {
  constructor(t = 1) {
    const e = [
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      0,
      0,
      t
    ], n = [
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ], i = new ua();
    i.setAttribute("position", new On(e, 3)), i.setAttribute("color", new On(n, 3));
    const a = new g1({ vertexColors: !0, toneMapped: !1 });
    super(i, a), this.type = "AxesHelper";
  }
  setColors(t, e, n) {
    const i = new le(), a = this.geometry.attributes.color.array;
    return i.set(t), i.toArray(a, 0), i.toArray(a, 3), i.set(e), i.toArray(a, 6), i.toArray(a, 9), i.set(n), i.toArray(a, 12), i.toArray(a, 15), this.geometry.attributes.color.needsUpdate = !0, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: u1
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = u1);
const F4 = ["innerHTML"], z4 = /* @__PURE__ */ l1({
  name: "JBHeatMap3D",
  __name: "HeatMap",
  props: {
    data: {
      type: Array,
      default: () => []
    },
    width: { type: Number, default: 600 },
    height: { type: Number, default: 500 },
    baseSize: { type: Number, default: 0.1 },
    maxHeight: { type: Number, default: 3 },
    enableOrbit: { type: Boolean, default: !0 },
    backgroundColor: { type: String, default: "#0d1b2a" },
    showGridHelper: { type: Boolean, default: !0 },
    showAxesHelper: { type: Boolean, default: !0 },
    isStandardColor: { type: Boolean, default: !0 },
    rotateAnimation: { type: Boolean, default: !1 },
    // 
    rotationSpeed: { type: Number, default: 0.01 },
    // 
    autoAnimate: { type: Boolean, default: !1 },
    cameraPosition: {
      type: Object,
      default: () => ({ x: 5, y: 5, z: 5 })
    }
  },
  setup(r, { expose: t }) {
    const e = Rr(0), n = r;
    new Nr();
    const i = Rr(null), a = Rr({ show: !1, x: 0, y: 0, content: "" }), o = Rr(n.autoAnimate);
    let s, l, u, c = null, f, h, d, p = null, g = [], v = 0, m = 0;
    Lg(async () => {
      const { OrbitControls: E } = await import("./OrbitControls-ZLI6LDjr.js");
      y(), n.enableOrbit && (c = new E(l, u.domElement), c.enableDamping = !0, c.dampingFactor = 0.05), w(), window.addEventListener("mousemove", T), window.addEventListener("resize", M), i.value && i.value.addEventListener("mouseleave", () => {
        a.value.show = !1;
      });
    }), sI(() => {
      p && cancelAnimationFrame(p), window.removeEventListener("mousemove", T), window.removeEventListener("resize", M), u.dispose();
    });
    function y() {
      const { backgroundColor: E, showGridHelper: R, showAxesHelper: C, cameraPosition: D } = n;
      s = new VI(), s.background = new le(E), l = new Ln(75, n.width / n.height, 0.1, 1e3), l.position.set(D.x, D.y, D.z), u = new BI({ antialias: !0 }), u.setSize(n.width, n.height), u.shadowMap.enabled = !0, i.value && i.value.appendChild(u.domElement), n.enableOrbit && c && (c.enableDamping = !0, c.dampingFactor = 0.05), s.add(new GI(16777215, 0.6));
      const I = new UI(16777215, 0.8);
      if (I.position.set(10, 20, 5), s.add(I), f = new Iu(), s.add(f), R) {
        const P = Math.max(v, m) * n.baseSize * 1.2, O = new WI(P, Math.max(v, m), 4473924, 2236962);
        s.add(O);
      }
      if (C) {
        const P = new XI(Math.max(v, m) * n.baseSize * 0.6);
        s.add(P);
      }
      h = new HI(), d = new Ce(), S();
    }
    function _(E = 10, R = 10) {
      return Array.from({ length: E }, () => Array.from({ length: R }, () => Math.random() * 15 + 1));
    }
    function x(E, R, C, D, I, P) {
      let O = 0.1;
      I !== D && (O += (C - D) / (I - D) * n.maxHeight);
      const N = new bl(n.baseSize, O, n.baseSize, 1, 8, 1), B = N.attributes.position, F = N.attributes.normal, G = [], X = I !== D ? (C - D) / (I - D) : 0, K = [
        new le(536927),
        // 
        new le(4556987),
        // 
        new le(8765155),
        // 
        new le(12508404),
        // 
        new le(14997468),
        // 
        new le(16572378),
        // 
        new le(16365218),
        // 
        new le(16349280),
        // 
        new le(13112870),
        // 
        new le(11468815)
        // 
      ];
      let U = [], $ = 0;
      X >= 0.9 ? ($ = 10, U = K.slice(0, 10)) : X >= 0.8 ? ($ = 9, U = K.slice(0, 9)) : X >= 0.7 ? ($ = 8, U = K.slice(0, 8)) : X >= 0.6 ? ($ = 7, U = K.slice(0, 7)) : X >= 0.5 ? ($ = 6, U = K.slice(0, 6)) : X >= 0.4 ? ($ = 5, U = K.slice(0, 5)) : X >= 0.3 ? ($ = 4, U = K.slice(0, 4)) : X >= 0.2 ? ($ = 3, U = K.slice(0, 3)) : X >= 0.1 ? ($ = 2, U = K.slice(0, 2)) : ($ = 1, U = K.slice(0, 1));
      for (let lt = 0; lt < B.count; lt++) {
        const ot = B.getY(lt), H = F.getY(lt);
        let st = new le();
        const ut = Math.max(0, Math.min(1, (ot + O / 2) / O));
        if (H > 0.5)
          st.copy(U[U.length - 1]);
        else if ($ === 1)
          st.copy(U[0]);
        else {
          const Gt = 1 / ($ - 1);
          let gt = Math.floor(ut / Gt);
          gt = Math.min(gt, $ - 2), gt = Math.max(0, gt);
          const Lt = (ut - gt * Gt) / Gt;
          gt >= 0 && gt + 1 < U.length ? st.lerpColors(U[gt], U[gt + 1], Lt) : st.copy(U[U.length - 1]);
        }
        G.push(st.r, st.g, st.b);
      }
      N.setAttribute("color", new ri(new Float32Array(G), 3));
      const ct = new d1({ vertexColors: !0 }), at = new In(N, ct);
      return at.position.set((E - (v - 1) / 2) * n.baseSize, O / 2, (R - (m - 1) / 2) * n.baseSize), at.userData = { value: C, x: E, z: R }, at;
    }
    function b() {
      {
        const { children: E } = f;
        E.forEach((R) => {
          R instanceof In && (R.geometry.dispose(), (Array.isArray(R.material) ? R.material : [R.material]).forEach((D) => D.dispose()));
        }), f.clear();
      }
    }
    function S() {
      var D;
      if (b(), Array.isArray(n.data) && n.data.length > 0 && n.data.every((I) => Array.isArray(I)) ? g = n.data.map((I) => [...I]) : (console.log(""), g = _()), f.clear(), v = g.length, m = ((D = g[0]) == null ? void 0 : D.length) || 0, v === 0 || m === 0) {
        console.warn("");
        return;
      }
      let R = 1 / 0, C = -1 / 0;
      for (let I = 0; I < v; I++) {
        const P = g[I];
        if (Array.isArray(P))
          for (let O = 0; O < m; O++) {
            const N = P[O];
            typeof N == "number" && (N < R && (R = N), N > C && (C = N));
          }
      }
      R === 1 / 0 && (R = 0), C === -1 / 0 && (C = 0);
      for (let I = 0; I < v; I++) {
        const P = g[I];
        if (Array.isArray(P))
          for (let O = 0; O < m; O++) {
            const N = P[O], B = typeof N == "number" ? N : 0;
            let F = null;
            n.isStandardColor, F = x(I, O, B, R, C), f.add(F);
          }
      }
    }
    function w() {
      p = requestAnimationFrame(w), n.rotateAnimation && (e.value += n.rotationSpeed, f.rotation.y = e.value), c && c.update(), u.render(s, l);
    }
    let A = null;
    function T(E) {
      if (!i.value)
        return;
      const R = i.value.getBoundingClientRect();
      if (E.clientX < R.left || E.clientX > R.right || E.clientY < R.top || E.clientY > R.bottom) {
        a.value.show = !1;
        return;
      }
      A && cancelAnimationFrame(A), A = requestAnimationFrame(() => {
        d.x = (E.clientX - R.left) / R.width * 2 - 1, d.y = -((E.clientY - R.top) / R.height) * 2 + 1, h.setFromCamera(d, l);
        const C = h.intersectObjects(f.children);
        if (C.length) {
          const D = C[0].object, { value: I, x: P, z: O } = D.userData;
          a.value = {
            show: !0,
            x: E.clientX - R.left + 10,
            y: E.clientY - R.top - 30,
            content: `: ${I.toFixed(2)}<br>: (${P}, ${O})`
          };
        } else
          a.value.show = !1;
      });
    }
    function M() {
      l.aspect = n.width / n.height, l.updateProjectionMatrix(), u.setSize(n.width, n.height);
    }
    return t({
      refresh: S,
      toggleAnimation: () => o.value = !o.value
    }), (E, R) => (Ra(), Do("div", {
      class: "heatmap-wrapper",
      style: Zu({ width: r.width + "px", height: r.height + "px" })
    }, [
      Hi(a).show ? (Ra(), Do("div", {
        key: 0,
        class: "tooltip",
        style: Zu({ left: Hi(a).x + "px", top: Hi(a).y + "px" }),
        innerHTML: Hi(a).content
      }, null, 12, F4)) : lv("", !0),
      Sr("div", {
        ref_key: "containerRef",
        ref: i,
        class: "three-container"
      }, null, 512)
    ], 4));
  }
}), U4 = /* @__PURE__ */ Rg(z4, [["__scopeId", "data-v-2dbe1985"]]), G4 = Ch(U4), H4 = ["innerHTML"], W4 = /* @__PURE__ */ l1({
  name: "JBHeatMap3DUV",
  __name: "HeatMap2",
  props: {
    data: {
      type: Array,
      default: () => []
    },
    width: { type: Number, default: 600 },
    height: { type: Number, default: 500 },
    baseSize: { type: Number, default: 0.1 },
    maxHeight: { type: Number, default: 3 },
    enableOrbit: { type: Boolean, default: !0 },
    backgroundColor: { type: String, default: "#0d1b2a" },
    showGridHelper: { type: Boolean, default: !0 },
    showAxesHelper: { type: Boolean, default: !0 },
    gradientColors: {
      type: Array,
      default: () => ["#00008b", "#00ffff", "#ffff00", "#ff0000"]
    },
    autoAnimate: { type: Boolean, default: !1 },
    cameraPosition: {
      type: Object,
      default: () => ({ x: 8, y: 8, z: 8 })
    }
  },
  setup(r, { expose: t }) {
    const e = r, n = Rr(null), i = Rr({ show: !1, x: 0, y: 0, content: "" }), a = Rr(e.autoAnimate);
    let o, s, l, u = null, c, f, h, d = null, p = null;
    const g = [];
    let v = 0, m = 0, y;
    Lg(async () => {
      x();
      const { OrbitControls: D } = await import("./OrbitControls-ZLI6LDjr.js");
      e.enableOrbit && (u = new D(s, l.domElement), u.enableDamping = !0, u.dampingFactor = 0.05), M(), window.addEventListener("mousemove", R), window.addEventListener("resize", C), n.value && n.value.addEventListener("mouseleave", () => {
        i.value.show = !1;
      });
    }), sI(() => {
      d && cancelAnimationFrame(d), window.removeEventListener("mousemove", R), window.removeEventListener("resize", C), p && (p.geometry.dispose(), p.material.dispose()), y && y.dispose(), l == null || l.dispose();
    });
    function _() {
      console.log("...");
      const D = [
        new j(0.0314, 0.1922, 0.3725),
        // #08315f 
        new j(0.2706, 0.5333, 0.7333),
        // #4588bb 
        new j(0.5216, 0.7451, 0.8902),
        // #85bee3 
        new j(0.7451, 0.8627, 0.9569),
        // #bedcf4 
        new j(0.8941, 0.8431, 0.8627),
        // #e4d7dc 
        new j(0.9882, 0.8745, 0.8549),
        // #fcdfda 
        new j(0.9765, 0.7137, 0.6353),
        // #f9b6a2 
        new j(0.9765, 0.4706, 0.3765),
        // #f97860 
        new j(0.7843, 0.0863, 0.149),
        // #c81626 
        new j(0.6863, 0, 0.0588)
        // #af000f 
      ], I = new Fa({
        uniforms: {
          color0: { value: D[0] },
          color1: { value: D[1] },
          color2: { value: D[2] },
          color3: { value: D[3] },
          color4: { value: D[4] },
          color5: { value: D[5] },
          color6: { value: D[6] },
          color7: { value: D[7] },
          color8: { value: D[8] },
          color9: { value: D[9] },
          baseSize: { value: e.baseSize },
          maxHeight: { value: e.maxHeight }
        },
        vertexShader: `
            attribute float instanceValue;
            attribute vec3 instancePosition;
            attribute vec3 instanceScale;

            varying float vValue;
            varying float vHeight;
            varying vec3 vPosition;

            void main() {
                vValue = instanceValue;
                vPosition = position;

                //  (01)
                vHeight = (position.y + 0.5); // y-0.50.5

                // 
                vec3 transformed = position * instanceScale;
                transformed += instancePosition;

                gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed, 1.0);
            }
        `,
        fragmentShader: `
            uniform vec3 color0;
            uniform vec3 color1;
            uniform vec3 color2;
            uniform vec3 color3;
            uniform vec3 color4;
            uniform vec3 color5;
            uniform vec3 color6;
            uniform vec3 color7;
            uniform vec3 color8;
            uniform vec3 color9;

            varying float vValue;
            varying float vHeight;
            varying vec3 vPosition;

            vec3 getGradientColor(float value, float height) {
                // 
                if (value < 0.1) {
                    // 
                    return color0;
                } else if (value < 0.2) {
                    // 2
                    return mix(color0, color1, height);
                } else if (value < 0.3) {
                    // 3
                    if (height < 0.5) {
                        return mix(color0, color1, height / 0.5);
                    } else {
                        return mix(color1, color2, (height - 0.5) / 0.5);
                    }
                } else if (value < 0.4) {
                    // 4
                    if (height < 0.33) {
                        return mix(color0, color1, height / 0.33);
                    } else if (height < 0.66) {
                        return mix(color1, color2, (height - 0.33) / 0.33);
                    } else {
                        return mix(color2, color3, (height - 0.66) / 0.34);
                    }
                } else if (value < 0.5) {
                    // 5
                    if (height < 0.25) {
                        return mix(color0, color1, height / 0.25);
                    } else if (height < 0.5) {
                        return mix(color1, color2, (height - 0.25) / 0.25);
                    } else if (height < 0.75) {
                        return mix(color2, color3, (height - 0.5) / 0.25);
                    } else {
                        return mix(color3, color4, (height - 0.75) / 0.25);
                    }
                } else if (value < 0.6) {
                    // 6
                    if (height < 0.2) {
                        return mix(color0, color1, height / 0.2);
                    } else if (height < 0.4) {
                        return mix(color1, color2, (height - 0.2) / 0.2);
                    } else if (height < 0.6) {
                        return mix(color2, color3, (height - 0.4) / 0.2);
                    } else if (height < 0.8) {
                        return mix(color3, color4, (height - 0.6) / 0.2);
                    } else {
                        return mix(color4, color5, (height - 0.8) / 0.2);
                    }
                } else if (value < 0.7) {
                    // 7
                    if (height < 0.1667) {
                        return mix(color0, color1, height / 0.1667);
                    } else if (height < 0.3333) {
                        return mix(color1, color2, (height - 0.1667) / 0.1667);
                    } else if (height < 0.5) {
                        return mix(color2, color3, (height - 0.3333) / 0.1667);
                    } else if (height < 0.6667) {
                        return mix(color3, color4, (height - 0.5) / 0.1667);
                    } else if (height < 0.8333) {
                        return mix(color4, color5, (height - 0.6667) / 0.1667);
                    } else {
                        return mix(color5, color6, (height - 0.8333) / 0.1667);
                    }
                } else if (value < 0.8) {
                    // 8
                    if (height < 0.1429) {
                        return mix(color0, color1, height / 0.1429);
                    } else if (height < 0.2857) {
                        return mix(color1, color2, (height - 0.1429) / 0.1429);
                    } else if (height < 0.4286) {
                        return mix(color2, color3, (height - 0.2857) / 0.1429);
                    } else if (height < 0.5714) {
                        return mix(color3, color4, (height - 0.4286) / 0.1429);
                    } else if (height < 0.7143) {
                        return mix(color4, color5, (height - 0.5714) / 0.1429);
                    } else if (height < 0.8571) {
                        return mix(color5, color6, (height - 0.7143) / 0.1429);
                    } else {
                        return mix(color6, color7, (height - 0.8571) / 0.1429);
                    }
                } else if (value < 0.9) {
                    // 9
                    if (height < 0.125) {
                        return mix(color0, color1, height / 0.125);
                    } else if (height < 0.25) {
                        return mix(color1, color2, (height - 0.125) / 0.125);
                    } else if (height < 0.375) {
                        return mix(color2, color3, (height - 0.25) / 0.125);
                    } else if (height < 0.5) {
                        return mix(color3, color4, (height - 0.375) / 0.125);
                    } else if (height < 0.625) {
                        return mix(color4, color5, (height - 0.5) / 0.125);
                    } else if (height < 0.75) {
                        return mix(color5, color6, (height - 0.625) / 0.125);
                    } else if (height < 0.875) {
                        return mix(color6, color7, (height - 0.75) / 0.125);
                    } else {
                        return mix(color7, color8, (height - 0.875) / 0.125);
                    }
                } else {
                    // 10
                    if (height < 0.1111) {
                        return mix(color0, color1, height / 0.1111);
                    } else if (height < 0.2222) {
                        return mix(color1, color2, (height - 0.1111) / 0.1111);
                    } else if (height < 0.3333) {
                        return mix(color2, color3, (height - 0.2222) / 0.1111);
                    } else if (height < 0.4444) {
                        return mix(color3, color4, (height - 0.3333) / 0.1111);
                    } else if (height < 0.5556) {
                        return mix(color4, color5, (height - 0.4444) / 0.1111);
                    } else if (height < 0.6667) {
                        return mix(color5, color6, (height - 0.5556) / 0.1111);
                    } else if (height < 0.7778) {
                        return mix(color6, color7, (height - 0.6667) / 0.1111);
                    } else if (height < 0.8889) {
                        return mix(color7, color8, (height - 0.7778) / 0.1111);
                    } else {
                        return mix(color8, color9, (height - 0.8889) / 0.1111);
                    }
                }
            }

            void main() {
                // 
                vec3 lightDir = normalize(vec3(1.0, 2.0, 0.5));
                vec3 normal;

                // 
                if (abs(vPosition.y) > 0.49) {
                    normal = vec3(0.0, sign(vPosition.y), 0.0);
                } else if (abs(vPosition.x) > 0.49) {
                    normal = vec3(sign(vPosition.x), 0.0, 0.0);
                } else {
                    normal = vec3(0.0, 0.0, sign(vPosition.z));
                }

                float diffuse = max(dot(normal, lightDir), 0.3);

                // 
                float topBrightness = vPosition.y > 0.4 ? 1.2 : 1.0;

                // 
                vec3 gradientColor = getGradientColor(vValue, vHeight);

                gl_FragColor = vec4(gradientColor * diffuse * topBrightness, 1.0);
            }
        `,
        transparent: !1
      });
      return console.log(""), I;
    }
    function x() {
      console.log(" Three.js...");
      const { backgroundColor: D, showGridHelper: I, showAxesHelper: P, cameraPosition: O, enableOrbit: N } = e;
      o = new VI(), o.background = new le(D), console.log(":", D), s = new Ln(75, e.width / e.height, 0.1, 1e3), s.position.set(O.x, O.y, O.z), console.log(":", O), l = new BI({
        antialias: !0,
        powerPreference: "high-performance"
      }), l.setSize(e.width, e.height), l.setPixelRatio(Math.min(window.devicePixelRatio, 2)), console.log(":", e.width, "x", e.height), n.value && (n.value.innerHTML = "", n.value.appendChild(l.domElement), console.log("DOM"));
      const B = new GI(16777215, 0.8);
      o.add(B);
      const F = new UI(16777215, 0.8);
      F.position.set(5, 10, 5), o.add(F), console.log(""), c = new Iu(), o.add(c), console.log(""), f = new HI(), h = new Ce(), S(), console.log("Three.js ");
    }
    function b() {
      return new bl(1, 1, 1, 1, 8, 1);
    }
    function S() {
      var U;
      console.log("..."), p && (c.remove(p), p.geometry.dispose(), p.material.dispose(), p = null, console.log("")), g.length = 0;
      let D = e.data;
      Array.isArray(D) && D.length > 0 && D.every(($) => Array.isArray($) && $.length > 0) || (console.log(""), D = [
        [1, 3, 5, 7, 9],
        [2, 4, 6, 8, 10],
        [3, 5, 7, 9, 11],
        [4, 6, 8, 10, 12],
        [5, 7, 9, 11, 13]
      ]), v = D.length, m = ((U = D[0]) == null ? void 0 : U.length) || 0, console.log(`: ${v} x ${m}`, ":", D);
      let P = 1 / 0, O = -1 / 0;
      for (let $ = 0; $ < v; $++) {
        const ct = D[$];
        if (Array.isArray(ct))
          for (let at = 0; at < m; at++) {
            const lt = ct[at];
            typeof lt == "number" && (lt < P && (P = lt), lt > O && (O = lt));
          }
      }
      P === 1 / 0 && (P = 0), O === -1 / 0 && (O = 1), P === O && (O = P + 1), console.log(`: ${P} - ${O}`), y = _();
      const N = b(), B = v * m, F = new Float32Array(B), G = new Float32Array(B * 3), X = new Float32Array(B * 3);
      let K = 0;
      for (let $ = 0; $ < v; $++) {
        const ct = D[$];
        if (Array.isArray(ct))
          for (let at = 0; at < m; at++) {
            const lt = typeof ct[at] == "number" ? ct[at] : 0, ot = (lt - P) / (O - P), H = 0.1 + ot * e.maxHeight;
            F[K] = ot;
            const st = ($ - (v - 1) / 2) * e.baseSize, ut = (at - (m - 1) / 2) * e.baseSize, Gt = H / 2;
            G[K * 3] = st, G[K * 3 + 1] = Gt, G[K * 3 + 2] = ut, X[K * 3] = e.baseSize, X[K * 3 + 1] = H, X[K * 3 + 2] = e.baseSize, g[K] = {
              value: lt,
              x: $,
              z: at,
              normalizedValue: ot
            }, K++;
          }
      }
      console.log(` ${B} `), N.setAttribute("instanceValue", new Ff(F, 1)), N.setAttribute("instancePosition", new Ff(G, 3)), N.setAttribute("instanceScale", new Ff(X, 3)), p = new O4(N, y, B), c.add(p), T(), console.log("");
    }
    let w = null, A = null;
    function T() {
      w && (o.remove(w), w = null), A && (o.remove(A), A = null);
      const { showGridHelper: D, showAxesHelper: I } = e;
      if (D) {
        const P = Math.max(v, m) * e.baseSize * 1.5, O = Math.max(v, m);
        w = new WI(P, O, 16777215, 8947848), w.position.y = -0.01, o.add(w);
      }
      if (I) {
        const P = Math.max(v, m) * e.baseSize * 0.8;
        A = new XI(P), o.add(A);
      }
    }
    function M() {
      d = requestAnimationFrame(M), u && u.update(), l.render(o, s);
    }
    let E = null;
    function R(D) {
      if (!n.value || !p)
        return;
      const I = n.value.getBoundingClientRect();
      if (D.clientX < I.left || D.clientX > I.right || D.clientY < I.top || D.clientY < I.bottom) {
        i.value.show = !1;
        return;
      }
      E && cancelAnimationFrame(E), E = requestAnimationFrame(() => {
        h.x = (D.clientX - I.left) / I.width * 2 - 1, h.y = -((D.clientY - I.top) / I.height) * 2 + 1, f.setFromCamera(h, s);
        const P = f.intersectObject(p);
        if (P.length > 0) {
          const O = P[0].instanceId;
          if (O !== void 0 && g[O]) {
            const N = g[O];
            i.value = {
              show: !0,
              x: D.clientX - I.left + 10,
              y: D.clientY - I.top - 30,
              content: `: ${N.value.toFixed(2)}<br>: (${N.x}, ${N.z})<br>: ${(N.normalizedValue * 100).toFixed(1)}%`
            };
          }
        } else
          i.value.show = !1;
      });
    }
    function C() {
      !s || !l || (s.aspect = e.width / e.height, s.updateProjectionMatrix(), l.setSize(e.width, e.height));
    }
    return t({
      refresh: S,
      toggleAnimation: () => a.value = !a.value,
      updateData: (D) => {
        S();
      }
    }), (D, I) => (Ra(), Do("div", {
      class: "heatmap-wrapper",
      style: Zu({ width: r.width + "px", height: r.height + "px" })
    }, [
      Hi(i).show ? (Ra(), Do("div", {
        key: 0,
        class: "tooltip",
        style: Zu({ left: Hi(i).x + "px", top: Hi(i).y + "px" }),
        innerHTML: Hi(i).content
      }, null, 12, H4)) : lv("", !0),
      Sr("div", {
        ref_key: "containerRef",
        ref: n,
        class: "three-container"
      }, null, 512)
    ], 4));
  }
}), X4 = /* @__PURE__ */ Rg(W4, [["__scopeId", "data-v-1db22db8"]]), Y4 = Ch(X4), $4 = { class: "heatmap-container" }, Z4 = { class: "coordinates" }, q4 = {
  key: 0,
  class: "controls"
}, K4 = { class: "data-info" }, j4 = {
  key: 1,
  class: "legend"
}, J4 = /* @__PURE__ */ Object.assign({ name: "HeatMap2D" }, {
  __name: "HeatMap2D",
  props: {
    width: { type: Number, default: 612 },
    height: { type: Number, default: 831 },
    blockWidth: { type: Number, default: 36 },
    blockHeight: { type: Number, default: 36 },
    refreshTrigger: { type: [Number, String, Boolean], default: null },
    // 
    showControls: { type: Boolean, default: !1 },
    showLegend: { type: Boolean, default: !1 },
    heatmapData: { type: Array, default: () => [] }
  },
  setup(r) {
    const t = r, e = Rr(t.width ? t.width : 0), n = Rr(t.height), i = Rr(t.blockWidth), a = Rr(t.blockHeight), o = Rr(null);
    let s = null;
    const l = Rr(0), u = Rr(0), c = Rr([]), f = Rr(0), h = Rr(0), d = hF({
      visible: !1,
      x: 0,
      y: 0,
      col: 0,
      row: 0,
      value: 0,
      rawX: 0,
      rawY: 0
    });
    let p = !1;
    const g = [
      { threshold: 0.1, color: "#08315f" },
      { threshold: 0.2, color: "#4588bb" },
      { threshold: 0.3, color: "#85bee3" },
      { threshold: 0.4, color: "#bedcf4" },
      { threshold: 0.5, color: "#e4d7dc" },
      { threshold: 0.6, color: "#fcdfda" },
      { threshold: 0.7, color: "#f9b6a2" },
      { threshold: 0.8, color: "#f97860" },
      { threshold: 0.9, color: "#c81626" },
      { threshold: 1, color: "#af000f" }
    ];
    Vp(
      () => t.heatmapData,
      (D) => {
        c.value = D, S();
      },
      { deep: !0 }
    );
    function v(D, I) {
      if (I === 0)
        return "transparent";
      const P = D / I;
      for (let O of g)
        if (P <= O.threshold)
          return O.color;
      return g[g.length - 1].color;
    }
    const m = Bp(() => {
      var I;
      let D = 0;
      for (let P = 0; P < u.value; P++)
        for (let O = 0; O < l.value; O++)
          ((I = c.value[P]) == null ? void 0 : I[O]) > 0 && D++;
      return D;
    }), y = Bp(() => {
      var I;
      let D = 0;
      for (let P = 0; P < u.value; P++)
        for (let O = 0; O < l.value; O++) {
          const N = ((I = c.value[P]) == null ? void 0 : I[O]) || 0;
          N > D && (D = N);
        }
      return D;
    }), _ = Bp(() => {
      var P;
      let D = 0, I = 0;
      for (let O = 0; O < u.value; O++)
        for (let N = 0; N < l.value; N++) {
          const B = ((P = c.value[O]) == null ? void 0 : P[N]) || 0;
          B > 0 && (D += B, I++);
        }
      return I > 0 ? D / I : 0;
    });
    function x() {
      l.value = Math.ceil(e.value / i.value), u.value = Math.ceil(n.value / a.value);
    }
    function b() {
      c.value = Array(u.value).fill().map(() => Array(l.value).fill(0));
    }
    function S() {
      var D;
      if (s) {
        s.clearRect(0, 0, e.value, n.value);
        for (let I = 0; I < u.value; I++)
          for (let P = 0; P < l.value; P++) {
            const O = ((D = c.value[I]) == null ? void 0 : D[P]) || 0;
            if (O > 0) {
              const N = P * i.value, B = I * a.value;
              s.fillStyle = v(O, y.value), s.fillRect(N, B, i.value, a.value);
            }
          }
      }
    }
    function w(D, I, P, O) {
      for (let N = 0; N < u.value; N++)
        for (let B = 0; B < l.value; B++) {
          const F = B * i.value + i.value / 2, G = N * a.value + a.value / 2, X = Math.sqrt((F - D) ** 2 + (G - I) ** 2);
          if (X < P) {
            const K = O * (1 - X / P);
            c.value[N][B] = Math.max(c.value[N][B], Math.floor(K));
          }
        }
    }
    function A(D, I, P, O) {
      const N = Math.floor(D / i.value), B = Math.floor(I / a.value), F = Math.ceil(P / Math.max(i.value, a.value)), G = Math.max(0, N - F), X = Math.min(l.value - 1, N + F), K = Math.max(0, B - F), U = Math.min(u.value - 1, B + F);
      for (let $ = K; $ <= U; $++)
        for (let ct = G; ct <= X; ct++) {
          const lt = Math.sqrt((ct - N) ** 2 + ($ - B) ** 2) * Math.max(i.value, a.value);
          if (lt < P) {
            const ot = O * (1 - lt / P);
            c.value[$][ct] = Math.max(c.value[$][ct], Math.floor(ot));
          }
        }
      S();
    }
    function T() {
      for (let D = 0; D < u.value; D++)
        for (let I = 0; I < l.value; I++)
          c.value[D][I] = Math.random() < 0.1 ? Math.floor(Math.random() * 100) : 0;
      S();
    }
    function M() {
      E(), w(0.1 * e.value, 0.1 * n.value, 50, 90), w(0.3 * e.value, 0.2 * n.value, 40, 80), w(0.2 * e.value, 0.5 * n.value, 60, 95), S();
    }
    function E() {
      c.value.forEach((D) => D.fill(0)), S();
    }
    function R(D) {
      var F;
      const I = o.value.getBoundingClientRect(), P = D.clientX - I.left, O = D.clientY - I.top;
      f.value = Math.floor(P), h.value = Math.floor(O);
      const N = Math.floor(P / i.value), B = Math.floor(O / a.value);
      N >= 0 && N < l.value && B >= 0 && B < u.value ? (d.visible = !0, d.col = N, d.row = B, d.value = ((F = c.value[B]) == null ? void 0 : F[N]) || 0, d.rawX = P, d.rawY = O, d.x = D.clientX + 15, d.y = D.clientY - 30) : d.visible = !1, p && A(P, O, 15, 60);
    }
    function C() {
      p = !1, d.visible = !1;
    }
    return Lg(() => {
      const D = o.value;
      D.width = t.width, D.height = t.height, s = D.getContext("2d"), x(), t.heatmapData && t.heatmapData.length > 0 ? c.value = t.heatmapData : b(), S();
    }), Vp(
      () => [t.width, t.height, t.blockWidth, t.blockHeight],
      () => {
        e.value = t.width, n.value = t.height, i.value = t.blockWidth, a.value = t.blockHeight, dF(() => {
          const D = o.value;
          D && (D.width = e.value, D.height = n.value, s = D.getContext("2d"), x(), S());
        });
      }
      //  { immediate: true }
    ), Vp(
      () => t.refreshTrigger,
      () => {
        t.refreshTrigger !== null && S();
      }
    ), (D, I) => (Ra(), Do("div", $4, [
      Sr("div", {
        class: "canvas-wrapper",
        style: Zu({ width: `${e.value}px`, height: `${n.value}px` })
      }, [
        Sr("canvas", {
          ref_key: "heatmapCanvas",
          ref: o,
          onMousemove: R,
          onMouseleave: C,
          onContextmenu: I[0] || (I[0] = pF(() => {
          }, ["prevent"]))
        }, null, 544),
        Sr("div", Z4, "X: " + Mn(f.value) + ", Y: " + Mn(h.value), 1),
        Sr("div", {
          class: vF(["tooltip", { show: d.visible }]),
          style: Zu({ left: d.x + "px", top: d.y + "px" })
        }, [
          I[1] || (I[1] = Sr("h3", null, "", -1)),
          Sr("p", null, ": (" + Mn(d.col) + ", " + Mn(d.row) + ")", 1),
          Sr("p", null, ": " + Mn(d.value), 1),
          Sr("p", null, ": (" + Mn(Math.floor(d.rawX)) + ", " + Mn(Math.floor(d.rawY)) + ")", 1)
        ], 6)
      ], 4),
      t.showControls ? (Ra(), Do("div", q4, [
        Sr("div", K4, " : " + Mn(l.value) + "  " + Mn(u.value) + " ( " + Mn(l.value * u.value) + " ) : " + Mn(m.value) + " : " + Mn(y.value) + " : " + Mn(_.value.toFixed(2)), 1),
        Sr("div", { class: "btn-group" }, [
          Sr("button", { onClick: T }, ""),
          Sr("button", { onClick: M }, ""),
          Sr("button", { onClick: E }, "")
        ])
      ])) : lv("", !0),
      t.showLegend ? (Ra(), Do("div", j4, [...I[2] || (I[2] = [
        Sr("div", { class: "color-scale" }, null, -1),
        Sr("div", { class: "color-labels" }, [
          Sr("span", null, ""),
          Sr("span", null, "")
        ], -1)
      ])])) : lv("", !0)
    ]));
  }
}), Q4 = /* @__PURE__ */ Rg(J4, [["__scopeId", "data-v-fa92eb4d"]]), tW = Ch(Q4);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Z_ = function(r, t) {
  return Z_ = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, n) {
    e.__proto__ = n;
  } || function(e, n) {
    for (var i in n)
      Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
  }, Z_(r, t);
};
function W(r, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  Z_(r, t);
  function e() {
    this.constructor = r;
  }
  r.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
var eW = /* @__PURE__ */ function() {
  function r() {
    this.firefox = !1, this.ie = !1, this.edge = !1, this.newEdge = !1, this.weChat = !1;
  }
  return r;
}(), rW = /* @__PURE__ */ function() {
  function r() {
    this.browser = new eW(), this.node = !1, this.wxa = !1, this.worker = !1, this.svgSupported = !1, this.touchEventsSupported = !1, this.pointerEventsSupported = !1, this.domSupported = !1, this.transformSupported = !1, this.transform3dSupported = !1, this.hasGlobalWindow = typeof window < "u";
  }
  return r;
}(), oe = new rW();
typeof wx == "object" && typeof wx.getSystemInfoSync == "function" ? (oe.wxa = !0, oe.touchEventsSupported = !0) : typeof document > "u" && typeof self < "u" ? oe.worker = !0 : !oe.hasGlobalWindow || "Deno" in window || typeof navigator < "u" && typeof navigator.userAgent == "string" && navigator.userAgent.indexOf("Node.js") > -1 ? (oe.node = !0, oe.svgSupported = !0) : nW(navigator.userAgent, oe);
function nW(r, t) {
  var e = t.browser, n = r.match(/Firefox\/([\d.]+)/), i = r.match(/MSIE\s([\d.]+)/) || r.match(/Trident\/.+?rv:(([\d.]+))/), a = r.match(/Edge?\/([\d.]+)/), o = /micromessenger/i.test(r);
  n && (e.firefox = !0, e.version = n[1]), i && (e.ie = !0, e.version = i[1]), a && (e.edge = !0, e.version = a[1], e.newEdge = +a[1].split(".")[0] > 18), o && (e.weChat = !0), t.svgSupported = typeof SVGRect < "u", t.touchEventsSupported = "ontouchstart" in window && !e.ie && !e.edge, t.pointerEventsSupported = "onpointerdown" in window && (e.edge || e.ie && +e.version >= 11);
  var s = t.domSupported = typeof document < "u";
  if (s) {
    var l = document.documentElement.style;
    t.transform3dSupported = (e.ie && "transition" in l || e.edge || "WebKitCSSMatrix" in window && "m11" in new WebKitCSSMatrix() || "MozPerspective" in l) && !("OTransition" in l), t.transformSupported = t.transform3dSupported || e.ie && +e.version >= 9;
  }
}
var m1 = 12, YI = "sans-serif", za = m1 + "px " + YI, iW = 20, aW = 100, oW = "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N";
function sW(r) {
  var t = {};
  if (typeof JSON > "u")
    return t;
  for (var e = 0; e < r.length; e++) {
    var n = String.fromCharCode(e + 32), i = (r.charCodeAt(e) - iW) / aW;
    t[n] = i;
  }
  return t;
}
var lW = sW(oW), xi = {
  createCanvas: function() {
    return typeof document < "u" && document.createElement("canvas");
  },
  measureText: /* @__PURE__ */ function() {
    var r, t;
    return function(e, n) {
      if (!r) {
        var i = xi.createCanvas();
        r = i && i.getContext("2d");
      }
      if (r)
        return t !== n && (t = r.font = n || za), r.measureText(e);
      e = e || "", n = n || za;
      var a = /((?:\d+)?\.?\d*)px/.exec(n), o = a && +a[1] || m1, s = 0;
      if (n.indexOf("mono") >= 0)
        s = o * e.length;
      else
        for (var l = 0; l < e.length; l++) {
          var u = lW[e[l]];
          s += u == null ? o : u * o;
        }
      return { width: s };
    };
  }(),
  loadImage: function(r, t, e) {
    var n = new Image();
    return n.onload = t, n.onerror = e, n.src = r, n;
  }
}, $I = ea([
  "Function",
  "RegExp",
  "Date",
  "Error",
  "CanvasGradient",
  "CanvasPattern",
  "Image",
  "Canvas"
], function(r, t) {
  return r["[object " + t + "]"] = !0, r;
}, {}), ZI = ea([
  "Int8",
  "Uint8",
  "Uint8Clamped",
  "Int16",
  "Uint16",
  "Int32",
  "Uint32",
  "Float32",
  "Float64"
], function(r, t) {
  return r["[object " + t + "Array]"] = !0, r;
}, {}), yc = Object.prototype.toString, Bg = Array.prototype, uW = Bg.forEach, cW = Bg.filter, y1 = Bg.slice, fW = Bg.map, _T = (function() {
}).constructor, Md = _T ? _T.prototype : null, _1 = "__proto__", hW = 2311;
function qI() {
  return hW++;
}
function gi() {
  for (var r = [], t = 0; t < arguments.length; t++)
    r[t] = arguments[t];
  typeof console < "u" && console.error.apply(console, r);
}
function Ct(r) {
  if (r == null || typeof r != "object")
    return r;
  var t = r, e = yc.call(r);
  if (e === "[object Array]") {
    if (!zf(r)) {
      t = [];
      for (var n = 0, i = r.length; n < i; n++)
        t[n] = Ct(r[n]);
    }
  } else if (ZI[e]) {
    if (!zf(r)) {
      var a = r.constructor;
      if (a.from)
        t = a.from(r);
      else {
        t = new a(r.length);
        for (var n = 0, i = r.length; n < i; n++)
          t[n] = r[n];
      }
    }
  } else if (!$I[e] && !zf(r) && !fl(r)) {
    t = {};
    for (var o in r)
      r.hasOwnProperty(o) && o !== _1 && (t[o] = Ct(r[o]));
  }
  return t;
}
function qt(r, t, e) {
  if (!Dt(t) || !Dt(r))
    return e ? Ct(t) : r;
  for (var n in t)
    if (t.hasOwnProperty(n) && n !== _1) {
      var i = r[n], a = t[n];
      Dt(a) && Dt(i) && !et(a) && !et(i) && !fl(a) && !fl(i) && !xT(a) && !xT(i) && !zf(a) && !zf(i) ? qt(i, a, e) : (e || !(n in r)) && (r[n] = Ct(t[n]));
    }
  return r;
}
function x1(r, t) {
  for (var e = r[0], n = 1, i = r.length; n < i; n++)
    e = qt(e, r[n], t);
  return e;
}
function J(r, t) {
  if (Object.assign)
    Object.assign(r, t);
  else
    for (var e in t)
      t.hasOwnProperty(e) && e !== _1 && (r[e] = t[e]);
  return r;
}
function kt(r, t, e) {
  for (var n = se(t), i = 0, a = n.length; i < a; i++) {
    var o = n[i];
    (e ? t[o] != null : r[o] == null) && (r[o] = t[o]);
  }
  return r;
}
function Zt(r, t) {
  if (r) {
    if (r.indexOf)
      return r.indexOf(t);
    for (var e = 0, n = r.length; e < n; e++)
      if (r[e] === t)
        return e;
  }
  return -1;
}
function dW(r, t) {
  var e = r.prototype;
  function n() {
  }
  n.prototype = t.prototype, r.prototype = new n();
  for (var i in e)
    e.hasOwnProperty(i) && (r.prototype[i] = e[i]);
  r.prototype.constructor = r, r.superClass = t;
}
function hr(r, t, e) {
  if (r = "prototype" in r ? r.prototype : r, t = "prototype" in t ? t.prototype : t, Object.getOwnPropertyNames)
    for (var n = Object.getOwnPropertyNames(t), i = 0; i < n.length; i++) {
      var a = n[i];
      a !== "constructor" && (e ? t[a] != null : r[a] == null) && (r[a] = t[a]);
    }
  else
    kt(r, t, e);
}
function qr(r) {
  return !r || typeof r == "string" ? !1 : typeof r.length == "number";
}
function L(r, t, e) {
  if (r && t)
    if (r.forEach && r.forEach === uW)
      r.forEach(t, e);
    else if (r.length === +r.length)
      for (var n = 0, i = r.length; n < i; n++)
        t.call(e, r[n], n, r);
    else
      for (var a in r)
        r.hasOwnProperty(a) && t.call(e, r[a], a, r);
}
function rt(r, t, e) {
  if (!r)
    return [];
  if (!t)
    return S1(r);
  if (r.map && r.map === fW)
    return r.map(t, e);
  for (var n = [], i = 0, a = r.length; i < a; i++)
    n.push(t.call(e, r[i], i, r));
  return n;
}
function ea(r, t, e, n) {
  if (r && t) {
    for (var i = 0, a = r.length; i < a; i++)
      e = t.call(n, e, r[i], i, r);
    return e;
  }
}
function Te(r, t, e) {
  if (!r)
    return [];
  if (!t)
    return S1(r);
  if (r.filter && r.filter === cW)
    return r.filter(t, e);
  for (var n = [], i = 0, a = r.length; i < a; i++)
    t.call(e, r[i], i, r) && n.push(r[i]);
  return n;
}
function wl(r, t, e) {
  if (r && t) {
    for (var n = 0, i = r.length; n < i; n++)
      if (t.call(e, r[n], n, r))
        return r[n];
  }
}
function se(r) {
  if (!r)
    return [];
  if (Object.keys)
    return Object.keys(r);
  var t = [];
  for (var e in r)
    r.hasOwnProperty(e) && t.push(e);
  return t;
}
function pW(r, t) {
  for (var e = [], n = 2; n < arguments.length; n++)
    e[n - 2] = arguments[n];
  return function() {
    return r.apply(t, e.concat(y1.call(arguments)));
  };
}
var mt = Md && Tt(Md.bind) ? Md.call.bind(Md.bind) : pW;
function Yt(r) {
  for (var t = [], e = 1; e < arguments.length; e++)
    t[e - 1] = arguments[e];
  return function() {
    return r.apply(this, t.concat(y1.call(arguments)));
  };
}
function et(r) {
  return Array.isArray ? Array.isArray(r) : yc.call(r) === "[object Array]";
}
function Tt(r) {
  return typeof r == "function";
}
function pt(r) {
  return typeof r == "string";
}
function mv(r) {
  return yc.call(r) === "[object String]";
}
function fe(r) {
  return typeof r == "number";
}
function Dt(r) {
  var t = typeof r;
  return t === "function" || !!r && t === "object";
}
function xT(r) {
  return !!$I[yc.call(r)];
}
function fn(r) {
  return !!ZI[yc.call(r)];
}
function fl(r) {
  return typeof r == "object" && typeof r.nodeType == "number" && typeof r.ownerDocument == "object";
}
function Vg(r) {
  return r.colorStops != null;
}
function vW(r) {
  return r.image != null;
}
function KI(r) {
  return yc.call(r) === "[object RegExp]";
}
function Or(r) {
  return r !== r;
}
function gr() {
  for (var r = [], t = 0; t < arguments.length; t++)
    r[t] = arguments[t];
  for (var e = 0, n = r.length; e < n; e++)
    if (r[e] != null)
      return r[e];
}
function bt(r, t) {
  return r ?? t;
}
function ln(r, t, e) {
  return r ?? t ?? e;
}
function S1(r) {
  for (var t = [], e = 1; e < arguments.length; e++)
    t[e - 1] = arguments[e];
  return y1.apply(r, t);
}
function Fg(r) {
  if (typeof r == "number")
    return [r, r, r, r];
  var t = r.length;
  return t === 2 ? [r[0], r[1], r[0], r[1]] : t === 3 ? [r[0], r[1], r[2], r[1]] : r;
}
function St(r, t) {
  if (!r)
    throw new Error(t);
}
function ti(r) {
  return r == null ? null : typeof r.trim == "function" ? r.trim() : r.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
}
var jI = "__ec_primitive__";
function yv(r) {
  r[jI] = !0;
}
function zf(r) {
  return r[jI];
}
var gW = function() {
  function r() {
    this.data = {};
  }
  return r.prototype.delete = function(t) {
    var e = this.has(t);
    return e && delete this.data[t], e;
  }, r.prototype.has = function(t) {
    return this.data.hasOwnProperty(t);
  }, r.prototype.get = function(t) {
    return this.data[t];
  }, r.prototype.set = function(t, e) {
    return this.data[t] = e, this;
  }, r.prototype.keys = function() {
    return se(this.data);
  }, r.prototype.forEach = function(t) {
    var e = this.data;
    for (var n in e)
      e.hasOwnProperty(n) && t(e[n], n);
  }, r;
}(), JI = typeof Map == "function";
function mW() {
  return JI ? /* @__PURE__ */ new Map() : new gW();
}
var yW = function() {
  function r(t) {
    var e = et(t);
    this.data = mW();
    var n = this;
    t instanceof r ? t.each(i) : t && L(t, i);
    function i(a, o) {
      e ? n.set(a, o) : n.set(o, a);
    }
  }
  return r.prototype.hasKey = function(t) {
    return this.data.has(t);
  }, r.prototype.get = function(t) {
    return this.data.get(t);
  }, r.prototype.set = function(t, e) {
    return this.data.set(t, e), e;
  }, r.prototype.each = function(t, e) {
    this.data.forEach(function(n, i) {
      t.call(e, n, i);
    });
  }, r.prototype.keys = function() {
    var t = this.data.keys();
    return JI ? Array.from(t) : t;
  }, r.prototype.removeKey = function(t) {
    this.data.delete(t);
  }, r;
}();
function wt(r) {
  return new yW(r);
}
function th(r, t) {
  for (var e = new r.constructor(r.length + t.length), n = 0; n < r.length; n++)
    e[n] = r[n];
  for (var i = r.length, n = 0; n < t.length; n++)
    e[n + i] = t[n];
  return e;
}
function zg(r, t) {
  var e;
  if (Object.create)
    e = Object.create(r);
  else {
    var n = function() {
    };
    n.prototype = r, e = new n();
  }
  return t && J(e, t), e;
}
function QI(r) {
  var t = r.style;
  t.webkitUserSelect = "none", t.userSelect = "none", t.webkitTapHighlightColor = "rgba(0,0,0,0)", t["-webkit-touch-callout"] = "none";
}
function _t(r, t) {
  return r.hasOwnProperty(t);
}
function er() {
}
var Up = 180 / Math.PI;
function Ml(r, t) {
  return r == null && (r = 0), t == null && (t = 0), [r, t];
}
function en(r, t) {
  return r[0] = t[0], r[1] = t[1], r;
}
function Ia(r) {
  return [r[0], r[1]];
}
function b1(r, t, e) {
  return r[0] = t, r[1] = e, r;
}
function ST(r, t, e) {
  return r[0] = t[0] + e[0], r[1] = t[1] + e[1], r;
}
function q_(r, t, e, n) {
  return r[0] = t[0] + e[0] * n, r[1] = t[1] + e[1] * n, r;
}
function Zs(r, t, e) {
  return r[0] = t[0] - e[0], r[1] = t[1] - e[1], r;
}
function K_(r) {
  return Math.sqrt(_W(r));
}
function _W(r) {
  return r[0] * r[0] + r[1] * r[1];
}
function Gp(r, t, e) {
  return r[0] = t[0] * e, r[1] = t[1] * e, r;
}
function _c(r, t) {
  var e = K_(t);
  return e === 0 ? (r[0] = 0, r[1] = 0) : (r[0] = t[0] / e, r[1] = t[1] / e), r;
}
function j_(r, t) {
  return Math.sqrt((r[0] - t[0]) * (r[0] - t[0]) + (r[1] - t[1]) * (r[1] - t[1]));
}
var xo = j_;
function xW(r, t) {
  return (r[0] - t[0]) * (r[0] - t[0]) + (r[1] - t[1]) * (r[1] - t[1]);
}
var el = xW;
function Hp(r, t, e, n) {
  return r[0] = t[0] + n * (e[0] - t[0]), r[1] = t[1] + n * (e[1] - t[1]), r;
}
function rr(r, t, e) {
  var n = t[0], i = t[1];
  return r[0] = e[0] * n + e[2] * i + e[4], r[1] = e[1] * n + e[3] * i + e[5], r;
}
function So(r, t, e) {
  return r[0] = Math.min(t[0], e[0]), r[1] = Math.min(t[1], e[1]), r;
}
function bo(r, t, e) {
  return r[0] = Math.max(t[0], e[0]), r[1] = Math.max(t[1], e[1]), r;
}
var Jl = /* @__PURE__ */ function() {
  function r(t, e) {
    this.target = t, this.topTarget = e && e.topTarget;
  }
  return r;
}(), SW = function() {
  function r(t) {
    this.handler = t, t.on("mousedown", this._dragStart, this), t.on("mousemove", this._drag, this), t.on("mouseup", this._dragEnd, this);
  }
  return r.prototype._dragStart = function(t) {
    for (var e = t.target; e && !e.draggable; )
      e = e.parent || e.__hostTarget;
    e && (this._draggingTarget = e, e.dragging = !0, this._x = t.offsetX, this._y = t.offsetY, this.handler.dispatchToElement(new Jl(e, t), "dragstart", t.event));
  }, r.prototype._drag = function(t) {
    var e = this._draggingTarget;
    if (e) {
      var n = t.offsetX, i = t.offsetY, a = n - this._x, o = i - this._y;
      this._x = n, this._y = i, e.drift(a, o, t), this.handler.dispatchToElement(new Jl(e, t), "drag", t.event);
      var s = this.handler.findHover(n, i, e).target, l = this._dropTarget;
      this._dropTarget = s, e !== s && (l && s !== l && this.handler.dispatchToElement(new Jl(l, t), "dragleave", t.event), s && s !== l && this.handler.dispatchToElement(new Jl(s, t), "dragenter", t.event));
    }
  }, r.prototype._dragEnd = function(t) {
    var e = this._draggingTarget;
    e && (e.dragging = !1), this.handler.dispatchToElement(new Jl(e, t), "dragend", t.event), this._dropTarget && this.handler.dispatchToElement(new Jl(this._dropTarget, t), "drop", t.event), this._draggingTarget = null, this._dropTarget = null;
  }, r;
}(), oi = function() {
  function r(t) {
    t && (this._$eventProcessor = t);
  }
  return r.prototype.on = function(t, e, n, i) {
    this._$handlers || (this._$handlers = {});
    var a = this._$handlers;
    if (typeof e == "function" && (i = n, n = e, e = null), !n || !t)
      return this;
    var o = this._$eventProcessor;
    e != null && o && o.normalizeQuery && (e = o.normalizeQuery(e)), a[t] || (a[t] = []);
    for (var s = 0; s < a[t].length; s++)
      if (a[t][s].h === n)
        return this;
    var l = {
      h: n,
      query: e,
      ctx: i || this,
      callAtLast: n.zrEventfulCallAtLast
    }, u = a[t].length - 1, c = a[t][u];
    return c && c.callAtLast ? a[t].splice(u, 0, l) : a[t].push(l), this;
  }, r.prototype.isSilent = function(t) {
    var e = this._$handlers;
    return !e || !e[t] || !e[t].length;
  }, r.prototype.off = function(t, e) {
    var n = this._$handlers;
    if (!n)
      return this;
    if (!t)
      return this._$handlers = {}, this;
    if (e) {
      if (n[t]) {
        for (var i = [], a = 0, o = n[t].length; a < o; a++)
          n[t][a].h !== e && i.push(n[t][a]);
        n[t] = i;
      }
      n[t] && n[t].length === 0 && delete n[t];
    } else
      delete n[t];
    return this;
  }, r.prototype.trigger = function(t) {
    for (var e = [], n = 1; n < arguments.length; n++)
      e[n - 1] = arguments[n];
    if (!this._$handlers)
      return this;
    var i = this._$handlers[t], a = this._$eventProcessor;
    if (i)
      for (var o = e.length, s = i.length, l = 0; l < s; l++) {
        var u = i[l];
        if (!(a && a.filter && u.query != null && !a.filter(t, u.query)))
          switch (o) {
            case 0:
              u.h.call(u.ctx);
              break;
            case 1:
              u.h.call(u.ctx, e[0]);
              break;
            case 2:
              u.h.call(u.ctx, e[0], e[1]);
              break;
            default:
              u.h.apply(u.ctx, e);
              break;
          }
      }
    return a && a.afterTrigger && a.afterTrigger(t), this;
  }, r.prototype.triggerWithContext = function(t) {
    for (var e = [], n = 1; n < arguments.length; n++)
      e[n - 1] = arguments[n];
    if (!this._$handlers)
      return this;
    var i = this._$handlers[t], a = this._$eventProcessor;
    if (i)
      for (var o = e.length, s = e[o - 1], l = i.length, u = 0; u < l; u++) {
        var c = i[u];
        if (!(a && a.filter && c.query != null && !a.filter(t, c.query)))
          switch (o) {
            case 0:
              c.h.call(s);
              break;
            case 1:
              c.h.call(s, e[0]);
              break;
            case 2:
              c.h.call(s, e[0], e[1]);
              break;
            default:
              c.h.apply(s, e.slice(1, o - 1));
              break;
          }
      }
    return a && a.afterTrigger && a.afterTrigger(t), this;
  }, r;
}(), bW = Math.log(2);
function J_(r, t, e, n, i, a) {
  var o = n + "-" + i, s = r.length;
  if (a.hasOwnProperty(o))
    return a[o];
  if (t === 1) {
    var l = Math.round(Math.log((1 << s) - 1 & ~i) / bW);
    return r[e][l];
  }
  for (var u = n | 1 << e, c = e + 1; n & 1 << c; )
    c++;
  for (var f = 0, h = 0, d = 0; h < s; h++) {
    var p = 1 << h;
    p & i || (f += (d % 2 ? -1 : 1) * r[e][h] * J_(r, t - 1, c, u, i | p, a), d++);
  }
  return a[o] = f, f;
}
function bT(r, t) {
  var e = [
    [r[0], r[1], 1, 0, 0, 0, -t[0] * r[0], -t[0] * r[1]],
    [0, 0, 0, r[0], r[1], 1, -t[1] * r[0], -t[1] * r[1]],
    [r[2], r[3], 1, 0, 0, 0, -t[2] * r[2], -t[2] * r[3]],
    [0, 0, 0, r[2], r[3], 1, -t[3] * r[2], -t[3] * r[3]],
    [r[4], r[5], 1, 0, 0, 0, -t[4] * r[4], -t[4] * r[5]],
    [0, 0, 0, r[4], r[5], 1, -t[5] * r[4], -t[5] * r[5]],
    [r[6], r[7], 1, 0, 0, 0, -t[6] * r[6], -t[6] * r[7]],
    [0, 0, 0, r[6], r[7], 1, -t[7] * r[6], -t[7] * r[7]]
  ], n = {}, i = J_(e, 8, 0, 0, 0, n);
  if (i !== 0) {
    for (var a = [], o = 0; o < 8; o++)
      for (var s = 0; s < 8; s++)
        a[s] == null && (a[s] = 0), a[s] += ((o + s) % 2 ? -1 : 1) * J_(e, 7, o === 0 ? 1 : 0, 1 << o, 1 << s, n) / i * t[o];
    return function(l, u, c) {
      var f = u * a[6] + c * a[7] + 1;
      l[0] = (u * a[0] + c * a[1] + a[2]) / f, l[1] = (u * a[3] + c * a[4] + a[5]) / f;
    };
  }
}
var _v = "___zrEVENTSAVED", uy = [];
function wW(r, t, e, n, i) {
  return Q_(uy, t, n, i, !0) && Q_(r, e, uy[0], uy[1]);
}
function MW(r, t) {
  r && e(r), t && e(t);
  function e(n) {
    var i = n[_v];
    i && (i.clearMarkers && i.clearMarkers(), delete n[_v]);
  }
}
function Q_(r, t, e, n, i) {
  if (t.getBoundingClientRect && oe.domSupported && !tP(t)) {
    var a = t[_v] || (t[_v] = {}), o = TW(t, a), s = AW(o, a, i);
    if (s)
      return s(r, e, n), !0;
  }
  return !1;
}
function TW(r, t) {
  var e = t.markers;
  if (e)
    return e;
  e = t.markers = [];
  for (var n = ["left", "right"], i = ["top", "bottom"], a = 0; a < 4; a++) {
    var o = document.createElement("div"), s = o.style, l = a % 2, u = (a >> 1) % 2;
    s.cssText = [
      "position: absolute",
      "visibility: hidden",
      "padding: 0",
      "margin: 0",
      "border-width: 0",
      "user-select: none",
      "width:0",
      "height:0",
      n[l] + ":0",
      i[u] + ":0",
      n[1 - l] + ":auto",
      i[1 - u] + ":auto",
      ""
    ].join("!important;"), r.appendChild(o), e.push(o);
  }
  return t.clearMarkers = function() {
    L(e, function(c) {
      c.parentNode && c.parentNode.removeChild(c);
    });
  }, e;
}
function AW(r, t, e) {
  for (var n = e ? "invTrans" : "trans", i = t[n], a = t.srcCoords, o = [], s = [], l = !0, u = 0; u < 4; u++) {
    var c = r[u].getBoundingClientRect(), f = 2 * u, h = c.left, d = c.top;
    o.push(h, d), l = l && a && h === a[f] && d === a[f + 1], s.push(r[u].offsetLeft, r[u].offsetTop);
  }
  return l && i ? i : (t.srcCoords = o, t[n] = e ? bT(s, o) : bT(o, s));
}
function tP(r) {
  return r.nodeName.toUpperCase() === "CANVAS";
}
var EW = /([&<>"'])/g, CW = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function on(r) {
  return r == null ? "" : (r + "").replace(EW, function(t, e) {
    return CW[e];
  });
}
var DW = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, cy = [], LW = oe.browser.firefox && +oe.browser.version.split(".")[0] < 39;
function tx(r, t, e, n) {
  return e = e || {}, n ? wT(r, t, e) : LW && t.layerX != null && t.layerX !== t.offsetX ? (e.zrX = t.layerX, e.zrY = t.layerY) : t.offsetX != null ? (e.zrX = t.offsetX, e.zrY = t.offsetY) : wT(r, t, e), e;
}
function wT(r, t, e) {
  if (oe.domSupported && r.getBoundingClientRect) {
    var n = t.clientX, i = t.clientY;
    if (tP(r)) {
      var a = r.getBoundingClientRect();
      e.zrX = n - a.left, e.zrY = i - a.top;
      return;
    } else if (Q_(cy, r, n, i)) {
      e.zrX = cy[0], e.zrY = cy[1];
      return;
    }
  }
  e.zrX = e.zrY = 0;
}
function w1(r) {
  return r || window.event;
}
function Yn(r, t, e) {
  if (t = w1(t), t.zrX != null)
    return t;
  var n = t.type, i = n && n.indexOf("touch") >= 0;
  if (i) {
    var o = n !== "touchend" ? t.targetTouches[0] : t.changedTouches[0];
    o && tx(r, o, t, e);
  } else {
    tx(r, t, t, e);
    var a = RW(t);
    t.zrDelta = a ? a / 120 : -(t.detail || 0) / 3;
  }
  var s = t.button;
  return t.which == null && s !== void 0 && DW.test(t.type) && (t.which = s & 1 ? 1 : s & 2 ? 3 : s & 4 ? 2 : 0), t;
}
function RW(r) {
  var t = r.wheelDelta;
  if (t)
    return t;
  var e = r.deltaX, n = r.deltaY;
  if (e == null || n == null)
    return t;
  var i = Math.abs(n !== 0 ? n : e), a = n > 0 ? -1 : n < 0 ? 1 : e > 0 ? -1 : 1;
  return 3 * i * a;
}
function ex(r, t, e, n) {
  r.addEventListener(t, e, n);
}
function IW(r, t, e, n) {
  r.removeEventListener(t, e, n);
}
var Ua = function(r) {
  r.preventDefault(), r.stopPropagation(), r.cancelBubble = !0;
};
function MT(r) {
  return r.which === 2 || r.which === 3;
}
var PW = function() {
  function r() {
    this._track = [];
  }
  return r.prototype.recognize = function(t, e, n) {
    return this._doTrack(t, e, n), this._recognize(t);
  }, r.prototype.clear = function() {
    return this._track.length = 0, this;
  }, r.prototype._doTrack = function(t, e, n) {
    var i = t.touches;
    if (i) {
      for (var a = {
        points: [],
        touches: [],
        target: e,
        event: t
      }, o = 0, s = i.length; o < s; o++) {
        var l = i[o], u = tx(n, l, {});
        a.points.push([u.zrX, u.zrY]), a.touches.push(l);
      }
      this._track.push(a);
    }
  }, r.prototype._recognize = function(t) {
    for (var e in fy)
      if (fy.hasOwnProperty(e)) {
        var n = fy[e](this._track, t);
        if (n)
          return n;
      }
  }, r;
}();
function TT(r) {
  var t = r[1][0] - r[0][0], e = r[1][1] - r[0][1];
  return Math.sqrt(t * t + e * e);
}
function NW(r) {
  return [
    (r[0][0] + r[1][0]) / 2,
    (r[0][1] + r[1][1]) / 2
  ];
}
var fy = {
  pinch: function(r, t) {
    var e = r.length;
    if (e) {
      var n = (r[e - 1] || {}).points, i = (r[e - 2] || {}).points || n;
      if (i && i.length > 1 && n && n.length > 1) {
        var a = TT(n) / TT(i);
        !isFinite(a) && (a = 1), t.pinchScale = a;
        var o = NW(n);
        return t.pinchX = o[0], t.pinchY = o[1], {
          type: "pinch",
          target: r[0].target,
          event: t
        };
      }
    }
  }
};
function kr() {
  return [1, 0, 0, 1, 0, 0];
}
function Ug(r) {
  return r[0] = 1, r[1] = 0, r[2] = 0, r[3] = 1, r[4] = 0, r[5] = 0, r;
}
function Gg(r, t) {
  return r[0] = t[0], r[1] = t[1], r[2] = t[2], r[3] = t[3], r[4] = t[4], r[5] = t[5], r;
}
function ji(r, t, e) {
  var n = t[0] * e[0] + t[2] * e[1], i = t[1] * e[0] + t[3] * e[1], a = t[0] * e[2] + t[2] * e[3], o = t[1] * e[2] + t[3] * e[3], s = t[0] * e[4] + t[2] * e[5] + t[4], l = t[1] * e[4] + t[3] * e[5] + t[5];
  return r[0] = n, r[1] = i, r[2] = a, r[3] = o, r[4] = s, r[5] = l, r;
}
function ra(r, t, e) {
  return r[0] = t[0], r[1] = t[1], r[2] = t[2], r[3] = t[3], r[4] = t[4] + e[0], r[5] = t[5] + e[1], r;
}
function qo(r, t, e, n) {
  n === void 0 && (n = [0, 0]);
  var i = t[0], a = t[2], o = t[4], s = t[1], l = t[3], u = t[5], c = Math.sin(e), f = Math.cos(e);
  return r[0] = i * f + s * c, r[1] = -i * c + s * f, r[2] = a * f + l * c, r[3] = -a * c + f * l, r[4] = f * (o - n[0]) + c * (u - n[1]) + n[0], r[5] = f * (u - n[1]) - c * (o - n[0]) + n[1], r;
}
function M1(r, t, e) {
  var n = e[0], i = e[1];
  return r[0] = t[0] * n, r[1] = t[1] * i, r[2] = t[2] * n, r[3] = t[3] * i, r[4] = t[4] * n, r[5] = t[5] * i, r;
}
function Si(r, t) {
  var e = t[0], n = t[2], i = t[4], a = t[1], o = t[3], s = t[5], l = e * o - a * n;
  return l ? (l = 1 / l, r[0] = o * l, r[1] = -a * l, r[2] = -n * l, r[3] = e * l, r[4] = (n * s - o * i) * l, r[5] = (a * i - e * s) * l, r) : null;
}
function OW(r) {
  var t = kr();
  return Gg(t, r), t;
}
var Nt = function() {
  function r(t, e) {
    this.x = t || 0, this.y = e || 0;
  }
  return r.prototype.copy = function(t) {
    return this.x = t.x, this.y = t.y, this;
  }, r.prototype.clone = function() {
    return new r(this.x, this.y);
  }, r.prototype.set = function(t, e) {
    return this.x = t, this.y = e, this;
  }, r.prototype.equal = function(t) {
    return t.x === this.x && t.y === this.y;
  }, r.prototype.add = function(t) {
    return this.x += t.x, this.y += t.y, this;
  }, r.prototype.scale = function(t) {
    this.x *= t, this.y *= t;
  }, r.prototype.scaleAndAdd = function(t, e) {
    this.x += t.x * e, this.y += t.y * e;
  }, r.prototype.sub = function(t) {
    return this.x -= t.x, this.y -= t.y, this;
  }, r.prototype.dot = function(t) {
    return this.x * t.x + this.y * t.y;
  }, r.prototype.len = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }, r.prototype.lenSquare = function() {
    return this.x * this.x + this.y * this.y;
  }, r.prototype.normalize = function() {
    var t = this.len();
    return this.x /= t, this.y /= t, this;
  }, r.prototype.distance = function(t) {
    var e = this.x - t.x, n = this.y - t.y;
    return Math.sqrt(e * e + n * n);
  }, r.prototype.distanceSquare = function(t) {
    var e = this.x - t.x, n = this.y - t.y;
    return e * e + n * n;
  }, r.prototype.negate = function() {
    return this.x = -this.x, this.y = -this.y, this;
  }, r.prototype.transform = function(t) {
    if (t) {
      var e = this.x, n = this.y;
      return this.x = t[0] * e + t[2] * n + t[4], this.y = t[1] * e + t[3] * n + t[5], this;
    }
  }, r.prototype.toArray = function(t) {
    return t[0] = this.x, t[1] = this.y, t;
  }, r.prototype.fromArray = function(t) {
    this.x = t[0], this.y = t[1];
  }, r.set = function(t, e, n) {
    t.x = e, t.y = n;
  }, r.copy = function(t, e) {
    t.x = e.x, t.y = e.y;
  }, r.len = function(t) {
    return Math.sqrt(t.x * t.x + t.y * t.y);
  }, r.lenSquare = function(t) {
    return t.x * t.x + t.y * t.y;
  }, r.dot = function(t, e) {
    return t.x * e.x + t.y * e.y;
  }, r.add = function(t, e, n) {
    t.x = e.x + n.x, t.y = e.y + n.y;
  }, r.sub = function(t, e, n) {
    t.x = e.x - n.x, t.y = e.y - n.y;
  }, r.scale = function(t, e, n) {
    t.x = e.x * n, t.y = e.y * n;
  }, r.scaleAndAdd = function(t, e, n, i) {
    t.x = e.x + n.x * i, t.y = e.y + n.y * i;
  }, r.lerp = function(t, e, n, i) {
    var a = 1 - i;
    t.x = a * e.x + i * n.x, t.y = a * e.y + i * n.y;
  }, r;
}(), qs = Math.min, Pu = Math.max, rx = Math.abs, AT = ["x", "y"], kW = ["width", "height"], os = new Nt(), ss = new Nt(), ls = new Nt(), us = new Nt(), Dn = eP(), Tf = Dn.minTv, nx = Dn.maxTv, Uf = [0, 0], Bt = function() {
  function r(t, e, n, i) {
    r.set(this, t, e, n, i);
  }
  return r.set = function(t, e, n, i, a) {
    return i < 0 && (e = e + i, i = -i), a < 0 && (n = n + a, a = -a), t.x = e, t.y = n, t.width = i, t.height = a, t;
  }, r.prototype.union = function(t) {
    var e = qs(t.x, this.x), n = qs(t.y, this.y);
    isFinite(this.x) && isFinite(this.width) ? this.width = Pu(t.x + t.width, this.x + this.width) - e : this.width = t.width, isFinite(this.y) && isFinite(this.height) ? this.height = Pu(t.y + t.height, this.y + this.height) - n : this.height = t.height, this.x = e, this.y = n;
  }, r.prototype.applyTransform = function(t) {
    r.applyTransform(this, this, t);
  }, r.prototype.calculateTransform = function(t) {
    var e = this, n = t.width / e.width, i = t.height / e.height, a = kr();
    return ra(a, a, [-e.x, -e.y]), M1(a, a, [n, i]), ra(a, a, [t.x, t.y]), a;
  }, r.prototype.intersect = function(t, e, n) {
    return r.intersect(this, t, e, n);
  }, r.intersect = function(t, e, n, i) {
    n && Nt.set(n, 0, 0);
    var a = i && i.outIntersectRect || null, o = i && i.clamp;
    if (a && (a.x = a.y = a.width = a.height = NaN), !t || !e)
      return !1;
    t instanceof r || (t = r.set(BW, t.x, t.y, t.width, t.height)), e instanceof r || (e = r.set(VW, e.x, e.y, e.width, e.height));
    var s = !!n;
    Dn.reset(i, s);
    var l = Dn.touchThreshold, u = t.x + l, c = t.x + t.width - l, f = t.y + l, h = t.y + t.height - l, d = e.x + l, p = e.x + e.width - l, g = e.y + l, v = e.y + e.height - l;
    if (u > c || f > h || d > p || g > v)
      return !1;
    var m = !(c < d || p < u || h < g || v < f);
    return (s || a) && (Uf[0] = 1 / 0, Uf[1] = 0, ET(u, c, d, p, 0, s, a, o), ET(f, h, g, v, 1, s, a, o), s && Nt.copy(n, m ? Dn.useDir ? Dn.dirMinTv : Tf : nx)), m;
  }, r.contain = function(t, e, n) {
    return e >= t.x && e <= t.x + t.width && n >= t.y && n <= t.y + t.height;
  }, r.prototype.contain = function(t, e) {
    return r.contain(this, t, e);
  }, r.prototype.clone = function() {
    return new r(this.x, this.y, this.width, this.height);
  }, r.prototype.copy = function(t) {
    r.copy(this, t);
  }, r.prototype.plain = function() {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height
    };
  }, r.prototype.isFinite = function() {
    return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
  }, r.prototype.isZero = function() {
    return this.width === 0 || this.height === 0;
  }, r.create = function(t) {
    return new r(t.x, t.y, t.width, t.height);
  }, r.copy = function(t, e) {
    return t.x = e.x, t.y = e.y, t.width = e.width, t.height = e.height, t;
  }, r.applyTransform = function(t, e, n) {
    if (!n) {
      t !== e && r.copy(t, e);
      return;
    }
    if (n[1] < 1e-5 && n[1] > -1e-5 && n[2] < 1e-5 && n[2] > -1e-5) {
      var i = n[0], a = n[3], o = n[4], s = n[5];
      t.x = e.x * i + o, t.y = e.y * a + s, t.width = e.width * i, t.height = e.height * a, t.width < 0 && (t.x += t.width, t.width = -t.width), t.height < 0 && (t.y += t.height, t.height = -t.height);
      return;
    }
    os.x = ls.x = e.x, os.y = us.y = e.y, ss.x = us.x = e.x + e.width, ss.y = ls.y = e.y + e.height, os.transform(n), us.transform(n), ss.transform(n), ls.transform(n), t.x = qs(os.x, ss.x, ls.x, us.x), t.y = qs(os.y, ss.y, ls.y, us.y);
    var l = Pu(os.x, ss.x, ls.x, us.x), u = Pu(os.y, ss.y, ls.y, us.y);
    t.width = l - t.x, t.height = u - t.y;
  }, r;
}(), BW = new Bt(0, 0, 0, 0), VW = new Bt(0, 0, 0, 0);
function ET(r, t, e, n, i, a, o, s) {
  var l = rx(t - e), u = rx(n - r), c = qs(l, u), f = AT[i], h = AT[1 - i], d = kW[i];
  t < e || n < r ? l < u ? (a && (nx[f] = -l), s && (o[f] = t, o[d] = 0)) : (a && (nx[f] = u), s && (o[f] = r, o[d] = 0)) : (o && (o[f] = Pu(r, e), o[d] = qs(t, n) - o[f]), a && (c < Uf[0] || Dn.useDir) && (Uf[0] = qs(c, Uf[0]), (l < u || !Dn.bidirectional) && (Tf[f] = l, Tf[h] = 0, Dn.useDir && Dn.calcDirMTV()), (l >= u || !Dn.bidirectional) && (Tf[f] = -u, Tf[h] = 0, Dn.useDir && Dn.calcDirMTV())));
}
function eP() {
  var r = 0, t = new Nt(), e = new Nt(), n = {
    minTv: new Nt(),
    maxTv: new Nt(),
    useDir: !1,
    dirMinTv: new Nt(),
    touchThreshold: 0,
    bidirectional: !0,
    negativeSize: !1,
    reset: function(a, o) {
      n.touchThreshold = 0, a && a.touchThreshold != null && (n.touchThreshold = Pu(0, a.touchThreshold)), n.negativeSize = !1, o && (n.minTv.set(1 / 0, 1 / 0), n.maxTv.set(0, 0), n.useDir = !1, a && a.direction != null && (n.useDir = !0, n.dirMinTv.copy(n.minTv), e.copy(n.minTv), r = a.direction, n.bidirectional = a.bidirectional == null || !!a.bidirectional, n.bidirectional || t.set(Math.cos(r), Math.sin(r))));
    },
    calcDirMTV: function() {
      var a = n.minTv, o = n.dirMinTv, s = a.y * a.y + a.x * a.x, l = Math.sin(r), u = Math.cos(r), c = l * a.y + u * a.x;
      if (i(c)) {
        i(a.x) && i(a.y) && o.set(0, 0);
        return;
      }
      if (e.x = s * u / c, e.y = s * l / c, i(e.x) && i(e.y)) {
        o.set(0, 0);
        return;
      }
      (n.bidirectional || t.dot(e) > 0) && e.len() < o.len() && o.copy(e);
    }
  };
  function i(a) {
    return rx(a) < 1e-10;
  }
  return n;
}
var rP = "silent";
function FW(r, t, e) {
  return {
    type: r,
    event: e,
    target: t.target,
    topTarget: t.topTarget,
    cancelBubble: !1,
    offsetX: e.zrX,
    offsetY: e.zrY,
    gestureEvent: e.gestureEvent,
    pinchX: e.pinchX,
    pinchY: e.pinchY,
    pinchScale: e.pinchScale,
    wheelDelta: e.zrDelta,
    zrByTouch: e.zrByTouch,
    which: e.which,
    stop: zW
  };
}
function zW() {
  Ua(this.event);
}
var UW = function(r) {
  W(t, r);
  function t() {
    var e = r !== null && r.apply(this, arguments) || this;
    return e.handler = null, e;
  }
  return t.prototype.dispose = function() {
  }, t.prototype.setCursor = function() {
  }, t;
}(oi), Xc = /* @__PURE__ */ function() {
  function r(t, e) {
    this.x = t, this.y = e;
  }
  return r;
}(), GW = [
  "click",
  "dblclick",
  "mousewheel",
  "mouseout",
  "mouseup",
  "mousedown",
  "mousemove",
  "contextmenu"
], hy = new Bt(0, 0, 0, 0), nP = function(r) {
  W(t, r);
  function t(e, n, i, a, o) {
    var s = r.call(this) || this;
    return s._hovered = new Xc(0, 0), s.storage = e, s.painter = n, s.painterRoot = a, s._pointerSize = o, i = i || new UW(), s.proxy = null, s.setHandlerProxy(i), s._draggingMgr = new SW(s), s;
  }
  return t.prototype.setHandlerProxy = function(e) {
    this.proxy && this.proxy.dispose(), e && (L(GW, function(n) {
      e.on && e.on(n, this[n], this);
    }, this), e.handler = this), this.proxy = e;
  }, t.prototype.mousemove = function(e) {
    var n = e.zrX, i = e.zrY, a = iP(this, n, i), o = this._hovered, s = o.target;
    s && !s.__zr && (o = this.findHover(o.x, o.y), s = o.target);
    var l = this._hovered = a ? new Xc(n, i) : this.findHover(n, i), u = l.target, c = this.proxy;
    c.setCursor && c.setCursor(u ? u.cursor : "default"), s && u !== s && this.dispatchToElement(o, "mouseout", e), this.dispatchToElement(l, "mousemove", e), u && u !== s && this.dispatchToElement(l, "mouseover", e);
  }, t.prototype.mouseout = function(e) {
    var n = e.zrEventControl;
    n !== "only_globalout" && this.dispatchToElement(this._hovered, "mouseout", e), n !== "no_globalout" && this.trigger("globalout", { type: "globalout", event: e });
  }, t.prototype.resize = function() {
    this._hovered = new Xc(0, 0);
  }, t.prototype.dispatch = function(e, n) {
    var i = this[e];
    i && i.call(this, n);
  }, t.prototype.dispose = function() {
    this.proxy.dispose(), this.storage = null, this.proxy = null, this.painter = null;
  }, t.prototype.setCursorStyle = function(e) {
    var n = this.proxy;
    n.setCursor && n.setCursor(e);
  }, t.prototype.dispatchToElement = function(e, n, i) {
    e = e || {};
    var a = e.target;
    if (!(a && a.silent)) {
      for (var o = "on" + n, s = FW(n, e, i); a && (a[o] && (s.cancelBubble = !!a[o].call(a, s)), a.trigger(n, s), a = a.__hostTarget ? a.__hostTarget : a.parent, !s.cancelBubble); )
        ;
      s.cancelBubble || (this.trigger(n, s), this.painter && this.painter.eachOtherLayer && this.painter.eachOtherLayer(function(l) {
        typeof l[o] == "function" && l[o].call(l, s), l.trigger && l.trigger(n, s);
      }));
    }
  }, t.prototype.findHover = function(e, n, i) {
    var a = this.storage.getDisplayList(), o = new Xc(e, n);
    if (CT(a, o, e, n, i), this._pointerSize && !o.target) {
      for (var s = [], l = this._pointerSize, u = l / 2, c = new Bt(e - u, n - u, l, l), f = a.length - 1; f >= 0; f--) {
        var h = a[f];
        h !== i && !h.ignore && !h.ignoreCoarsePointer && (!h.parent || !h.parent.ignoreCoarsePointer) && (hy.copy(h.getBoundingRect()), h.transform && hy.applyTransform(h.transform), hy.intersect(c) && s.push(h));
      }
      if (s.length)
        for (var d = 4, p = Math.PI / 12, g = Math.PI * 2, v = 0; v < u; v += d)
          for (var m = 0; m < g; m += p) {
            var y = e + v * Math.cos(m), _ = n + v * Math.sin(m);
            if (CT(s, o, y, _, i), o.target)
              return o;
          }
    }
    return o;
  }, t.prototype.processGesture = function(e, n) {
    this._gestureMgr || (this._gestureMgr = new PW());
    var i = this._gestureMgr;
    n === "start" && i.clear();
    var a = i.recognize(e, this.findHover(e.zrX, e.zrY, null).target, this.proxy.dom);
    if (n === "end" && i.clear(), a) {
      var o = a.type;
      e.gestureEvent = o;
      var s = new Xc();
      s.target = a.target, this.dispatchToElement(s, o, a.event);
    }
  }, t;
}(oi);
L(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(r) {
  nP.prototype[r] = function(t) {
    var e = t.zrX, n = t.zrY, i = iP(this, e, n), a, o;
    if ((r !== "mouseup" || !i) && (a = this.findHover(e, n), o = a.target), r === "mousedown")
      this._downEl = o, this._downPoint = [t.zrX, t.zrY], this._upEl = o;
    else if (r === "mouseup")
      this._upEl = o;
    else if (r === "click") {
      if (this._downEl !== this._upEl || !this._downPoint || xo(this._downPoint, [t.zrX, t.zrY]) > 4)
        return;
      this._downPoint = null;
    }
    this.dispatchToElement(a, r, t);
  };
});
function HW(r, t, e) {
  if (r[r.rectHover ? "rectContain" : "contain"](t, e)) {
    for (var n = r, i = void 0, a = !1; n; ) {
      if (n.ignoreClip && (a = !0), !a) {
        var o = n.getClipPath();
        if (o && !o.contain(t, e))
          return !1;
      }
      n.silent && (i = !0);
      var s = n.__hostTarget;
      n = s ? n.ignoreHostSilent ? null : s : n.parent;
    }
    return i ? rP : !0;
  }
  return !1;
}
function CT(r, t, e, n, i) {
  for (var a = r.length - 1; a >= 0; a--) {
    var o = r[a], s = void 0;
    if (o !== i && !o.ignore && (s = HW(o, e, n)) && (!t.topTarget && (t.topTarget = o), s !== rP)) {
      t.target = o;
      break;
    }
  }
}
function iP(r, t, e) {
  var n = r.painter;
  return t < 0 || t > n.getWidth() || e < 0 || e > n.getHeight();
}
var aP = 32, Yc = 7;
function WW(r) {
  for (var t = 0; r >= aP; )
    t |= r & 1, r >>= 1;
  return r + t;
}
function DT(r, t, e, n) {
  var i = t + 1;
  if (i === e)
    return 1;
  if (n(r[i++], r[t]) < 0) {
    for (; i < e && n(r[i], r[i - 1]) < 0; )
      i++;
    XW(r, t, i);
  } else
    for (; i < e && n(r[i], r[i - 1]) >= 0; )
      i++;
  return i - t;
}
function XW(r, t, e) {
  for (e--; t < e; ) {
    var n = r[t];
    r[t++] = r[e], r[e--] = n;
  }
}
function LT(r, t, e, n, i) {
  for (n === t && n++; n < e; n++) {
    for (var a = r[n], o = t, s = n, l; o < s; )
      l = o + s >>> 1, i(a, r[l]) < 0 ? s = l : o = l + 1;
    var u = n - o;
    switch (u) {
      case 3:
        r[o + 3] = r[o + 2];
      case 2:
        r[o + 2] = r[o + 1];
      case 1:
        r[o + 1] = r[o];
        break;
      default:
        for (; u > 0; )
          r[o + u] = r[o + u - 1], u--;
    }
    r[o] = a;
  }
}
function dy(r, t, e, n, i, a) {
  var o = 0, s = 0, l = 1;
  if (a(r, t[e + i]) > 0) {
    for (s = n - i; l < s && a(r, t[e + i + l]) > 0; )
      o = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s), o += i, l += i;
  } else {
    for (s = i + 1; l < s && a(r, t[e + i - l]) <= 0; )
      o = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s);
    var u = o;
    o = i - l, l = i - u;
  }
  for (o++; o < l; ) {
    var c = o + (l - o >>> 1);
    a(r, t[e + c]) > 0 ? o = c + 1 : l = c;
  }
  return l;
}
function py(r, t, e, n, i, a) {
  var o = 0, s = 0, l = 1;
  if (a(r, t[e + i]) < 0) {
    for (s = i + 1; l < s && a(r, t[e + i - l]) < 0; )
      o = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s);
    var u = o;
    o = i - l, l = i - u;
  } else {
    for (s = n - i; l < s && a(r, t[e + i + l]) >= 0; )
      o = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s), o += i, l += i;
  }
  for (o++; o < l; ) {
    var c = o + (l - o >>> 1);
    a(r, t[e + c]) < 0 ? l = c : o = c + 1;
  }
  return l;
}
function YW(r, t) {
  var e = Yc, n, i, a = 0, o = [];
  n = [], i = [];
  function s(d, p) {
    n[a] = d, i[a] = p, a += 1;
  }
  function l() {
    for (; a > 1; ) {
      var d = a - 2;
      if (d >= 1 && i[d - 1] <= i[d] + i[d + 1] || d >= 2 && i[d - 2] <= i[d] + i[d - 1])
        i[d - 1] < i[d + 1] && d--;
      else if (i[d] > i[d + 1])
        break;
      c(d);
    }
  }
  function u() {
    for (; a > 1; ) {
      var d = a - 2;
      d > 0 && i[d - 1] < i[d + 1] && d--, c(d);
    }
  }
  function c(d) {
    var p = n[d], g = i[d], v = n[d + 1], m = i[d + 1];
    i[d] = g + m, d === a - 3 && (n[d + 1] = n[d + 2], i[d + 1] = i[d + 2]), a--;
    var y = py(r[v], r, p, g, 0, t);
    p += y, g -= y, g !== 0 && (m = dy(r[p + g - 1], r, v, m, m - 1, t), m !== 0 && (g <= m ? f(p, g, v, m) : h(p, g, v, m)));
  }
  function f(d, p, g, v) {
    var m = 0;
    for (m = 0; m < p; m++)
      o[m] = r[d + m];
    var y = 0, _ = g, x = d;
    if (r[x++] = r[_++], --v === 0) {
      for (m = 0; m < p; m++)
        r[x + m] = o[y + m];
      return;
    }
    if (p === 1) {
      for (m = 0; m < v; m++)
        r[x + m] = r[_ + m];
      r[x + v] = o[y];
      return;
    }
    for (var b = e, S, w, A; ; ) {
      S = 0, w = 0, A = !1;
      do
        if (t(r[_], o[y]) < 0) {
          if (r[x++] = r[_++], w++, S = 0, --v === 0) {
            A = !0;
            break;
          }
        } else if (r[x++] = o[y++], S++, w = 0, --p === 1) {
          A = !0;
          break;
        }
      while ((S | w) < b);
      if (A)
        break;
      do {
        if (S = py(r[_], o, y, p, 0, t), S !== 0) {
          for (m = 0; m < S; m++)
            r[x + m] = o[y + m];
          if (x += S, y += S, p -= S, p <= 1) {
            A = !0;
            break;
          }
        }
        if (r[x++] = r[_++], --v === 0) {
          A = !0;
          break;
        }
        if (w = dy(o[y], r, _, v, 0, t), w !== 0) {
          for (m = 0; m < w; m++)
            r[x + m] = r[_ + m];
          if (x += w, _ += w, v -= w, v === 0) {
            A = !0;
            break;
          }
        }
        if (r[x++] = o[y++], --p === 1) {
          A = !0;
          break;
        }
        b--;
      } while (S >= Yc || w >= Yc);
      if (A)
        break;
      b < 0 && (b = 0), b += 2;
    }
    if (e = b, e < 1 && (e = 1), p === 1) {
      for (m = 0; m < v; m++)
        r[x + m] = r[_ + m];
      r[x + v] = o[y];
    } else {
      if (p === 0)
        throw new Error();
      for (m = 0; m < p; m++)
        r[x + m] = o[y + m];
    }
  }
  function h(d, p, g, v) {
    var m = 0;
    for (m = 0; m < v; m++)
      o[m] = r[g + m];
    var y = d + p - 1, _ = v - 1, x = g + v - 1, b = 0, S = 0;
    if (r[x--] = r[y--], --p === 0) {
      for (b = x - (v - 1), m = 0; m < v; m++)
        r[b + m] = o[m];
      return;
    }
    if (v === 1) {
      for (x -= p, y -= p, S = x + 1, b = y + 1, m = p - 1; m >= 0; m--)
        r[S + m] = r[b + m];
      r[x] = o[_];
      return;
    }
    for (var w = e; ; ) {
      var A = 0, T = 0, M = !1;
      do
        if (t(o[_], r[y]) < 0) {
          if (r[x--] = r[y--], A++, T = 0, --p === 0) {
            M = !0;
            break;
          }
        } else if (r[x--] = o[_--], T++, A = 0, --v === 1) {
          M = !0;
          break;
        }
      while ((A | T) < w);
      if (M)
        break;
      do {
        if (A = p - py(o[_], r, d, p, p - 1, t), A !== 0) {
          for (x -= A, y -= A, p -= A, S = x + 1, b = y + 1, m = A - 1; m >= 0; m--)
            r[S + m] = r[b + m];
          if (p === 0) {
            M = !0;
            break;
          }
        }
        if (r[x--] = o[_--], --v === 1) {
          M = !0;
          break;
        }
        if (T = v - dy(r[y], o, 0, v, v - 1, t), T !== 0) {
          for (x -= T, _ -= T, v -= T, S = x + 1, b = _ + 1, m = 0; m < T; m++)
            r[S + m] = o[b + m];
          if (v <= 1) {
            M = !0;
            break;
          }
        }
        if (r[x--] = r[y--], --p === 0) {
          M = !0;
          break;
        }
        w--;
      } while (A >= Yc || T >= Yc);
      if (M)
        break;
      w < 0 && (w = 0), w += 2;
    }
    if (e = w, e < 1 && (e = 1), v === 1) {
      for (x -= p, y -= p, S = x + 1, b = y + 1, m = p - 1; m >= 0; m--)
        r[S + m] = r[b + m];
      r[x] = o[_];
    } else {
      if (v === 0)
        throw new Error();
      for (b = x - (v - 1), m = 0; m < v; m++)
        r[b + m] = o[m];
    }
  }
  return {
    mergeRuns: l,
    forceMergeRuns: u,
    pushRun: s
  };
}
function Wp(r, t, e, n) {
  e || (e = 0), n || (n = r.length);
  var i = n - e;
  if (!(i < 2)) {
    var a = 0;
    if (i < aP) {
      a = DT(r, e, n, t), LT(r, e, n, e + a, t);
      return;
    }
    var o = YW(r, t), s = WW(i);
    do {
      if (a = DT(r, e, n, t), a < s) {
        var l = i;
        l > s && (l = s), LT(r, e, e + l, e + a, t), a = l;
      }
      o.pushRun(e, a), o.mergeRuns(), i -= a, e += a;
    } while (i !== 0);
    o.forceMergeRuns();
  }
}
var Rn = 1, Af = 2, Eu = 4, RT = !1;
function vy() {
  RT || (RT = !0, console.warn("z / z2 / zlevel of displayable is invalid, which may cause unexpected errors"));
}
function IT(r, t) {
  return r.zlevel === t.zlevel ? r.z === t.z ? r.z2 - t.z2 : r.z - t.z : r.zlevel - t.zlevel;
}
var $W = function() {
  function r() {
    this._roots = [], this._displayList = [], this._displayListLen = 0, this.displayableSortFunc = IT;
  }
  return r.prototype.traverse = function(t, e) {
    for (var n = 0; n < this._roots.length; n++)
      this._roots[n].traverse(t, e);
  }, r.prototype.getDisplayList = function(t, e) {
    e = e || !1;
    var n = this._displayList;
    return (t || !n.length) && this.updateDisplayList(e), n;
  }, r.prototype.updateDisplayList = function(t) {
    this._displayListLen = 0;
    for (var e = this._roots, n = this._displayList, i = 0, a = e.length; i < a; i++)
      this._updateAndAddDisplayable(e[i], null, t);
    n.length = this._displayListLen, Wp(n, IT);
  }, r.prototype._updateAndAddDisplayable = function(t, e, n) {
    if (!(t.ignore && !n)) {
      t.beforeUpdate(), t.update(), t.afterUpdate();
      var i = t.getClipPath(), a = e && e.length, o = 0, s = t.__clipPaths;
      if (!t.ignoreClip && (a || i)) {
        if (s || (s = t.__clipPaths = []), a)
          for (var l = 0; l < e.length; l++)
            s[o++] = e[l];
        for (var u = i, c = t; u; )
          u.parent = c, u.updateTransform(), s[o++] = u, c = u, u = u.getClipPath();
      }
      if (s && (s.length = o), t.childrenRef) {
        for (var f = t.childrenRef(), h = 0; h < f.length; h++) {
          var d = f[h];
          t.__dirty && (d.__dirty |= Rn), this._updateAndAddDisplayable(d, s, n);
        }
        t.__dirty = 0;
      } else {
        var p = t;
        isNaN(p.z) && (vy(), p.z = 0), isNaN(p.z2) && (vy(), p.z2 = 0), isNaN(p.zlevel) && (vy(), p.zlevel = 0), this._displayList[this._displayListLen++] = p;
      }
      var g = t.getDecalElement && t.getDecalElement();
      g && this._updateAndAddDisplayable(g, s, n);
      var v = t.getTextGuideLine();
      v && this._updateAndAddDisplayable(v, s, n);
      var m = t.getTextContent();
      m && this._updateAndAddDisplayable(m, s, n);
    }
  }, r.prototype.addRoot = function(t) {
    t.__zr && t.__zr.storage === this || this._roots.push(t);
  }, r.prototype.delRoot = function(t) {
    if (t instanceof Array) {
      for (var e = 0, n = t.length; e < n; e++)
        this.delRoot(t[e]);
      return;
    }
    var i = Zt(this._roots, t);
    i >= 0 && this._roots.splice(i, 1);
  }, r.prototype.delAllRoots = function() {
    this._roots = [], this._displayList = [], this._displayListLen = 0;
  }, r.prototype.getRoots = function() {
    return this._roots;
  }, r.prototype.dispose = function() {
    this._displayList = null, this._roots = null;
  }, r;
}(), xv;
xv = oe.hasGlobalWindow && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(r) {
  return setTimeout(r, 16);
};
var Gf = {
  linear: function(r) {
    return r;
  },
  quadraticIn: function(r) {
    return r * r;
  },
  quadraticOut: function(r) {
    return r * (2 - r);
  },
  quadraticInOut: function(r) {
    return (r *= 2) < 1 ? 0.5 * r * r : -0.5 * (--r * (r - 2) - 1);
  },
  cubicIn: function(r) {
    return r * r * r;
  },
  cubicOut: function(r) {
    return --r * r * r + 1;
  },
  cubicInOut: function(r) {
    return (r *= 2) < 1 ? 0.5 * r * r * r : 0.5 * ((r -= 2) * r * r + 2);
  },
  quarticIn: function(r) {
    return r * r * r * r;
  },
  quarticOut: function(r) {
    return 1 - --r * r * r * r;
  },
  quarticInOut: function(r) {
    return (r *= 2) < 1 ? 0.5 * r * r * r * r : -0.5 * ((r -= 2) * r * r * r - 2);
  },
  quinticIn: function(r) {
    return r * r * r * r * r;
  },
  quinticOut: function(r) {
    return --r * r * r * r * r + 1;
  },
  quinticInOut: function(r) {
    return (r *= 2) < 1 ? 0.5 * r * r * r * r * r : 0.5 * ((r -= 2) * r * r * r * r + 2);
  },
  sinusoidalIn: function(r) {
    return 1 - Math.cos(r * Math.PI / 2);
  },
  sinusoidalOut: function(r) {
    return Math.sin(r * Math.PI / 2);
  },
  sinusoidalInOut: function(r) {
    return 0.5 * (1 - Math.cos(Math.PI * r));
  },
  exponentialIn: function(r) {
    return r === 0 ? 0 : Math.pow(1024, r - 1);
  },
  exponentialOut: function(r) {
    return r === 1 ? 1 : 1 - Math.pow(2, -10 * r);
  },
  exponentialInOut: function(r) {
    return r === 0 ? 0 : r === 1 ? 1 : (r *= 2) < 1 ? 0.5 * Math.pow(1024, r - 1) : 0.5 * (-Math.pow(2, -10 * (r - 1)) + 2);
  },
  circularIn: function(r) {
    return 1 - Math.sqrt(1 - r * r);
  },
  circularOut: function(r) {
    return Math.sqrt(1 - --r * r);
  },
  circularInOut: function(r) {
    return (r *= 2) < 1 ? -0.5 * (Math.sqrt(1 - r * r) - 1) : 0.5 * (Math.sqrt(1 - (r -= 2) * r) + 1);
  },
  elasticIn: function(r) {
    var t, e = 0.1, n = 0.4;
    return r === 0 ? 0 : r === 1 ? 1 : (!e || e < 1 ? (e = 1, t = n / 4) : t = n * Math.asin(1 / e) / (2 * Math.PI), -(e * Math.pow(2, 10 * (r -= 1)) * Math.sin((r - t) * (2 * Math.PI) / n)));
  },
  elasticOut: function(r) {
    var t, e = 0.1, n = 0.4;
    return r === 0 ? 0 : r === 1 ? 1 : (!e || e < 1 ? (e = 1, t = n / 4) : t = n * Math.asin(1 / e) / (2 * Math.PI), e * Math.pow(2, -10 * r) * Math.sin((r - t) * (2 * Math.PI) / n) + 1);
  },
  elasticInOut: function(r) {
    var t, e = 0.1, n = 0.4;
    return r === 0 ? 0 : r === 1 ? 1 : (!e || e < 1 ? (e = 1, t = n / 4) : t = n * Math.asin(1 / e) / (2 * Math.PI), (r *= 2) < 1 ? -0.5 * (e * Math.pow(2, 10 * (r -= 1)) * Math.sin((r - t) * (2 * Math.PI) / n)) : e * Math.pow(2, -10 * (r -= 1)) * Math.sin((r - t) * (2 * Math.PI) / n) * 0.5 + 1);
  },
  backIn: function(r) {
    var t = 1.70158;
    return r * r * ((t + 1) * r - t);
  },
  backOut: function(r) {
    var t = 1.70158;
    return --r * r * ((t + 1) * r + t) + 1;
  },
  backInOut: function(r) {
    var t = 2.5949095;
    return (r *= 2) < 1 ? 0.5 * (r * r * ((t + 1) * r - t)) : 0.5 * ((r -= 2) * r * ((t + 1) * r + t) + 2);
  },
  bounceIn: function(r) {
    return 1 - Gf.bounceOut(1 - r);
  },
  bounceOut: function(r) {
    return r < 1 / 2.75 ? 7.5625 * r * r : r < 2 / 2.75 ? 7.5625 * (r -= 1.5 / 2.75) * r + 0.75 : r < 2.5 / 2.75 ? 7.5625 * (r -= 2.25 / 2.75) * r + 0.9375 : 7.5625 * (r -= 2.625 / 2.75) * r + 0.984375;
  },
  bounceInOut: function(r) {
    return r < 0.5 ? Gf.bounceIn(r * 2) * 0.5 : Gf.bounceOut(r * 2 - 1) * 0.5 + 0.5;
  }
}, Td = Math.pow, Io = Math.sqrt, Sv = 1e-8, oP = 1e-4, PT = Io(3), Ad = 1 / 3, zi = Ml(), Kn = Ml(), Hu = Ml();
function wo(r) {
  return r > -Sv && r < Sv;
}
function sP(r) {
  return r > Sv || r < -Sv;
}
function br(r, t, e, n, i) {
  var a = 1 - i;
  return a * a * (a * r + 3 * i * t) + i * i * (i * n + 3 * a * e);
}
function NT(r, t, e, n, i) {
  var a = 1 - i;
  return 3 * (((t - r) * a + 2 * (e - t) * i) * a + (n - e) * i * i);
}
function bv(r, t, e, n, i, a) {
  var o = n + 3 * (t - e) - r, s = 3 * (e - t * 2 + r), l = 3 * (t - r), u = r - i, c = s * s - 3 * o * l, f = s * l - 9 * o * u, h = l * l - 3 * s * u, d = 0;
  if (wo(c) && wo(f))
    if (wo(s))
      a[0] = 0;
    else {
      var p = -l / s;
      p >= 0 && p <= 1 && (a[d++] = p);
    }
  else {
    var g = f * f - 4 * c * h;
    if (wo(g)) {
      var v = f / c, p = -s / o + v, m = -v / 2;
      p >= 0 && p <= 1 && (a[d++] = p), m >= 0 && m <= 1 && (a[d++] = m);
    } else if (g > 0) {
      var y = Io(g), _ = c * s + 1.5 * o * (-f + y), x = c * s + 1.5 * o * (-f - y);
      _ < 0 ? _ = -Td(-_, Ad) : _ = Td(_, Ad), x < 0 ? x = -Td(-x, Ad) : x = Td(x, Ad);
      var p = (-s - (_ + x)) / (3 * o);
      p >= 0 && p <= 1 && (a[d++] = p);
    } else {
      var b = (2 * c * s - 3 * o * f) / (2 * Io(c * c * c)), S = Math.acos(b) / 3, w = Io(c), A = Math.cos(S), p = (-s - 2 * w * A) / (3 * o), m = (-s + w * (A + PT * Math.sin(S))) / (3 * o), T = (-s + w * (A - PT * Math.sin(S))) / (3 * o);
      p >= 0 && p <= 1 && (a[d++] = p), m >= 0 && m <= 1 && (a[d++] = m), T >= 0 && T <= 1 && (a[d++] = T);
    }
  }
  return d;
}
function lP(r, t, e, n, i) {
  var a = 6 * e - 12 * t + 6 * r, o = 9 * t + 3 * n - 3 * r - 9 * e, s = 3 * t - 3 * r, l = 0;
  if (wo(o)) {
    if (sP(a)) {
      var u = -s / a;
      u >= 0 && u <= 1 && (i[l++] = u);
    }
  } else {
    var c = a * a - 4 * o * s;
    if (wo(c))
      i[0] = -a / (2 * o);
    else if (c > 0) {
      var f = Io(c), u = (-a + f) / (2 * o), h = (-a - f) / (2 * o);
      u >= 0 && u <= 1 && (i[l++] = u), h >= 0 && h <= 1 && (i[l++] = h);
    }
  }
  return l;
}
function zo(r, t, e, n, i, a) {
  var o = (t - r) * i + r, s = (e - t) * i + t, l = (n - e) * i + e, u = (s - o) * i + o, c = (l - s) * i + s, f = (c - u) * i + u;
  a[0] = r, a[1] = o, a[2] = u, a[3] = f, a[4] = f, a[5] = c, a[6] = l, a[7] = n;
}
function uP(r, t, e, n, i, a, o, s, l, u, c) {
  var f, h = 5e-3, d = 1 / 0, p, g, v, m;
  zi[0] = l, zi[1] = u;
  for (var y = 0; y < 1; y += 0.05)
    Kn[0] = br(r, e, i, o, y), Kn[1] = br(t, n, a, s, y), v = el(zi, Kn), v < d && (f = y, d = v);
  d = 1 / 0;
  for (var _ = 0; _ < 32 && !(h < oP); _++)
    p = f - h, g = f + h, Kn[0] = br(r, e, i, o, p), Kn[1] = br(t, n, a, s, p), v = el(Kn, zi), p >= 0 && v < d ? (f = p, d = v) : (Hu[0] = br(r, e, i, o, g), Hu[1] = br(t, n, a, s, g), m = el(Hu, zi), g <= 1 && m < d ? (f = g, d = m) : h *= 0.5);
  return c && (c[0] = br(r, e, i, o, f), c[1] = br(t, n, a, s, f)), Io(d);
}
function ZW(r, t, e, n, i, a, o, s, l) {
  for (var u = r, c = t, f = 0, h = 1 / l, d = 1; d <= l; d++) {
    var p = d * h, g = br(r, e, i, o, p), v = br(t, n, a, s, p), m = g - u, y = v - c;
    f += Math.sqrt(m * m + y * y), u = g, c = v;
  }
  return f;
}
function Ir(r, t, e, n) {
  var i = 1 - n;
  return i * (i * r + 2 * n * t) + n * n * e;
}
function ix(r, t, e, n) {
  return 2 * ((1 - n) * (t - r) + n * (e - t));
}
function qW(r, t, e, n, i) {
  var a = r - 2 * t + e, o = 2 * (t - r), s = r - n, l = 0;
  if (wo(a)) {
    if (sP(o)) {
      var u = -s / o;
      u >= 0 && u <= 1 && (i[l++] = u);
    }
  } else {
    var c = o * o - 4 * a * s;
    if (wo(c)) {
      var u = -o / (2 * a);
      u >= 0 && u <= 1 && (i[l++] = u);
    } else if (c > 0) {
      var f = Io(c), u = (-o + f) / (2 * a), h = (-o - f) / (2 * a);
      u >= 0 && u <= 1 && (i[l++] = u), h >= 0 && h <= 1 && (i[l++] = h);
    }
  }
  return l;
}
function cP(r, t, e) {
  var n = r + e - 2 * t;
  return n === 0 ? 0.5 : (r - t) / n;
}
function eh(r, t, e, n, i) {
  var a = (t - r) * n + r, o = (e - t) * n + t, s = (o - a) * n + a;
  i[0] = r, i[1] = a, i[2] = s, i[3] = s, i[4] = o, i[5] = e;
}
function fP(r, t, e, n, i, a, o, s, l) {
  var u, c = 5e-3, f = 1 / 0;
  zi[0] = o, zi[1] = s;
  for (var h = 0; h < 1; h += 0.05) {
    Kn[0] = Ir(r, e, i, h), Kn[1] = Ir(t, n, a, h);
    var d = el(zi, Kn);
    d < f && (u = h, f = d);
  }
  f = 1 / 0;
  for (var p = 0; p < 32 && !(c < oP); p++) {
    var g = u - c, v = u + c;
    Kn[0] = Ir(r, e, i, g), Kn[1] = Ir(t, n, a, g);
    var d = el(Kn, zi);
    if (g >= 0 && d < f)
      u = g, f = d;
    else {
      Hu[0] = Ir(r, e, i, v), Hu[1] = Ir(t, n, a, v);
      var m = el(Hu, zi);
      v <= 1 && m < f ? (u = v, f = m) : c *= 0.5;
    }
  }
  return l && (l[0] = Ir(r, e, i, u), l[1] = Ir(t, n, a, u)), Io(f);
}
function KW(r, t, e, n, i, a, o) {
  for (var s = r, l = t, u = 0, c = 1 / o, f = 1; f <= o; f++) {
    var h = f * c, d = Ir(r, e, i, h), p = Ir(t, n, a, h), g = d - s, v = p - l;
    u += Math.sqrt(g * g + v * v), s = d, l = p;
  }
  return u;
}
var jW = /cubic-bezier\(([0-9,\.e ]+)\)/;
function T1(r) {
  var t = r && jW.exec(r);
  if (t) {
    var e = t[1].split(","), n = +ti(e[0]), i = +ti(e[1]), a = +ti(e[2]), o = +ti(e[3]);
    if (isNaN(n + i + a + o))
      return;
    var s = [];
    return function(l) {
      return l <= 0 ? 0 : l >= 1 ? 1 : bv(0, n, a, 1, l, s) && br(0, i, o, 1, s[0]);
    };
  }
}
var JW = function() {
  function r(t) {
    this._inited = !1, this._startTime = 0, this._pausedTime = 0, this._paused = !1, this._life = t.life || 1e3, this._delay = t.delay || 0, this.loop = t.loop || !1, this.onframe = t.onframe || er, this.ondestroy = t.ondestroy || er, this.onrestart = t.onrestart || er, t.easing && this.setEasing(t.easing);
  }
  return r.prototype.step = function(t, e) {
    if (this._inited || (this._startTime = t + this._delay, this._inited = !0), this._paused) {
      this._pausedTime += e;
      return;
    }
    var n = this._life, i = t - this._startTime - this._pausedTime, a = i / n;
    a < 0 && (a = 0), a = Math.min(a, 1);
    var o = this.easingFunc, s = o ? o(a) : a;
    if (this.onframe(s), a === 1)
      if (this.loop) {
        var l = i % n;
        this._startTime = t - l, this._pausedTime = 0, this.onrestart();
      } else
        return !0;
    return !1;
  }, r.prototype.pause = function() {
    this._paused = !0;
  }, r.prototype.resume = function() {
    this._paused = !1;
  }, r.prototype.setEasing = function(t) {
    this.easing = t, this.easingFunc = Tt(t) ? t : Gf[t] || T1(t);
  }, r;
}(), hP = /* @__PURE__ */ function() {
  function r(t) {
    this.value = t;
  }
  return r;
}(), QW = function() {
  function r() {
    this._len = 0;
  }
  return r.prototype.insert = function(t) {
    var e = new hP(t);
    return this.insertEntry(e), e;
  }, r.prototype.insertEntry = function(t) {
    this.head ? (this.tail.next = t, t.prev = this.tail, t.next = null, this.tail = t) : this.head = this.tail = t, this._len++;
  }, r.prototype.remove = function(t) {
    var e = t.prev, n = t.next;
    e ? e.next = n : this.head = n, n ? n.prev = e : this.tail = e, t.next = t.prev = null, this._len--;
  }, r.prototype.len = function() {
    return this._len;
  }, r.prototype.clear = function() {
    this.head = this.tail = null, this._len = 0;
  }, r;
}(), Qu = function() {
  function r(t) {
    this._list = new QW(), this._maxSize = 10, this._map = {}, this._maxSize = t;
  }
  return r.prototype.put = function(t, e) {
    var n = this._list, i = this._map, a = null;
    if (i[t] == null) {
      var o = n.len(), s = this._lastRemovedEntry;
      if (o >= this._maxSize && o > 0) {
        var l = n.head;
        n.remove(l), delete i[l.key], a = l.value, this._lastRemovedEntry = l;
      }
      s ? s.value = e : s = new hP(e), s.key = t, n.insertEntry(s), i[t] = s;
    }
    return a;
  }, r.prototype.get = function(t) {
    var e = this._map[t], n = this._list;
    if (e != null)
      return e !== n.tail && (n.remove(e), n.insertEntry(e)), e.value;
  }, r.prototype.clear = function() {
    this._list.clear(), this._map = {};
  }, r.prototype.len = function() {
    return this._list.len();
  }, r;
}(), OT = {
  transparent: [0, 0, 0, 0],
  aliceblue: [240, 248, 255, 1],
  antiquewhite: [250, 235, 215, 1],
  aqua: [0, 255, 255, 1],
  aquamarine: [127, 255, 212, 1],
  azure: [240, 255, 255, 1],
  beige: [245, 245, 220, 1],
  bisque: [255, 228, 196, 1],
  black: [0, 0, 0, 1],
  blanchedalmond: [255, 235, 205, 1],
  blue: [0, 0, 255, 1],
  blueviolet: [138, 43, 226, 1],
  brown: [165, 42, 42, 1],
  burlywood: [222, 184, 135, 1],
  cadetblue: [95, 158, 160, 1],
  chartreuse: [127, 255, 0, 1],
  chocolate: [210, 105, 30, 1],
  coral: [255, 127, 80, 1],
  cornflowerblue: [100, 149, 237, 1],
  cornsilk: [255, 248, 220, 1],
  crimson: [220, 20, 60, 1],
  cyan: [0, 255, 255, 1],
  darkblue: [0, 0, 139, 1],
  darkcyan: [0, 139, 139, 1],
  darkgoldenrod: [184, 134, 11, 1],
  darkgray: [169, 169, 169, 1],
  darkgreen: [0, 100, 0, 1],
  darkgrey: [169, 169, 169, 1],
  darkkhaki: [189, 183, 107, 1],
  darkmagenta: [139, 0, 139, 1],
  darkolivegreen: [85, 107, 47, 1],
  darkorange: [255, 140, 0, 1],
  darkorchid: [153, 50, 204, 1],
  darkred: [139, 0, 0, 1],
  darksalmon: [233, 150, 122, 1],
  darkseagreen: [143, 188, 143, 1],
  darkslateblue: [72, 61, 139, 1],
  darkslategray: [47, 79, 79, 1],
  darkslategrey: [47, 79, 79, 1],
  darkturquoise: [0, 206, 209, 1],
  darkviolet: [148, 0, 211, 1],
  deeppink: [255, 20, 147, 1],
  deepskyblue: [0, 191, 255, 1],
  dimgray: [105, 105, 105, 1],
  dimgrey: [105, 105, 105, 1],
  dodgerblue: [30, 144, 255, 1],
  firebrick: [178, 34, 34, 1],
  floralwhite: [255, 250, 240, 1],
  forestgreen: [34, 139, 34, 1],
  fuchsia: [255, 0, 255, 1],
  gainsboro: [220, 220, 220, 1],
  ghostwhite: [248, 248, 255, 1],
  gold: [255, 215, 0, 1],
  goldenrod: [218, 165, 32, 1],
  gray: [128, 128, 128, 1],
  green: [0, 128, 0, 1],
  greenyellow: [173, 255, 47, 1],
  grey: [128, 128, 128, 1],
  honeydew: [240, 255, 240, 1],
  hotpink: [255, 105, 180, 1],
  indianred: [205, 92, 92, 1],
  indigo: [75, 0, 130, 1],
  ivory: [255, 255, 240, 1],
  khaki: [240, 230, 140, 1],
  lavender: [230, 230, 250, 1],
  lavenderblush: [255, 240, 245, 1],
  lawngreen: [124, 252, 0, 1],
  lemonchiffon: [255, 250, 205, 1],
  lightblue: [173, 216, 230, 1],
  lightcoral: [240, 128, 128, 1],
  lightcyan: [224, 255, 255, 1],
  lightgoldenrodyellow: [250, 250, 210, 1],
  lightgray: [211, 211, 211, 1],
  lightgreen: [144, 238, 144, 1],
  lightgrey: [211, 211, 211, 1],
  lightpink: [255, 182, 193, 1],
  lightsalmon: [255, 160, 122, 1],
  lightseagreen: [32, 178, 170, 1],
  lightskyblue: [135, 206, 250, 1],
  lightslategray: [119, 136, 153, 1],
  lightslategrey: [119, 136, 153, 1],
  lightsteelblue: [176, 196, 222, 1],
  lightyellow: [255, 255, 224, 1],
  lime: [0, 255, 0, 1],
  limegreen: [50, 205, 50, 1],
  linen: [250, 240, 230, 1],
  magenta: [255, 0, 255, 1],
  maroon: [128, 0, 0, 1],
  mediumaquamarine: [102, 205, 170, 1],
  mediumblue: [0, 0, 205, 1],
  mediumorchid: [186, 85, 211, 1],
  mediumpurple: [147, 112, 219, 1],
  mediumseagreen: [60, 179, 113, 1],
  mediumslateblue: [123, 104, 238, 1],
  mediumspringgreen: [0, 250, 154, 1],
  mediumturquoise: [72, 209, 204, 1],
  mediumvioletred: [199, 21, 133, 1],
  midnightblue: [25, 25, 112, 1],
  mintcream: [245, 255, 250, 1],
  mistyrose: [255, 228, 225, 1],
  moccasin: [255, 228, 181, 1],
  navajowhite: [255, 222, 173, 1],
  navy: [0, 0, 128, 1],
  oldlace: [253, 245, 230, 1],
  olive: [128, 128, 0, 1],
  olivedrab: [107, 142, 35, 1],
  orange: [255, 165, 0, 1],
  orangered: [255, 69, 0, 1],
  orchid: [218, 112, 214, 1],
  palegoldenrod: [238, 232, 170, 1],
  palegreen: [152, 251, 152, 1],
  paleturquoise: [175, 238, 238, 1],
  palevioletred: [219, 112, 147, 1],
  papayawhip: [255, 239, 213, 1],
  peachpuff: [255, 218, 185, 1],
  peru: [205, 133, 63, 1],
  pink: [255, 192, 203, 1],
  plum: [221, 160, 221, 1],
  powderblue: [176, 224, 230, 1],
  purple: [128, 0, 128, 1],
  red: [255, 0, 0, 1],
  rosybrown: [188, 143, 143, 1],
  royalblue: [65, 105, 225, 1],
  saddlebrown: [139, 69, 19, 1],
  salmon: [250, 128, 114, 1],
  sandybrown: [244, 164, 96, 1],
  seagreen: [46, 139, 87, 1],
  seashell: [255, 245, 238, 1],
  sienna: [160, 82, 45, 1],
  silver: [192, 192, 192, 1],
  skyblue: [135, 206, 235, 1],
  slateblue: [106, 90, 205, 1],
  slategray: [112, 128, 144, 1],
  slategrey: [112, 128, 144, 1],
  snow: [255, 250, 250, 1],
  springgreen: [0, 255, 127, 1],
  steelblue: [70, 130, 180, 1],
  tan: [210, 180, 140, 1],
  teal: [0, 128, 128, 1],
  thistle: [216, 191, 216, 1],
  tomato: [255, 99, 71, 1],
  turquoise: [64, 224, 208, 1],
  violet: [238, 130, 238, 1],
  wheat: [245, 222, 179, 1],
  white: [255, 255, 255, 1],
  whitesmoke: [245, 245, 245, 1],
  yellow: [255, 255, 0, 1],
  yellowgreen: [154, 205, 50, 1]
};
function mi(r) {
  return r = Math.round(r), r < 0 ? 0 : r > 255 ? 255 : r;
}
function t8(r) {
  return r = Math.round(r), r < 0 ? 0 : r > 360 ? 360 : r;
}
function rh(r) {
  return r < 0 ? 0 : r > 1 ? 1 : r;
}
function gy(r) {
  var t = r;
  return t.length && t.charAt(t.length - 1) === "%" ? mi(parseFloat(t) / 100 * 255) : mi(parseInt(t, 10));
}
function Po(r) {
  var t = r;
  return t.length && t.charAt(t.length - 1) === "%" ? rh(parseFloat(t) / 100) : rh(parseFloat(t));
}
function my(r, t, e) {
  return e < 0 ? e += 1 : e > 1 && (e -= 1), e * 6 < 1 ? r + (t - r) * e * 6 : e * 2 < 1 ? t : e * 3 < 2 ? r + (t - r) * (2 / 3 - e) * 6 : r;
}
function Mo(r, t, e) {
  return r + (t - r) * e;
}
function Xn(r, t, e, n, i) {
  return r[0] = t, r[1] = e, r[2] = n, r[3] = i, r;
}
function ax(r, t) {
  return r[0] = t[0], r[1] = t[1], r[2] = t[2], r[3] = t[3], r;
}
var dP = new Qu(20), Ed = null;
function Ql(r, t) {
  Ed && ax(Ed, t), Ed = dP.put(r, Ed || t.slice());
}
function bn(r, t) {
  if (r) {
    t = t || [];
    var e = dP.get(r);
    if (e)
      return ax(t, e);
    r = r + "";
    var n = r.replace(/ /g, "").toLowerCase();
    if (n in OT)
      return ax(t, OT[n]), Ql(r, t), t;
    var i = n.length;
    if (n.charAt(0) === "#") {
      if (i === 4 || i === 5) {
        var a = parseInt(n.slice(1, 4), 16);
        if (!(a >= 0 && a <= 4095)) {
          Xn(t, 0, 0, 0, 1);
          return;
        }
        return Xn(t, (a & 3840) >> 4 | (a & 3840) >> 8, a & 240 | (a & 240) >> 4, a & 15 | (a & 15) << 4, i === 5 ? parseInt(n.slice(4), 16) / 15 : 1), Ql(r, t), t;
      } else if (i === 7 || i === 9) {
        var a = parseInt(n.slice(1, 7), 16);
        if (!(a >= 0 && a <= 16777215)) {
          Xn(t, 0, 0, 0, 1);
          return;
        }
        return Xn(t, (a & 16711680) >> 16, (a & 65280) >> 8, a & 255, i === 9 ? parseInt(n.slice(7), 16) / 255 : 1), Ql(r, t), t;
      }
      return;
    }
    var o = n.indexOf("("), s = n.indexOf(")");
    if (o !== -1 && s + 1 === i) {
      var l = n.substr(0, o), u = n.substr(o + 1, s - (o + 1)).split(","), c = 1;
      switch (l) {
        case "rgba":
          if (u.length !== 4)
            return u.length === 3 ? Xn(t, +u[0], +u[1], +u[2], 1) : Xn(t, 0, 0, 0, 1);
          c = Po(u.pop());
        case "rgb":
          if (u.length >= 3)
            return Xn(t, gy(u[0]), gy(u[1]), gy(u[2]), u.length === 3 ? c : Po(u[3])), Ql(r, t), t;
          Xn(t, 0, 0, 0, 1);
          return;
        case "hsla":
          if (u.length !== 4) {
            Xn(t, 0, 0, 0, 1);
            return;
          }
          return u[3] = Po(u[3]), ox(u, t), Ql(r, t), t;
        case "hsl":
          if (u.length !== 3) {
            Xn(t, 0, 0, 0, 1);
            return;
          }
          return ox(u, t), Ql(r, t), t;
        default:
          return;
      }
    }
    Xn(t, 0, 0, 0, 1);
  }
}
function ox(r, t) {
  var e = (parseFloat(r[0]) % 360 + 360) % 360 / 360, n = Po(r[1]), i = Po(r[2]), a = i <= 0.5 ? i * (n + 1) : i + n - i * n, o = i * 2 - a;
  return t = t || [], Xn(t, mi(my(o, a, e + 1 / 3) * 255), mi(my(o, a, e) * 255), mi(my(o, a, e - 1 / 3) * 255), 1), r.length === 4 && (t[3] = r[3]), t;
}
function e8(r) {
  if (r) {
    var t = r[0] / 255, e = r[1] / 255, n = r[2] / 255, i = Math.min(t, e, n), a = Math.max(t, e, n), o = a - i, s = (a + i) / 2, l, u;
    if (o === 0)
      l = 0, u = 0;
    else {
      s < 0.5 ? u = o / (a + i) : u = o / (2 - a - i);
      var c = ((a - t) / 6 + o / 2) / o, f = ((a - e) / 6 + o / 2) / o, h = ((a - n) / 6 + o / 2) / o;
      t === a ? l = h - f : e === a ? l = 1 / 3 + c - h : n === a && (l = 2 / 3 + f - c), l < 0 && (l += 1), l > 1 && (l -= 1);
    }
    var d = [l * 360, u, s];
    return r[3] != null && d.push(r[3]), d;
  }
}
function sx(r, t) {
  var e = bn(r);
  if (e) {
    for (var n = 0; n < 3; n++)
      t < 0 ? e[n] = e[n] * (1 - t) | 0 : e[n] = (255 - e[n]) * t + e[n] | 0, e[n] > 255 ? e[n] = 255 : e[n] < 0 && (e[n] = 0);
    return Ji(e, e.length === 4 ? "rgba" : "rgb");
  }
}
function yy(r, t, e) {
  if (!(!(t && t.length) || !(r >= 0 && r <= 1))) {
    e = e || [];
    var n = r * (t.length - 1), i = Math.floor(n), a = Math.ceil(n), o = t[i], s = t[a], l = n - i;
    return e[0] = mi(Mo(o[0], s[0], l)), e[1] = mi(Mo(o[1], s[1], l)), e[2] = mi(Mo(o[2], s[2], l)), e[3] = rh(Mo(o[3], s[3], l)), e;
  }
}
function r8(r, t, e) {
  if (!(!(t && t.length) || !(r >= 0 && r <= 1))) {
    var n = r * (t.length - 1), i = Math.floor(n), a = Math.ceil(n), o = bn(t[i]), s = bn(t[a]), l = n - i, u = Ji([
      mi(Mo(o[0], s[0], l)),
      mi(Mo(o[1], s[1], l)),
      mi(Mo(o[2], s[2], l)),
      rh(Mo(o[3], s[3], l))
    ], "rgba");
    return e ? {
      color: u,
      leftIndex: i,
      rightIndex: a,
      value: n
    } : u;
  }
}
function No(r, t, e, n) {
  var i = bn(r);
  if (r)
    return i = e8(i), t != null && (i[0] = t8(Tt(t) ? t(i[0]) : t)), e != null && (i[1] = Po(Tt(e) ? e(i[1]) : e)), n != null && (i[2] = Po(Tt(n) ? n(i[2]) : n)), Ji(ox(i), "rgba");
}
function wv(r, t) {
  var e = bn(r);
  if (e && t != null)
    return e[3] = rh(t), Ji(e, "rgba");
}
function Ji(r, t) {
  if (!(!r || !r.length)) {
    var e = r[0] + "," + r[1] + "," + r[2];
    return (t === "rgba" || t === "hsva" || t === "hsla") && (e += "," + r[3]), t + "(" + e + ")";
  }
}
function Mv(r, t) {
  var e = bn(r);
  return e ? (0.299 * e[0] + 0.587 * e[1] + 0.114 * e[2]) * e[3] / 255 + (1 - e[3]) * t : 0;
}
var kT = new Qu(100);
function lx(r) {
  if (pt(r)) {
    var t = kT.get(r);
    return t || (t = sx(r, -0.1), kT.put(r, t)), t;
  } else if (Vg(r)) {
    var e = J({}, r);
    return e.colorStops = rt(r.colorStops, function(n) {
      return {
        offset: n.offset,
        color: sx(n.color, -0.1)
      };
    }), e;
  }
  return r;
}
var Tv = Math.round;
function nh(r) {
  var t;
  if (!r || r === "transparent")
    r = "none";
  else if (typeof r == "string" && r.indexOf("rgba") > -1) {
    var e = bn(r);
    e && (r = "rgb(" + e[0] + "," + e[1] + "," + e[2] + ")", t = e[3]);
  }
  return {
    color: r,
    opacity: t ?? 1
  };
}
var BT = 1e-4;
function To(r) {
  return r < BT && r > -BT;
}
function Cd(r) {
  return Tv(r * 1e3) / 1e3;
}
function ux(r) {
  return Tv(r * 1e4) / 1e4;
}
function n8(r) {
  return "matrix(" + Cd(r[0]) + "," + Cd(r[1]) + "," + Cd(r[2]) + "," + Cd(r[3]) + "," + ux(r[4]) + "," + ux(r[5]) + ")";
}
var i8 = {
  left: "start",
  right: "end",
  center: "middle",
  middle: "middle"
};
function a8(r, t, e) {
  return e === "top" ? r += t / 2 : e === "bottom" && (r -= t / 2), r;
}
function o8(r) {
  return r && (r.shadowBlur || r.shadowOffsetX || r.shadowOffsetY);
}
function s8(r) {
  var t = r.style, e = r.getGlobalScale();
  return [
    t.shadowColor,
    (t.shadowBlur || 0).toFixed(2),
    (t.shadowOffsetX || 0).toFixed(2),
    (t.shadowOffsetY || 0).toFixed(2),
    e[0],
    e[1]
  ].join(",");
}
function pP(r) {
  return r && !!r.image;
}
function l8(r) {
  return r && !!r.svgElement;
}
function A1(r) {
  return pP(r) || l8(r);
}
function vP(r) {
  return r.type === "linear";
}
function gP(r) {
  return r.type === "radial";
}
function mP(r) {
  return r && (r.type === "linear" || r.type === "radial");
}
function Hg(r) {
  return "url(#" + r + ")";
}
function yP(r) {
  var t = r.getGlobalScale(), e = Math.max(t[0], t[1]);
  return Math.max(Math.ceil(Math.log(e) / Math.log(10)), 1);
}
function _P(r) {
  var t = r.x || 0, e = r.y || 0, n = (r.rotation || 0) * Up, i = bt(r.scaleX, 1), a = bt(r.scaleY, 1), o = r.skewX || 0, s = r.skewY || 0, l = [];
  return (t || e) && l.push("translate(" + t + "px," + e + "px)"), n && l.push("rotate(" + n + ")"), (i !== 1 || a !== 1) && l.push("scale(" + i + "," + a + ")"), (o || s) && l.push("skew(" + Tv(o * Up) + "deg, " + Tv(s * Up) + "deg)"), l.join(" ");
}
var u8 = function() {
  return oe.hasGlobalWindow && Tt(window.btoa) ? function(r) {
    return window.btoa(unescape(encodeURIComponent(r)));
  } : typeof Buffer < "u" ? function(r) {
    return Buffer.from(r).toString("base64");
  } : function(r) {
    return process.env.NODE_ENV !== "production" && gi("Base64 isn't natively supported in the current environment."), null;
  };
}(), cx = Array.prototype.slice;
function wa(r, t, e) {
  return (t - r) * e + r;
}
function _y(r, t, e, n) {
  for (var i = t.length, a = 0; a < i; a++)
    r[a] = wa(t[a], e[a], n);
  return r;
}
function c8(r, t, e, n) {
  for (var i = t.length, a = i && t[0].length, o = 0; o < i; o++) {
    r[o] || (r[o] = []);
    for (var s = 0; s < a; s++)
      r[o][s] = wa(t[o][s], e[o][s], n);
  }
  return r;
}
function Dd(r, t, e, n) {
  for (var i = t.length, a = 0; a < i; a++)
    r[a] = t[a] + e[a] * n;
  return r;
}
function VT(r, t, e, n) {
  for (var i = t.length, a = i && t[0].length, o = 0; o < i; o++) {
    r[o] || (r[o] = []);
    for (var s = 0; s < a; s++)
      r[o][s] = t[o][s] + e[o][s] * n;
  }
  return r;
}
function f8(r, t) {
  for (var e = r.length, n = t.length, i = e > n ? t : r, a = Math.min(e, n), o = i[a - 1] || { color: [0, 0, 0, 0], offset: 0 }, s = a; s < Math.max(e, n); s++)
    i.push({
      offset: o.offset,
      color: o.color.slice()
    });
}
function h8(r, t, e) {
  var n = r, i = t;
  if (!(!n.push || !i.push)) {
    var a = n.length, o = i.length;
    if (a !== o) {
      var s = a > o;
      if (s)
        n.length = o;
      else
        for (var l = a; l < o; l++)
          n.push(e === 1 ? i[l] : cx.call(i[l]));
    }
    for (var u = n[0] && n[0].length, l = 0; l < n.length; l++)
      if (e === 1)
        isNaN(n[l]) && (n[l] = i[l]);
      else
        for (var c = 0; c < u; c++)
          isNaN(n[l][c]) && (n[l][c] = i[l][c]);
  }
}
function Hf(r) {
  if (qr(r)) {
    var t = r.length;
    if (qr(r[0])) {
      for (var e = [], n = 0; n < t; n++)
        e.push(cx.call(r[n]));
      return e;
    }
    return cx.call(r);
  }
  return r;
}
function Xp(r) {
  return r[0] = Math.floor(r[0]) || 0, r[1] = Math.floor(r[1]) || 0, r[2] = Math.floor(r[2]) || 0, r[3] = r[3] == null ? 1 : r[3], "rgba(" + r.join(",") + ")";
}
function d8(r) {
  return qr(r && r[0]) ? 2 : 1;
}
var Ld = 0, Yp = 1, xP = 2, Ef = 3, fx = 4, hx = 5, FT = 6;
function zT(r) {
  return r === fx || r === hx;
}
function Rd(r) {
  return r === Yp || r === xP;
}
var $c = [0, 0, 0, 0], p8 = function() {
  function r(t) {
    this.keyframes = [], this.discrete = !1, this._invalid = !1, this._needsSort = !1, this._lastFr = 0, this._lastFrP = 0, this.propName = t;
  }
  return r.prototype.isFinished = function() {
    return this._finished;
  }, r.prototype.setFinished = function() {
    this._finished = !0, this._additiveTrack && this._additiveTrack.setFinished();
  }, r.prototype.needsAnimate = function() {
    return this.keyframes.length >= 1;
  }, r.prototype.getAdditiveTrack = function() {
    return this._additiveTrack;
  }, r.prototype.addKeyframe = function(t, e, n) {
    this._needsSort = !0;
    var i = this.keyframes, a = i.length, o = !1, s = FT, l = e;
    if (qr(e)) {
      var u = d8(e);
      s = u, (u === 1 && !fe(e[0]) || u === 2 && !fe(e[0][0])) && (o = !0);
    } else if (fe(e) && !Or(e))
      s = Ld;
    else if (pt(e))
      if (!isNaN(+e))
        s = Ld;
      else {
        var c = bn(e);
        c && (l = c, s = Ef);
      }
    else if (Vg(e)) {
      var f = J({}, l);
      f.colorStops = rt(e.colorStops, function(d) {
        return {
          offset: d.offset,
          color: bn(d.color)
        };
      }), vP(e) ? s = fx : gP(e) && (s = hx), l = f;
    }
    a === 0 ? this.valType = s : (s !== this.valType || s === FT) && (o = !0), this.discrete = this.discrete || o;
    var h = {
      time: t,
      value: l,
      rawValue: e,
      percent: 0
    };
    return n && (h.easing = n, h.easingFunc = Tt(n) ? n : Gf[n] || T1(n)), i.push(h), h;
  }, r.prototype.prepare = function(t, e) {
    var n = this.keyframes;
    this._needsSort && n.sort(function(g, v) {
      return g.time - v.time;
    });
    for (var i = this.valType, a = n.length, o = n[a - 1], s = this.discrete, l = Rd(i), u = zT(i), c = 0; c < a; c++) {
      var f = n[c], h = f.value, d = o.value;
      f.percent = f.time / t, s || (l && c !== a - 1 ? h8(h, d, i) : u && f8(h.colorStops, d.colorStops));
    }
    if (!s && i !== hx && e && this.needsAnimate() && e.needsAnimate() && i === e.valType && !e._finished) {
      this._additiveTrack = e;
      for (var p = n[0].value, c = 0; c < a; c++)
        i === Ld ? n[c].additiveValue = n[c].value - p : i === Ef ? n[c].additiveValue = Dd([], n[c].value, p, -1) : Rd(i) && (n[c].additiveValue = i === Yp ? Dd([], n[c].value, p, -1) : VT([], n[c].value, p, -1));
    }
  }, r.prototype.step = function(t, e) {
    if (!this._finished) {
      this._additiveTrack && this._additiveTrack._finished && (this._additiveTrack = null);
      var n = this._additiveTrack != null, i = n ? "additiveValue" : "value", a = this.valType, o = this.keyframes, s = o.length, l = this.propName, u = a === Ef, c, f = this._lastFr, h = Math.min, d, p;
      if (s === 1)
        d = p = o[0];
      else {
        if (e < 0)
          c = 0;
        else if (e < this._lastFrP) {
          var g = h(f + 1, s - 1);
          for (c = g; c >= 0 && !(o[c].percent <= e); c--)
            ;
          c = h(c, s - 2);
        } else {
          for (c = f; c < s && !(o[c].percent > e); c++)
            ;
          c = h(c - 1, s - 2);
        }
        p = o[c + 1], d = o[c];
      }
      if (d && p) {
        this._lastFr = c, this._lastFrP = e;
        var v = p.percent - d.percent, m = v === 0 ? 1 : h((e - d.percent) / v, 1);
        p.easingFunc && (m = p.easingFunc(m));
        var y = n ? this._additiveValue : u ? $c : t[l];
        if ((Rd(a) || u) && !y && (y = this._additiveValue = []), this.discrete)
          t[l] = m < 1 ? d.rawValue : p.rawValue;
        else if (Rd(a))
          a === Yp ? _y(y, d[i], p[i], m) : c8(y, d[i], p[i], m);
        else if (zT(a)) {
          var _ = d[i], x = p[i], b = a === fx;
          t[l] = {
            type: b ? "linear" : "radial",
            x: wa(_.x, x.x, m),
            y: wa(_.y, x.y, m),
            colorStops: rt(_.colorStops, function(w, A) {
              var T = x.colorStops[A];
              return {
                offset: wa(w.offset, T.offset, m),
                color: Xp(_y([], w.color, T.color, m))
              };
            }),
            global: x.global
          }, b ? (t[l].x2 = wa(_.x2, x.x2, m), t[l].y2 = wa(_.y2, x.y2, m)) : t[l].r = wa(_.r, x.r, m);
        } else if (u)
          _y(y, d[i], p[i], m), n || (t[l] = Xp(y));
        else {
          var S = wa(d[i], p[i], m);
          n ? this._additiveValue = S : t[l] = S;
        }
        n && this._addToTarget(t);
      }
    }
  }, r.prototype._addToTarget = function(t) {
    var e = this.valType, n = this.propName, i = this._additiveValue;
    e === Ld ? t[n] = t[n] + i : e === Ef ? (bn(t[n], $c), Dd($c, $c, i, 1), t[n] = Xp($c)) : e === Yp ? Dd(t[n], t[n], i, 1) : e === xP && VT(t[n], t[n], i, 1);
  }, r;
}(), E1 = function() {
  function r(t, e, n, i) {
    if (this._tracks = {}, this._trackKeys = [], this._maxTime = 0, this._started = 0, this._clip = null, this._target = t, this._loop = e, e && i) {
      gi("Can' use additive animation on looped animation.");
      return;
    }
    this._additiveAnimators = i, this._allowDiscrete = n;
  }
  return r.prototype.getMaxTime = function() {
    return this._maxTime;
  }, r.prototype.getDelay = function() {
    return this._delay;
  }, r.prototype.getLoop = function() {
    return this._loop;
  }, r.prototype.getTarget = function() {
    return this._target;
  }, r.prototype.changeTarget = function(t) {
    this._target = t;
  }, r.prototype.when = function(t, e, n) {
    return this.whenWithKeys(t, e, se(e), n);
  }, r.prototype.whenWithKeys = function(t, e, n, i) {
    for (var a = this._tracks, o = 0; o < n.length; o++) {
      var s = n[o], l = a[s];
      if (!l) {
        l = a[s] = new p8(s);
        var u = void 0, c = this._getAdditiveTrack(s);
        if (c) {
          var f = c.keyframes, h = f[f.length - 1];
          u = h && h.value, c.valType === Ef && u && (u = Xp(u));
        } else
          u = this._target[s];
        if (u == null)
          continue;
        t > 0 && l.addKeyframe(0, Hf(u), i), this._trackKeys.push(s);
      }
      l.addKeyframe(t, Hf(e[s]), i);
    }
    return this._maxTime = Math.max(this._maxTime, t), this;
  }, r.prototype.pause = function() {
    this._clip.pause(), this._paused = !0;
  }, r.prototype.resume = function() {
    this._clip.resume(), this._paused = !1;
  }, r.prototype.isPaused = function() {
    return !!this._paused;
  }, r.prototype.duration = function(t) {
    return this._maxTime = t, this._force = !0, this;
  }, r.prototype._doneCallback = function() {
    this._setTracksFinished(), this._clip = null;
    var t = this._doneCbs;
    if (t)
      for (var e = t.length, n = 0; n < e; n++)
        t[n].call(this);
  }, r.prototype._abortedCallback = function() {
    this._setTracksFinished();
    var t = this.animation, e = this._abortedCbs;
    if (t && t.removeClip(this._clip), this._clip = null, e)
      for (var n = 0; n < e.length; n++)
        e[n].call(this);
  }, r.prototype._setTracksFinished = function() {
    for (var t = this._tracks, e = this._trackKeys, n = 0; n < e.length; n++)
      t[e[n]].setFinished();
  }, r.prototype._getAdditiveTrack = function(t) {
    var e, n = this._additiveAnimators;
    if (n)
      for (var i = 0; i < n.length; i++) {
        var a = n[i].getTrack(t);
        a && (e = a);
      }
    return e;
  }, r.prototype.start = function(t) {
    if (!(this._started > 0)) {
      this._started = 1;
      for (var e = this, n = [], i = this._maxTime || 0, a = 0; a < this._trackKeys.length; a++) {
        var o = this._trackKeys[a], s = this._tracks[o], l = this._getAdditiveTrack(o), u = s.keyframes, c = u.length;
        if (s.prepare(i, l), s.needsAnimate())
          if (!this._allowDiscrete && s.discrete) {
            var f = u[c - 1];
            f && (e._target[s.propName] = f.rawValue), s.setFinished();
          } else
            n.push(s);
      }
      if (n.length || this._force) {
        var h = new JW({
          life: i,
          loop: this._loop,
          delay: this._delay || 0,
          onframe: function(d) {
            e._started = 2;
            var p = e._additiveAnimators;
            if (p) {
              for (var g = !1, v = 0; v < p.length; v++)
                if (p[v]._clip) {
                  g = !0;
                  break;
                }
              g || (e._additiveAnimators = null);
            }
            for (var v = 0; v < n.length; v++)
              n[v].step(e._target, d);
            var m = e._onframeCbs;
            if (m)
              for (var v = 0; v < m.length; v++)
                m[v](e._target, d);
          },
          ondestroy: function() {
            e._doneCallback();
          }
        });
        this._clip = h, this.animation && this.animation.addClip(h), t && h.setEasing(t);
      } else
        this._doneCallback();
      return this;
    }
  }, r.prototype.stop = function(t) {
    if (this._clip) {
      var e = this._clip;
      t && e.onframe(1), this._abortedCallback();
    }
  }, r.prototype.delay = function(t) {
    return this._delay = t, this;
  }, r.prototype.during = function(t) {
    return t && (this._onframeCbs || (this._onframeCbs = []), this._onframeCbs.push(t)), this;
  }, r.prototype.done = function(t) {
    return t && (this._doneCbs || (this._doneCbs = []), this._doneCbs.push(t)), this;
  }, r.prototype.aborted = function(t) {
    return t && (this._abortedCbs || (this._abortedCbs = []), this._abortedCbs.push(t)), this;
  }, r.prototype.getClip = function() {
    return this._clip;
  }, r.prototype.getTrack = function(t) {
    return this._tracks[t];
  }, r.prototype.getTracks = function() {
    var t = this;
    return rt(this._trackKeys, function(e) {
      return t._tracks[e];
    });
  }, r.prototype.stopTracks = function(t, e) {
    if (!t.length || !this._clip)
      return !0;
    for (var n = this._tracks, i = this._trackKeys, a = 0; a < t.length; a++) {
      var o = n[t[a]];
      o && !o.isFinished() && (e ? o.step(this._target, 1) : this._started === 1 && o.step(this._target, 0), o.setFinished());
    }
    for (var s = !0, a = 0; a < i.length; a++)
      if (!n[i[a]].isFinished()) {
        s = !1;
        break;
      }
    return s && this._abortedCallback(), s;
  }, r.prototype.saveTo = function(t, e, n) {
    if (t) {
      e = e || this._trackKeys;
      for (var i = 0; i < e.length; i++) {
        var a = e[i], o = this._tracks[a];
        if (!(!o || o.isFinished())) {
          var s = o.keyframes, l = s[n ? 0 : s.length - 1];
          l && (t[a] = Hf(l.rawValue));
        }
      }
    }
  }, r.prototype.__changeFinalValue = function(t, e) {
    e = e || se(t);
    for (var n = 0; n < e.length; n++) {
      var i = e[n], a = this._tracks[i];
      if (a) {
        var o = a.keyframes;
        if (o.length > 1) {
          var s = o.pop();
          a.addKeyframe(s.time, t[i]), a.prepare(this._maxTime, a.getAdditiveTrack());
        }
      }
    }
  }, r;
}();
function Nu() {
  return (/* @__PURE__ */ new Date()).getTime();
}
var v8 = function(r) {
  W(t, r);
  function t(e) {
    var n = r.call(this) || this;
    return n._running = !1, n._time = 0, n._pausedTime = 0, n._pauseStart = 0, n._paused = !1, e = e || {}, n.stage = e.stage || {}, n;
  }
  return t.prototype.addClip = function(e) {
    e.animation && this.removeClip(e), this._head ? (this._tail.next = e, e.prev = this._tail, e.next = null, this._tail = e) : this._head = this._tail = e, e.animation = this;
  }, t.prototype.addAnimator = function(e) {
    e.animation = this;
    var n = e.getClip();
    n && this.addClip(n);
  }, t.prototype.removeClip = function(e) {
    if (e.animation) {
      var n = e.prev, i = e.next;
      n ? n.next = i : this._head = i, i ? i.prev = n : this._tail = n, e.next = e.prev = e.animation = null;
    }
  }, t.prototype.removeAnimator = function(e) {
    var n = e.getClip();
    n && this.removeClip(n), e.animation = null;
  }, t.prototype.update = function(e) {
    for (var n = Nu() - this._pausedTime, i = n - this._time, a = this._head; a; ) {
      var o = a.next, s = a.step(n, i);
      s && (a.ondestroy(), this.removeClip(a)), a = o;
    }
    this._time = n, e || (this.trigger("frame", i), this.stage.update && this.stage.update());
  }, t.prototype._startLoop = function() {
    var e = this;
    this._running = !0;
    function n() {
      e._running && (xv(n), !e._paused && e.update());
    }
    xv(n);
  }, t.prototype.start = function() {
    this._running || (this._time = Nu(), this._pausedTime = 0, this._startLoop());
  }, t.prototype.stop = function() {
    this._running = !1;
  }, t.prototype.pause = function() {
    this._paused || (this._pauseStart = Nu(), this._paused = !0);
  }, t.prototype.resume = function() {
    this._paused && (this._pausedTime += Nu() - this._pauseStart, this._paused = !1);
  }, t.prototype.clear = function() {
    for (var e = this._head; e; ) {
      var n = e.next;
      e.prev = e.next = e.animation = null, e = n;
    }
    this._head = this._tail = null;
  }, t.prototype.isFinished = function() {
    return this._head == null;
  }, t.prototype.animate = function(e, n) {
    n = n || {}, this.start();
    var i = new E1(e, n.loop);
    return this.addAnimator(i), i;
  }, t;
}(oi), g8 = 300, xy = oe.domSupported, Sy = function() {
  var r = [
    "click",
    "dblclick",
    "mousewheel",
    "wheel",
    "mouseout",
    "mouseup",
    "mousedown",
    "mousemove",
    "contextmenu"
  ], t = [
    "touchstart",
    "touchend",
    "touchmove"
  ], e = {
    pointerdown: 1,
    pointerup: 1,
    pointermove: 1,
    pointerout: 1
  }, n = rt(r, function(i) {
    var a = i.replace("mouse", "pointer");
    return e.hasOwnProperty(a) ? a : i;
  });
  return {
    mouse: r,
    touch: t,
    pointer: n
  };
}(), UT = {
  mouse: ["mousemove", "mouseup"],
  pointer: ["pointermove", "pointerup"]
}, GT = !1;
function dx(r) {
  var t = r.pointerType;
  return t === "pen" || t === "touch";
}
function m8(r) {
  r.touching = !0, r.touchTimer != null && (clearTimeout(r.touchTimer), r.touchTimer = null), r.touchTimer = setTimeout(function() {
    r.touching = !1, r.touchTimer = null;
  }, 700);
}
function by(r) {
  r && (r.zrByTouch = !0);
}
function y8(r, t) {
  return Yn(r.dom, new _8(r, t), !0);
}
function SP(r, t) {
  for (var e = t, n = !1; e && e.nodeType !== 9 && !(n = e.domBelongToZr || e !== t && e === r.painterRoot); )
    e = e.parentNode;
  return n;
}
var _8 = /* @__PURE__ */ function() {
  function r(t, e) {
    this.stopPropagation = er, this.stopImmediatePropagation = er, this.preventDefault = er, this.type = e.type, this.target = this.currentTarget = t.dom, this.pointerType = e.pointerType, this.clientX = e.clientX, this.clientY = e.clientY;
  }
  return r;
}(), fi = {
  mousedown: function(r) {
    r = Yn(this.dom, r), this.__mayPointerCapture = [r.zrX, r.zrY], this.trigger("mousedown", r);
  },
  mousemove: function(r) {
    r = Yn(this.dom, r);
    var t = this.__mayPointerCapture;
    t && (r.zrX !== t[0] || r.zrY !== t[1]) && this.__togglePointerCapture(!0), this.trigger("mousemove", r);
  },
  mouseup: function(r) {
    r = Yn(this.dom, r), this.__togglePointerCapture(!1), this.trigger("mouseup", r);
  },
  mouseout: function(r) {
    r = Yn(this.dom, r);
    var t = r.toElement || r.relatedTarget;
    SP(this, t) || (this.__pointerCapturing && (r.zrEventControl = "no_globalout"), this.trigger("mouseout", r));
  },
  wheel: function(r) {
    GT = !0, r = Yn(this.dom, r), this.trigger("mousewheel", r);
  },
  mousewheel: function(r) {
    GT || (r = Yn(this.dom, r), this.trigger("mousewheel", r));
  },
  touchstart: function(r) {
    r = Yn(this.dom, r), by(r), this.__lastTouchMoment = /* @__PURE__ */ new Date(), this.handler.processGesture(r, "start"), fi.mousemove.call(this, r), fi.mousedown.call(this, r);
  },
  touchmove: function(r) {
    r = Yn(this.dom, r), by(r), this.handler.processGesture(r, "change"), fi.mousemove.call(this, r);
  },
  touchend: function(r) {
    r = Yn(this.dom, r), by(r), this.handler.processGesture(r, "end"), fi.mouseup.call(this, r), +/* @__PURE__ */ new Date() - +this.__lastTouchMoment < g8 && fi.click.call(this, r);
  },
  pointerdown: function(r) {
    fi.mousedown.call(this, r);
  },
  pointermove: function(r) {
    dx(r) || fi.mousemove.call(this, r);
  },
  pointerup: function(r) {
    fi.mouseup.call(this, r);
  },
  pointerout: function(r) {
    dx(r) || fi.mouseout.call(this, r);
  }
};
L(["click", "dblclick", "contextmenu"], function(r) {
  fi[r] = function(t) {
    t = Yn(this.dom, t), this.trigger(r, t);
  };
});
var px = {
  pointermove: function(r) {
    dx(r) || px.mousemove.call(this, r);
  },
  pointerup: function(r) {
    px.mouseup.call(this, r);
  },
  mousemove: function(r) {
    this.trigger("mousemove", r);
  },
  mouseup: function(r) {
    var t = this.__pointerCapturing;
    this.__togglePointerCapture(!1), this.trigger("mouseup", r), t && (r.zrEventControl = "only_globalout", this.trigger("mouseout", r));
  }
};
function x8(r, t) {
  var e = t.domHandlers;
  oe.pointerEventsSupported ? L(Sy.pointer, function(n) {
    $p(t, n, function(i) {
      e[n].call(r, i);
    });
  }) : (oe.touchEventsSupported && L(Sy.touch, function(n) {
    $p(t, n, function(i) {
      e[n].call(r, i), m8(t);
    });
  }), L(Sy.mouse, function(n) {
    $p(t, n, function(i) {
      i = w1(i), t.touching || e[n].call(r, i);
    });
  }));
}
function S8(r, t) {
  oe.pointerEventsSupported ? L(UT.pointer, e) : oe.touchEventsSupported || L(UT.mouse, e);
  function e(n) {
    function i(a) {
      a = w1(a), SP(r, a.target) || (a = y8(r, a), t.domHandlers[n].call(r, a));
    }
    $p(t, n, i, { capture: !0 });
  }
}
function $p(r, t, e, n) {
  r.mounted[t] = e, r.listenerOpts[t] = n, ex(r.domTarget, t, e, n);
}
function wy(r) {
  var t = r.mounted;
  for (var e in t)
    t.hasOwnProperty(e) && IW(r.domTarget, e, t[e], r.listenerOpts[e]);
  r.mounted = {};
}
var HT = /* @__PURE__ */ function() {
  function r(t, e) {
    this.mounted = {}, this.listenerOpts = {}, this.touching = !1, this.domTarget = t, this.domHandlers = e;
  }
  return r;
}(), b8 = function(r) {
  W(t, r);
  function t(e, n) {
    var i = r.call(this) || this;
    return i.__pointerCapturing = !1, i.dom = e, i.painterRoot = n, i._localHandlerScope = new HT(e, fi), xy && (i._globalHandlerScope = new HT(document, px)), x8(i, i._localHandlerScope), i;
  }
  return t.prototype.dispose = function() {
    wy(this._localHandlerScope), xy && wy(this._globalHandlerScope);
  }, t.prototype.setCursor = function(e) {
    this.dom.style && (this.dom.style.cursor = e || "default");
  }, t.prototype.__togglePointerCapture = function(e) {
    if (this.__mayPointerCapture = null, xy && +this.__pointerCapturing ^ +e) {
      this.__pointerCapturing = e;
      var n = this._globalHandlerScope;
      e ? S8(this, n) : wy(n);
    }
  }, t;
}(oi), bP = 1;
oe.hasGlobalWindow && (bP = Math.max(window.devicePixelRatio || window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI || 1, 1));
var Av = bP, vx = 0.4, gx = "#333", mx = "#ccc", w8 = "#eee", WT = Ug, XT = 5e-5;
function cs(r) {
  return r > XT || r < -XT;
}
var fs = [], tu = [], My = kr(), Ty = Math.abs, Da = function() {
  function r() {
  }
  return r.prototype.getLocalTransform = function(t) {
    return r.getLocalTransform(this, t);
  }, r.prototype.setPosition = function(t) {
    this.x = t[0], this.y = t[1];
  }, r.prototype.setScale = function(t) {
    this.scaleX = t[0], this.scaleY = t[1];
  }, r.prototype.setSkew = function(t) {
    this.skewX = t[0], this.skewY = t[1];
  }, r.prototype.setOrigin = function(t) {
    this.originX = t[0], this.originY = t[1];
  }, r.prototype.needLocalTransform = function() {
    return cs(this.rotation) || cs(this.x) || cs(this.y) || cs(this.scaleX - 1) || cs(this.scaleY - 1) || cs(this.skewX) || cs(this.skewY);
  }, r.prototype.updateTransform = function() {
    var t = this.parent && this.parent.transform, e = this.needLocalTransform(), n = this.transform;
    if (!(e || t)) {
      n && (WT(n), this.invTransform = null);
      return;
    }
    n = n || kr(), e ? this.getLocalTransform(n) : WT(n), t && (e ? ji(n, t, n) : Gg(n, t)), this.transform = n, this._resolveGlobalScaleRatio(n);
  }, r.prototype._resolveGlobalScaleRatio = function(t) {
    var e = this.globalScaleRatio;
    if (e != null && e !== 1) {
      this.getGlobalScale(fs);
      var n = fs[0] < 0 ? -1 : 1, i = fs[1] < 0 ? -1 : 1, a = ((fs[0] - n) * e + n) / fs[0] || 0, o = ((fs[1] - i) * e + i) / fs[1] || 0;
      t[0] *= a, t[1] *= a, t[2] *= o, t[3] *= o;
    }
    this.invTransform = this.invTransform || kr(), Si(this.invTransform, t);
  }, r.prototype.getComputedTransform = function() {
    for (var t = this, e = []; t; )
      e.push(t), t = t.parent;
    for (; t = e.pop(); )
      t.updateTransform();
    return this.transform;
  }, r.prototype.setLocalTransform = function(t) {
    if (t) {
      var e = t[0] * t[0] + t[1] * t[1], n = t[2] * t[2] + t[3] * t[3], i = Math.atan2(t[1], t[0]), a = Math.PI / 2 + i - Math.atan2(t[3], t[2]);
      n = Math.sqrt(n) * Math.cos(a), e = Math.sqrt(e), this.skewX = a, this.skewY = 0, this.rotation = -i, this.x = +t[4], this.y = +t[5], this.scaleX = e, this.scaleY = n, this.originX = 0, this.originY = 0;
    }
  }, r.prototype.decomposeTransform = function() {
    if (this.transform) {
      var t = this.parent, e = this.transform;
      t && t.transform && (t.invTransform = t.invTransform || kr(), ji(tu, t.invTransform, e), e = tu);
      var n = this.originX, i = this.originY;
      (n || i) && (My[4] = n, My[5] = i, ji(tu, e, My), tu[4] -= n, tu[5] -= i, e = tu), this.setLocalTransform(e);
    }
  }, r.prototype.getGlobalScale = function(t) {
    var e = this.transform;
    return t = t || [], e ? (t[0] = Math.sqrt(e[0] * e[0] + e[1] * e[1]), t[1] = Math.sqrt(e[2] * e[2] + e[3] * e[3]), e[0] < 0 && (t[0] = -t[0]), e[3] < 0 && (t[1] = -t[1]), t) : (t[0] = 1, t[1] = 1, t);
  }, r.prototype.transformCoordToLocal = function(t, e) {
    var n = [t, e], i = this.invTransform;
    return i && rr(n, n, i), n;
  }, r.prototype.transformCoordToGlobal = function(t, e) {
    var n = [t, e], i = this.transform;
    return i && rr(n, n, i), n;
  }, r.prototype.getLineScale = function() {
    var t = this.transform;
    return t && Ty(t[0] - 1) > 1e-10 && Ty(t[3] - 1) > 1e-10 ? Math.sqrt(Ty(t[0] * t[3] - t[2] * t[1])) : 1;
  }, r.prototype.copyTransform = function(t) {
    Ev(this, t);
  }, r.getLocalTransform = function(t, e) {
    e = e || [];
    var n = t.originX || 0, i = t.originY || 0, a = t.scaleX, o = t.scaleY, s = t.anchorX, l = t.anchorY, u = t.rotation || 0, c = t.x, f = t.y, h = t.skewX ? Math.tan(t.skewX) : 0, d = t.skewY ? Math.tan(-t.skewY) : 0;
    if (n || i || s || l) {
      var p = n + s, g = i + l;
      e[4] = -p * a - h * g * o, e[5] = -g * o - d * p * a;
    } else
      e[4] = e[5] = 0;
    return e[0] = a, e[3] = o, e[1] = d * a, e[2] = h * o, u && qo(e, e, u), e[4] += n + c, e[5] += i + f, e;
  }, r.initDefaultProps = function() {
    var t = r.prototype;
    t.scaleX = t.scaleY = t.globalScaleRatio = 1, t.x = t.y = t.originX = t.originY = t.skewX = t.skewY = t.rotation = t.anchorX = t.anchorY = 0;
  }(), r;
}(), na = [
  "x",
  "y",
  "originX",
  "originY",
  "anchorX",
  "anchorY",
  "rotation",
  "scaleX",
  "scaleY",
  "skewX",
  "skewY"
];
function Ev(r, t) {
  for (var e = 0; e < na.length; e++) {
    var n = na[e];
    r[n] = t[n];
  }
}
function Qi(r) {
  Id || (Id = new Qu(100)), r = r || za;
  var t = Id.get(r);
  return t || (t = {
    font: r,
    strWidthCache: new Qu(500),
    asciiWidthMap: null,
    asciiWidthMapTried: !1,
    stWideCharWidth: xi.measureText("", r).width,
    asciiCharWidth: xi.measureText("a", r).width
  }, Id.put(r, t)), t;
}
var Id;
function M8(r) {
  if (!(Ay >= YT)) {
    r = r || za;
    for (var t = [], e = +/* @__PURE__ */ new Date(), n = 0; n <= 127; n++)
      t[n] = xi.measureText(String.fromCharCode(n), r).width;
    var i = +/* @__PURE__ */ new Date() - e;
    return i > 16 ? Ay = YT : i > 2 && Ay++, t;
  }
}
var Ay = 0, YT = 5;
function wP(r, t) {
  return r.asciiWidthMapTried || (r.asciiWidthMap = M8(r.font), r.asciiWidthMapTried = !0), 0 <= t && t <= 127 ? r.asciiWidthMap != null ? r.asciiWidthMap[t] : r.asciiCharWidth : r.stWideCharWidth;
}
function ta(r, t) {
  var e = r.strWidthCache, n = e.get(t);
  return n == null && (n = xi.measureText(t, r.font).width, e.put(t, n)), n;
}
function $T(r, t, e, n) {
  var i = ta(Qi(t), r), a = Ph(t), o = tc(0, i, e), s = rl(0, a, n), l = new Bt(o, s, i, a);
  return l;
}
function Wg(r, t, e, n) {
  var i = ((r || "") + "").split(`
`), a = i.length;
  if (a === 1)
    return $T(i[0], t, e, n);
  for (var o = new Bt(0, 0, 0, 0), s = 0; s < i.length; s++) {
    var l = $T(i[s], t, e, n);
    s === 0 ? o.copy(l) : o.union(l);
  }
  return o;
}
function tc(r, t, e, n) {
  return e === "right" ? n ? r += t : r -= t : e === "center" && (n ? r += t / 2 : r -= t / 2), r;
}
function rl(r, t, e, n) {
  return e === "middle" ? n ? r += t / 2 : r -= t / 2 : e === "bottom" && (n ? r += t : r -= t), r;
}
function Ph(r) {
  return Qi(r).stWideCharWidth;
}
function bi(r, t) {
  return typeof r == "string" ? r.lastIndexOf("%") >= 0 ? parseFloat(r) / 100 * t : parseFloat(r) : r;
}
function Cv(r, t, e) {
  var n = t.position || "inside", i = t.distance != null ? t.distance : 5, a = e.height, o = e.width, s = a / 2, l = e.x, u = e.y, c = "left", f = "top";
  if (n instanceof Array)
    l += bi(n[0], e.width), u += bi(n[1], e.height), c = null, f = null;
  else
    switch (n) {
      case "left":
        l -= i, u += s, c = "right", f = "middle";
        break;
      case "right":
        l += i + o, u += s, f = "middle";
        break;
      case "top":
        l += o / 2, u -= i, c = "center", f = "bottom";
        break;
      case "bottom":
        l += o / 2, u += a + i, c = "center";
        break;
      case "inside":
        l += o / 2, u += s, c = "center", f = "middle";
        break;
      case "insideLeft":
        l += i, u += s, f = "middle";
        break;
      case "insideRight":
        l += o - i, u += s, c = "right", f = "middle";
        break;
      case "insideTop":
        l += o / 2, u += i, c = "center";
        break;
      case "insideBottom":
        l += o / 2, u += a - i, c = "center", f = "bottom";
        break;
      case "insideTopLeft":
        l += i, u += i;
        break;
      case "insideTopRight":
        l += o - i, u += i, c = "right";
        break;
      case "insideBottomLeft":
        l += i, u += a - i, f = "bottom";
        break;
      case "insideBottomRight":
        l += o - i, u += a - i, c = "right", f = "bottom";
        break;
    }
  return r = r || {}, r.x = l, r.y = u, r.align = c, r.verticalAlign = f, r;
}
var Ey = "__zr_normal__", Cy = na.concat(["ignore"]), T8 = ea(na, function(r, t) {
  return r[t] = !0, r;
}, { ignore: !1 }), eu = {}, A8 = new Bt(0, 0, 0, 0), Pd = [], Xg = function() {
  function r(t) {
    this.id = qI(), this.animators = [], this.currentStates = [], this.states = {}, this._init(t);
  }
  return r.prototype._init = function(t) {
    this.attr(t);
  }, r.prototype.drift = function(t, e, n) {
    switch (this.draggable) {
      case "horizontal":
        e = 0;
        break;
      case "vertical":
        t = 0;
        break;
    }
    var i = this.transform;
    i || (i = this.transform = [1, 0, 0, 1, 0, 0]), i[4] += t, i[5] += e, this.decomposeTransform(), this.markRedraw();
  }, r.prototype.beforeUpdate = function() {
  }, r.prototype.afterUpdate = function() {
  }, r.prototype.update = function() {
    this.updateTransform(), this.__dirty && this.updateInnerText();
  }, r.prototype.updateInnerText = function(t) {
    var e = this._textContent;
    if (e && (!e.ignore || t)) {
      this.textConfig || (this.textConfig = {});
      var n = this.textConfig, i = n.local, a = e.innerTransformable, o = void 0, s = void 0, l = !1;
      a.parent = i ? this : null;
      var u = !1;
      a.copyTransform(e);
      var c = n.position != null, f = n.autoOverflowArea, h = void 0;
      if ((f || c) && (h = A8, n.layoutRect ? h.copy(n.layoutRect) : h.copy(this.getBoundingRect()), i || h.applyTransform(this.transform)), c) {
        this.calculateTextPosition ? this.calculateTextPosition(eu, n, h) : Cv(eu, n, h), a.x = eu.x, a.y = eu.y, o = eu.align, s = eu.verticalAlign;
        var d = n.origin;
        if (d && n.rotation != null) {
          var p = void 0, g = void 0;
          d === "center" ? (p = h.width * 0.5, g = h.height * 0.5) : (p = bi(d[0], h.width), g = bi(d[1], h.height)), u = !0, a.originX = -a.x + p + (i ? 0 : h.x), a.originY = -a.y + g + (i ? 0 : h.y);
        }
      }
      n.rotation != null && (a.rotation = n.rotation);
      var v = n.offset;
      v && (a.x += v[0], a.y += v[1], u || (a.originX = -v[0], a.originY = -v[1]));
      var m = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {});
      if (f) {
        var y = m.overflowRect = m.overflowRect || new Bt(0, 0, 0, 0);
        a.getLocalTransform(Pd), Si(Pd, Pd), Bt.copy(y, h), y.applyTransform(Pd);
      } else
        m.overflowRect = null;
      var _ = n.inside == null ? typeof n.position == "string" && n.position.indexOf("inside") >= 0 : n.inside, x = void 0, b = void 0, S = void 0;
      _ && this.canBeInsideText() ? (x = n.insideFill, b = n.insideStroke, (x == null || x === "auto") && (x = this.getInsideTextFill()), (b == null || b === "auto") && (b = this.getInsideTextStroke(x), S = !0)) : (x = n.outsideFill, b = n.outsideStroke, (x == null || x === "auto") && (x = this.getOutsideFill()), (b == null || b === "auto") && (b = this.getOutsideStroke(x), S = !0)), x = x || "#000", (x !== m.fill || b !== m.stroke || S !== m.autoStroke || o !== m.align || s !== m.verticalAlign) && (l = !0, m.fill = x, m.stroke = b, m.autoStroke = S, m.align = o, m.verticalAlign = s, e.setDefaultTextStyle(m)), e.__dirty |= Rn, l && e.dirtyStyle(!0);
    }
  }, r.prototype.canBeInsideText = function() {
    return !0;
  }, r.prototype.getInsideTextFill = function() {
    return "#fff";
  }, r.prototype.getInsideTextStroke = function(t) {
    return "#000";
  }, r.prototype.getOutsideFill = function() {
    return this.__zr && this.__zr.isDarkMode() ? mx : gx;
  }, r.prototype.getOutsideStroke = function(t) {
    var e = this.__zr && this.__zr.getBackgroundColor(), n = typeof e == "string" && bn(e);
    n || (n = [255, 255, 255, 1]);
    for (var i = n[3], a = this.__zr.isDarkMode(), o = 0; o < 3; o++)
      n[o] = n[o] * i + (a ? 0 : 255) * (1 - i);
    return n[3] = 1, Ji(n, "rgba");
  }, r.prototype.traverse = function(t, e) {
  }, r.prototype.attrKV = function(t, e) {
    t === "textConfig" ? this.setTextConfig(e) : t === "textContent" ? this.setTextContent(e) : t === "clipPath" ? this.setClipPath(e) : t === "extra" ? (this.extra = this.extra || {}, J(this.extra, e)) : this[t] = e;
  }, r.prototype.hide = function() {
    this.ignore = !0, this.markRedraw();
  }, r.prototype.show = function() {
    this.ignore = !1, this.markRedraw();
  }, r.prototype.attr = function(t, e) {
    if (typeof t == "string")
      this.attrKV(t, e);
    else if (Dt(t))
      for (var n = t, i = se(n), a = 0; a < i.length; a++) {
        var o = i[a];
        this.attrKV(o, t[o]);
      }
    return this.markRedraw(), this;
  }, r.prototype.saveCurrentToNormalState = function(t) {
    this._innerSaveToNormal(t);
    for (var e = this._normalState, n = 0; n < this.animators.length; n++) {
      var i = this.animators[n], a = i.__fromStateTransition;
      if (!(i.getLoop() || a && a !== Ey)) {
        var o = i.targetName, s = o ? e[o] : e;
        i.saveTo(s);
      }
    }
  }, r.prototype._innerSaveToNormal = function(t) {
    var e = this._normalState;
    e || (e = this._normalState = {}), t.textConfig && !e.textConfig && (e.textConfig = this.textConfig), this._savePrimaryToNormal(t, e, Cy);
  }, r.prototype._savePrimaryToNormal = function(t, e, n) {
    for (var i = 0; i < n.length; i++) {
      var a = n[i];
      t[a] != null && !(a in e) && (e[a] = this[a]);
    }
  }, r.prototype.hasState = function() {
    return this.currentStates.length > 0;
  }, r.prototype.getState = function(t) {
    return this.states[t];
  }, r.prototype.ensureState = function(t) {
    var e = this.states;
    return e[t] || (e[t] = {}), e[t];
  }, r.prototype.clearStates = function(t) {
    this.useState(Ey, !1, t);
  }, r.prototype.useState = function(t, e, n, i) {
    var a = t === Ey, o = this.hasState();
    if (!(!o && a)) {
      var s = this.currentStates, l = this.stateTransition;
      if (!(Zt(s, t) >= 0 && (e || s.length === 1))) {
        var u;
        if (this.stateProxy && !a && (u = this.stateProxy(t)), u || (u = this.states && this.states[t]), !u && !a) {
          gi("State " + t + " not exists.");
          return;
        }
        a || this.saveCurrentToNormalState(u);
        var c = !!(u && u.hoverLayer || i);
        c && this._toggleHoverLayerFlag(!0), this._applyStateObj(t, u, this._normalState, e, !n && !this.__inHover && l && l.duration > 0, l);
        var f = this._textContent, h = this._textGuide;
        return f && f.useState(t, e, n, c), h && h.useState(t, e, n, c), a ? (this.currentStates = [], this._normalState = {}) : e ? this.currentStates.push(t) : this.currentStates = [t], this._updateAnimationTargets(), this.markRedraw(), !c && this.__inHover && (this._toggleHoverLayerFlag(!1), this.__dirty &= ~Rn), u;
      }
    }
  }, r.prototype.useStates = function(t, e, n) {
    if (!t.length)
      this.clearStates();
    else {
      var i = [], a = this.currentStates, o = t.length, s = o === a.length;
      if (s) {
        for (var l = 0; l < o; l++)
          if (t[l] !== a[l]) {
            s = !1;
            break;
          }
      }
      if (s)
        return;
      for (var l = 0; l < o; l++) {
        var u = t[l], c = void 0;
        this.stateProxy && (c = this.stateProxy(u, t)), c || (c = this.states[u]), c && i.push(c);
      }
      var f = i[o - 1], h = !!(f && f.hoverLayer || n);
      h && this._toggleHoverLayerFlag(!0);
      var d = this._mergeStates(i), p = this.stateTransition;
      this.saveCurrentToNormalState(d), this._applyStateObj(t.join(","), d, this._normalState, !1, !e && !this.__inHover && p && p.duration > 0, p);
      var g = this._textContent, v = this._textGuide;
      g && g.useStates(t, e, h), v && v.useStates(t, e, h), this._updateAnimationTargets(), this.currentStates = t.slice(), this.markRedraw(), !h && this.__inHover && (this._toggleHoverLayerFlag(!1), this.__dirty &= ~Rn);
    }
  }, r.prototype.isSilent = function() {
    for (var t = this; t; ) {
      if (t.silent)
        return !0;
      var e = t.__hostTarget;
      t = e ? t.ignoreHostSilent ? null : e : t.parent;
    }
    return !1;
  }, r.prototype._updateAnimationTargets = function() {
    for (var t = 0; t < this.animators.length; t++) {
      var e = this.animators[t];
      e.targetName && e.changeTarget(this[e.targetName]);
    }
  }, r.prototype.removeState = function(t) {
    var e = Zt(this.currentStates, t);
    if (e >= 0) {
      var n = this.currentStates.slice();
      n.splice(e, 1), this.useStates(n);
    }
  }, r.prototype.replaceState = function(t, e, n) {
    var i = this.currentStates.slice(), a = Zt(i, t), o = Zt(i, e) >= 0;
    a >= 0 ? o ? i.splice(a, 1) : i[a] = e : n && !o && i.push(e), this.useStates(i);
  }, r.prototype.toggleState = function(t, e) {
    e ? this.useState(t, !0) : this.removeState(t);
  }, r.prototype._mergeStates = function(t) {
    for (var e = {}, n, i = 0; i < t.length; i++) {
      var a = t[i];
      J(e, a), a.textConfig && (n = n || {}, J(n, a.textConfig));
    }
    return n && (e.textConfig = n), e;
  }, r.prototype._applyStateObj = function(t, e, n, i, a, o) {
    var s = !(e && i);
    e && e.textConfig ? (this.textConfig = J({}, i ? this.textConfig : n.textConfig), J(this.textConfig, e.textConfig)) : s && n.textConfig && (this.textConfig = n.textConfig);
    for (var l = {}, u = !1, c = 0; c < Cy.length; c++) {
      var f = Cy[c], h = a && T8[f];
      e && e[f] != null ? h ? (u = !0, l[f] = e[f]) : this[f] = e[f] : s && n[f] != null && (h ? (u = !0, l[f] = n[f]) : this[f] = n[f]);
    }
    if (!a)
      for (var c = 0; c < this.animators.length; c++) {
        var d = this.animators[c], p = d.targetName;
        d.getLoop() || d.__changeFinalValue(p ? (e || n)[p] : e || n);
      }
    u && this._transitionState(t, l, o);
  }, r.prototype._attachComponent = function(t) {
    if (t.__zr && !t.__hostTarget) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("Text element has been added to zrender.");
      return;
    }
    if (t === this) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("Recursive component attachment.");
      return;
    }
    var e = this.__zr;
    e && t.addSelfToZr(e), t.__zr = e, t.__hostTarget = this;
  }, r.prototype._detachComponent = function(t) {
    t.__zr && t.removeSelfFromZr(t.__zr), t.__zr = null, t.__hostTarget = null;
  }, r.prototype.getClipPath = function() {
    return this._clipPath;
  }, r.prototype.setClipPath = function(t) {
    this._clipPath && this._clipPath !== t && this.removeClipPath(), this._attachComponent(t), this._clipPath = t, this.markRedraw();
  }, r.prototype.removeClipPath = function() {
    var t = this._clipPath;
    t && (this._detachComponent(t), this._clipPath = null, this.markRedraw());
  }, r.prototype.getTextContent = function() {
    return this._textContent;
  }, r.prototype.setTextContent = function(t) {
    var e = this._textContent;
    if (e !== t) {
      if (e && e !== t && this.removeTextContent(), process.env.NODE_ENV !== "production" && t.__zr && !t.__hostTarget)
        throw new Error("Text element has been added to zrender.");
      t.innerTransformable = new Da(), this._attachComponent(t), this._textContent = t, this.markRedraw();
    }
  }, r.prototype.setTextConfig = function(t) {
    this.textConfig || (this.textConfig = {}), J(this.textConfig, t), this.markRedraw();
  }, r.prototype.removeTextConfig = function() {
    this.textConfig = null, this.markRedraw();
  }, r.prototype.removeTextContent = function() {
    var t = this._textContent;
    t && (t.innerTransformable = null, this._detachComponent(t), this._textContent = null, this._innerTextDefaultStyle = null, this.markRedraw());
  }, r.prototype.getTextGuideLine = function() {
    return this._textGuide;
  }, r.prototype.setTextGuideLine = function(t) {
    this._textGuide && this._textGuide !== t && this.removeTextGuideLine(), this._attachComponent(t), this._textGuide = t, this.markRedraw();
  }, r.prototype.removeTextGuideLine = function() {
    var t = this._textGuide;
    t && (this._detachComponent(t), this._textGuide = null, this.markRedraw());
  }, r.prototype.markRedraw = function() {
    this.__dirty |= Rn;
    var t = this.__zr;
    t && (this.__inHover ? t.refreshHover() : t.refresh()), this.__hostTarget && this.__hostTarget.markRedraw();
  }, r.prototype.dirty = function() {
    this.markRedraw();
  }, r.prototype._toggleHoverLayerFlag = function(t) {
    this.__inHover = t;
    var e = this._textContent, n = this._textGuide;
    e && (e.__inHover = t), n && (n.__inHover = t);
  }, r.prototype.addSelfToZr = function(t) {
    if (this.__zr !== t) {
      this.__zr = t;
      var e = this.animators;
      if (e)
        for (var n = 0; n < e.length; n++)
          t.animation.addAnimator(e[n]);
      this._clipPath && this._clipPath.addSelfToZr(t), this._textContent && this._textContent.addSelfToZr(t), this._textGuide && this._textGuide.addSelfToZr(t);
    }
  }, r.prototype.removeSelfFromZr = function(t) {
    if (this.__zr) {
      this.__zr = null;
      var e = this.animators;
      if (e)
        for (var n = 0; n < e.length; n++)
          t.animation.removeAnimator(e[n]);
      this._clipPath && this._clipPath.removeSelfFromZr(t), this._textContent && this._textContent.removeSelfFromZr(t), this._textGuide && this._textGuide.removeSelfFromZr(t);
    }
  }, r.prototype.animate = function(t, e, n) {
    var i = t ? this[t] : this;
    if (process.env.NODE_ENV !== "production" && !i) {
      gi('Property "' + t + '" is not existed in element ' + this.id);
      return;
    }
    var a = new E1(i, e, n);
    return t && (a.targetName = t), this.addAnimator(a, t), a;
  }, r.prototype.addAnimator = function(t, e) {
    var n = this.__zr, i = this;
    t.during(function() {
      i.updateDuringAnimation(e);
    }).done(function() {
      var a = i.animators, o = Zt(a, t);
      o >= 0 && a.splice(o, 1);
    }), this.animators.push(t), n && n.animation.addAnimator(t), n && n.wakeUp();
  }, r.prototype.updateDuringAnimation = function(t) {
    this.markRedraw();
  }, r.prototype.stopAnimation = function(t, e) {
    for (var n = this.animators, i = n.length, a = [], o = 0; o < i; o++) {
      var s = n[o];
      !t || t === s.scope ? s.stop(e) : a.push(s);
    }
    return this.animators = a, this;
  }, r.prototype.animateTo = function(t, e, n) {
    Dy(this, t, e, n);
  }, r.prototype.animateFrom = function(t, e, n) {
    Dy(this, t, e, n, !0);
  }, r.prototype._transitionState = function(t, e, n, i) {
    for (var a = Dy(this, e, n, i), o = 0; o < a.length; o++)
      a[o].__fromStateTransition = t;
  }, r.prototype.getBoundingRect = function() {
    return null;
  }, r.prototype.getPaintRect = function() {
    return null;
  }, r.initDefaultProps = function() {
    var t = r.prototype;
    t.type = "element", t.name = "", t.ignore = t.silent = t.ignoreHostSilent = t.isGroup = t.draggable = t.dragging = t.ignoreClip = t.__inHover = !1, t.__dirty = Rn;
    var e = {};
    function n(a, o, s) {
      e[a + o + s] || (console.warn("DEPRECATED: '" + a + "' has been deprecated. use '" + o + "', '" + s + "' instead"), e[a + o + s] = !0);
    }
    function i(a, o, s, l) {
      Object.defineProperty(t, a, {
        get: function() {
          if (process.env.NODE_ENV !== "production" && n(a, s, l), !this[o]) {
            var c = this[o] = [];
            u(this, c);
          }
          return this[o];
        },
        set: function(c) {
          process.env.NODE_ENV !== "production" && n(a, s, l), this[s] = c[0], this[l] = c[1], this[o] = c, u(this, c);
        }
      });
      function u(c, f) {
        Object.defineProperty(f, 0, {
          get: function() {
            return c[s];
          },
          set: function(h) {
            c[s] = h;
          }
        }), Object.defineProperty(f, 1, {
          get: function() {
            return c[l];
          },
          set: function(h) {
            c[l] = h;
          }
        });
      }
    }
    Object.defineProperty && (i("position", "_legacyPos", "x", "y"), i("scale", "_legacyScale", "scaleX", "scaleY"), i("origin", "_legacyOrigin", "originX", "originY"));
  }(), r;
}();
hr(Xg, oi);
hr(Xg, Da);
function Dy(r, t, e, n, i) {
  e = e || {};
  var a = [];
  MP(r, "", r, t, e, n, a, i);
  var o = a.length, s = !1, l = e.done, u = e.aborted, c = function() {
    s = !0, o--, o <= 0 && (s ? l && l() : u && u());
  }, f = function() {
    o--, o <= 0 && (s ? l && l() : u && u());
  };
  o || l && l(), a.length > 0 && e.during && a[0].during(function(p, g) {
    e.during(g);
  });
  for (var h = 0; h < a.length; h++) {
    var d = a[h];
    c && d.done(c), f && d.aborted(f), e.force && d.duration(e.duration), d.start(e.easing);
  }
  return a;
}
function Ly(r, t, e) {
  for (var n = 0; n < e; n++)
    r[n] = t[n];
}
function E8(r) {
  return qr(r[0]);
}
function C8(r, t, e) {
  if (qr(t[e]))
    if (qr(r[e]) || (r[e] = []), fn(t[e])) {
      var n = t[e].length;
      r[e].length !== n && (r[e] = new t[e].constructor(n), Ly(r[e], t[e], n));
    } else {
      var i = t[e], a = r[e], o = i.length;
      if (E8(i))
        for (var s = i[0].length, l = 0; l < o; l++)
          a[l] ? Ly(a[l], i[l], s) : a[l] = Array.prototype.slice.call(i[l]);
      else
        Ly(a, i, o);
      a.length = i.length;
    }
  else
    r[e] = t[e];
}
function D8(r, t) {
  return r === t || qr(r) && qr(t) && L8(r, t);
}
function L8(r, t) {
  var e = r.length;
  if (e !== t.length)
    return !1;
  for (var n = 0; n < e; n++)
    if (r[n] !== t[n])
      return !1;
  return !0;
}
function MP(r, t, e, n, i, a, o, s) {
  for (var l = se(n), u = i.duration, c = i.delay, f = i.additive, h = i.setToFinal, d = !Dt(a), p = r.animators, g = [], v = 0; v < l.length; v++) {
    var m = l[v], y = n[m];
    if (y != null && e[m] != null && (d || a[m]))
      if (Dt(y) && !qr(y) && !Vg(y)) {
        if (t) {
          s || (e[m] = y, r.updateDuringAnimation(t));
          continue;
        }
        MP(r, m, e[m], y, i, a && a[m], o, s);
      } else
        g.push(m);
    else
      s || (e[m] = y, r.updateDuringAnimation(t), g.push(m));
  }
  var _ = g.length;
  if (!f && _)
    for (var x = 0; x < p.length; x++) {
      var b = p[x];
      if (b.targetName === t) {
        var S = b.stopTracks(g);
        if (S) {
          var w = Zt(p, b);
          p.splice(w, 1);
        }
      }
    }
  if (i.force || (g = Te(g, function(E) {
    return !D8(n[E], e[E]);
  }), _ = g.length), _ > 0 || i.force && !o.length) {
    var A = void 0, T = void 0, M = void 0;
    if (s) {
      T = {}, h && (A = {});
      for (var x = 0; x < _; x++) {
        var m = g[x];
        T[m] = e[m], h ? A[m] = n[m] : e[m] = n[m];
      }
    } else if (h) {
      M = {};
      for (var x = 0; x < _; x++) {
        var m = g[x];
        M[m] = Hf(e[m]), C8(e, n, m);
      }
    }
    var b = new E1(e, !1, !1, f ? Te(p, function(R) {
      return R.targetName === t;
    }) : null);
    b.targetName = t, i.scope && (b.scope = i.scope), h && A && b.whenWithKeys(0, A, g), M && b.whenWithKeys(0, M, g), b.whenWithKeys(u ?? 500, s ? T : n, g).delay(c || 0), r.addAnimator(b, t), o.push(b);
  }
}
var Et = function(r) {
  W(t, r);
  function t(e) {
    var n = r.call(this) || this;
    return n.isGroup = !0, n._children = [], n.attr(e), n;
  }
  return t.prototype.childrenRef = function() {
    return this._children;
  }, t.prototype.children = function() {
    return this._children.slice();
  }, t.prototype.childAt = function(e) {
    return this._children[e];
  }, t.prototype.childOfName = function(e) {
    for (var n = this._children, i = 0; i < n.length; i++)
      if (n[i].name === e)
        return n[i];
  }, t.prototype.childCount = function() {
    return this._children.length;
  }, t.prototype.add = function(e) {
    if (e && (e !== this && e.parent !== this && (this._children.push(e), this._doAdd(e)), process.env.NODE_ENV !== "production" && e.__hostTarget))
      throw "This elemenet has been used as an attachment";
    return this;
  }, t.prototype.addBefore = function(e, n) {
    if (e && e !== this && e.parent !== this && n && n.parent === this) {
      var i = this._children, a = i.indexOf(n);
      a >= 0 && (i.splice(a, 0, e), this._doAdd(e));
    }
    return this;
  }, t.prototype.replace = function(e, n) {
    var i = Zt(this._children, e);
    return i >= 0 && this.replaceAt(n, i), this;
  }, t.prototype.replaceAt = function(e, n) {
    var i = this._children, a = i[n];
    if (e && e !== this && e.parent !== this && e !== a) {
      i[n] = e, a.parent = null;
      var o = this.__zr;
      o && a.removeSelfFromZr(o), this._doAdd(e);
    }
    return this;
  }, t.prototype._doAdd = function(e) {
    e.parent && e.parent.remove(e), e.parent = this;
    var n = this.__zr;
    n && n !== e.__zr && e.addSelfToZr(n), n && n.refresh();
  }, t.prototype.remove = function(e) {
    var n = this.__zr, i = this._children, a = Zt(i, e);
    return a < 0 ? this : (i.splice(a, 1), e.parent = null, n && e.removeSelfFromZr(n), n && n.refresh(), this);
  }, t.prototype.removeAll = function() {
    for (var e = this._children, n = this.__zr, i = 0; i < e.length; i++) {
      var a = e[i];
      n && a.removeSelfFromZr(n), a.parent = null;
    }
    return e.length = 0, this;
  }, t.prototype.eachChild = function(e, n) {
    for (var i = this._children, a = 0; a < i.length; a++) {
      var o = i[a];
      e.call(n, o, a);
    }
    return this;
  }, t.prototype.traverse = function(e, n) {
    for (var i = 0; i < this._children.length; i++) {
      var a = this._children[i], o = e.call(n, a);
      a.isGroup && !o && a.traverse(e, n);
    }
    return this;
  }, t.prototype.addSelfToZr = function(e) {
    r.prototype.addSelfToZr.call(this, e);
    for (var n = 0; n < this._children.length; n++) {
      var i = this._children[n];
      i.addSelfToZr(e);
    }
  }, t.prototype.removeSelfFromZr = function(e) {
    r.prototype.removeSelfFromZr.call(this, e);
    for (var n = 0; n < this._children.length; n++) {
      var i = this._children[n];
      i.removeSelfFromZr(e);
    }
  }, t.prototype.getBoundingRect = function(e) {
    for (var n = new Bt(0, 0, 0, 0), i = e || this._children, a = [], o = null, s = 0; s < i.length; s++) {
      var l = i[s];
      if (!(l.ignore || l.invisible)) {
        var u = l.getBoundingRect(), c = l.getLocalTransform(a);
        c ? (Bt.applyTransform(n, u, c), o = o || n.clone(), o.union(n)) : (o = o || u.clone(), o.union(u));
      }
    }
    return o || n;
  }, t;
}(Xg);
Et.prototype.type = "group";
/*!
* ZRender, a high performance 2d drawing library.
*
* Copyright (c) 2013, Baidu Inc.
* All rights reserved.
*
* LICENSE
* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
*/
var Cf = {}, TP = {};
function R8(r) {
  delete TP[r];
}
function I8(r) {
  if (!r)
    return !1;
  if (typeof r == "string")
    return Mv(r, 1) < vx;
  if (r.colorStops) {
    for (var t = r.colorStops, e = 0, n = t.length, i = 0; i < n; i++)
      e += Mv(t[i].color, 1);
    return e /= n, e < vx;
  }
  return !1;
}
var P8 = function() {
  function r(t, e, n) {
    var i = this;
    this._sleepAfterStill = 10, this._stillFrameAccum = 0, this._needsRefresh = !0, this._needsRefreshHover = !0, this._darkMode = !1, n = n || {}, this.dom = e, this.id = t;
    var a = new $W(), o = n.renderer || "canvas";
    if (Cf[o] || (o = se(Cf)[0]), process.env.NODE_ENV !== "production" && !Cf[o])
      throw new Error("Renderer '" + o + "' is not imported. Please import it first.");
    n.useDirtyRect = n.useDirtyRect == null ? !1 : n.useDirtyRect;
    var s = new Cf[o](e, a, n, t), l = n.ssr || s.ssrOnly;
    this.storage = a, this.painter = s;
    var u = !oe.node && !oe.worker && !l ? new b8(s.getViewportRoot(), s.root) : null, c = n.useCoarsePointer, f = c == null || c === "auto" ? oe.touchEventsSupported : !!c, h = 44, d;
    f && (d = bt(n.pointerSize, h)), this.handler = new nP(a, s, u, s.root, d), this.animation = new v8({
      stage: {
        update: l ? null : function() {
          return i._flush(!0);
        }
      }
    }), l || this.animation.start();
  }
  return r.prototype.add = function(t) {
    this._disposed || !t || (this.storage.addRoot(t), t.addSelfToZr(this), this.refresh());
  }, r.prototype.remove = function(t) {
    this._disposed || !t || (this.storage.delRoot(t), t.removeSelfFromZr(this), this.refresh());
  }, r.prototype.configLayer = function(t, e) {
    this._disposed || (this.painter.configLayer && this.painter.configLayer(t, e), this.refresh());
  }, r.prototype.setBackgroundColor = function(t) {
    this._disposed || (this.painter.setBackgroundColor && this.painter.setBackgroundColor(t), this.refresh(), this._backgroundColor = t, this._darkMode = I8(t));
  }, r.prototype.getBackgroundColor = function() {
    return this._backgroundColor;
  }, r.prototype.setDarkMode = function(t) {
    this._darkMode = t;
  }, r.prototype.isDarkMode = function() {
    return this._darkMode;
  }, r.prototype.refreshImmediately = function(t) {
    this._disposed || (t || this.animation.update(!0), this._needsRefresh = !1, this.painter.refresh(), this._needsRefresh = !1);
  }, r.prototype.refresh = function() {
    this._disposed || (this._needsRefresh = !0, this.animation.start());
  }, r.prototype.flush = function() {
    this._disposed || this._flush(!1);
  }, r.prototype._flush = function(t) {
    var e, n = Nu();
    this._needsRefresh && (e = !0, this.refreshImmediately(t)), this._needsRefreshHover && (e = !0, this.refreshHoverImmediately());
    var i = Nu();
    e ? (this._stillFrameAccum = 0, this.trigger("rendered", {
      elapsedTime: i - n
    })) : this._sleepAfterStill > 0 && (this._stillFrameAccum++, this._stillFrameAccum > this._sleepAfterStill && this.animation.stop());
  }, r.prototype.setSleepAfterStill = function(t) {
    this._sleepAfterStill = t;
  }, r.prototype.wakeUp = function() {
    this._disposed || (this.animation.start(), this._stillFrameAccum = 0);
  }, r.prototype.refreshHover = function() {
    this._needsRefreshHover = !0;
  }, r.prototype.refreshHoverImmediately = function() {
    this._disposed || (this._needsRefreshHover = !1, this.painter.refreshHover && this.painter.getType() === "canvas" && this.painter.refreshHover());
  }, r.prototype.resize = function(t) {
    this._disposed || (t = t || {}, this.painter.resize(t.width, t.height), this.handler.resize());
  }, r.prototype.clearAnimation = function() {
    this._disposed || this.animation.clear();
  }, r.prototype.getWidth = function() {
    if (!this._disposed)
      return this.painter.getWidth();
  }, r.prototype.getHeight = function() {
    if (!this._disposed)
      return this.painter.getHeight();
  }, r.prototype.setCursorStyle = function(t) {
    this._disposed || this.handler.setCursorStyle(t);
  }, r.prototype.findHover = function(t, e) {
    if (!this._disposed)
      return this.handler.findHover(t, e);
  }, r.prototype.on = function(t, e, n) {
    return this._disposed || this.handler.on(t, e, n), this;
  }, r.prototype.off = function(t, e) {
    this._disposed || this.handler.off(t, e);
  }, r.prototype.trigger = function(t, e) {
    this._disposed || this.handler.trigger(t, e);
  }, r.prototype.clear = function() {
    if (!this._disposed) {
      for (var t = this.storage.getRoots(), e = 0; e < t.length; e++)
        t[e] instanceof Et && t[e].removeSelfFromZr(this);
      this.storage.delAllRoots(), this.painter.clear();
    }
  }, r.prototype.dispose = function() {
    this._disposed || (this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler.dispose(), this.animation = this.storage = this.painter = this.handler = null, this._disposed = !0, R8(this.id));
  }, r;
}();
function ZT(r, t) {
  var e = new P8(qI(), r, t);
  return TP[e.id] = e, e;
}
function N8(r, t) {
  Cf[r] = t;
}
var yx;
function O8(r) {
  if (typeof yx == "function")
    return yx(r);
}
function k8(r) {
  yx = r;
}
var qT = 1e-4, AP = 20;
function B8(r) {
  return r.replace(/^\s+|\s+$/g, "");
}
var kn = Math.min, tr = Math.max, Xi = Math.abs;
function Me(r, t, e, n) {
  var i = t[0], a = t[1], o = e[0], s = e[1], l = a - i, u = s - o;
  if (l === 0)
    return u === 0 ? o : (o + s) / 2;
  if (n)
    if (l > 0) {
      if (r <= i)
        return o;
      if (r >= a)
        return s;
    } else {
      if (r >= i)
        return o;
      if (r <= a)
        return s;
    }
  else {
    if (r === i)
      return o;
    if (r === a)
      return s;
  }
  return (r - i) / l * u + o;
}
var dt = V8;
function V8(r, t, e) {
  switch (r) {
    case "center":
    case "middle":
      r = "50%";
      break;
    case "left":
    case "top":
      r = "0%";
      break;
    case "right":
    case "bottom":
      r = "100%";
      break;
  }
  return Dv(r, t, e);
}
function Dv(r, t, e) {
  return pt(r) ? B8(r).match(/%$/) ? parseFloat(r) / 100 * t + (e || 0) : parseFloat(r) : r == null ? NaN : +r;
}
function or(r, t, e) {
  return t == null && (t = 10), t = Math.min(Math.max(0, t), AP), r = (+r).toFixed(t), e ? r : +r;
}
function ei(r) {
  return r.sort(function(t, e) {
    return t - e;
  }), r;
}
function Yi(r) {
  if (r = +r, isNaN(r))
    return 0;
  if (r > 1e-14) {
    for (var t = 1, e = 0; e < 15; e++, t *= 10)
      if (Math.round(r * t) / t === r)
        return e;
  }
  return _x(r);
}
function _x(r) {
  var t = r.toString().toLowerCase(), e = t.indexOf("e"), n = e > 0 ? +t.slice(e + 1) : 0, i = e > 0 ? e : t.length, a = t.indexOf("."), o = a < 0 ? 0 : i - 1 - a;
  return Math.max(0, o - n);
}
function EP(r, t) {
  var e = Math.log, n = Math.LN10, i = Math.floor(e(r[1] - r[0]) / n), a = Math.round(e(Xi(t[1] - t[0])) / n), o = Math.min(Math.max(-i + a, 0), 20);
  return isFinite(o) ? o : 20;
}
function F8(r, t) {
  var e = ea(r, function(d, p) {
    return d + (isNaN(p) ? 0 : p);
  }, 0);
  if (e === 0)
    return [];
  for (var n = Math.pow(10, t), i = rt(r, function(d) {
    return (isNaN(d) ? 0 : d) / e * n * 100;
  }), a = n * 100, o = rt(i, function(d) {
    return Math.floor(d);
  }), s = ea(o, function(d, p) {
    return d + p;
  }, 0), l = rt(i, function(d, p) {
    return d - o[p];
  }); s < a; ) {
    for (var u = Number.NEGATIVE_INFINITY, c = null, f = 0, h = l.length; f < h; ++f)
      l[f] > u && (u = l[f], c = f);
    ++o[c], l[c] = 0, ++s;
  }
  return rt(o, function(d) {
    return d / n;
  });
}
function z8(r, t) {
  var e = Math.max(Yi(r), Yi(t)), n = r + t;
  return e > AP ? n : or(n, e);
}
var KT = 9007199254740991;
function CP(r) {
  var t = Math.PI * 2;
  return (r % t + t) % t;
}
function ih(r) {
  return r > -qT && r < qT;
}
var U8 = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
function Tl(r) {
  if (r instanceof Date)
    return r;
  if (pt(r)) {
    var t = U8.exec(r);
    if (!t)
      return /* @__PURE__ */ new Date(NaN);
    if (t[8]) {
      var e = +t[4] || 0;
      return t[8].toUpperCase() !== "Z" && (e -= +t[8].slice(0, 3)), new Date(Date.UTC(+t[1], +(t[2] || 1) - 1, +t[3] || 1, e, +(t[5] || 0), +t[6] || 0, t[7] ? +t[7].substring(0, 3) : 0));
    } else
      return new Date(+t[1], +(t[2] || 1) - 1, +t[3] || 1, +t[4] || 0, +(t[5] || 0), +t[6] || 0, t[7] ? +t[7].substring(0, 3) : 0);
  } else if (r == null)
    return /* @__PURE__ */ new Date(NaN);
  return new Date(Math.round(r));
}
function G8(r) {
  return Math.pow(10, Yg(r));
}
function Yg(r) {
  if (r === 0)
    return 0;
  var t = Math.floor(Math.log(r) / Math.LN10);
  return r / Math.pow(10, t) >= 10 && t++, t;
}
function DP(r, t) {
  var e = Yg(r), n = Math.pow(10, e), i = r / n, a;
  return i < 1.5 ? a = 1 : i < 2.5 ? a = 2 : i < 4 ? a = 3 : i < 7 ? a = 5 : a = 10, r = a * n, e >= -20 ? +r.toFixed(e < 0 ? -e : 0) : r;
}
function Ry(r, t) {
  var e = (r.length - 1) * t + 1, n = Math.floor(e), i = +r[n - 1], a = e - n;
  return a ? i + a * (r[n] - i) : i;
}
function jT(r) {
  r.sort(function(l, u) {
    return s(l, u, 0) ? -1 : 1;
  });
  for (var t = -1 / 0, e = 1, n = 0; n < r.length; ) {
    for (var i = r[n].interval, a = r[n].close, o = 0; o < 2; o++)
      i[o] <= t && (i[o] = t, a[o] = o ? 1 : 1 - e), t = i[o], e = a[o];
    i[0] === i[1] && a[0] * a[1] !== 1 ? r.splice(n, 1) : n++;
  }
  return r;
  function s(l, u, c) {
    return l.interval[c] < u.interval[c] || l.interval[c] === u.interval[c] && (l.close[c] - u.close[c] === (c ? -1 : 1) || !c && s(l, u, 1));
  }
}
function Ga(r) {
  var t = parseFloat(r);
  return t == r && (t !== 0 || !pt(r) || r.indexOf("x") <= 0) ? t : NaN;
}
function C1(r) {
  return !isNaN(Ga(r));
}
function LP() {
  return Math.round(Math.random() * 9);
}
function RP(r, t) {
  return t === 0 ? r : RP(t, r % t);
}
function JT(r, t) {
  return r == null ? t : t == null ? r : r * t / RP(r, t);
}
var H8 = "[ECharts] ", QT = {}, W8 = typeof console < "u" && console.warn && console.log;
function $g(r, t, e) {
  if (W8) {
    if (e) {
      if (QT[t])
        return;
      QT[t] = !0;
    }
    console[r](H8 + t);
  }
}
function IP(r, t) {
  $g("log", r, t);
}
function Xe(r, t) {
  $g("warn", r, t);
}
function ce(r, t) {
  $g("error", r, t);
}
function ia(r) {
  process.env.NODE_ENV !== "production" && $g("warn", "DEPRECATED: " + r, !0);
}
function ar(r, t, e) {
  process.env.NODE_ENV !== "production" && ia((e ? "[" + e + "]" : "") + (r + " is deprecated; use " + t + " instead."));
}
function hn() {
  for (var r = [], t = 0; t < arguments.length; t++)
    r[t] = arguments[t];
  var e = "";
  if (process.env.NODE_ENV !== "production") {
    var n = function(i) {
      return i === void 0 ? "undefined" : i === 1 / 0 ? "Infinity" : i === -1 / 0 ? "-Infinity" : Or(i) ? "NaN" : i instanceof Date ? "Date(" + i.toISOString() + ")" : Tt(i) ? "function () { ... }" : KI(i) ? i + "" : null;
    };
    e = rt(r, function(i) {
      if (pt(i))
        return i;
      var a = n(i);
      if (a != null)
        return a;
      if (typeof JSON < "u" && JSON.stringify)
        try {
          return JSON.stringify(i, function(o, s) {
            var l = n(s);
            return l ?? s;
          });
        } catch {
          return "?";
        }
      else
        return "?";
    }).join(" ");
  }
  return e;
}
function we(r) {
  throw new Error(r);
}
function tA(r, t, e) {
  return (t - r) * e + r;
}
var PP = "series\0", NP = "\0_ec_\0";
function Ie(r) {
  return r instanceof Array ? r : r == null ? [] : [r];
}
function hl(r, t, e) {
  if (r) {
    r[t] = r[t] || {}, r.emphasis = r.emphasis || {}, r.emphasis[t] = r.emphasis[t] || {};
    for (var n = 0, i = e.length; n < i; n++) {
      var a = e[n];
      !r.emphasis[t].hasOwnProperty(a) && r[t].hasOwnProperty(a) && (r.emphasis[t][a] = r[t][a]);
    }
  }
}
var eA = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor", "textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth", "borderRadius", "padding"];
function xc(r) {
  return Dt(r) && !et(r) && !(r instanceof Date) ? r.value : r;
}
function X8(r) {
  return Dt(r) && !(r instanceof Array);
}
function OP(r, t, e) {
  var n = e === "normalMerge", i = e === "replaceMerge", a = e === "replaceAll";
  r = r || [], t = (t || []).slice();
  var o = wt();
  L(t, function(l, u) {
    if (!Dt(l)) {
      t[u] = null;
      return;
    }
    process.env.NODE_ENV !== "production" && (l.id != null && !nA(l.id) && rA(l.id), l.name != null && !nA(l.name) && rA(l.name));
  });
  var s = Y8(r, o, e);
  return (n || i) && $8(s, r, o, t), n && Z8(s, t), n || i ? q8(s, t, i) : a && K8(s, t), j8(s), s;
}
function Y8(r, t, e) {
  var n = [];
  if (e === "replaceAll")
    return n;
  for (var i = 0; i < r.length; i++) {
    var a = r[i];
    a && a.id != null && t.set(a.id, i), n.push({
      existing: e === "replaceMerge" || ec(a) ? null : a,
      newOption: null,
      keyInfo: null,
      brandNew: null
    });
  }
  return n;
}
function $8(r, t, e, n) {
  L(n, function(i, a) {
    if (!(!i || i.id == null)) {
      var o = Wf(i.id), s = e.get(o);
      if (s != null) {
        var l = r[s];
        St(!l.newOption, 'Duplicated option on id "' + o + '".'), l.newOption = i, l.existing = t[s], n[a] = null;
      }
    }
  });
}
function Z8(r, t) {
  L(t, function(e, n) {
    if (!(!e || e.name == null))
      for (var i = 0; i < r.length; i++) {
        var a = r[i].existing;
        if (!r[i].newOption && a && (a.id == null || e.id == null) && !ec(e) && !ec(a) && kP("name", a, e)) {
          r[i].newOption = e, t[n] = null;
          return;
        }
      }
  });
}
function q8(r, t, e) {
  L(t, function(n) {
    if (n) {
      for (
        var i, a = 0;
        // Be `!resultItem` only when `nextIdx >= result.length`.
        (i = r[a]) && (i.newOption || ec(i.existing) || // In mode "replaceMerge", here no not-mapped-non-internal-existing.
        i.existing && n.id != null && !kP("id", n, i.existing));
      )
        a++;
      i ? (i.newOption = n, i.brandNew = e) : r.push({
        newOption: n,
        brandNew: e,
        existing: null,
        keyInfo: null
      }), a++;
    }
  });
}
function K8(r, t) {
  L(t, function(e) {
    r.push({
      newOption: e,
      brandNew: !0,
      existing: null,
      keyInfo: null
    });
  });
}
function j8(r) {
  var t = wt();
  L(r, function(e) {
    var n = e.existing;
    n && t.set(n.id, e);
  }), L(r, function(e) {
    var n = e.newOption;
    St(!n || n.id == null || !t.get(n.id) || t.get(n.id) === e, "id duplicates: " + (n && n.id)), n && n.id != null && t.set(n.id, e), !e.keyInfo && (e.keyInfo = {});
  }), L(r, function(e, n) {
    var i = e.existing, a = e.newOption, o = e.keyInfo;
    if (Dt(a)) {
      if (o.name = a.name != null ? Wf(a.name) : i ? i.name : PP + n, i)
        o.id = Wf(i.id);
      else if (a.id != null)
        o.id = Wf(a.id);
      else {
        var s = 0;
        do
          o.id = "\0" + o.name + "\0" + s++;
        while (t.get(o.id));
      }
      t.set(o.id, e);
    }
  });
}
function kP(r, t, e) {
  var n = mr(t[r], null), i = mr(e[r], null);
  return n != null && i != null && n === i;
}
function Wf(r) {
  if (process.env.NODE_ENV !== "production" && r == null)
    throw new Error();
  return mr(r, "");
}
function mr(r, t) {
  return r == null ? t : pt(r) ? r : fe(r) || mv(r) ? r + "" : t;
}
function rA(r) {
  process.env.NODE_ENV !== "production" && Xe("`" + r + "` is invalid id or name. Must be a string or number.");
}
function nA(r) {
  return mv(r) || C1(r);
}
function D1(r) {
  var t = r.name;
  return !!(t && t.indexOf(PP));
}
function ec(r) {
  return r && r.id != null && Wf(r.id).indexOf(NP) === 0;
}
function J8(r) {
  return NP + r;
}
function Q8(r, t, e) {
  L(r, function(n) {
    var i = n.newOption;
    Dt(i) && (n.keyInfo.mainType = t, n.keyInfo.subType = t6(t, i, n.existing, e));
  });
}
function t6(r, t, e, n) {
  var i = t.type ? t.type : e ? e.subType : n.determineSubType(r, t);
  return i;
}
function e6(r, t) {
  var e = {}, n = {};
  return i(r || [], e), i(t || [], n, e), [a(e), a(n)];
  function i(o, s, l) {
    for (var u = 0, c = o.length; u < c; u++) {
      var f = mr(o[u].seriesId, null);
      if (f == null)
        return;
      for (var h = Ie(o[u].dataIndex), d = l && l[f], p = 0, g = h.length; p < g; p++) {
        var v = h[p];
        d && d[v] ? d[v] = null : (s[f] || (s[f] = {}))[v] = 1;
      }
    }
  }
  function a(o, s) {
    var l = [];
    for (var u in o)
      if (o.hasOwnProperty(u) && o[u] != null)
        if (s)
          l.push(+u);
        else {
          var c = a(o[u], !0);
          c.length && l.push({
            seriesId: u,
            dataIndex: c
          });
        }
    return l;
  }
}
function dl(r, t) {
  if (t.dataIndexInside != null)
    return t.dataIndexInside;
  if (t.dataIndex != null)
    return et(t.dataIndex) ? rt(t.dataIndex, function(e) {
      return r.indexOfRawIndex(e);
    }) : r.indexOfRawIndex(t.dataIndex);
  if (t.name != null)
    return et(t.name) ? rt(t.name, function(e) {
      return r.indexOfName(e);
    }) : r.indexOfName(t.name);
}
function ee() {
  var r = "__ec_inner_" + r6++;
  return function(t) {
    return t[r] || (t[r] = {});
  };
}
var r6 = LP();
function Wu(r, t, e) {
  var n = L1(t, e), i = n.mainTypeSpecified, a = n.queryOptionMap, o = n.others, s = o, l = e ? e.defaultMainType : null;
  return !i && l && a.set(l, {}), a.each(function(u, c) {
    var f = Sc(r, c, u, {
      useDefault: l === c,
      enableAll: e && e.enableAll != null ? e.enableAll : !0,
      enableNone: e && e.enableNone != null ? e.enableNone : !0
    });
    s[c + "Models"] = f.models, s[c + "Model"] = f.models[0];
  }), s;
}
function L1(r, t) {
  var e;
  if (pt(r)) {
    var n = {};
    n[r + "Index"] = 0, e = n;
  } else
    e = r;
  var i = wt(), a = {}, o = !1;
  return L(e, function(s, l) {
    if (l === "dataIndex" || l === "dataIndexInside") {
      a[l] = s;
      return;
    }
    var u = l.match(/^(\w+)(Index|Id|Name)$/) || [], c = u[1], f = (u[2] || "").toLowerCase();
    if (!(!c || !f || t && t.includeMainTypes && Zt(t.includeMainTypes, c) < 0)) {
      o = o || !!c;
      var h = i.get(c) || i.set(c, {});
      h[f] = s;
    }
  }), {
    mainTypeSpecified: o,
    queryOptionMap: i,
    others: a
  };
}
var Ke = {
  useDefault: !0,
  enableAll: !1,
  enableNone: !1
}, n6 = {
  useDefault: !1,
  enableAll: !0,
  enableNone: !0
};
function Sc(r, t, e, n) {
  n = n || Ke;
  var i = e.index, a = e.id, o = e.name, s = {
    models: null,
    specified: i != null || a != null || o != null
  };
  if (!s.specified) {
    var l = void 0;
    return s.models = n.useDefault && (l = r.getComponent(t)) ? [l] : [], s;
  }
  if (i === "none" || i === !1) {
    if (n.enableNone)
      return s.models = [], s;
    process.env.NODE_ENV !== "production" && ce('`"none"` or `false` is not a valid value on index option.'), i = -1;
  }
  return i === "all" && (n.enableAll ? i = a = o = null : (process.env.NODE_ENV !== "production" && ce('`"all"` is not a valid value on index option.'), i = -1)), s.models = r.queryComponents({
    mainType: t,
    index: i,
    id: a,
    name: o
  }), s;
}
function BP(r, t, e) {
  r.setAttribute ? r.setAttribute(t, e) : r[t] = e;
}
function i6(r, t) {
  return r.getAttribute ? r.getAttribute(t) : r[t];
}
function a6(r) {
  return r === "auto" ? oe.domSupported ? "html" : "richText" : r || "html";
}
function xx(r, t) {
  var e = wt(), n = [];
  return L(r, function(i) {
    var a = t(i);
    (e.get(a) || (n.push(a), e.set(a, []))).push(i);
  }), {
    keys: n,
    buckets: e
  };
}
function VP(r, t, e, n, i) {
  var a = t == null || t === "auto";
  if (n == null)
    return n;
  if (fe(n)) {
    var o = tA(e || 0, n, i);
    return or(o, a ? Math.max(Yi(e || 0), Yi(n)) : t);
  } else {
    if (pt(n))
      return i < 1 ? e : n;
    for (var s = [], l = e, u = n, c = Math.max(l ? l.length : 0, u.length), f = 0; f < c; ++f) {
      var h = r.getDimensionInfo(f);
      if (h && h.type === "ordinal")
        s[f] = (i < 1 && l ? l : u)[f];
      else {
        var d = l && l[f] ? l[f] : 0, p = u[f], o = tA(d, p, i);
        s[f] = or(o, a ? Math.max(Yi(d), Yi(p)) : t);
      }
    }
    return s;
  }
}
var Oo = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.reset = function(t, e, n, i) {
      return this._list = t, this._step = i = i || 1, this._idx = e, this._end = n ?? (i > 0 ? t.length : 0), this.item = null, this.key = NaN, this;
    }, r.prototype.next = function() {
      return (this._step > 0 ? this._idx < this._end : this._idx >= this._end) ? (this.item = this._list[this._idx], this.key = this._idx = this._idx + this._step, !0) : !1;
    }, r;
  }()
);
function Iy(r) {
  r.option = r.parentModel = r.ecModel = null;
}
var o6 = ".", hs = "___EC__COMPONENT__CONTAINER___", FP = "___EC__EXTENDED_CLASS___";
function $i(r) {
  var t = {
    main: "",
    sub: ""
  };
  if (r) {
    var e = r.split(o6);
    t.main = e[0] || "", t.sub = e[1] || "";
  }
  return t;
}
function s6(r) {
  St(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(r), 'componentType "' + r + '" illegal');
}
function l6(r) {
  return !!(r && r[FP]);
}
function R1(r, t) {
  r.$constructor = r, r.extend = function(e) {
    process.env.NODE_ENV !== "production" && L(t, function(a) {
      e[a] || console.warn("Method `" + a + "` should be implemented" + (e.type ? " in " + e.type : "") + ".");
    });
    var n = this, i;
    return u6(n) ? i = /** @class */
    function(a) {
      W(o, a);
      function o() {
        return a.apply(this, arguments) || this;
      }
      return o;
    }(n) : (i = function() {
      (e.$constructor || n).apply(this, arguments);
    }, dW(i, this)), J(i.prototype, e), i[FP] = !0, i.extend = this.extend, i.superCall = h6, i.superApply = d6, i.superClass = n, i;
  };
}
function u6(r) {
  return Tt(r) && /^class\s/.test(Function.prototype.toString.call(r));
}
function zP(r, t) {
  r.extend = t.extend;
}
var c6 = Math.round(Math.random() * 10);
function f6(r) {
  var t = ["__\0is_clz", c6++].join("_");
  r.prototype[t] = !0, process.env.NODE_ENV !== "production" && St(!r.isInstance, 'The method "is" can not be defined.'), r.isInstance = function(e) {
    return !!(e && e[t]);
  };
}
function h6(r, t) {
  for (var e = [], n = 2; n < arguments.length; n++)
    e[n - 2] = arguments[n];
  return this.superClass.prototype[t].apply(r, e);
}
function d6(r, t, e) {
  return this.superClass.prototype[t].apply(r, e);
}
function Zg(r) {
  var t = {};
  r.registerClass = function(n) {
    var i = n.type || n.prototype.type;
    if (i) {
      s6(i), n.prototype.type = i;
      var a = $i(i);
      if (!a.sub)
        process.env.NODE_ENV !== "production" && t[a.main] && console.warn(a.main + " exists."), t[a.main] = n;
      else if (a.sub !== hs) {
        var o = e(a);
        o[a.sub] = n;
      }
    }
    return n;
  }, r.getClass = function(n, i, a) {
    var o = t[n];
    if (o && o[hs] && (o = i ? o[i] : null), a && !o)
      throw new Error(i ? "Component " + n + "." + (i || "") + " is used but not imported." : n + ".type should be specified.");
    return o;
  }, r.getClassesByMainType = function(n) {
    var i = $i(n), a = [], o = t[i.main];
    return o && o[hs] ? L(o, function(s, l) {
      l !== hs && a.push(s);
    }) : a.push(o), a;
  }, r.hasClass = function(n) {
    var i = $i(n);
    return !!t[i.main];
  }, r.getAllClassMainTypes = function() {
    var n = [];
    return L(t, function(i, a) {
      n.push(a);
    }), n;
  }, r.hasSubTypes = function(n) {
    var i = $i(n), a = t[i.main];
    return a && a[hs];
  };
  function e(n) {
    var i = t[n.main];
    return (!i || !i[hs]) && (i = t[n.main] = {}, i[hs] = !0), i;
  }
}
function pl(r, t) {
  for (var e = 0; e < r.length; e++)
    r[e][1] || (r[e][1] = r[e][0]);
  return t = t || !1, function(n, i, a) {
    for (var o = {}, s = 0; s < r.length; s++) {
      var l = r[s][1];
      if (!(i && Zt(i, l) >= 0 || a && Zt(a, l) < 0)) {
        var u = n.getShallow(l, t);
        u != null && (o[r[s][0]] = u);
      }
    }
    return o;
  };
}
var p6 = [
  ["fill", "color"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["opacity"],
  ["shadowColor"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], v6 = pl(p6), g6 = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getAreaStyle = function(t, e) {
      return v6(this, t, e);
    }, r;
  }()
), Sx = new Qu(50);
function m6(r) {
  if (typeof r == "string") {
    var t = Sx.get(r);
    return t && t.image;
  } else
    return r;
}
function I1(r, t, e, n, i) {
  if (r)
    if (typeof r == "string") {
      if (t && t.__zrImageSrc === r || !e)
        return t;
      var a = Sx.get(r), o = { hostEl: e, cb: n, cbPayload: i };
      return a ? (t = a.image, !qg(t) && a.pending.push(o)) : (t = xi.loadImage(r, iA, iA), t.__zrImageSrc = r, Sx.put(r, t.__cachedImgObj = {
        image: t,
        pending: [o]
      })), t;
    } else
      return r;
  else
    return t;
}
function iA() {
  var r = this.__cachedImgObj;
  this.onload = this.onerror = this.__cachedImgObj = null;
  for (var t = 0; t < r.pending.length; t++) {
    var e = r.pending[t], n = e.cb;
    n && n(this, e.cbPayload), e.hostEl.dirty();
  }
  r.pending.length = 0;
}
function qg(r) {
  return r && r.width && r.height;
}
var Py = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
function y6(r, t, e, n, i, a) {
  if (!e) {
    r.text = "", r.isTruncated = !1;
    return;
  }
  var o = (t + "").split(`
`);
  a = UP(e, n, i, a);
  for (var s = !1, l = {}, u = 0, c = o.length; u < c; u++)
    GP(l, o[u], a), o[u] = l.textLine, s = s || l.isTruncated;
  r.text = o.join(`
`), r.isTruncated = s;
}
function UP(r, t, e, n) {
  n = n || {};
  var i = J({}, n);
  e = bt(e, "..."), i.maxIterations = bt(n.maxIterations, 2);
  var a = i.minChar = bt(n.minChar, 0), o = i.fontMeasureInfo = Qi(t), s = o.asciiCharWidth;
  i.placeholder = bt(n.placeholder, "");
  for (var l = r = Math.max(0, r - 1), u = 0; u < a && l >= s; u++)
    l -= s;
  var c = ta(o, e);
  return c > l && (e = "", c = 0), l = r - c, i.ellipsis = e, i.ellipsisWidth = c, i.contentWidth = l, i.containerWidth = r, i;
}
function GP(r, t, e) {
  var n = e.containerWidth, i = e.contentWidth, a = e.fontMeasureInfo;
  if (!n) {
    r.textLine = "", r.isTruncated = !1;
    return;
  }
  var o = ta(a, t);
  if (o <= n) {
    r.textLine = t, r.isTruncated = !1;
    return;
  }
  for (var s = 0; ; s++) {
    if (o <= i || s >= e.maxIterations) {
      t += e.ellipsis;
      break;
    }
    var l = s === 0 ? _6(t, i, a) : o > 0 ? Math.floor(t.length * i / o) : 0;
    t = t.substr(0, l), o = ta(a, t);
  }
  t === "" && (t = e.placeholder), r.textLine = t, r.isTruncated = !0;
}
function _6(r, t, e) {
  for (var n = 0, i = 0, a = r.length; i < a && n < t; i++)
    n += wP(e, r.charCodeAt(i));
  return i;
}
function x6(r, t, e, n) {
  var i = P1(r), a = t.overflow, o = t.padding, s = o ? o[1] + o[3] : 0, l = o ? o[0] + o[2] : 0, u = t.font, c = a === "truncate", f = Ph(u), h = bt(t.lineHeight, f), d = t.lineOverflow === "truncate", p = !1, g = t.width;
  g == null && e != null && (g = e - s);
  var v = t.height;
  v == null && n != null && (v = n - l);
  var m;
  g != null && (a === "break" || a === "breakAll") ? m = i ? HP(i, t.font, g, a === "breakAll", 0).lines : [] : m = i ? i.split(`
`) : [];
  var y = m.length * h;
  if (v == null && (v = y), y > v && d) {
    var _ = Math.floor(v / h);
    p = p || m.length > _, m = m.slice(0, _), y = m.length * h;
  }
  if (i && c && g != null)
    for (var x = UP(g, u, t.ellipsis, {
      minChar: t.truncateMinChar,
      placeholder: t.placeholder
    }), b = {}, S = 0; S < m.length; S++)
      GP(b, m[S], x), m[S] = b.textLine, p = p || b.isTruncated;
  for (var w = v, A = 0, T = Qi(u), S = 0; S < m.length; S++)
    A = Math.max(ta(T, m[S]), A);
  g == null && (g = A);
  var M = g;
  return w += l, M += s, {
    lines: m,
    height: v,
    outerWidth: M,
    outerHeight: w,
    lineHeight: h,
    calculatedLineHeight: f,
    contentWidth: A,
    contentHeight: y,
    width: g,
    isTruncated: p
  };
}
var S6 = /* @__PURE__ */ function() {
  function r() {
  }
  return r;
}(), aA = /* @__PURE__ */ function() {
  function r(t) {
    this.tokens = [], t && (this.tokens = t);
  }
  return r;
}(), b6 = /* @__PURE__ */ function() {
  function r() {
    this.width = 0, this.height = 0, this.contentWidth = 0, this.contentHeight = 0, this.outerWidth = 0, this.outerHeight = 0, this.lines = [], this.isTruncated = !1;
  }
  return r;
}();
function w6(r, t, e, n, i) {
  var a = new b6(), o = P1(r);
  if (!o)
    return a;
  var s = t.padding, l = s ? s[1] + s[3] : 0, u = s ? s[0] + s[2] : 0, c = t.width;
  c == null && e != null && (c = e - l);
  var f = t.height;
  f == null && n != null && (f = n - u);
  for (var h = t.overflow, d = (h === "break" || h === "breakAll") && c != null ? { width: c, accumWidth: 0, breakAll: h === "breakAll" } : null, p = Py.lastIndex = 0, g; (g = Py.exec(o)) != null; ) {
    var v = g.index;
    v > p && Ny(a, o.substring(p, v), t, d), Ny(a, g[2], t, d, g[1]), p = Py.lastIndex;
  }
  p < o.length && Ny(a, o.substring(p, o.length), t, d);
  var m = [], y = 0, _ = 0, x = h === "truncate", b = t.lineOverflow === "truncate", S = {};
  function w(ct, at, lt) {
    ct.width = at, ct.lineHeight = lt, y += lt, _ = Math.max(_, at);
  }
  t:
    for (var A = 0; A < a.lines.length; A++) {
      for (var T = a.lines[A], M = 0, E = 0, R = 0; R < T.tokens.length; R++) {
        var C = T.tokens[R], D = C.styleName && t.rich[C.styleName] || {}, I = C.textPadding = D.padding, P = I ? I[1] + I[3] : 0, O = C.font = D.font || t.font;
        C.contentHeight = Ph(O);
        var N = bt(D.height, C.contentHeight);
        if (C.innerHeight = N, I && (N += I[0] + I[2]), C.height = N, C.lineHeight = ln(D.lineHeight, t.lineHeight, N), C.align = D && D.align || i, C.verticalAlign = D && D.verticalAlign || "middle", b && f != null && y + C.lineHeight > f) {
          var B = a.lines.length;
          R > 0 ? (T.tokens = T.tokens.slice(0, R), w(T, E, M), a.lines = a.lines.slice(0, A + 1)) : a.lines = a.lines.slice(0, A), a.isTruncated = a.isTruncated || a.lines.length < B;
          break t;
        }
        var F = D.width, G = F == null || F === "auto";
        if (typeof F == "string" && F.charAt(F.length - 1) === "%")
          C.percentWidth = F, m.push(C), C.contentWidth = ta(Qi(O), C.text);
        else {
          if (G) {
            var X = D.backgroundColor, K = X && X.image;
            K && (K = m6(K), qg(K) && (C.width = Math.max(C.width, K.width * N / K.height)));
          }
          var U = x && c != null ? c - E : null;
          U != null && U < C.width ? !G || U < P ? (C.text = "", C.width = C.contentWidth = 0) : (y6(S, C.text, U - P, O, t.ellipsis, { minChar: t.truncateMinChar }), C.text = S.text, a.isTruncated = a.isTruncated || S.isTruncated, C.width = C.contentWidth = ta(Qi(O), C.text)) : C.contentWidth = ta(Qi(O), C.text);
        }
        C.width += P, E += C.width, D && (M = Math.max(M, C.lineHeight));
      }
      w(T, E, M);
    }
  a.outerWidth = a.width = bt(c, _), a.outerHeight = a.height = bt(f, y), a.contentHeight = y, a.contentWidth = _, a.outerWidth += l, a.outerHeight += u;
  for (var A = 0; A < m.length; A++) {
    var C = m[A], $ = C.percentWidth;
    C.width = parseInt($, 10) / 100 * a.width;
  }
  return a;
}
function Ny(r, t, e, n, i) {
  var a = t === "", o = i && e.rich[i] || {}, s = r.lines, l = o.font || e.font, u = !1, c, f;
  if (n) {
    var h = o.padding, d = h ? h[1] + h[3] : 0;
    if (o.width != null && o.width !== "auto") {
      var p = bi(o.width, n.width) + d;
      s.length > 0 && p + n.accumWidth > n.width && (c = t.split(`
`), u = !0), n.accumWidth = p;
    } else {
      var g = HP(t, l, n.width, n.breakAll, n.accumWidth);
      n.accumWidth = g.accumWidth + d, f = g.linesWidths, c = g.lines;
    }
  }
  c || (c = t.split(`
`));
  for (var v = Qi(l), m = 0; m < c.length; m++) {
    var y = c[m], _ = new S6();
    if (_.styleName = i, _.text = y, _.isLineHolder = !y && !a, typeof o.width == "number" ? _.width = o.width : _.width = f ? f[m] : ta(v, y), !m && !u) {
      var x = (s[s.length - 1] || (s[0] = new aA())).tokens, b = x.length;
      b === 1 && x[0].isLineHolder ? x[0] = _ : (y || !b || a) && x.push(_);
    } else
      s.push(new aA([_]));
  }
}
function M6(r) {
  var t = r.charCodeAt(0);
  return t >= 32 && t <= 591 || t >= 880 && t <= 4351 || t >= 4608 && t <= 5119 || t >= 7680 && t <= 8303;
}
var T6 = ea(",&?/;] ".split(""), function(r, t) {
  return r[t] = !0, r;
}, {});
function A6(r) {
  return M6(r) ? !!T6[r] : !0;
}
function HP(r, t, e, n, i) {
  for (var a = [], o = [], s = "", l = "", u = 0, c = 0, f = Qi(t), h = 0; h < r.length; h++) {
    var d = r.charAt(h);
    if (d === `
`) {
      l && (s += l, c += u), a.push(s), o.push(c), s = "", l = "", u = 0, c = 0;
      continue;
    }
    var p = wP(f, d.charCodeAt(0)), g = n ? !1 : !A6(d);
    if (a.length ? c + p > e : i + c + p > e) {
      c ? (s || l) && (g ? (s || (s = l, l = "", u = 0, c = u), a.push(s), o.push(c - u), l += d, u += p, s = "", c = u) : (l && (s += l, l = "", u = 0), a.push(s), o.push(c), s = d, c = p)) : g ? (a.push(l), o.push(u), l = d, u = p) : (a.push(d), o.push(p));
      continue;
    }
    c += p, g ? (l += d, u += p) : (l && (s += l, l = "", u = 0), s += d);
  }
  return l && (s += l), s && (a.push(s), o.push(c)), a.length === 1 && (c += i), {
    accumWidth: c,
    lines: a,
    linesWidths: o
  };
}
function oA(r, t, e, n, i, a) {
  if (r.baseX = e, r.baseY = n, r.outerWidth = r.outerHeight = null, !!t) {
    var o = t.width * 2, s = t.height * 2;
    Bt.set(sA, tc(e, o, i), rl(n, s, a), o, s), Bt.intersect(t, sA, null, lA);
    var l = lA.outIntersectRect;
    r.outerWidth = l.width, r.outerHeight = l.height, r.baseX = tc(l.x, l.width, i, !0), r.baseY = rl(l.y, l.height, a, !0);
  }
}
var sA = new Bt(0, 0, 0, 0), lA = { outIntersectRect: {}, clamp: !0 };
function P1(r) {
  return r != null ? r += "" : r = "";
}
function E6(r) {
  var t = P1(r.text), e = r.font, n = ta(Qi(e), t), i = Ph(e);
  return bx(r, n, i, null);
}
function bx(r, t, e, n) {
  var i = new Bt(tc(r.x || 0, t, r.textAlign), rl(r.y || 0, e, r.textBaseline), t, e), a = n ?? (WP(r) ? r.lineWidth : 0);
  return a > 0 && (i.x -= a / 2, i.y -= a / 2, i.width += a, i.height += a), i;
}
function WP(r) {
  var t = r.stroke;
  return t != null && t !== "none" && r.lineWidth > 0;
}
var Mx = "__zr_style_" + Math.round(Math.random() * 10), nl = {
  shadowBlur: 0,
  shadowOffsetX: 0,
  shadowOffsetY: 0,
  shadowColor: "#000",
  opacity: 1,
  blend: "source-over"
}, Kg = {
  style: {
    shadowBlur: !0,
    shadowOffsetX: !0,
    shadowOffsetY: !0,
    shadowColor: !0,
    opacity: !0
  }
};
nl[Mx] = !0;
var uA = ["z", "z2", "invisible"], C6 = ["invisible"], ii = function(r) {
  W(t, r);
  function t(e) {
    return r.call(this, e) || this;
  }
  return t.prototype._init = function(e) {
    for (var n = se(e), i = 0; i < n.length; i++) {
      var a = n[i];
      a === "style" ? this.useStyle(e[a]) : r.prototype.attrKV.call(this, a, e[a]);
    }
    this.style || this.useStyle({});
  }, t.prototype.beforeBrush = function() {
  }, t.prototype.afterBrush = function() {
  }, t.prototype.innerBeforeBrush = function() {
  }, t.prototype.innerAfterBrush = function() {
  }, t.prototype.shouldBePainted = function(e, n, i, a) {
    var o = this.transform;
    if (this.ignore || this.invisible || this.style.opacity === 0 || this.culling && D6(this, e, n) || o && !o[0] && !o[3])
      return !1;
    if (i && this.__clipPaths && this.__clipPaths.length) {
      for (var s = 0; s < this.__clipPaths.length; ++s)
        if (this.__clipPaths[s].isZeroArea())
          return !1;
    }
    if (a && this.parent)
      for (var l = this.parent; l; ) {
        if (l.ignore)
          return !1;
        l = l.parent;
      }
    return !0;
  }, t.prototype.contain = function(e, n) {
    return this.rectContain(e, n);
  }, t.prototype.traverse = function(e, n) {
    e.call(n, this);
  }, t.prototype.rectContain = function(e, n) {
    var i = this.transformCoordToLocal(e, n), a = this.getBoundingRect();
    return a.contain(i[0], i[1]);
  }, t.prototype.getPaintRect = function() {
    var e = this._paintRect;
    if (!this._paintRect || this.__dirty) {
      var n = this.transform, i = this.getBoundingRect(), a = this.style, o = a.shadowBlur || 0, s = a.shadowOffsetX || 0, l = a.shadowOffsetY || 0;
      e = this._paintRect || (this._paintRect = new Bt(0, 0, 0, 0)), n ? Bt.applyTransform(e, i, n) : e.copy(i), (o || s || l) && (e.width += o * 2 + Math.abs(s), e.height += o * 2 + Math.abs(l), e.x = Math.min(e.x, e.x + s - o), e.y = Math.min(e.y, e.y + l - o));
      var u = this.dirtyRectTolerance;
      e.isZero() || (e.x = Math.floor(e.x - u), e.y = Math.floor(e.y - u), e.width = Math.ceil(e.width + 1 + u * 2), e.height = Math.ceil(e.height + 1 + u * 2));
    }
    return e;
  }, t.prototype.setPrevPaintRect = function(e) {
    e ? (this._prevPaintRect = this._prevPaintRect || new Bt(0, 0, 0, 0), this._prevPaintRect.copy(e)) : this._prevPaintRect = null;
  }, t.prototype.getPrevPaintRect = function() {
    return this._prevPaintRect;
  }, t.prototype.animateStyle = function(e) {
    return this.animate("style", e);
  }, t.prototype.updateDuringAnimation = function(e) {
    e === "style" ? this.dirtyStyle() : this.markRedraw();
  }, t.prototype.attrKV = function(e, n) {
    e !== "style" ? r.prototype.attrKV.call(this, e, n) : this.style ? this.setStyle(n) : this.useStyle(n);
  }, t.prototype.setStyle = function(e, n) {
    return typeof e == "string" ? this.style[e] = n : J(this.style, e), this.dirtyStyle(), this;
  }, t.prototype.dirtyStyle = function(e) {
    e || this.markRedraw(), this.__dirty |= Af, this._rect && (this._rect = null);
  }, t.prototype.dirty = function() {
    this.dirtyStyle();
  }, t.prototype.styleChanged = function() {
    return !!(this.__dirty & Af);
  }, t.prototype.styleUpdated = function() {
    this.__dirty &= ~Af;
  }, t.prototype.createStyle = function(e) {
    return zg(nl, e);
  }, t.prototype.useStyle = function(e) {
    e[Mx] || (e = this.createStyle(e)), this.__inHover ? this.__hoverStyle = e : this.style = e, this.dirtyStyle();
  }, t.prototype.isStyleObject = function(e) {
    return e[Mx];
  }, t.prototype._innerSaveToNormal = function(e) {
    r.prototype._innerSaveToNormal.call(this, e);
    var n = this._normalState;
    e.style && !n.style && (n.style = this._mergeStyle(this.createStyle(), this.style)), this._savePrimaryToNormal(e, n, uA);
  }, t.prototype._applyStateObj = function(e, n, i, a, o, s) {
    r.prototype._applyStateObj.call(this, e, n, i, a, o, s);
    var l = !(n && a), u;
    if (n && n.style ? o ? a ? u = n.style : (u = this._mergeStyle(this.createStyle(), i.style), this._mergeStyle(u, n.style)) : (u = this._mergeStyle(this.createStyle(), a ? this.style : i.style), this._mergeStyle(u, n.style)) : l && (u = i.style), u)
      if (o) {
        var c = this.style;
        if (this.style = this.createStyle(l ? {} : c), l)
          for (var f = se(c), h = 0; h < f.length; h++) {
            var d = f[h];
            d in u && (u[d] = u[d], this.style[d] = c[d]);
          }
        for (var p = se(u), h = 0; h < p.length; h++) {
          var d = p[h];
          this.style[d] = this.style[d];
        }
        this._transitionState(e, {
          style: u
        }, s, this.getAnimationStyleProps());
      } else
        this.useStyle(u);
    for (var g = this.__inHover ? C6 : uA, h = 0; h < g.length; h++) {
      var d = g[h];
      n && n[d] != null ? this[d] = n[d] : l && i[d] != null && (this[d] = i[d]);
    }
  }, t.prototype._mergeStates = function(e) {
    for (var n = r.prototype._mergeStates.call(this, e), i, a = 0; a < e.length; a++) {
      var o = e[a];
      o.style && (i = i || {}, this._mergeStyle(i, o.style));
    }
    return i && (n.style = i), n;
  }, t.prototype._mergeStyle = function(e, n) {
    return J(e, n), e;
  }, t.prototype.getAnimationStyleProps = function() {
    return Kg;
  }, t.initDefaultProps = function() {
    var e = t.prototype;
    e.type = "displayable", e.invisible = !1, e.z = 0, e.z2 = 0, e.zlevel = 0, e.culling = !1, e.cursor = "pointer", e.rectHover = !1, e.incremental = !1, e._rect = null, e.dirtyRectTolerance = 0, e.__dirty = Rn | Af;
  }(), t;
}(Xg), Oy = new Bt(0, 0, 0, 0), ky = new Bt(0, 0, 0, 0);
function D6(r, t, e) {
  return Oy.copy(r.getBoundingRect()), r.transform && Oy.applyTransform(r.transform), ky.width = t, ky.height = e, !Oy.intersect(ky);
}
var mn = Math.min, yn = Math.max, By = Math.sin, Vy = Math.cos, ds = Math.PI * 2, Nd = Ml(), Od = Ml(), kd = Ml();
function jg(r, t, e) {
  if (r.length !== 0) {
    for (var n = r[0], i = n[0], a = n[0], o = n[1], s = n[1], l = 1; l < r.length; l++)
      n = r[l], i = mn(i, n[0]), a = yn(a, n[0]), o = mn(o, n[1]), s = yn(s, n[1]);
    t[0] = i, t[1] = o, e[0] = a, e[1] = s;
  }
}
function cA(r, t, e, n, i, a) {
  i[0] = mn(r, e), i[1] = mn(t, n), a[0] = yn(r, e), a[1] = yn(t, n);
}
var fA = [], hA = [];
function L6(r, t, e, n, i, a, o, s, l, u) {
  var c = lP, f = br, h = c(r, e, i, o, fA);
  l[0] = 1 / 0, l[1] = 1 / 0, u[0] = -1 / 0, u[1] = -1 / 0;
  for (var d = 0; d < h; d++) {
    var p = f(r, e, i, o, fA[d]);
    l[0] = mn(p, l[0]), u[0] = yn(p, u[0]);
  }
  h = c(t, n, a, s, hA);
  for (var d = 0; d < h; d++) {
    var g = f(t, n, a, s, hA[d]);
    l[1] = mn(g, l[1]), u[1] = yn(g, u[1]);
  }
  l[0] = mn(r, l[0]), u[0] = yn(r, u[0]), l[0] = mn(o, l[0]), u[0] = yn(o, u[0]), l[1] = mn(t, l[1]), u[1] = yn(t, u[1]), l[1] = mn(s, l[1]), u[1] = yn(s, u[1]);
}
function R6(r, t, e, n, i, a, o, s) {
  var l = cP, u = Ir, c = yn(mn(l(r, e, i), 1), 0), f = yn(mn(l(t, n, a), 1), 0), h = u(r, e, i, c), d = u(t, n, a, f);
  o[0] = mn(r, i, h), o[1] = mn(t, a, d), s[0] = yn(r, i, h), s[1] = yn(t, a, d);
}
function I6(r, t, e, n, i, a, o, s, l) {
  var u = So, c = bo, f = Math.abs(i - a);
  if (f % ds < 1e-4 && f > 1e-4) {
    s[0] = r - e, s[1] = t - n, l[0] = r + e, l[1] = t + n;
    return;
  }
  if (Nd[0] = Vy(i) * e + r, Nd[1] = By(i) * n + t, Od[0] = Vy(a) * e + r, Od[1] = By(a) * n + t, u(s, Nd, Od), c(l, Nd, Od), i = i % ds, i < 0 && (i = i + ds), a = a % ds, a < 0 && (a = a + ds), i > a && !o ? a += ds : i < a && o && (i += ds), o) {
    var h = a;
    a = i, i = h;
  }
  for (var d = 0; d < a; d += Math.PI / 2)
    d > i && (kd[0] = Vy(d) * e + r, kd[1] = By(d) * n + t, u(s, kd, s), c(l, kd, l));
}
var Ne = {
  M: 1,
  L: 2,
  C: 3,
  Q: 4,
  A: 5,
  Z: 6,
  R: 7
}, ps = [], vs = [], Ci = [], ao = [], Di = [], Li = [], Fy = Math.min, zy = Math.max, gs = Math.cos, ms = Math.sin, ma = Math.abs, Tx = Math.PI, vo = Tx * 2, Uy = typeof Float32Array < "u", Zc = [];
function Gy(r) {
  var t = Math.round(r / Tx * 1e8) / 1e8;
  return t % 2 * Tx;
}
function Jg(r, t) {
  var e = Gy(r[0]);
  e < 0 && (e += vo);
  var n = e - r[0], i = r[1];
  i += n, !t && i - e >= vo ? i = e + vo : t && e - i >= vo ? i = e - vo : !t && e > i ? i = e + (vo - Gy(e - i)) : t && e < i && (i = e - (vo - Gy(i - e))), r[0] = e, r[1] = i;
}
var aa = function() {
  function r(t) {
    this.dpr = 1, this._xi = 0, this._yi = 0, this._x0 = 0, this._y0 = 0, this._len = 0, t && (this._saveData = !1), this._saveData && (this.data = []);
  }
  return r.prototype.increaseVersion = function() {
    this._version++;
  }, r.prototype.getVersion = function() {
    return this._version;
  }, r.prototype.setScale = function(t, e, n) {
    n = n || 0, n > 0 && (this._ux = ma(n / Av / t) || 0, this._uy = ma(n / Av / e) || 0);
  }, r.prototype.setDPR = function(t) {
    this.dpr = t;
  }, r.prototype.setContext = function(t) {
    this._ctx = t;
  }, r.prototype.getContext = function() {
    return this._ctx;
  }, r.prototype.beginPath = function() {
    return this._ctx && this._ctx.beginPath(), this.reset(), this;
  }, r.prototype.reset = function() {
    this._saveData && (this._len = 0), this._pathSegLen && (this._pathSegLen = null, this._pathLen = 0), this._version++;
  }, r.prototype.moveTo = function(t, e) {
    return this._drawPendingPt(), this.addData(Ne.M, t, e), this._ctx && this._ctx.moveTo(t, e), this._x0 = t, this._y0 = e, this._xi = t, this._yi = e, this;
  }, r.prototype.lineTo = function(t, e) {
    var n = ma(t - this._xi), i = ma(e - this._yi), a = n > this._ux || i > this._uy;
    if (this.addData(Ne.L, t, e), this._ctx && a && this._ctx.lineTo(t, e), a)
      this._xi = t, this._yi = e, this._pendingPtDist = 0;
    else {
      var o = n * n + i * i;
      o > this._pendingPtDist && (this._pendingPtX = t, this._pendingPtY = e, this._pendingPtDist = o);
    }
    return this;
  }, r.prototype.bezierCurveTo = function(t, e, n, i, a, o) {
    return this._drawPendingPt(), this.addData(Ne.C, t, e, n, i, a, o), this._ctx && this._ctx.bezierCurveTo(t, e, n, i, a, o), this._xi = a, this._yi = o, this;
  }, r.prototype.quadraticCurveTo = function(t, e, n, i) {
    return this._drawPendingPt(), this.addData(Ne.Q, t, e, n, i), this._ctx && this._ctx.quadraticCurveTo(t, e, n, i), this._xi = n, this._yi = i, this;
  }, r.prototype.arc = function(t, e, n, i, a, o) {
    this._drawPendingPt(), Zc[0] = i, Zc[1] = a, Jg(Zc, o), i = Zc[0], a = Zc[1];
    var s = a - i;
    return this.addData(Ne.A, t, e, n, n, i, s, 0, o ? 0 : 1), this._ctx && this._ctx.arc(t, e, n, i, a, o), this._xi = gs(a) * n + t, this._yi = ms(a) * n + e, this;
  }, r.prototype.arcTo = function(t, e, n, i, a) {
    return this._drawPendingPt(), this._ctx && this._ctx.arcTo(t, e, n, i, a), this;
  }, r.prototype.rect = function(t, e, n, i) {
    return this._drawPendingPt(), this._ctx && this._ctx.rect(t, e, n, i), this.addData(Ne.R, t, e, n, i), this;
  }, r.prototype.closePath = function() {
    this._drawPendingPt(), this.addData(Ne.Z);
    var t = this._ctx, e = this._x0, n = this._y0;
    return t && t.closePath(), this._xi = e, this._yi = n, this;
  }, r.prototype.fill = function(t) {
    t && t.fill(), this.toStatic();
  }, r.prototype.stroke = function(t) {
    t && t.stroke(), this.toStatic();
  }, r.prototype.len = function() {
    return this._len;
  }, r.prototype.setData = function(t) {
    if (this._saveData) {
      var e = t.length;
      !(this.data && this.data.length === e) && Uy && (this.data = new Float32Array(e));
      for (var n = 0; n < e; n++)
        this.data[n] = t[n];
      this._len = e;
    }
  }, r.prototype.appendPath = function(t) {
    if (this._saveData) {
      t instanceof Array || (t = [t]);
      for (var e = t.length, n = 0, i = this._len, a = 0; a < e; a++)
        n += t[a].len();
      var o = this.data;
      if (Uy && (o instanceof Float32Array || !o) && (this.data = new Float32Array(i + n), i > 0 && o))
        for (var s = 0; s < i; s++)
          this.data[s] = o[s];
      for (var a = 0; a < e; a++)
        for (var l = t[a].data, s = 0; s < l.length; s++)
          this.data[i++] = l[s];
      this._len = i;
    }
  }, r.prototype.addData = function(t, e, n, i, a, o, s, l, u) {
    if (this._saveData) {
      var c = this.data;
      this._len + arguments.length > c.length && (this._expandData(), c = this.data);
      for (var f = 0; f < arguments.length; f++)
        c[this._len++] = arguments[f];
    }
  }, r.prototype._drawPendingPt = function() {
    this._pendingPtDist > 0 && (this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY), this._pendingPtDist = 0);
  }, r.prototype._expandData = function() {
    if (!(this.data instanceof Array)) {
      for (var t = [], e = 0; e < this._len; e++)
        t[e] = this.data[e];
      this.data = t;
    }
  }, r.prototype.toStatic = function() {
    if (this._saveData) {
      this._drawPendingPt();
      var t = this.data;
      t instanceof Array && (t.length = this._len, Uy && this._len > 11 && (this.data = new Float32Array(t)));
    }
  }, r.prototype.getBoundingRect = function() {
    Ci[0] = Ci[1] = Di[0] = Di[1] = Number.MAX_VALUE, ao[0] = ao[1] = Li[0] = Li[1] = -Number.MAX_VALUE;
    var t = this.data, e = 0, n = 0, i = 0, a = 0, o;
    for (o = 0; o < this._len; ) {
      var s = t[o++], l = o === 1;
      switch (l && (e = t[o], n = t[o + 1], i = e, a = n), s) {
        case Ne.M:
          e = i = t[o++], n = a = t[o++], Di[0] = i, Di[1] = a, Li[0] = i, Li[1] = a;
          break;
        case Ne.L:
          cA(e, n, t[o], t[o + 1], Di, Li), e = t[o++], n = t[o++];
          break;
        case Ne.C:
          L6(e, n, t[o++], t[o++], t[o++], t[o++], t[o], t[o + 1], Di, Li), e = t[o++], n = t[o++];
          break;
        case Ne.Q:
          R6(e, n, t[o++], t[o++], t[o], t[o + 1], Di, Li), e = t[o++], n = t[o++];
          break;
        case Ne.A:
          var u = t[o++], c = t[o++], f = t[o++], h = t[o++], d = t[o++], p = t[o++] + d;
          o += 1;
          var g = !t[o++];
          l && (i = gs(d) * f + u, a = ms(d) * h + c), I6(u, c, f, h, d, p, g, Di, Li), e = gs(p) * f + u, n = ms(p) * h + c;
          break;
        case Ne.R:
          i = e = t[o++], a = n = t[o++];
          var v = t[o++], m = t[o++];
          cA(i, a, i + v, a + m, Di, Li);
          break;
        case Ne.Z:
          e = i, n = a;
          break;
      }
      So(Ci, Ci, Di), bo(ao, ao, Li);
    }
    return o === 0 && (Ci[0] = Ci[1] = ao[0] = ao[1] = 0), new Bt(Ci[0], Ci[1], ao[0] - Ci[0], ao[1] - Ci[1]);
  }, r.prototype._calculateLength = function() {
    var t = this.data, e = this._len, n = this._ux, i = this._uy, a = 0, o = 0, s = 0, l = 0;
    this._pathSegLen || (this._pathSegLen = []);
    for (var u = this._pathSegLen, c = 0, f = 0, h = 0; h < e; ) {
      var d = t[h++], p = h === 1;
      p && (a = t[h], o = t[h + 1], s = a, l = o);
      var g = -1;
      switch (d) {
        case Ne.M:
          a = s = t[h++], o = l = t[h++];
          break;
        case Ne.L: {
          var v = t[h++], m = t[h++], y = v - a, _ = m - o;
          (ma(y) > n || ma(_) > i || h === e - 1) && (g = Math.sqrt(y * y + _ * _), a = v, o = m);
          break;
        }
        case Ne.C: {
          var x = t[h++], b = t[h++], v = t[h++], m = t[h++], S = t[h++], w = t[h++];
          g = ZW(a, o, x, b, v, m, S, w, 10), a = S, o = w;
          break;
        }
        case Ne.Q: {
          var x = t[h++], b = t[h++], v = t[h++], m = t[h++];
          g = KW(a, o, x, b, v, m, 10), a = v, o = m;
          break;
        }
        case Ne.A:
          var A = t[h++], T = t[h++], M = t[h++], E = t[h++], R = t[h++], C = t[h++], D = C + R;
          h += 1, p && (s = gs(R) * M + A, l = ms(R) * E + T), g = zy(M, E) * Fy(vo, Math.abs(C)), a = gs(D) * M + A, o = ms(D) * E + T;
          break;
        case Ne.R: {
          s = a = t[h++], l = o = t[h++];
          var I = t[h++], P = t[h++];
          g = I * 2 + P * 2;
          break;
        }
        case Ne.Z: {
          var y = s - a, _ = l - o;
          g = Math.sqrt(y * y + _ * _), a = s, o = l;
          break;
        }
      }
      g >= 0 && (u[f++] = g, c += g);
    }
    return this._pathLen = c, c;
  }, r.prototype.rebuildPath = function(t, e) {
    var n = this.data, i = this._ux, a = this._uy, o = this._len, s, l, u, c, f, h, d = e < 1, p, g, v = 0, m = 0, y, _ = 0, x, b;
    if (!(d && (this._pathSegLen || this._calculateLength(), p = this._pathSegLen, g = this._pathLen, y = e * g, !y)))
      t:
        for (var S = 0; S < o; ) {
          var w = n[S++], A = S === 1;
          switch (A && (u = n[S], c = n[S + 1], s = u, l = c), w !== Ne.L && _ > 0 && (t.lineTo(x, b), _ = 0), w) {
            case Ne.M:
              s = u = n[S++], l = c = n[S++], t.moveTo(u, c);
              break;
            case Ne.L: {
              f = n[S++], h = n[S++];
              var T = ma(f - u), M = ma(h - c);
              if (T > i || M > a) {
                if (d) {
                  var E = p[m++];
                  if (v + E > y) {
                    var R = (y - v) / E;
                    t.lineTo(u * (1 - R) + f * R, c * (1 - R) + h * R);
                    break t;
                  }
                  v += E;
                }
                t.lineTo(f, h), u = f, c = h, _ = 0;
              } else {
                var C = T * T + M * M;
                C > _ && (x = f, b = h, _ = C);
              }
              break;
            }
            case Ne.C: {
              var D = n[S++], I = n[S++], P = n[S++], O = n[S++], N = n[S++], B = n[S++];
              if (d) {
                var E = p[m++];
                if (v + E > y) {
                  var R = (y - v) / E;
                  zo(u, D, P, N, R, ps), zo(c, I, O, B, R, vs), t.bezierCurveTo(ps[1], vs[1], ps[2], vs[2], ps[3], vs[3]);
                  break t;
                }
                v += E;
              }
              t.bezierCurveTo(D, I, P, O, N, B), u = N, c = B;
              break;
            }
            case Ne.Q: {
              var D = n[S++], I = n[S++], P = n[S++], O = n[S++];
              if (d) {
                var E = p[m++];
                if (v + E > y) {
                  var R = (y - v) / E;
                  eh(u, D, P, R, ps), eh(c, I, O, R, vs), t.quadraticCurveTo(ps[1], vs[1], ps[2], vs[2]);
                  break t;
                }
                v += E;
              }
              t.quadraticCurveTo(D, I, P, O), u = P, c = O;
              break;
            }
            case Ne.A:
              var F = n[S++], G = n[S++], X = n[S++], K = n[S++], U = n[S++], $ = n[S++], ct = n[S++], at = !n[S++], lt = X > K ? X : K, ot = ma(X - K) > 1e-3, H = U + $, st = !1;
              if (d) {
                var E = p[m++];
                v + E > y && (H = U + $ * (y - v) / E, st = !0), v += E;
              }
              if (ot && t.ellipse ? t.ellipse(F, G, X, K, ct, U, H, at) : t.arc(F, G, lt, U, H, at), st)
                break t;
              A && (s = gs(U) * X + F, l = ms(U) * K + G), u = gs(H) * X + F, c = ms(H) * K + G;
              break;
            case Ne.R:
              s = u = n[S], l = c = n[S + 1], f = n[S++], h = n[S++];
              var ut = n[S++], Gt = n[S++];
              if (d) {
                var E = p[m++];
                if (v + E > y) {
                  var gt = y - v;
                  t.moveTo(f, h), t.lineTo(f + Fy(gt, ut), h), gt -= ut, gt > 0 && t.lineTo(f + ut, h + Fy(gt, Gt)), gt -= Gt, gt > 0 && t.lineTo(f + zy(ut - gt, 0), h + Gt), gt -= ut, gt > 0 && t.lineTo(f, h + zy(Gt - gt, 0));
                  break t;
                }
                v += E;
              }
              t.rect(f, h, ut, Gt);
              break;
            case Ne.Z:
              if (d) {
                var E = p[m++];
                if (v + E > y) {
                  var R = (y - v) / E;
                  t.lineTo(u * (1 - R) + s * R, c * (1 - R) + l * R);
                  break t;
                }
                v += E;
              }
              t.closePath(), u = s, c = l;
          }
        }
  }, r.prototype.clone = function() {
    var t = new r(), e = this.data;
    return t.data = e.slice ? e.slice() : Array.prototype.slice.call(e), t._len = this._len, t;
  }, r.prototype.canSave = function() {
    return !!this._saveData;
  }, r.CMD = Ne, r.initDefaultProps = function() {
    var t = r.prototype;
    t._saveData = !0, t._ux = 0, t._uy = 0, t._pendingPtDist = 0, t._version = 0;
  }(), r;
}();
function mo(r, t, e, n, i, a, o) {
  if (i === 0)
    return !1;
  var s = i, l = 0, u = r;
  if (o > t + s && o > n + s || o < t - s && o < n - s || a > r + s && a > e + s || a < r - s && a < e - s)
    return !1;
  if (r !== e)
    l = (t - n) / (r - e), u = (r * n - e * t) / (r - e);
  else
    return Math.abs(a - r) <= s / 2;
  var c = l * a - o + u, f = c * c / (l * l + 1);
  return f <= s / 2 * s / 2;
}
function P6(r, t, e, n, i, a, o, s, l, u, c) {
  if (l === 0)
    return !1;
  var f = l;
  if (c > t + f && c > n + f && c > a + f && c > s + f || c < t - f && c < n - f && c < a - f && c < s - f || u > r + f && u > e + f && u > i + f && u > o + f || u < r - f && u < e - f && u < i - f && u < o - f)
    return !1;
  var h = uP(r, t, e, n, i, a, o, s, u, c, null);
  return h <= f / 2;
}
function XP(r, t, e, n, i, a, o, s, l) {
  if (o === 0)
    return !1;
  var u = o;
  if (l > t + u && l > n + u && l > a + u || l < t - u && l < n - u && l < a - u || s > r + u && s > e + u && s > i + u || s < r - u && s < e - u && s < i - u)
    return !1;
  var c = fP(r, t, e, n, i, a, s, l, null);
  return c <= u / 2;
}
var dA = Math.PI * 2;
function Pn(r) {
  return r %= dA, r < 0 && (r += dA), r;
}
var qc = Math.PI * 2;
function N6(r, t, e, n, i, a, o, s, l) {
  if (o === 0)
    return !1;
  var u = o;
  s -= r, l -= t;
  var c = Math.sqrt(s * s + l * l);
  if (c - u > e || c + u < e)
    return !1;
  if (Math.abs(n - i) % qc < 1e-4)
    return !0;
  if (a) {
    var f = n;
    n = Pn(i), i = Pn(f);
  } else
    n = Pn(n), i = Pn(i);
  n > i && (i += qc);
  var h = Math.atan2(l, s);
  return h < 0 && (h += qc), h >= n && h <= i || h + qc >= n && h + qc <= i;
}
function Ma(r, t, e, n, i, a) {
  if (a > t && a > n || a < t && a < n || n === t)
    return 0;
  var o = (a - t) / (n - t), s = n < t ? 1 : -1;
  (o === 1 || o === 0) && (s = n < t ? 0.5 : -0.5);
  var l = o * (e - r) + r;
  return l === i ? 1 / 0 : l > i ? s : 0;
}
var oo = aa.CMD, ys = Math.PI * 2, O6 = 1e-4;
function k6(r, t) {
  return Math.abs(r - t) < O6;
}
var rn = [-1, -1, -1], Zn = [-1, -1];
function B6() {
  var r = Zn[0];
  Zn[0] = Zn[1], Zn[1] = r;
}
function V6(r, t, e, n, i, a, o, s, l, u) {
  if (u > t && u > n && u > a && u > s || u < t && u < n && u < a && u < s)
    return 0;
  var c = bv(t, n, a, s, u, rn);
  if (c === 0)
    return 0;
  for (var f = 0, h = -1, d = void 0, p = void 0, g = 0; g < c; g++) {
    var v = rn[g], m = v === 0 || v === 1 ? 0.5 : 1, y = br(r, e, i, o, v);
    y < l || (h < 0 && (h = lP(t, n, a, s, Zn), Zn[1] < Zn[0] && h > 1 && B6(), d = br(t, n, a, s, Zn[0]), h > 1 && (p = br(t, n, a, s, Zn[1]))), h === 2 ? v < Zn[0] ? f += d < t ? m : -m : v < Zn[1] ? f += p < d ? m : -m : f += s < p ? m : -m : v < Zn[0] ? f += d < t ? m : -m : f += s < d ? m : -m);
  }
  return f;
}
function F6(r, t, e, n, i, a, o, s) {
  if (s > t && s > n && s > a || s < t && s < n && s < a)
    return 0;
  var l = qW(t, n, a, s, rn);
  if (l === 0)
    return 0;
  var u = cP(t, n, a);
  if (u >= 0 && u <= 1) {
    for (var c = 0, f = Ir(t, n, a, u), h = 0; h < l; h++) {
      var d = rn[h] === 0 || rn[h] === 1 ? 0.5 : 1, p = Ir(r, e, i, rn[h]);
      p < o || (rn[h] < u ? c += f < t ? d : -d : c += a < f ? d : -d);
    }
    return c;
  } else {
    var d = rn[0] === 0 || rn[0] === 1 ? 0.5 : 1, p = Ir(r, e, i, rn[0]);
    return p < o ? 0 : a < t ? d : -d;
  }
}
function z6(r, t, e, n, i, a, o, s) {
  if (s -= t, s > e || s < -e)
    return 0;
  var l = Math.sqrt(e * e - s * s);
  rn[0] = -l, rn[1] = l;
  var u = Math.abs(n - i);
  if (u < 1e-4)
    return 0;
  if (u >= ys - 1e-4) {
    n = 0, i = ys;
    var c = a ? 1 : -1;
    return o >= rn[0] + r && o <= rn[1] + r ? c : 0;
  }
  if (n > i) {
    var f = n;
    n = i, i = f;
  }
  n < 0 && (n += ys, i += ys);
  for (var h = 0, d = 0; d < 2; d++) {
    var p = rn[d];
    if (p + r > o) {
      var g = Math.atan2(s, p), c = a ? 1 : -1;
      g < 0 && (g = ys + g), (g >= n && g <= i || g + ys >= n && g + ys <= i) && (g > Math.PI / 2 && g < Math.PI * 1.5 && (c = -c), h += c);
    }
  }
  return h;
}
function YP(r, t, e, n, i) {
  for (var a = r.data, o = r.len(), s = 0, l = 0, u = 0, c = 0, f = 0, h, d, p = 0; p < o; ) {
    var g = a[p++], v = p === 1;
    switch (g === oo.M && p > 1 && (e || (s += Ma(l, u, c, f, n, i))), v && (l = a[p], u = a[p + 1], c = l, f = u), g) {
      case oo.M:
        c = a[p++], f = a[p++], l = c, u = f;
        break;
      case oo.L:
        if (e) {
          if (mo(l, u, a[p], a[p + 1], t, n, i))
            return !0;
        } else
          s += Ma(l, u, a[p], a[p + 1], n, i) || 0;
        l = a[p++], u = a[p++];
        break;
      case oo.C:
        if (e) {
          if (P6(l, u, a[p++], a[p++], a[p++], a[p++], a[p], a[p + 1], t, n, i))
            return !0;
        } else
          s += V6(l, u, a[p++], a[p++], a[p++], a[p++], a[p], a[p + 1], n, i) || 0;
        l = a[p++], u = a[p++];
        break;
      case oo.Q:
        if (e) {
          if (XP(l, u, a[p++], a[p++], a[p], a[p + 1], t, n, i))
            return !0;
        } else
          s += F6(l, u, a[p++], a[p++], a[p], a[p + 1], n, i) || 0;
        l = a[p++], u = a[p++];
        break;
      case oo.A:
        var m = a[p++], y = a[p++], _ = a[p++], x = a[p++], b = a[p++], S = a[p++];
        p += 1;
        var w = !!(1 - a[p++]);
        h = Math.cos(b) * _ + m, d = Math.sin(b) * x + y, v ? (c = h, f = d) : s += Ma(l, u, h, d, n, i);
        var A = (n - m) * x / _ + m;
        if (e) {
          if (N6(m, y, x, b, b + S, w, t, A, i))
            return !0;
        } else
          s += z6(m, y, x, b, b + S, w, A, i);
        l = Math.cos(b + S) * _ + m, u = Math.sin(b + S) * x + y;
        break;
      case oo.R:
        c = l = a[p++], f = u = a[p++];
        var T = a[p++], M = a[p++];
        if (h = c + T, d = f + M, e) {
          if (mo(c, f, h, f, t, n, i) || mo(h, f, h, d, t, n, i) || mo(h, d, c, d, t, n, i) || mo(c, d, c, f, t, n, i))
            return !0;
        } else
          s += Ma(h, f, h, d, n, i), s += Ma(c, d, c, f, n, i);
        break;
      case oo.Z:
        if (e) {
          if (mo(l, u, c, f, t, n, i))
            return !0;
        } else
          s += Ma(l, u, c, f, n, i);
        l = c, u = f;
        break;
    }
  }
  return !e && !k6(u, f) && (s += Ma(l, u, c, f, n, i) || 0), s !== 0;
}
function U6(r, t, e) {
  return YP(r, 0, !1, t, e);
}
function G6(r, t, e, n) {
  return YP(r, t, !0, e, n);
}
var Lv = kt({
  fill: "#000",
  stroke: null,
  strokePercent: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  lineDashOffset: 0,
  lineWidth: 1,
  lineCap: "butt",
  miterLimit: 10,
  strokeNoScale: !1,
  strokeFirst: !1
}, nl), H6 = {
  style: kt({
    fill: !0,
    stroke: !0,
    strokePercent: !0,
    fillOpacity: !0,
    strokeOpacity: !0,
    lineDashOffset: !0,
    lineWidth: !0,
    miterLimit: !0
  }, Kg.style)
}, Hy = na.concat([
  "invisible",
  "culling",
  "z",
  "z2",
  "zlevel",
  "parent"
]), ne = function(r) {
  W(t, r);
  function t(e) {
    return r.call(this, e) || this;
  }
  return t.prototype.update = function() {
    var e = this;
    r.prototype.update.call(this);
    var n = this.style;
    if (n.decal) {
      var i = this._decalEl = this._decalEl || new t();
      i.buildPath === t.prototype.buildPath && (i.buildPath = function(l) {
        e.buildPath(l, e.shape);
      }), i.silent = !0;
      var a = i.style;
      for (var o in n)
        a[o] !== n[o] && (a[o] = n[o]);
      a.fill = n.fill ? n.decal : null, a.decal = null, a.shadowColor = null, n.strokeFirst && (a.stroke = null);
      for (var s = 0; s < Hy.length; ++s)
        i[Hy[s]] = this[Hy[s]];
      i.__dirty |= Rn;
    } else
      this._decalEl && (this._decalEl = null);
  }, t.prototype.getDecalElement = function() {
    return this._decalEl;
  }, t.prototype._init = function(e) {
    var n = se(e);
    this.shape = this.getDefaultShape();
    var i = this.getDefaultStyle();
    i && this.useStyle(i);
    for (var a = 0; a < n.length; a++) {
      var o = n[a], s = e[o];
      o === "style" ? this.style ? J(this.style, s) : this.useStyle(s) : o === "shape" ? J(this.shape, s) : r.prototype.attrKV.call(this, o, s);
    }
    this.style || this.useStyle({});
  }, t.prototype.getDefaultStyle = function() {
    return null;
  }, t.prototype.getDefaultShape = function() {
    return {};
  }, t.prototype.canBeInsideText = function() {
    return this.hasFill();
  }, t.prototype.getInsideTextFill = function() {
    var e = this.style.fill;
    if (e !== "none") {
      if (pt(e)) {
        var n = Mv(e, 0);
        return n > 0.5 ? gx : n > 0.2 ? w8 : mx;
      } else if (e)
        return mx;
    }
    return gx;
  }, t.prototype.getInsideTextStroke = function(e) {
    var n = this.style.fill;
    if (pt(n)) {
      var i = this.__zr, a = !!(i && i.isDarkMode()), o = Mv(e, 0) < vx;
      if (a === o)
        return n;
    }
  }, t.prototype.buildPath = function(e, n, i) {
  }, t.prototype.pathUpdated = function() {
    this.__dirty &= ~Eu;
  }, t.prototype.getUpdatedPathProxy = function(e) {
    return !this.path && this.createPathProxy(), this.path.beginPath(), this.buildPath(this.path, this.shape, e), this.path;
  }, t.prototype.createPathProxy = function() {
    this.path = new aa(!1);
  }, t.prototype.hasStroke = function() {
    var e = this.style, n = e.stroke;
    return !(n == null || n === "none" || !(e.lineWidth > 0));
  }, t.prototype.hasFill = function() {
    var e = this.style, n = e.fill;
    return n != null && n !== "none";
  }, t.prototype.getBoundingRect = function() {
    var e = this._rect, n = this.style, i = !e;
    if (i) {
      var a = !1;
      this.path || (a = !0, this.createPathProxy());
      var o = this.path;
      (a || this.__dirty & Eu) && (o.beginPath(), this.buildPath(o, this.shape, !1), this.pathUpdated()), e = o.getBoundingRect();
    }
    if (this._rect = e, this.hasStroke() && this.path && this.path.len() > 0) {
      var s = this._rectStroke || (this._rectStroke = e.clone());
      if (this.__dirty || i) {
        s.copy(e);
        var l = n.strokeNoScale ? this.getLineScale() : 1, u = n.lineWidth;
        if (!this.hasFill()) {
          var c = this.strokeContainThreshold;
          u = Math.max(u, c ?? 4);
        }
        l > 1e-10 && (s.width += u / l, s.height += u / l, s.x -= u / l / 2, s.y -= u / l / 2);
      }
      return s;
    }
    return e;
  }, t.prototype.contain = function(e, n) {
    var i = this.transformCoordToLocal(e, n), a = this.getBoundingRect(), o = this.style;
    if (e = i[0], n = i[1], a.contain(e, n)) {
      var s = this.path;
      if (this.hasStroke()) {
        var l = o.lineWidth, u = o.strokeNoScale ? this.getLineScale() : 1;
        if (u > 1e-10 && (this.hasFill() || (l = Math.max(l, this.strokeContainThreshold)), G6(s, l / u, e, n)))
          return !0;
      }
      if (this.hasFill())
        return U6(s, e, n);
    }
    return !1;
  }, t.prototype.dirtyShape = function() {
    this.__dirty |= Eu, this._rect && (this._rect = null), this._decalEl && this._decalEl.dirtyShape(), this.markRedraw();
  }, t.prototype.dirty = function() {
    this.dirtyStyle(), this.dirtyShape();
  }, t.prototype.animateShape = function(e) {
    return this.animate("shape", e);
  }, t.prototype.updateDuringAnimation = function(e) {
    e === "style" ? this.dirtyStyle() : e === "shape" ? this.dirtyShape() : this.markRedraw();
  }, t.prototype.attrKV = function(e, n) {
    e === "shape" ? this.setShape(n) : r.prototype.attrKV.call(this, e, n);
  }, t.prototype.setShape = function(e, n) {
    var i = this.shape;
    return i || (i = this.shape = {}), typeof e == "string" ? i[e] = n : J(i, e), this.dirtyShape(), this;
  }, t.prototype.shapeChanged = function() {
    return !!(this.__dirty & Eu);
  }, t.prototype.createStyle = function(e) {
    return zg(Lv, e);
  }, t.prototype._innerSaveToNormal = function(e) {
    r.prototype._innerSaveToNormal.call(this, e);
    var n = this._normalState;
    e.shape && !n.shape && (n.shape = J({}, this.shape));
  }, t.prototype._applyStateObj = function(e, n, i, a, o, s) {
    r.prototype._applyStateObj.call(this, e, n, i, a, o, s);
    var l = !(n && a), u;
    if (n && n.shape ? o ? a ? u = n.shape : (u = J({}, i.shape), J(u, n.shape)) : (u = J({}, a ? this.shape : i.shape), J(u, n.shape)) : l && (u = i.shape), u)
      if (o) {
        this.shape = J({}, this.shape);
        for (var c = {}, f = se(u), h = 0; h < f.length; h++) {
          var d = f[h];
          typeof u[d] == "object" ? this.shape[d] = u[d] : c[d] = u[d];
        }
        this._transitionState(e, {
          shape: c
        }, s);
      } else
        this.shape = u, this.dirtyShape();
  }, t.prototype._mergeStates = function(e) {
    for (var n = r.prototype._mergeStates.call(this, e), i, a = 0; a < e.length; a++) {
      var o = e[a];
      o.shape && (i = i || {}, this._mergeStyle(i, o.shape));
    }
    return i && (n.shape = i), n;
  }, t.prototype.getAnimationStyleProps = function() {
    return H6;
  }, t.prototype.isZeroArea = function() {
    return !1;
  }, t.extend = function(e) {
    var n = function(a) {
      W(o, a);
      function o(s) {
        var l = a.call(this, s) || this;
        return e.init && e.init.call(l, s), l;
      }
      return o.prototype.getDefaultStyle = function() {
        return Ct(e.style);
      }, o.prototype.getDefaultShape = function() {
        return Ct(e.shape);
      }, o;
    }(t);
    for (var i in e)
      typeof e[i] == "function" && (n.prototype[i] = e[i]);
    return n;
  }, t.initDefaultProps = function() {
    var e = t.prototype;
    e.type = "path", e.strokeContainThreshold = 5, e.segmentIgnoreThreshold = 0, e.subPixelOptimize = !1, e.autoBatch = !1, e.__dirty = Rn | Af | Eu;
  }(), t;
}(ii), W6 = kt({
  strokeFirst: !0,
  font: za,
  x: 0,
  y: 0,
  textAlign: "left",
  textBaseline: "top",
  miterLimit: 2
}, Lv), rc = function(r) {
  W(t, r);
  function t() {
    return r !== null && r.apply(this, arguments) || this;
  }
  return t.prototype.hasStroke = function() {
    return WP(this.style);
  }, t.prototype.hasFill = function() {
    var e = this.style, n = e.fill;
    return n != null && n !== "none";
  }, t.prototype.createStyle = function(e) {
    return zg(W6, e);
  }, t.prototype.setBoundingRect = function(e) {
    this._rect = e;
  }, t.prototype.getBoundingRect = function() {
    return this._rect || (this._rect = E6(this.style)), this._rect;
  }, t.initDefaultProps = function() {
    var e = t.prototype;
    e.dirtyRectTolerance = 10;
  }(), t;
}(ii);
rc.prototype.type = "tspan";
var X6 = kt({
  x: 0,
  y: 0
}, nl), Y6 = {
  style: kt({
    x: !0,
    y: !0,
    width: !0,
    height: !0,
    sx: !0,
    sy: !0,
    sWidth: !0,
    sHeight: !0
  }, Kg.style)
};
function $6(r) {
  return !!(r && typeof r != "string" && r.width && r.height);
}
var Vr = function(r) {
  W(t, r);
  function t() {
    return r !== null && r.apply(this, arguments) || this;
  }
  return t.prototype.createStyle = function(e) {
    return zg(X6, e);
  }, t.prototype._getSize = function(e) {
    var n = this.style, i = n[e];
    if (i != null)
      return i;
    var a = $6(n.image) ? n.image : this.__image;
    if (!a)
      return 0;
    var o = e === "width" ? "height" : "width", s = n[o];
    return s == null ? a[e] : a[e] / a[o] * s;
  }, t.prototype.getWidth = function() {
    return this._getSize("width");
  }, t.prototype.getHeight = function() {
    return this._getSize("height");
  }, t.prototype.getAnimationStyleProps = function() {
    return Y6;
  }, t.prototype.getBoundingRect = function() {
    var e = this.style;
    return this._rect || (this._rect = new Bt(e.x || 0, e.y || 0, this.getWidth(), this.getHeight())), this._rect;
  }, t;
}(ii);
Vr.prototype.type = "image";
function Z6(r, t) {
  var e = t.x, n = t.y, i = t.width, a = t.height, o = t.r, s, l, u, c;
  i < 0 && (e = e + i, i = -i), a < 0 && (n = n + a, a = -a), typeof o == "number" ? s = l = u = c = o : o instanceof Array ? o.length === 1 ? s = l = u = c = o[0] : o.length === 2 ? (s = u = o[0], l = c = o[1]) : o.length === 3 ? (s = o[0], l = c = o[1], u = o[2]) : (s = o[0], l = o[1], u = o[2], c = o[3]) : s = l = u = c = 0;
  var f;
  s + l > i && (f = s + l, s *= i / f, l *= i / f), u + c > i && (f = u + c, u *= i / f, c *= i / f), l + u > a && (f = l + u, l *= a / f, u *= a / f), s + c > a && (f = s + c, s *= a / f, c *= a / f), r.moveTo(e + s, n), r.lineTo(e + i - l, n), l !== 0 && r.arc(e + i - l, n + l, l, -Math.PI / 2, 0), r.lineTo(e + i, n + a - u), u !== 0 && r.arc(e + i - u, n + a - u, u, 0, Math.PI / 2), r.lineTo(e + c, n + a), c !== 0 && r.arc(e + c, n + a - c, c, Math.PI / 2, Math.PI), r.lineTo(e, n + s), s !== 0 && r.arc(e + s, n + s, s, Math.PI, Math.PI * 1.5);
}
var Ou = Math.round;
function Qg(r, t, e) {
  if (t) {
    var n = t.x1, i = t.x2, a = t.y1, o = t.y2;
    r.x1 = n, r.x2 = i, r.y1 = a, r.y2 = o;
    var s = e && e.lineWidth;
    return s && (Ou(n * 2) === Ou(i * 2) && (r.x1 = r.x2 = Nn(n, s, !0)), Ou(a * 2) === Ou(o * 2) && (r.y1 = r.y2 = Nn(a, s, !0))), r;
  }
}
function $P(r, t, e) {
  if (t) {
    var n = t.x, i = t.y, a = t.width, o = t.height;
    r.x = n, r.y = i, r.width = a, r.height = o;
    var s = e && e.lineWidth;
    return s && (r.x = Nn(n, s, !0), r.y = Nn(i, s, !0), r.width = Math.max(Nn(n + a, s, !1) - r.x, a === 0 ? 0 : 1), r.height = Math.max(Nn(i + o, s, !1) - r.y, o === 0 ? 0 : 1)), r;
  }
}
function Nn(r, t, e) {
  if (!t)
    return r;
  var n = Ou(r * 2);
  return (n + Ou(t)) % 2 === 0 ? n / 2 : (n + (e ? 1 : -1)) / 2;
}
var q6 = /* @__PURE__ */ function() {
  function r() {
    this.x = 0, this.y = 0, this.width = 0, this.height = 0;
  }
  return r;
}(), K6 = {}, te = function(r) {
  W(t, r);
  function t(e) {
    return r.call(this, e) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new q6();
  }, t.prototype.buildPath = function(e, n) {
    var i, a, o, s;
    if (this.subPixelOptimize) {
      var l = $P(K6, n, this.style);
      i = l.x, a = l.y, o = l.width, s = l.height, l.r = n.r, n = l;
    } else
      i = n.x, a = n.y, o = n.width, s = n.height;
    n.r ? Z6(e, n) : e.rect(i, a, o, s);
  }, t.prototype.isZeroArea = function() {
    return !this.shape.width || !this.shape.height;
  }, t;
}(ne);
te.prototype.type = "rect";
var pA = {
  fill: "#000"
}, vA = 2, Ri = {}, j6 = {
  style: kt({
    fill: !0,
    stroke: !0,
    fillOpacity: !0,
    strokeOpacity: !0,
    lineWidth: !0,
    fontSize: !0,
    lineHeight: !0,
    width: !0,
    height: !0,
    textShadowColor: !0,
    textShadowBlur: !0,
    textShadowOffsetX: !0,
    textShadowOffsetY: !0,
    backgroundColor: !0,
    padding: !0,
    borderColor: !0,
    borderWidth: !0,
    borderRadius: !0
  }, Kg.style)
}, pe = function(r) {
  W(t, r);
  function t(e) {
    var n = r.call(this) || this;
    return n.type = "text", n._children = [], n._defaultStyle = pA, n.attr(e), n;
  }
  return t.prototype.childrenRef = function() {
    return this._children;
  }, t.prototype.update = function() {
    r.prototype.update.call(this), this.styleChanged() && this._updateSubTexts();
    for (var e = 0; e < this._children.length; e++) {
      var n = this._children[e];
      n.zlevel = this.zlevel, n.z = this.z, n.z2 = this.z2, n.culling = this.culling, n.cursor = this.cursor, n.invisible = this.invisible;
    }
  }, t.prototype.updateTransform = function() {
    var e = this.innerTransformable;
    e ? (e.updateTransform(), e.transform && (this.transform = e.transform)) : r.prototype.updateTransform.call(this);
  }, t.prototype.getLocalTransform = function(e) {
    var n = this.innerTransformable;
    return n ? n.getLocalTransform(e) : r.prototype.getLocalTransform.call(this, e);
  }, t.prototype.getComputedTransform = function() {
    return this.__hostTarget && (this.__hostTarget.getComputedTransform(), this.__hostTarget.updateInnerText(!0)), r.prototype.getComputedTransform.call(this);
  }, t.prototype._updateSubTexts = function() {
    this._childCursor = 0, t7(this.style), this.style.rich ? this._updateRichTexts() : this._updatePlainTexts(), this._children.length = this._childCursor, this.styleUpdated();
  }, t.prototype.addSelfToZr = function(e) {
    r.prototype.addSelfToZr.call(this, e);
    for (var n = 0; n < this._children.length; n++)
      this._children[n].__zr = e;
  }, t.prototype.removeSelfFromZr = function(e) {
    r.prototype.removeSelfFromZr.call(this, e);
    for (var n = 0; n < this._children.length; n++)
      this._children[n].__zr = null;
  }, t.prototype.getBoundingRect = function() {
    if (this.styleChanged() && this._updateSubTexts(), !this._rect) {
      for (var e = new Bt(0, 0, 0, 0), n = this._children, i = [], a = null, o = 0; o < n.length; o++) {
        var s = n[o], l = s.getBoundingRect(), u = s.getLocalTransform(i);
        u ? (e.copy(l), e.applyTransform(u), a = a || e.clone(), a.union(e)) : (a = a || l.clone(), a.union(l));
      }
      this._rect = a || e;
    }
    return this._rect;
  }, t.prototype.setDefaultTextStyle = function(e) {
    this._defaultStyle = e || pA;
  }, t.prototype.setTextContent = function(e) {
    if (process.env.NODE_ENV !== "production")
      throw new Error("Can't attach text on another text");
  }, t.prototype._mergeStyle = function(e, n) {
    if (!n)
      return e;
    var i = n.rich, a = e.rich || i && {};
    return J(e, n), i && a ? (this._mergeRich(a, i), e.rich = a) : a && (e.rich = a), e;
  }, t.prototype._mergeRich = function(e, n) {
    for (var i = se(n), a = 0; a < i.length; a++) {
      var o = i[a];
      e[o] = e[o] || {}, J(e[o], n[o]);
    }
  }, t.prototype.getAnimationStyleProps = function() {
    return j6;
  }, t.prototype._getOrCreateChild = function(e) {
    var n = this._children[this._childCursor];
    return (!n || !(n instanceof e)) && (n = new e()), this._children[this._childCursor++] = n, n.__zr = this.__zr, n.parent = this, n;
  }, t.prototype._updatePlainTexts = function() {
    var e = this.style, n = e.font || za, i = e.padding, a = this._defaultStyle, o = e.x || 0, s = e.y || 0, l = e.align || a.align || "left", u = e.verticalAlign || a.verticalAlign || "top";
    oA(Ri, a.overflowRect, o, s, l, u), o = Ri.baseX, s = Ri.baseY;
    var c = bA(e), f = x6(c, e, Ri.outerWidth, Ri.outerHeight), h = Wy(e), d = !!e.backgroundColor, p = f.outerHeight, g = f.outerWidth, v = f.lines, m = f.lineHeight;
    this.isTruncated = !!f.isTruncated;
    var y = o, _ = rl(s, f.contentHeight, u);
    if (h || i) {
      var x = tc(o, g, l), b = rl(s, p, u);
      h && this._renderBackground(e, e, x, b, g, p);
    }
    _ += m / 2, i && (y = SA(o, l, i), u === "top" ? _ += i[0] : u === "bottom" && (_ -= i[2]));
    for (var S = 0, w = !1, A = !1, T = xA("fill" in e ? e.fill : (A = !0, a.fill)), M = _A("stroke" in e ? e.stroke : !d && (!a.autoStroke || A) ? (S = vA, w = !0, a.stroke) : null), E = e.textShadowBlur > 0, R = 0; R < v.length; R++) {
      var C = this._getOrCreateChild(rc), D = C.createStyle();
      C.useStyle(D), D.text = v[R], D.x = y, D.y = _, D.textAlign = l, D.textBaseline = "middle", D.opacity = e.opacity, D.strokeFirst = !0, E && (D.shadowBlur = e.textShadowBlur || 0, D.shadowColor = e.textShadowColor || "transparent", D.shadowOffsetX = e.textShadowOffsetX || 0, D.shadowOffsetY = e.textShadowOffsetY || 0), D.stroke = M, D.fill = T, M && (D.lineWidth = e.lineWidth || S, D.lineDash = e.lineDash, D.lineDashOffset = e.lineDashOffset || 0), D.font = n, mA(D, e), _ += m, C.setBoundingRect(bx(D, f.contentWidth, f.calculatedLineHeight, w ? 0 : null));
    }
  }, t.prototype._updateRichTexts = function() {
    var e = this.style, n = this._defaultStyle, i = e.align || n.align, a = e.verticalAlign || n.verticalAlign, o = e.x || 0, s = e.y || 0;
    oA(Ri, n.overflowRect, o, s, i, a), o = Ri.baseX, s = Ri.baseY;
    var l = bA(e), u = w6(l, e, Ri.outerWidth, Ri.outerHeight, i), c = u.width, f = u.outerWidth, h = u.outerHeight, d = e.padding;
    this.isTruncated = !!u.isTruncated;
    var p = tc(o, f, i), g = rl(s, h, a), v = p, m = g;
    d && (v += d[3], m += d[0]);
    var y = v + c;
    Wy(e) && this._renderBackground(e, e, p, g, f, h);
    for (var _ = !!e.backgroundColor, x = 0; x < u.lines.length; x++) {
      for (var b = u.lines[x], S = b.tokens, w = S.length, A = b.lineHeight, T = b.width, M = 0, E = v, R = y, C = w - 1, D = void 0; M < w && (D = S[M], !D.align || D.align === "left"); )
        this._placeToken(D, e, A, m, E, "left", _), T -= D.width, E += D.width, M++;
      for (; C >= 0 && (D = S[C], D.align === "right"); )
        this._placeToken(D, e, A, m, R, "right", _), T -= D.width, R -= D.width, C--;
      for (E += (c - (E - v) - (y - R) - T) / 2; M <= C; )
        D = S[M], this._placeToken(D, e, A, m, E + D.width / 2, "center", _), E += D.width, M++;
      m += A;
    }
  }, t.prototype._placeToken = function(e, n, i, a, o, s, l) {
    var u = n.rich[e.styleName] || {};
    u.text = e.text;
    var c = e.verticalAlign, f = a + i / 2;
    c === "top" ? f = a + e.height / 2 : c === "bottom" && (f = a + i - e.height / 2);
    var h = !e.isLineHolder && Wy(u);
    h && this._renderBackground(u, n, s === "right" ? o - e.width : s === "center" ? o - e.width / 2 : o, f - e.height / 2, e.width, e.height);
    var d = !!u.backgroundColor, p = e.textPadding;
    p && (o = SA(o, s, p), f -= e.height / 2 - p[0] - e.innerHeight / 2);
    var g = this._getOrCreateChild(rc), v = g.createStyle();
    g.useStyle(v);
    var m = this._defaultStyle, y = !1, _ = 0, x = !1, b = xA("fill" in u ? u.fill : "fill" in n ? n.fill : (y = !0, m.fill)), S = _A("stroke" in u ? u.stroke : "stroke" in n ? n.stroke : !d && !l && (!m.autoStroke || y) ? (_ = vA, x = !0, m.stroke) : null), w = u.textShadowBlur > 0 || n.textShadowBlur > 0;
    v.text = e.text, v.x = o, v.y = f, w && (v.shadowBlur = u.textShadowBlur || n.textShadowBlur || 0, v.shadowColor = u.textShadowColor || n.textShadowColor || "transparent", v.shadowOffsetX = u.textShadowOffsetX || n.textShadowOffsetX || 0, v.shadowOffsetY = u.textShadowOffsetY || n.textShadowOffsetY || 0), v.textAlign = s, v.textBaseline = "middle", v.font = e.font || za, v.opacity = ln(u.opacity, n.opacity, 1), mA(v, u), S && (v.lineWidth = ln(u.lineWidth, n.lineWidth, _), v.lineDash = bt(u.lineDash, n.lineDash), v.lineDashOffset = n.lineDashOffset || 0, v.stroke = S), b && (v.fill = b), g.setBoundingRect(bx(v, e.contentWidth, e.contentHeight, x ? 0 : null));
  }, t.prototype._renderBackground = function(e, n, i, a, o, s) {
    var l = e.backgroundColor, u = e.borderWidth, c = e.borderColor, f = l && l.image, h = l && !f, d = e.borderRadius, p = this, g, v;
    if (h || e.lineHeight || u && c) {
      g = this._getOrCreateChild(te), g.useStyle(g.createStyle()), g.style.fill = null;
      var m = g.shape;
      m.x = i, m.y = a, m.width = o, m.height = s, m.r = d, g.dirtyShape();
    }
    if (h) {
      var y = g.style;
      y.fill = l || null, y.fillOpacity = bt(e.fillOpacity, 1);
    } else if (f) {
      v = this._getOrCreateChild(Vr), v.onload = function() {
        p.dirtyStyle();
      };
      var _ = v.style;
      _.image = l.image, _.x = i, _.y = a, _.width = o, _.height = s;
    }
    if (u && c) {
      var y = g.style;
      y.lineWidth = u, y.stroke = c, y.strokeOpacity = bt(e.strokeOpacity, 1), y.lineDash = e.borderDash, y.lineDashOffset = e.borderDashOffset || 0, g.strokeContainThreshold = 0, g.hasFill() && g.hasStroke() && (y.strokeFirst = !0, y.lineWidth *= 2);
    }
    var x = (g || v).style;
    x.shadowBlur = e.shadowBlur || 0, x.shadowColor = e.shadowColor || "transparent", x.shadowOffsetX = e.shadowOffsetX || 0, x.shadowOffsetY = e.shadowOffsetY || 0, x.opacity = ln(e.opacity, n.opacity, 1);
  }, t.makeFont = function(e) {
    var n = "";
    return qP(e) && (n = [
      e.fontStyle,
      e.fontWeight,
      ZP(e.fontSize),
      e.fontFamily || "sans-serif"
    ].join(" ")), n && ti(n) || e.textFont || e.font;
  }, t;
}(ii), J6 = { left: !0, right: 1, center: 1 }, Q6 = { top: 1, bottom: 1, middle: 1 }, gA = ["fontStyle", "fontWeight", "fontSize", "fontFamily"];
function ZP(r) {
  return typeof r == "string" && (r.indexOf("px") !== -1 || r.indexOf("rem") !== -1 || r.indexOf("em") !== -1) ? r : isNaN(+r) ? m1 + "px" : r + "px";
}
function mA(r, t) {
  for (var e = 0; e < gA.length; e++) {
    var n = gA[e], i = t[n];
    i != null && (r[n] = i);
  }
}
function qP(r) {
  return r.fontSize != null || r.fontFamily || r.fontWeight;
}
function t7(r) {
  return yA(r), L(r.rich, yA), r;
}
function yA(r) {
  if (r) {
    r.font = pe.makeFont(r);
    var t = r.align;
    t === "middle" && (t = "center"), r.align = t == null || J6[t] ? t : "left";
    var e = r.verticalAlign;
    e === "center" && (e = "middle"), r.verticalAlign = e == null || Q6[e] ? e : "top";
    var n = r.padding;
    n && (r.padding = Fg(r.padding));
  }
}
function _A(r, t) {
  return r == null || t <= 0 || r === "transparent" || r === "none" ? null : r.image || r.colorStops ? "#000" : r;
}
function xA(r) {
  return r == null || r === "none" ? null : r.image || r.colorStops ? "#000" : r;
}
function SA(r, t, e) {
  return t === "right" ? r - e[1] : t === "center" ? r + e[3] / 2 - e[1] / 2 : r + e[3];
}
function bA(r) {
  var t = r.text;
  return t != null && (t += ""), t;
}
function Wy(r) {
  return !!(r.backgroundColor || r.lineHeight || r.borderWidth && r.borderColor);
}
var zt = ee(), Ax = function(r, t, e, n) {
  if (n) {
    var i = zt(n);
    i.dataIndex = e, i.dataType = t, i.seriesIndex = r, i.ssrType = "chart", n.type === "group" && n.traverse(function(a) {
      var o = zt(a);
      o.seriesIndex = r, o.dataIndex = e, o.dataType = t, o.ssrType = "chart";
    });
  }
}, wA = 1, MA = {}, KP = ee(), N1 = ee(), O1 = 0, Nh = 1, tm = 2, dn = ["emphasis", "blur", "select"], ah = ["normal", "emphasis", "blur", "select"], bc = 10, e7 = 9, il = "highlight", Zp = "downplay", Rv = "select", Ex = "unselect", Iv = "toggleSelect", k1 = "selectchanged";
function ru(r) {
  return r != null && r !== "none";
}
function em(r, t, e) {
  r.onHoverStateChange && (r.hoverState || 0) !== e && r.onHoverStateChange(t), r.hoverState = e;
}
function jP(r) {
  em(r, "emphasis", tm);
}
function JP(r) {
  r.hoverState === tm && em(r, "normal", O1);
}
function B1(r) {
  em(r, "blur", Nh);
}
function QP(r) {
  r.hoverState === Nh && em(r, "normal", O1);
}
function r7(r) {
  r.selected = !0;
}
function n7(r) {
  r.selected = !1;
}
function TA(r, t, e) {
  t(r, e);
}
function Za(r, t, e) {
  TA(r, t, e), r.isGroup && r.traverse(function(n) {
    TA(n, t, e);
  });
}
function Pv(r, t) {
  switch (t) {
    case "emphasis":
      r.hoverState = tm;
      break;
    case "normal":
      r.hoverState = O1;
      break;
    case "blur":
      r.hoverState = Nh;
      break;
    case "select":
      r.selected = !0;
  }
}
function i7(r, t, e, n) {
  for (var i = r.style, a = {}, o = 0; o < t.length; o++) {
    var s = t[o], l = i[s];
    a[s] = l ?? (n && n[s]);
  }
  for (var o = 0; o < r.animators.length; o++) {
    var u = r.animators[o];
    u.__fromStateTransition && u.__fromStateTransition.indexOf(e) < 0 && u.targetName === "style" && u.saveTo(a, t);
  }
  return a;
}
function a7(r, t, e, n) {
  var i = e && Zt(e, "select") >= 0, a = !1;
  if (r instanceof ne) {
    var o = KP(r), s = i && o.selectFill || o.normalFill, l = i && o.selectStroke || o.normalStroke;
    if (ru(s) || ru(l)) {
      n = n || {};
      var u = n.style || {};
      u.fill === "inherit" ? (a = !0, n = J({}, n), u = J({}, u), u.fill = s) : !ru(u.fill) && ru(s) ? (a = !0, n = J({}, n), u = J({}, u), u.fill = lx(s)) : !ru(u.stroke) && ru(l) && (a || (n = J({}, n), u = J({}, u)), u.stroke = lx(l)), n.style = u;
    }
  }
  if (n && n.z2 == null) {
    a || (n = J({}, n));
    var c = r.z2EmphasisLift;
    n.z2 = r.z2 + (c ?? bc);
  }
  return n;
}
function o7(r, t, e) {
  if (e && e.z2 == null) {
    e = J({}, e);
    var n = r.z2SelectLift;
    e.z2 = r.z2 + (n ?? e7);
  }
  return e;
}
function s7(r, t, e) {
  var n = Zt(r.currentStates, t) >= 0, i = r.style.opacity, a = n ? null : i7(r, ["opacity"], t, {
    opacity: 1
  });
  e = e || {};
  var o = e.style || {};
  return o.opacity == null && (e = J({}, e), o = J({
    // Already being applied 'emphasis'. DON'T mul opacity multiple times.
    opacity: n ? i : a.opacity * 0.1
  }, o), e.style = o), e;
}
function Xy(r, t) {
  var e = this.states[r];
  if (this.style) {
    if (r === "emphasis")
      return a7(this, r, t, e);
    if (r === "blur")
      return s7(this, r, e);
    if (r === "select")
      return o7(this, r, e);
  }
  return e;
}
function vl(r) {
  r.stateProxy = Xy;
  var t = r.getTextContent(), e = r.getTextGuideLine();
  t && (t.stateProxy = Xy), e && (e.stateProxy = Xy);
}
function AA(r, t) {
  !nN(r, t) && !r.__highByOuter && Za(r, jP);
}
function EA(r, t) {
  !nN(r, t) && !r.__highByOuter && Za(r, JP);
}
function Ha(r, t) {
  r.__highByOuter |= 1 << (t || 0), Za(r, jP);
}
function Wa(r, t) {
  !(r.__highByOuter &= ~(1 << (t || 0))) && Za(r, JP);
}
function tN(r) {
  Za(r, B1);
}
function V1(r) {
  Za(r, QP);
}
function eN(r) {
  Za(r, r7);
}
function rN(r) {
  Za(r, n7);
}
function nN(r, t) {
  return r.__highDownSilentOnTouch && t.zrByTouch;
}
function iN(r) {
  var t = r.getModel(), e = [], n = [];
  t.eachComponent(function(i, a) {
    var o = N1(a), s = i === "series", l = s ? r.getViewOfSeriesModel(a) : r.getViewOfComponentModel(a);
    !s && n.push(l), o.isBlured && (l.group.traverse(function(u) {
      QP(u);
    }), s && e.push(a)), o.isBlured = !1;
  }), L(n, function(i) {
    i && i.toggleBlurSeries && i.toggleBlurSeries(e, !1, t);
  });
}
function Cx(r, t, e, n) {
  var i = n.getModel();
  e = e || "coordinateSystem";
  function a(u, c) {
    for (var f = 0; f < c.length; f++) {
      var h = u.getItemGraphicEl(c[f]);
      h && V1(h);
    }
  }
  if (r != null && !(!t || t === "none")) {
    var o = i.getSeriesByIndex(r), s = o.coordinateSystem;
    s && s.master && (s = s.master);
    var l = [];
    i.eachSeries(function(u) {
      var c = o === u, f = u.coordinateSystem;
      f && f.master && (f = f.master);
      var h = f && s ? f === s : c;
      if (!// Not blur other series if blurScope series
      (e === "series" && !c || e === "coordinateSystem" && !h || t === "series" && c)) {
        var d = n.getViewOfSeriesModel(u);
        if (d.group.traverse(function(v) {
          v.__highByOuter && c && t === "self" || B1(v);
        }), qr(t))
          a(u.getData(), t);
        else if (Dt(t))
          for (var p = se(t), g = 0; g < p.length; g++)
            a(u.getData(p[g]), t[p[g]]);
        l.push(u), N1(u).isBlured = !0;
      }
    }), i.eachComponent(function(u, c) {
      if (u !== "series") {
        var f = n.getViewOfComponentModel(c);
        f && f.toggleBlurSeries && f.toggleBlurSeries(l, !0, i);
      }
    });
  }
}
function Dx(r, t, e) {
  if (!(r == null || t == null)) {
    var n = e.getModel().getComponent(r, t);
    if (n) {
      N1(n).isBlured = !0;
      var i = e.getViewOfComponentModel(n);
      !i || !i.focusBlurEnabled || i.group.traverse(function(a) {
        B1(a);
      });
    }
  }
}
function l7(r, t, e) {
  var n = r.seriesIndex, i = r.getData(t.dataType);
  if (!i) {
    process.env.NODE_ENV !== "production" && ce("Unknown dataType " + t.dataType);
    return;
  }
  var a = dl(i, t);
  a = (et(a) ? a[0] : a) || 0;
  var o = i.getItemGraphicEl(a);
  if (!o)
    for (var s = i.count(), l = 0; !o && l < s; )
      o = i.getItemGraphicEl(l++);
  if (o) {
    var u = zt(o);
    Cx(n, u.focus, u.blurScope, e);
  } else {
    var c = r.get(["emphasis", "focus"]), f = r.get(["emphasis", "blurScope"]);
    c != null && Cx(n, c, f, e);
  }
}
function F1(r, t, e, n) {
  var i = {
    focusSelf: !1,
    dispatchers: null
  };
  if (r == null || r === "series" || t == null || e == null)
    return i;
  var a = n.getModel().getComponent(r, t);
  if (!a)
    return i;
  var o = n.getViewOfComponentModel(a);
  if (!o || !o.findHighDownDispatchers)
    return i;
  for (var s = o.findHighDownDispatchers(e), l, u = 0; u < s.length; u++)
    if (process.env.NODE_ENV !== "production" && !Uo(s[u]) && ce("param should be highDownDispatcher"), zt(s[u]).focus === "self") {
      l = !0;
      break;
    }
  return {
    focusSelf: l,
    dispatchers: s
  };
}
function u7(r, t, e) {
  process.env.NODE_ENV !== "production" && !Uo(r) && ce("param should be highDownDispatcher");
  var n = zt(r), i = F1(n.componentMainType, n.componentIndex, n.componentHighDownName, e), a = i.dispatchers, o = i.focusSelf;
  a ? (o && Dx(n.componentMainType, n.componentIndex, e), L(a, function(s) {
    return AA(s, t);
  })) : (Cx(n.seriesIndex, n.focus, n.blurScope, e), n.focus === "self" && Dx(n.componentMainType, n.componentIndex, e), AA(r, t));
}
function c7(r, t, e) {
  process.env.NODE_ENV !== "production" && !Uo(r) && ce("param should be highDownDispatcher"), iN(e);
  var n = zt(r), i = F1(n.componentMainType, n.componentIndex, n.componentHighDownName, e).dispatchers;
  i ? L(i, function(a) {
    return EA(a, t);
  }) : EA(r, t);
}
function f7(r, t, e) {
  if (Rx(t)) {
    var n = t.dataType, i = r.getData(n), a = dl(i, t);
    et(a) || (a = [a]), r[t.type === Iv ? "toggleSelect" : t.type === Rv ? "select" : "unselect"](a, n);
  }
}
function CA(r) {
  var t = r.getAllData();
  L(t, function(e) {
    var n = e.data, i = e.type;
    n.eachItemGraphicEl(function(a, o) {
      r.isSelected(o, i) ? eN(a) : rN(a);
    });
  });
}
function h7(r) {
  var t = [];
  return r.eachSeries(function(e) {
    var n = e.getAllData();
    L(n, function(i) {
      i.data;
      var a = i.type, o = e.getSelectedDataIndices();
      if (o.length > 0) {
        var s = {
          dataIndex: o,
          seriesIndex: e.seriesIndex
        };
        a != null && (s.dataType = a), t.push(s);
      }
    });
  }), t;
}
function al(r, t, e) {
  Ks(r, !0), Za(r, vl), Lx(r, t, e);
}
function d7(r) {
  Ks(r, !1);
}
function Ge(r, t, e, n) {
  n ? d7(r) : al(r, t, e);
}
function Lx(r, t, e) {
  var n = zt(r);
  t != null ? (n.focus = t, n.blurScope = e) : n.focus && (n.focus = null);
}
var DA = ["emphasis", "blur", "select"], p7 = {
  itemStyle: "getItemStyle",
  lineStyle: "getLineStyle",
  areaStyle: "getAreaStyle"
};
function yr(r, t, e, n) {
  e = e || "itemStyle";
  for (var i = 0; i < DA.length; i++) {
    var a = DA[i], o = t.getModel([a, e]), s = r.ensureState(a);
    s.style = n ? n(o) : o[p7[e]]();
  }
}
function Ks(r, t) {
  var e = t === !1, n = r;
  r.highDownSilentOnTouch && (n.__highDownSilentOnTouch = r.highDownSilentOnTouch), (!e || n.__highDownDispatcher) && (n.__highByOuter = n.__highByOuter || 0, n.__highDownDispatcher = !e);
}
function Uo(r) {
  return !!(r && r.__highDownDispatcher);
}
function v7(r, t, e) {
  var n = zt(r);
  n.componentMainType = t.mainType, n.componentIndex = t.componentIndex, n.componentHighDownName = e;
}
function g7(r) {
  var t = MA[r];
  return t == null && wA <= 32 && (t = MA[r] = wA++), t;
}
function Rx(r) {
  var t = r.type;
  return t === Rv || t === Ex || t === Iv;
}
function LA(r) {
  var t = r.type;
  return t === il || t === Zp;
}
function m7(r) {
  var t = KP(r);
  t.normalFill = r.style.fill, t.normalStroke = r.style.stroke;
  var e = r.states.select || {};
  t.selectFill = e.style && e.style.fill || null, t.selectStroke = e.style && e.style.stroke || null;
}
var nu = aa.CMD, y7 = [[], [], []], RA = Math.sqrt, _7 = Math.atan2;
function aN(r, t) {
  if (t) {
    var e = r.data, n = r.len(), i, a, o, s, l, u, c = nu.M, f = nu.C, h = nu.L, d = nu.R, p = nu.A, g = nu.Q;
    for (o = 0, s = 0; o < n; ) {
      switch (i = e[o++], s = o, a = 0, i) {
        case c:
          a = 1;
          break;
        case h:
          a = 1;
          break;
        case f:
          a = 3;
          break;
        case g:
          a = 2;
          break;
        case p:
          var v = t[4], m = t[5], y = RA(t[0] * t[0] + t[1] * t[1]), _ = RA(t[2] * t[2] + t[3] * t[3]), x = _7(-t[1] / _, t[0] / y);
          e[o] *= y, e[o++] += v, e[o] *= _, e[o++] += m, e[o++] *= y, e[o++] *= _, e[o++] += x, e[o++] += x, o += 2, s = o;
          break;
        case d:
          u[0] = e[o++], u[1] = e[o++], rr(u, u, t), e[s++] = u[0], e[s++] = u[1], u[0] += e[o++], u[1] += e[o++], rr(u, u, t), e[s++] = u[0], e[s++] = u[1];
      }
      for (l = 0; l < a; l++) {
        var b = y7[l];
        b[0] = e[o++], b[1] = e[o++], rr(b, b, t), e[s++] = b[0], e[s++] = b[1];
      }
    }
    r.increaseVersion();
  }
}
var Yy = Math.sqrt, Bd = Math.sin, Vd = Math.cos, Kc = Math.PI;
function IA(r) {
  return Math.sqrt(r[0] * r[0] + r[1] * r[1]);
}
function Ix(r, t) {
  return (r[0] * t[0] + r[1] * t[1]) / (IA(r) * IA(t));
}
function PA(r, t) {
  return (r[0] * t[1] < r[1] * t[0] ? -1 : 1) * Math.acos(Ix(r, t));
}
function NA(r, t, e, n, i, a, o, s, l, u, c) {
  var f = l * (Kc / 180), h = Vd(f) * (r - e) / 2 + Bd(f) * (t - n) / 2, d = -1 * Bd(f) * (r - e) / 2 + Vd(f) * (t - n) / 2, p = h * h / (o * o) + d * d / (s * s);
  p > 1 && (o *= Yy(p), s *= Yy(p));
  var g = (i === a ? -1 : 1) * Yy((o * o * (s * s) - o * o * (d * d) - s * s * (h * h)) / (o * o * (d * d) + s * s * (h * h))) || 0, v = g * o * d / s, m = g * -s * h / o, y = (r + e) / 2 + Vd(f) * v - Bd(f) * m, _ = (t + n) / 2 + Bd(f) * v + Vd(f) * m, x = PA([1, 0], [(h - v) / o, (d - m) / s]), b = [(h - v) / o, (d - m) / s], S = [(-1 * h - v) / o, (-1 * d - m) / s], w = PA(b, S);
  if (Ix(b, S) <= -1 && (w = Kc), Ix(b, S) >= 1 && (w = 0), w < 0) {
    var A = Math.round(w / Kc * 1e6) / 1e6;
    w = Kc * 2 + A % 2 * Kc;
  }
  c.addData(u, y, _, o, s, x, w, f, a);
}
var x7 = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig, S7 = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function b7(r) {
  var t = new aa();
  if (!r)
    return t;
  var e = 0, n = 0, i = e, a = n, o, s = aa.CMD, l = r.match(x7);
  if (!l)
    return t;
  for (var u = 0; u < l.length; u++) {
    for (var c = l[u], f = c.charAt(0), h = void 0, d = c.match(S7) || [], p = d.length, g = 0; g < p; g++)
      d[g] = parseFloat(d[g]);
    for (var v = 0; v < p; ) {
      var m = void 0, y = void 0, _ = void 0, x = void 0, b = void 0, S = void 0, w = void 0, A = e, T = n, M = void 0, E = void 0;
      switch (f) {
        case "l":
          e += d[v++], n += d[v++], h = s.L, t.addData(h, e, n);
          break;
        case "L":
          e = d[v++], n = d[v++], h = s.L, t.addData(h, e, n);
          break;
        case "m":
          e += d[v++], n += d[v++], h = s.M, t.addData(h, e, n), i = e, a = n, f = "l";
          break;
        case "M":
          e = d[v++], n = d[v++], h = s.M, t.addData(h, e, n), i = e, a = n, f = "L";
          break;
        case "h":
          e += d[v++], h = s.L, t.addData(h, e, n);
          break;
        case "H":
          e = d[v++], h = s.L, t.addData(h, e, n);
          break;
        case "v":
          n += d[v++], h = s.L, t.addData(h, e, n);
          break;
        case "V":
          n = d[v++], h = s.L, t.addData(h, e, n);
          break;
        case "C":
          h = s.C, t.addData(h, d[v++], d[v++], d[v++], d[v++], d[v++], d[v++]), e = d[v - 2], n = d[v - 1];
          break;
        case "c":
          h = s.C, t.addData(h, d[v++] + e, d[v++] + n, d[v++] + e, d[v++] + n, d[v++] + e, d[v++] + n), e += d[v - 2], n += d[v - 1];
          break;
        case "S":
          m = e, y = n, M = t.len(), E = t.data, o === s.C && (m += e - E[M - 4], y += n - E[M - 3]), h = s.C, A = d[v++], T = d[v++], e = d[v++], n = d[v++], t.addData(h, m, y, A, T, e, n);
          break;
        case "s":
          m = e, y = n, M = t.len(), E = t.data, o === s.C && (m += e - E[M - 4], y += n - E[M - 3]), h = s.C, A = e + d[v++], T = n + d[v++], e += d[v++], n += d[v++], t.addData(h, m, y, A, T, e, n);
          break;
        case "Q":
          A = d[v++], T = d[v++], e = d[v++], n = d[v++], h = s.Q, t.addData(h, A, T, e, n);
          break;
        case "q":
          A = d[v++] + e, T = d[v++] + n, e += d[v++], n += d[v++], h = s.Q, t.addData(h, A, T, e, n);
          break;
        case "T":
          m = e, y = n, M = t.len(), E = t.data, o === s.Q && (m += e - E[M - 4], y += n - E[M - 3]), e = d[v++], n = d[v++], h = s.Q, t.addData(h, m, y, e, n);
          break;
        case "t":
          m = e, y = n, M = t.len(), E = t.data, o === s.Q && (m += e - E[M - 4], y += n - E[M - 3]), e += d[v++], n += d[v++], h = s.Q, t.addData(h, m, y, e, n);
          break;
        case "A":
          _ = d[v++], x = d[v++], b = d[v++], S = d[v++], w = d[v++], A = e, T = n, e = d[v++], n = d[v++], h = s.A, NA(A, T, e, n, S, w, _, x, b, h, t);
          break;
        case "a":
          _ = d[v++], x = d[v++], b = d[v++], S = d[v++], w = d[v++], A = e, T = n, e += d[v++], n += d[v++], h = s.A, NA(A, T, e, n, S, w, _, x, b, h, t);
          break;
      }
    }
    (f === "z" || f === "Z") && (h = s.Z, t.addData(h), e = i, n = a), o = h;
  }
  return t.toStatic(), t;
}
var oN = function(r) {
  W(t, r);
  function t() {
    return r !== null && r.apply(this, arguments) || this;
  }
  return t.prototype.applyTransform = function(e) {
  }, t;
}(ne);
function sN(r) {
  return r.setData != null;
}
function lN(r, t) {
  var e = b7(r), n = J({}, t);
  return n.buildPath = function(i) {
    var a = sN(i);
    if (a && i.canSave()) {
      i.appendPath(e);
      var o = i.getContext();
      o && i.rebuildPath(o, 1);
    } else {
      var o = a ? i.getContext() : i;
      o && e.rebuildPath(o, 1);
    }
  }, n.applyTransform = function(i) {
    aN(e, i), this.dirtyShape();
  }, n;
}
function uN(r, t) {
  return new oN(lN(r, t));
}
function w7(r, t) {
  var e = lN(r, t), n = function(i) {
    W(a, i);
    function a(o) {
      var s = i.call(this, o) || this;
      return s.applyTransform = e.applyTransform, s.buildPath = e.buildPath, s;
    }
    return a;
  }(oN);
  return n;
}
function M7(r, t) {
  for (var e = [], n = r.length, i = 0; i < n; i++) {
    var a = r[i];
    e.push(a.getUpdatedPathProxy(!0));
  }
  var o = new ne(t);
  return o.createPathProxy(), o.buildPath = function(s) {
    if (sN(s)) {
      s.appendPath(e);
      var l = s.getContext();
      l && s.rebuildPath(l, 1);
    }
  }, o;
}
function z1(r, t) {
  t = t || {};
  var e = new ne();
  return r.shape && e.setShape(r.shape), e.setStyle(r.style), t.bakeTransform ? aN(e.path, r.getComputedTransform()) : t.toLocal ? e.setLocalTransform(r.getComputedTransform()) : e.copyTransform(r), e.buildPath = r.buildPath, e.applyTransform = e.applyTransform, e.z = r.z, e.z2 = r.z2, e.zlevel = r.zlevel, e;
}
var T7 = /* @__PURE__ */ function() {
  function r() {
    this.cx = 0, this.cy = 0, this.r = 0;
  }
  return r;
}(), qa = function(r) {
  W(t, r);
  function t(e) {
    return r.call(this, e) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new T7();
  }, t.prototype.buildPath = function(e, n) {
    e.moveTo(n.cx + n.r, n.cy), e.arc(n.cx, n.cy, n.r, 0, Math.PI * 2);
  }, t;
}(ne);
qa.prototype.type = "circle";
var A7 = /* @__PURE__ */ function() {
  function r() {
    this.cx = 0, this.cy = 0, this.rx = 0, this.ry = 0;
  }
  return r;
}(), rm = function(r) {
  W(t, r);
  function t(e) {
    return r.call(this, e) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new A7();
  }, t.prototype.buildPath = function(e, n) {
    var i = 0.5522848, a = n.cx, o = n.cy, s = n.rx, l = n.ry, u = s * i, c = l * i;
    e.moveTo(a - s, o), e.bezierCurveTo(a - s, o - c, a - u, o - l, a, o - l), e.bezierCurveTo(a + u, o - l, a + s, o - c, a + s, o), e.bezierCurveTo(a + s, o + c, a + u, o + l, a, o + l), e.bezierCurveTo(a - u, o + l, a - s, o + c, a - s, o), e.closePath();
  }, t;
}(ne);
rm.prototype.type = "ellipse";
var cN = Math.PI, $y = cN * 2, _s = Math.sin, iu = Math.cos, E7 = Math.acos, $r = Math.atan2, OA = Math.abs, Xf = Math.sqrt, Df = Math.max, Ii = Math.min, ci = 1e-4;
function C7(r, t, e, n, i, a, o, s) {
  var l = e - r, u = n - t, c = o - i, f = s - a, h = f * l - c * u;
  if (!(h * h < ci))
    return h = (c * (t - a) - f * (r - i)) / h, [r + h * l, t + h * u];
}
function Fd(r, t, e, n, i, a, o) {
  var s = r - e, l = t - n, u = (o ? a : -a) / Xf(s * s + l * l), c = u * l, f = -u * s, h = r + c, d = t + f, p = e + c, g = n + f, v = (h + p) / 2, m = (d + g) / 2, y = p - h, _ = g - d, x = y * y + _ * _, b = i - a, S = h * g - p * d, w = (_ < 0 ? -1 : 1) * Xf(Df(0, b * b * x - S * S)), A = (S * _ - y * w) / x, T = (-S * y - _ * w) / x, M = (S * _ + y * w) / x, E = (-S * y + _ * w) / x, R = A - v, C = T - m, D = M - v, I = E - m;
  return R * R + C * C > D * D + I * I && (A = M, T = E), {
    cx: A,
    cy: T,
    x0: -c,
    y0: -f,
    x1: A * (i / b - 1),
    y1: T * (i / b - 1)
  };
}
function D7(r) {
  var t;
  if (et(r)) {
    var e = r.length;
    if (!e)
      return r;
    e === 1 ? t = [r[0], r[0], 0, 0] : e === 2 ? t = [r[0], r[0], r[1], r[1]] : e === 3 ? t = r.concat(r[2]) : t = r;
  } else
    t = [r, r, r, r];
  return t;
}
function L7(r, t) {
  var e, n = Df(t.r, 0), i = Df(t.r0 || 0, 0), a = n > 0, o = i > 0;
  if (!(!a && !o)) {
    if (a || (n = i, i = 0), i > n) {
      var s = n;
      n = i, i = s;
    }
    var l = t.startAngle, u = t.endAngle;
    if (!(isNaN(l) || isNaN(u))) {
      var c = t.cx, f = t.cy, h = !!t.clockwise, d = OA(u - l), p = d > $y && d % $y;
      if (p > ci && (d = p), !(n > ci))
        r.moveTo(c, f);
      else if (d > $y - ci)
        r.moveTo(c + n * iu(l), f + n * _s(l)), r.arc(c, f, n, l, u, !h), i > ci && (r.moveTo(c + i * iu(u), f + i * _s(u)), r.arc(c, f, i, u, l, h));
      else {
        var g = void 0, v = void 0, m = void 0, y = void 0, _ = void 0, x = void 0, b = void 0, S = void 0, w = void 0, A = void 0, T = void 0, M = void 0, E = void 0, R = void 0, C = void 0, D = void 0, I = n * iu(l), P = n * _s(l), O = i * iu(u), N = i * _s(u), B = d > ci;
        if (B) {
          var F = t.cornerRadius;
          F && (e = D7(F), g = e[0], v = e[1], m = e[2], y = e[3]);
          var G = OA(n - i) / 2;
          if (_ = Ii(G, m), x = Ii(G, y), b = Ii(G, g), S = Ii(G, v), T = w = Df(_, x), M = A = Df(b, S), (w > ci || A > ci) && (E = n * iu(u), R = n * _s(u), C = i * iu(l), D = i * _s(l), d < cN)) {
            var X = C7(I, P, C, D, E, R, O, N);
            if (X) {
              var K = I - X[0], U = P - X[1], $ = E - X[0], ct = R - X[1], at = 1 / _s(E7((K * $ + U * ct) / (Xf(K * K + U * U) * Xf($ * $ + ct * ct))) / 2), lt = Xf(X[0] * X[0] + X[1] * X[1]);
              T = Ii(w, (n - lt) / (at + 1)), M = Ii(A, (i - lt) / (at - 1));
            }
          }
        }
        if (!B)
          r.moveTo(c + I, f + P);
        else if (T > ci) {
          var ot = Ii(m, T), H = Ii(y, T), st = Fd(C, D, I, P, n, ot, h), ut = Fd(E, R, O, N, n, H, h);
          r.moveTo(c + st.cx + st.x0, f + st.cy + st.y0), T < w && ot === H ? r.arc(c + st.cx, f + st.cy, T, $r(st.y0, st.x0), $r(ut.y0, ut.x0), !h) : (ot > 0 && r.arc(c + st.cx, f + st.cy, ot, $r(st.y0, st.x0), $r(st.y1, st.x1), !h), r.arc(c, f, n, $r(st.cy + st.y1, st.cx + st.x1), $r(ut.cy + ut.y1, ut.cx + ut.x1), !h), H > 0 && r.arc(c + ut.cx, f + ut.cy, H, $r(ut.y1, ut.x1), $r(ut.y0, ut.x0), !h));
        } else
          r.moveTo(c + I, f + P), r.arc(c, f, n, l, u, !h);
        if (!(i > ci) || !B)
          r.lineTo(c + O, f + N);
        else if (M > ci) {
          var ot = Ii(g, M), H = Ii(v, M), st = Fd(O, N, E, R, i, -H, h), ut = Fd(I, P, C, D, i, -ot, h);
          r.lineTo(c + st.cx + st.x0, f + st.cy + st.y0), M < A && ot === H ? r.arc(c + st.cx, f + st.cy, M, $r(st.y0, st.x0), $r(ut.y0, ut.x0), !h) : (H > 0 && r.arc(c + st.cx, f + st.cy, H, $r(st.y0, st.x0), $r(st.y1, st.x1), !h), r.arc(c, f, i, $r(st.cy + st.y1, st.cx + st.x1), $r(ut.cy + ut.y1, ut.cx + ut.x1), h), ot > 0 && r.arc(c + ut.cx, f + ut.cy, ot, $r(ut.y1, ut.x1), $r(ut.y0, ut.x0), !h));
        } else
          r.lineTo(c + O, f + N), r.arc(c, f, i, u, l, h);
      }
      r.closePath();
    }
  }
}
var R7 = /* @__PURE__ */ function() {
  function r() {
    this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0, this.cornerRadius = 0;
  }
  return r;
}(), Kr = function(r) {
  W(t, r);
  function t(e) {
    return r.call(this, e) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new R7();
  }, t.prototype.buildPath = function(e, n) {
    L7(e, n);
  }, t.prototype.isZeroArea = function() {
    return this.shape.startAngle === this.shape.endAngle || this.shape.r === this.shape.r0;
  }, t;
}(ne);
Kr.prototype.type = "sector";
var I7 = /* @__PURE__ */ function() {
  function r() {
    this.cx = 0, this.cy = 0, this.r = 0, this.r0 = 0;
  }
  return r;
}(), Oh = function(r) {
  W(t, r);
  function t(e) {
    return r.call(this, e) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new I7();
  }, t.prototype.buildPath = function(e, n) {
    var i = n.cx, a = n.cy, o = Math.PI * 2;
    e.moveTo(i + n.r, a), e.arc(i, a, n.r, 0, o, !1), e.moveTo(i + n.r0, a), e.arc(i, a, n.r0, 0, o, !0);
  }, t;
}(ne);
Oh.prototype.type = "ring";
function P7(r, t, e, n) {
  var i = [], a = [], o = [], s = [], l, u, c, f;
  if (n) {
    c = [1 / 0, 1 / 0], f = [-1 / 0, -1 / 0];
    for (var h = 0, d = r.length; h < d; h++)
      So(c, c, r[h]), bo(f, f, r[h]);
    So(c, c, n[0]), bo(f, f, n[1]);
  }
  for (var h = 0, d = r.length; h < d; h++) {
    var p = r[h];
    if (e)
      l = r[h ? h - 1 : d - 1], u = r[(h + 1) % d];
    else if (h === 0 || h === d - 1) {
      i.push(Ia(r[h]));
      continue;
    } else
      l = r[h - 1], u = r[h + 1];
    Zs(a, u, l), Gp(a, a, t);
    var g = j_(p, l), v = j_(p, u), m = g + v;
    m !== 0 && (g /= m, v /= m), Gp(o, a, -g), Gp(s, a, v);
    var y = ST([], p, o), _ = ST([], p, s);
    n && (bo(y, y, c), So(y, y, f), bo(_, _, c), So(_, _, f)), i.push(y), i.push(_);
  }
  return e && i.push(i.shift()), i;
}
function fN(r, t, e) {
  var n = t.smooth, i = t.points;
  if (i && i.length >= 2) {
    if (n) {
      var a = P7(i, n, e, t.smoothConstraint);
      r.moveTo(i[0][0], i[0][1]);
      for (var o = i.length, s = 0; s < (e ? o : o - 1); s++) {
        var l = a[s * 2], u = a[s * 2 + 1], c = i[(s + 1) % o];
        r.bezierCurveTo(l[0], l[1], u[0], u[1], c[0], c[1]);
      }
    } else {
      r.moveTo(i[0][0], i[0][1]);
      for (var s = 1, f = i.length; s < f; s++)
        r.lineTo(i[s][0], i[s][1]);
    }
    e && r.closePath();
  }
}
var N7 = /* @__PURE__ */ function() {
  function r() {
    this.points = null, this.smooth = 0, this.smoothConstraint = null;
  }
  return r;
}(), jr = function(r) {
  W(t, r);
  function t(e) {
    return r.call(this, e) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new N7();
  }, t.prototype.buildPath = function(e, n) {
    fN(e, n, !0);
  }, t;
}(ne);
jr.prototype.type = "polygon";
var O7 = /* @__PURE__ */ function() {
  function r() {
    this.points = null, this.percent = 1, this.smooth = 0, this.smoothConstraint = null;
  }
  return r;
}(), Ur = function(r) {
  W(t, r);
  function t(e) {
    return r.call(this, e) || this;
  }
  return t.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, t.prototype.getDefaultShape = function() {
    return new O7();
  }, t.prototype.buildPath = function(e, n) {
    fN(e, n, !1);
  }, t;
}(ne);
Ur.prototype.type = "polyline";
var k7 = {}, B7 = /* @__PURE__ */ function() {
  function r() {
    this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
  }
  return r;
}(), sr = function(r) {
  W(t, r);
  function t(e) {
    return r.call(this, e) || this;
  }
  return t.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, t.prototype.getDefaultShape = function() {
    return new B7();
  }, t.prototype.buildPath = function(e, n) {
    var i, a, o, s;
    if (this.subPixelOptimize) {
      var l = Qg(k7, n, this.style);
      i = l.x1, a = l.y1, o = l.x2, s = l.y2;
    } else
      i = n.x1, a = n.y1, o = n.x2, s = n.y2;
    var u = n.percent;
    u !== 0 && (e.moveTo(i, a), u < 1 && (o = i * (1 - u) + o * u, s = a * (1 - u) + s * u), e.lineTo(o, s));
  }, t.prototype.pointAt = function(e) {
    var n = this.shape;
    return [
      n.x1 * (1 - e) + n.x2 * e,
      n.y1 * (1 - e) + n.y2 * e
    ];
  }, t;
}(ne);
sr.prototype.type = "line";
var vn = [], V7 = /* @__PURE__ */ function() {
  function r() {
    this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.percent = 1;
  }
  return r;
}();
function kA(r, t, e) {
  var n = r.cpx2, i = r.cpy2;
  return n != null || i != null ? [
    (e ? NT : br)(r.x1, r.cpx1, r.cpx2, r.x2, t),
    (e ? NT : br)(r.y1, r.cpy1, r.cpy2, r.y2, t)
  ] : [
    (e ? ix : Ir)(r.x1, r.cpx1, r.x2, t),
    (e ? ix : Ir)(r.y1, r.cpy1, r.y2, t)
  ];
}
var kh = function(r) {
  W(t, r);
  function t(e) {
    return r.call(this, e) || this;
  }
  return t.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, t.prototype.getDefaultShape = function() {
    return new V7();
  }, t.prototype.buildPath = function(e, n) {
    var i = n.x1, a = n.y1, o = n.x2, s = n.y2, l = n.cpx1, u = n.cpy1, c = n.cpx2, f = n.cpy2, h = n.percent;
    h !== 0 && (e.moveTo(i, a), c == null || f == null ? (h < 1 && (eh(i, l, o, h, vn), l = vn[1], o = vn[2], eh(a, u, s, h, vn), u = vn[1], s = vn[2]), e.quadraticCurveTo(l, u, o, s)) : (h < 1 && (zo(i, l, c, o, h, vn), l = vn[1], c = vn[2], o = vn[3], zo(a, u, f, s, h, vn), u = vn[1], f = vn[2], s = vn[3]), e.bezierCurveTo(l, u, c, f, o, s)));
  }, t.prototype.pointAt = function(e) {
    return kA(this.shape, e, !1);
  }, t.prototype.tangentAt = function(e) {
    var n = kA(this.shape, e, !0);
    return _c(n, n);
  }, t;
}(ne);
kh.prototype.type = "bezier-curve";
var F7 = /* @__PURE__ */ function() {
  function r() {
    this.cx = 0, this.cy = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0;
  }
  return r;
}(), nm = function(r) {
  W(t, r);
  function t(e) {
    return r.call(this, e) || this;
  }
  return t.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, t.prototype.getDefaultShape = function() {
    return new F7();
  }, t.prototype.buildPath = function(e, n) {
    var i = n.cx, a = n.cy, o = Math.max(n.r, 0), s = n.startAngle, l = n.endAngle, u = n.clockwise, c = Math.cos(s), f = Math.sin(s);
    e.moveTo(c * o + i, f * o + a), e.arc(i, a, o, s, l, !u);
  }, t;
}(ne);
nm.prototype.type = "arc";
var im = function(r) {
  W(t, r);
  function t() {
    var e = r !== null && r.apply(this, arguments) || this;
    return e.type = "compound", e;
  }
  return t.prototype._updatePathDirty = function() {
    for (var e = this.shape.paths, n = this.shapeChanged(), i = 0; i < e.length; i++)
      n = n || e[i].shapeChanged();
    n && this.dirtyShape();
  }, t.prototype.beforeBrush = function() {
    this._updatePathDirty();
    for (var e = this.shape.paths || [], n = this.getGlobalScale(), i = 0; i < e.length; i++)
      e[i].path || e[i].createPathProxy(), e[i].path.setScale(n[0], n[1], e[i].segmentIgnoreThreshold);
  }, t.prototype.buildPath = function(e, n) {
    for (var i = n.paths || [], a = 0; a < i.length; a++)
      i[a].buildPath(e, i[a].shape, !0);
  }, t.prototype.afterBrush = function() {
    for (var e = this.shape.paths || [], n = 0; n < e.length; n++)
      e[n].pathUpdated();
  }, t.prototype.getBoundingRect = function() {
    return this._updatePathDirty.call(this), ne.prototype.getBoundingRect.call(this);
  }, t;
}(ne), hN = function() {
  function r(t) {
    this.colorStops = t || [];
  }
  return r.prototype.addColorStop = function(t, e) {
    this.colorStops.push({
      offset: t,
      color: e
    });
  }, r;
}(), wc = function(r) {
  W(t, r);
  function t(e, n, i, a, o, s) {
    var l = r.call(this, o) || this;
    return l.x = e ?? 0, l.y = n ?? 0, l.x2 = i ?? 1, l.y2 = a ?? 0, l.type = "linear", l.global = s || !1, l;
  }
  return t;
}(hN), dN = function(r) {
  W(t, r);
  function t(e, n, i, a, o) {
    var s = r.call(this, a) || this;
    return s.x = e ?? 0.5, s.y = n ?? 0.5, s.r = i ?? 0.5, s.type = "radial", s.global = o || !1, s;
  }
  return t;
}(hN), Zy = Math.min, z7 = Math.max, zd = Math.abs, xs = [0, 0], Ss = [0, 0], Lr = eP(), Ud = Lr.minTv, Gd = Lr.maxTv, pN = function() {
  function r(t, e) {
    this._corners = [], this._axes = [], this._origin = [0, 0];
    for (var n = 0; n < 4; n++)
      this._corners[n] = new Nt();
    for (var n = 0; n < 2; n++)
      this._axes[n] = new Nt();
    t && this.fromBoundingRect(t, e);
  }
  return r.prototype.fromBoundingRect = function(t, e) {
    var n = this._corners, i = this._axes, a = t.x, o = t.y, s = a + t.width, l = o + t.height;
    if (n[0].set(a, o), n[1].set(s, o), n[2].set(s, l), n[3].set(a, l), e)
      for (var u = 0; u < 4; u++)
        n[u].transform(e);
    Nt.sub(i[0], n[1], n[0]), Nt.sub(i[1], n[3], n[0]), i[0].normalize(), i[1].normalize();
    for (var u = 0; u < 2; u++)
      this._origin[u] = i[u].dot(n[0]);
  }, r.prototype.intersect = function(t, e, n) {
    var i = !0, a = !e;
    return e && Nt.set(e, 0, 0), Lr.reset(n, !a), !this._intersectCheckOneSide(this, t, a, 1) && (i = !1, a) || !this._intersectCheckOneSide(t, this, a, -1) && (i = !1, a) || !a && !Lr.negativeSize && Nt.copy(e, i ? Lr.useDir ? Lr.dirMinTv : Ud : Gd), i;
  }, r.prototype._intersectCheckOneSide = function(t, e, n, i) {
    for (var a = !0, o = 0; o < 2; o++) {
      var s = t._axes[o];
      if (t._getProjMinMaxOnAxis(o, t._corners, xs), t._getProjMinMaxOnAxis(o, e._corners, Ss), Lr.negativeSize || xs[1] < Ss[0] || xs[0] > Ss[1]) {
        if (a = !1, Lr.negativeSize || n)
          return a;
        var l = zd(Ss[0] - xs[1]), u = zd(xs[0] - Ss[1]);
        Zy(l, u) > Gd.len() && (l < u ? Nt.scale(Gd, s, -l * i) : Nt.scale(Gd, s, u * i));
      } else if (!n) {
        var l = zd(Ss[0] - xs[1]), u = zd(xs[0] - Ss[1]);
        (Lr.useDir || Zy(l, u) < Ud.len()) && ((l < u || !Lr.bidirectional) && (Nt.scale(Ud, s, l * i), Lr.useDir && Lr.calcDirMTV()), (l >= u || !Lr.bidirectional) && (Nt.scale(Ud, s, -u * i), Lr.useDir && Lr.calcDirMTV()));
      }
    }
    return a;
  }, r.prototype._getProjMinMaxOnAxis = function(t, e, n) {
    for (var i = this._axes[t], a = this._origin, o = e[0].dot(i) + a[t], s = o, l = o, u = 1; u < e.length; u++) {
      var c = e[u].dot(i) + a[t];
      s = Zy(c, s), l = z7(c, l);
    }
    n[0] = s + Lr.touchThreshold, n[1] = l - Lr.touchThreshold, Lr.negativeSize = n[1] < n[0];
  }, r;
}(), U7 = [], G7 = function(r) {
  W(t, r);
  function t() {
    var e = r !== null && r.apply(this, arguments) || this;
    return e.notClear = !0, e.incremental = !0, e._displayables = [], e._temporaryDisplayables = [], e._cursor = 0, e;
  }
  return t.prototype.traverse = function(e, n) {
    e.call(n, this);
  }, t.prototype.useStyle = function() {
    this.style = {};
  }, t.prototype.getCursor = function() {
    return this._cursor;
  }, t.prototype.innerAfterBrush = function() {
    this._cursor = this._displayables.length;
  }, t.prototype.clearDisplaybles = function() {
    this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.markRedraw(), this.notClear = !1;
  }, t.prototype.clearTemporalDisplayables = function() {
    this._temporaryDisplayables = [];
  }, t.prototype.addDisplayable = function(e, n) {
    n ? this._temporaryDisplayables.push(e) : this._displayables.push(e), this.markRedraw();
  }, t.prototype.addDisplayables = function(e, n) {
    n = n || !1;
    for (var i = 0; i < e.length; i++)
      this.addDisplayable(e[i], n);
  }, t.prototype.getDisplayables = function() {
    return this._displayables;
  }, t.prototype.getTemporalDisplayables = function() {
    return this._temporaryDisplayables;
  }, t.prototype.eachPendingDisplayable = function(e) {
    for (var n = this._cursor; n < this._displayables.length; n++)
      e && e(this._displayables[n]);
    for (var n = 0; n < this._temporaryDisplayables.length; n++)
      e && e(this._temporaryDisplayables[n]);
  }, t.prototype.update = function() {
    this.updateTransform();
    for (var e = this._cursor; e < this._displayables.length; e++) {
      var n = this._displayables[e];
      n.parent = this, n.update(), n.parent = null;
    }
    for (var e = 0; e < this._temporaryDisplayables.length; e++) {
      var n = this._temporaryDisplayables[e];
      n.parent = this, n.update(), n.parent = null;
    }
  }, t.prototype.getBoundingRect = function() {
    if (!this._rect) {
      for (var e = new Bt(1 / 0, 1 / 0, -1 / 0, -1 / 0), n = 0; n < this._displayables.length; n++) {
        var i = this._displayables[n], a = i.getBoundingRect().clone();
        i.needLocalTransform() && a.applyTransform(i.getLocalTransform(U7)), e.union(a);
      }
      this._rect = e;
    }
    return this._rect;
  }, t.prototype.contain = function(e, n) {
    var i = this.transformCoordToLocal(e, n), a = this.getBoundingRect();
    if (a.contain(i[0], i[1]))
      for (var o = 0; o < this._displayables.length; o++) {
        var s = this._displayables[o];
        if (s.contain(e, n))
          return !0;
      }
    return !1;
  }, t;
}(ii), vN = ee();
function Mc(r, t, e, n, i) {
  var a;
  if (t && t.ecModel) {
    var o = t.ecModel.getUpdatePayload();
    a = o && o.animation;
  }
  var s = t && t.isAnimationEnabled(), l = r === "update";
  if (s) {
    var u = void 0, c = void 0, f = void 0;
    n ? (u = bt(n.duration, 200), c = bt(n.easing, "cubicOut"), f = 0) : (u = t.getShallow(l ? "animationDurationUpdate" : "animationDuration"), c = t.getShallow(l ? "animationEasingUpdate" : "animationEasing"), f = t.getShallow(l ? "animationDelayUpdate" : "animationDelay")), a && (a.duration != null && (u = a.duration), a.easing != null && (c = a.easing), a.delay != null && (f = a.delay)), Tt(f) && (f = f(e, i)), Tt(u) && (u = u(e));
    var h = {
      duration: u || 0,
      delay: f,
      easing: c
    };
    return h;
  } else
    return null;
}
function U1(r, t, e, n, i, a, o) {
  var s = !1, l;
  Tt(i) ? (o = a, a = i, i = null) : Dt(i) && (a = i.cb, o = i.during, s = i.isFrom, l = i.removeOpt, i = i.dataIndex);
  var u = r === "leave";
  u || t.stopAnimation("leave");
  var c = Mc(r, n, i, u ? l || {} : null, n && n.getAnimationDelayParams ? n.getAnimationDelayParams(t, i) : null);
  if (c && c.duration > 0) {
    var f = c.duration, h = c.delay, d = c.easing, p = {
      duration: f,
      delay: h || 0,
      easing: d,
      done: a,
      force: !!a || !!o,
      // Set to final state in update/init animation.
      // So the post processing based on the path shape can be done correctly.
      setToFinal: !u,
      scope: r,
      during: o
    };
    s ? t.animateFrom(e, p) : t.animateTo(e, p);
  } else
    t.stopAnimation(), !s && t.attr(e), o && o(1), a && a();
}
function ve(r, t, e, n, i, a) {
  U1("update", r, t, e, n, i, a);
}
function ze(r, t, e, n, i, a) {
  U1("enter", r, t, e, n, i, a);
}
function Xu(r) {
  if (!r.__zr)
    return !0;
  for (var t = 0; t < r.animators.length; t++) {
    var e = r.animators[t];
    if (e.scope === "leave")
      return !0;
  }
  return !1;
}
function Go(r, t, e, n, i, a) {
  Xu(r) || U1("leave", r, t, e, n, i, a);
}
function BA(r, t, e, n) {
  r.removeTextContent(), r.removeTextGuideLine(), Go(r, {
    style: {
      opacity: 0
    }
  }, t, e, n);
}
function Pa(r, t, e) {
  function n() {
    r.parent && r.parent.remove(r);
  }
  r.isGroup ? r.traverse(function(i) {
    i.isGroup || BA(i, t, e, n);
  }) : BA(r, t, e, n);
}
function ai(r) {
  vN(r).oldStyle = r.style;
}
function H7(r) {
  return vN(r).oldStyle;
}
var Px = {}, Wt = ["x", "y"], ur = ["width", "height"];
function W7(r) {
  return ne.extend(r);
}
var X7 = w7;
function Y7(r, t) {
  return X7(r, t);
}
function Mi(r, t) {
  Px[r] = t;
}
function Nv(r) {
  if (Px.hasOwnProperty(r))
    return Px[r];
}
function oh(r, t, e, n) {
  var i = uN(r, t);
  return e && (n === "center" && (e = mN(e, i.getBoundingRect())), yN(i, e)), i;
}
function gN(r, t, e) {
  var n = new Vr({
    style: {
      image: r,
      x: t.x,
      y: t.y,
      width: t.width,
      height: t.height
    },
    onload: function(i) {
      if (e === "center") {
        var a = {
          width: i.width,
          height: i.height
        };
        n.setStyle(mN(t, a));
      }
    }
  });
  return n;
}
function mN(r, t) {
  var e = t.width / t.height, n = r.height * e, i;
  n <= r.width ? i = r.height : (n = r.width, i = n / e);
  var a = r.x + r.width / 2, o = r.y + r.height / 2;
  return {
    x: a - n / 2,
    y: o - i / 2,
    width: n,
    height: i
  };
}
var Jn = M7;
function yN(r, t) {
  if (r.applyTransform) {
    var e = r.getBoundingRect(), n = e.calculateTransform(t);
    r.applyTransform(n);
  }
}
function nc(r, t) {
  return Qg(r, r, {
    lineWidth: t
  }), r;
}
function $7(r, t) {
  return $P(r, r, t), r;
}
var qp = Nn;
function ol(r, t) {
  for (var e = Ug([]); r && r !== t; )
    ji(e, r.getLocalTransform(), e), r = r.parent;
  return e;
}
function yi(r, t, e) {
  return t && !qr(t) && (t = Da.getLocalTransform(t)), e && (t = Si([], t)), rr([], r, t);
}
function am(r, t, e) {
  var n = t[4] === 0 || t[5] === 0 || t[0] === 0 ? 1 : Xi(2 * t[4] / t[0]), i = t[4] === 0 || t[5] === 0 || t[2] === 0 ? 1 : Xi(2 * t[4] / t[2]), a = [r === "left" ? -n : r === "right" ? n : 0, r === "top" ? -i : r === "bottom" ? i : 0];
  return a = yi(a, t, e), Xi(a[0]) > Xi(a[1]) ? a[0] > 0 ? "right" : "left" : a[1] > 0 ? "bottom" : "top";
}
function VA(r) {
  return !r.isGroup;
}
function Z7(r) {
  return r.shape != null;
}
function Bh(r, t, e) {
  if (!r || !t)
    return;
  function n(o) {
    var s = {};
    return o.traverse(function(l) {
      VA(l) && l.anid && (s[l.anid] = l);
    }), s;
  }
  function i(o) {
    var s = {
      x: o.x,
      y: o.y,
      rotation: o.rotation
    };
    return Z7(o) && (s.shape = Ct(o.shape)), s;
  }
  var a = n(r);
  t.traverse(function(o) {
    if (VA(o) && o.anid) {
      var s = a[o.anid];
      if (s) {
        var l = i(o);
        o.attr(i(s)), ve(o, l, e, zt(o).dataIndex);
      }
    }
  });
}
function _N(r, t) {
  return rt(r, function(e) {
    var n = e[0];
    n = tr(n, t.x), n = kn(n, t.x + t.width);
    var i = e[1];
    return i = tr(i, t.y), i = kn(i, t.y + t.height), [n, i];
  });
}
function q7(r, t) {
  var e = tr(r.x, t.x), n = kn(r.x + r.width, t.x + t.width), i = tr(r.y, t.y), a = kn(r.y + r.height, t.y + t.height);
  if (n >= e && a >= i)
    return {
      x: e,
      y: i,
      width: n - e,
      height: a - i
    };
}
function Vh(r, t, e) {
  var n = J({
    rectHover: !0
  }, t), i = n.style = {
    strokeNoScale: !0
  };
  if (e = e || {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }, r)
    return r.indexOf("image://") === 0 ? (i.image = r.slice(8), kt(i, e), new Vr(n)) : oh(r.replace("path://", ""), n, e, "center");
}
function Lf(r, t, e, n, i) {
  for (var a = 0, o = i[i.length - 1]; a < i.length; a++) {
    var s = i[a];
    if (xN(r, t, e, n, s[0], s[1], o[0], o[1]))
      return !0;
    o = s;
  }
}
function xN(r, t, e, n, i, a, o, s) {
  var l = e - r, u = n - t, c = o - i, f = s - a, h = qy(c, f, l, u);
  if (K7(h))
    return !1;
  var d = r - i, p = t - a, g = qy(d, p, l, u) / h;
  if (g < 0 || g > 1)
    return !1;
  var v = qy(d, p, c, f) / h;
  return !(v < 0 || v > 1);
}
function qy(r, t, e, n) {
  return r * n - e * t;
}
function K7(r) {
  return r <= 1e-6 && r >= -1e-6;
}
function gl(r, t, e, n, i) {
  return t == null || (fe(t) ? We[0] = We[1] = We[2] = We[3] = t : (process.env.NODE_ENV !== "production" && St(t.length === 4), We[0] = t[0], We[1] = t[1], We[2] = t[2], We[3] = t[3]), n && (We[0] = tr(0, We[0]), We[1] = tr(0, We[1]), We[2] = tr(0, We[2]), We[3] = tr(0, We[3])), e && (We[0] = -We[0], We[1] = -We[1], We[2] = -We[2], We[3] = -We[3]), FA(r, We, "x", "width", 3, 1, i && i[0] || 0), FA(r, We, "y", "height", 0, 2, i && i[1] || 0)), r;
}
var We = [0, 0, 0, 0];
function FA(r, t, e, n, i, a, o) {
  var s = t[a] + t[i], l = r[n];
  r[n] += s, o = tr(0, kn(o, l)), r[n] < o ? (r[n] = o, r[e] += t[i] >= 0 ? -t[i] : t[a] >= 0 ? l + t[a] : Xi(s) > 1e-8 ? (l - o) * t[i] / s : 0) : r[e] -= t[i];
}
function Ka(r) {
  var t = r.itemTooltipOption, e = r.componentModel, n = r.itemName, i = pt(t) ? {
    formatter: t
  } : t, a = e.mainType, o = e.componentIndex, s = {
    componentType: a,
    name: n,
    $vars: ["name"]
  };
  s[a + "Index"] = o;
  var l = r.formatterParamsExtra;
  l && L(se(l), function(c) {
    _t(s, c) || (s[c] = l[c], s.$vars.push(c));
  });
  var u = zt(r.el);
  u.componentMainType = a, u.componentIndex = o, u.tooltipConfig = {
    name: n,
    option: kt({
      content: n,
      encodeHTMLContent: !0,
      formatterParams: s
    }, i)
  };
}
function Nx(r, t) {
  var e;
  r.isGroup && (e = t(r)), e || r.traverse(t);
}
function Ko(r, t) {
  if (r)
    if (et(r))
      for (var e = 0; e < r.length; e++)
        Nx(r[e], t);
    else
      Nx(r, t);
}
function G1(r) {
  return !r || Xi(r[1]) < Hd && Xi(r[2]) < Hd || Xi(r[0]) < Hd && Xi(r[3]) < Hd;
}
var Hd = 1e-5;
function sh(r, t) {
  return r ? Bt.copy(r, t) : t.clone();
}
function H1(r, t) {
  return t ? Gg(r || kr(), t) : void 0;
}
function ml(r) {
  return {
    z: r.get("z") || 0,
    zlevel: r.get("zlevel") || 0
  };
}
function SN(r) {
  var t = -1 / 0, e = 1 / 0;
  Nx(r, function(a) {
    n(a), n(a.getTextContent()), n(a.getTextGuideLine());
  });
  function n(a) {
    if (!(!a || a.isGroup)) {
      var o = a.currentStates;
      if (o.length)
        for (var s = 0; s < o.length; s++)
          i(a.states[o[s]]);
      i(a);
    }
  }
  function i(a) {
    if (a) {
      var o = a.z2;
      o > t && (t = o), o < e && (e = o);
    }
  }
  return e > t && (e = t = 0), {
    min: e,
    max: t
  };
}
function om(r, t, e) {
  bN(r, t, e, -1 / 0);
}
function bN(r, t, e, n) {
  if (r.ignoreModelZ)
    return n;
  var i = r.getTextContent(), a = r.getTextGuideLine(), o = r.isGroup;
  if (o)
    for (var s = r.childrenRef(), l = 0; l < s.length; l++)
      n = tr(bN(s[l], t, e, n), n);
  else
    r.z = t, r.zlevel = e, n = tr(r.z2 || 0, n);
  if (i && (i.z = t, i.zlevel = e, isFinite(n) && (i.z2 = n + 2)), a) {
    var u = r.textGuideLineConfig;
    a.z = t, a.zlevel = e, isFinite(n) && (a.z2 = n + (u && u.showAbove ? 1 : -1));
  }
  return n;
}
Mi("circle", qa);
Mi("ellipse", rm);
Mi("sector", Kr);
Mi("ring", Oh);
Mi("polygon", jr);
Mi("polyline", Ur);
Mi("rect", te);
Mi("line", sr);
Mi("bezierCurve", kh);
Mi("arc", nm);
const Al = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Arc: nm,
  BezierCurve: kh,
  BoundingRect: Bt,
  Circle: qa,
  CompoundPath: im,
  Ellipse: rm,
  Group: Et,
  Image: Vr,
  IncrementalDisplayable: G7,
  Line: sr,
  LinearGradient: wc,
  OrientedBoundingRect: pN,
  Path: ne,
  Point: Nt,
  Polygon: jr,
  Polyline: Ur,
  RadialGradient: dN,
  Rect: te,
  Ring: Oh,
  Sector: Kr,
  Text: pe,
  WH: ur,
  XY: Wt,
  applyTransform: yi,
  calcZ2Range: SN,
  clipPointsByRect: _N,
  clipRectByRect: q7,
  createIcon: Vh,
  ensureCopyRect: sh,
  ensureCopyTransform: H1,
  expandOrShrinkRect: gl,
  extendPath: Y7,
  extendShape: W7,
  getShapeClass: Nv,
  getTransform: ol,
  groupTransition: Bh,
  initProps: ze,
  isBoundingRectAxisAligned: G1,
  isElementRemoved: Xu,
  lineLineIntersect: xN,
  linePolygonIntersect: Lf,
  makeImage: gN,
  makePath: oh,
  mergePath: Jn,
  registerShape: Mi,
  removeElement: Go,
  removeElementWithFadeOut: Pa,
  resizePath: yN,
  retrieveZInfo: ml,
  setTooltipConfig: Ka,
  subPixelOptimize: qp,
  subPixelOptimizeLine: nc,
  subPixelOptimizeRect: $7,
  transformDirection: am,
  traverseElements: Ko,
  traverseUpdateZ: om,
  updateProps: ve
}, Symbol.toStringTag, { value: "Module" }));
var sm = {};
function wN(r, t) {
  for (var e = 0; e < dn.length; e++) {
    var n = dn[e], i = t[n], a = r.ensureState(n);
    a.style = a.style || {}, a.style.text = i;
  }
  var o = r.currentStates.slice();
  r.clearStates(!0), r.setStyle({
    text: t.normal
  }), r.useStates(o, !0);
}
function Ox(r, t, e) {
  var n = r.labelFetcher, i = r.labelDataIndex, a = r.labelDimIndex, o = t.normal, s;
  n && (s = n.getFormattedLabel(i, "normal", null, a, o && o.get("formatter"), e != null ? {
    interpolatedValue: e
  } : null)), s == null && (s = Tt(r.defaultText) ? r.defaultText(i, r, e) : r.defaultText);
  for (var l = {
    normal: s
  }, u = 0; u < dn.length; u++) {
    var c = dn[u], f = t[c];
    l[c] = bt(n ? n.getFormattedLabel(i, c, null, a, f && f.get("formatter")) : null, s);
  }
  return l;
}
function Er(r, t, e, n) {
  e = e || sm;
  for (var i = r instanceof pe, a = !1, o = 0; o < ah.length; o++) {
    var s = t[ah[o]];
    if (s && s.getShallow("show")) {
      a = !0;
      break;
    }
  }
  var l = i ? r : r.getTextContent();
  if (a) {
    i || (l || (l = new pe(), r.setTextContent(l)), r.stateProxy && (l.stateProxy = r.stateProxy));
    var u = Ox(e, t), c = t.normal, f = !!c.getShallow("show"), h = Oe(c, n && n.normal, e, !1, !i);
    h.text = u.normal, i || r.setTextConfig(Ov(c, e, !1));
    for (var o = 0; o < dn.length; o++) {
      var d = dn[o], s = t[d];
      if (s) {
        var p = l.ensureState(d), g = !!bt(s.getShallow("show"), f);
        if (g !== f && (p.ignore = !g), p.style = Oe(s, n && n[d], e, !0, !i), p.style.text = u[d], !i) {
          var v = r.ensureState(d);
          v.textConfig = Ov(s, e, !0);
        }
      }
    }
    l.silent = !!c.getShallow("silent"), l.style.x != null && (h.x = l.style.x), l.style.y != null && (h.y = l.style.y), l.ignore = !f, l.useStyle(h), l.dirty(), e.enableTextSetter && (Tc(l).setLabelText = function(m) {
      var y = Ox(e, t, m);
      wN(l, y);
    });
  } else
    l && (l.ignore = !0);
  r.dirty();
}
function _r(r, t) {
  t = t || "label";
  for (var e = {
    normal: r.getModel(t)
  }, n = 0; n < dn.length; n++) {
    var i = dn[n];
    e[i] = r.getModel([i, t]);
  }
  return e;
}
function Oe(r, t, e, n, i) {
  var a = {};
  return j7(a, r, e, n, i), t && J(a, t), a;
}
function Ov(r, t, e) {
  t = t || {};
  var n = {}, i, a = r.getShallow("rotate"), o = bt(r.getShallow("distance"), e ? null : 5), s = r.getShallow("offset");
  return i = r.getShallow("position") || (e ? null : "inside"), i === "outside" && (i = t.defaultOutsidePosition || "top"), i != null && (n.position = i), s != null && (n.offset = s), a != null && (a *= Math.PI / 180, n.rotation = a), o != null && (n.distance = o), n.outsideFill = r.get("color") === "inherit" ? t.inheritColor || null : "auto", t.autoOverflowArea != null && (n.autoOverflowArea = t.autoOverflowArea), t.layoutRect != null && (n.layoutRect = t.layoutRect), n;
}
function j7(r, t, e, n, i) {
  e = e || sm;
  var a = t.ecModel, o = a && a.option.textStyle, s = J7(t), l;
  if (s) {
    l = {};
    var u = "richInheritPlainLabel", c = bt(t.get(u), a ? a.get(u) : void 0);
    for (var f in s)
      if (s.hasOwnProperty(f)) {
        var h = t.getModel(["rich", f]);
        HA(l[f] = {}, h, o, t, c, e, n, i, !1, !0);
      }
  }
  l && (r.rich = l);
  var d = t.get("overflow");
  d && (r.overflow = d);
  var p = t.get("lineOverflow");
  p && (r.lineOverflow = p);
  var g = r, v = t.get("minMargin");
  if (v != null)
    v = fe(v) ? v / 2 : 0, g.margin = [v, v, v, v], g.__marginType = ku.minMargin;
  else {
    var m = t.get("textMargin");
    m != null && (g.margin = Fg(m), g.__marginType = ku.textMargin);
  }
  HA(r, t, o, null, null, e, n, i, !0, !1);
}
function J7(r) {
  for (var t; r && r !== r.ecModel; ) {
    var e = (r.option || sm).rich;
    if (e) {
      t = t || {};
      for (var n = se(e), i = 0; i < n.length; i++) {
        var a = n[i];
        t[a] = 1;
      }
    }
    r = r.parentModel;
  }
  return t;
}
var zA = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], UA = ["align", "lineHeight", "width", "height", "tag", "verticalAlign", "ellipsis"], GA = ["padding", "borderWidth", "borderRadius", "borderDashOffset", "backgroundColor", "borderColor", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"];
function HA(r, t, e, n, i, a, o, s, l, u) {
  e = !o && e || sm;
  var c = a && a.inheritColor, f = t.getShallow("color"), h = t.getShallow("textBorderColor"), d = bt(t.getShallow("opacity"), e.opacity);
  (f === "inherit" || f === "auto") && (process.env.NODE_ENV !== "production" && f === "auto" && ar("color: 'auto'", "color: 'inherit'"), c ? f = c : f = null), (h === "inherit" || h === "auto") && (process.env.NODE_ENV !== "production" && h === "auto" && ar("color: 'auto'", "color: 'inherit'"), c ? h = c : h = null), s || (f = f || e.color, h = h || e.textBorderColor), f != null && (r.fill = f), h != null && (r.stroke = h);
  var p = bt(t.getShallow("textBorderWidth"), e.textBorderWidth);
  p != null && (r.lineWidth = p);
  var g = bt(t.getShallow("textBorderType"), e.textBorderType);
  g != null && (r.lineDash = g);
  var v = bt(t.getShallow("textBorderDashOffset"), e.textBorderDashOffset);
  v != null && (r.lineDashOffset = v), !o && d == null && !u && (d = a && a.defaultOpacity), d != null && (r.opacity = d), !o && !s && r.fill == null && a.inheritColor && (r.fill = a.inheritColor);
  for (var m = 0; m < zA.length; m++) {
    var y = zA[m], _ = i !== !1 && n ? ln(t.getShallow(y), n.getShallow(y), e[y]) : bt(t.getShallow(y), e[y]);
    _ != null && (r[y] = _);
  }
  for (var m = 0; m < UA.length; m++) {
    var y = UA[m], _ = t.getShallow(y);
    _ != null && (r[y] = _);
  }
  if (r.verticalAlign == null) {
    var x = t.getShallow("baseline");
    x != null && (r.verticalAlign = x);
  }
  if (!l || !a.disableBox) {
    for (var m = 0; m < GA.length; m++) {
      var y = GA[m], _ = t.getShallow(y);
      _ != null && (r[y] = _);
    }
    var b = t.getShallow("borderType");
    b != null && (r.borderDash = b), (r.backgroundColor === "auto" || r.backgroundColor === "inherit") && c && (process.env.NODE_ENV !== "production" && r.backgroundColor === "auto" && ar("backgroundColor: 'auto'", "backgroundColor: 'inherit'"), r.backgroundColor = c), (r.borderColor === "auto" || r.borderColor === "inherit") && c && (process.env.NODE_ENV !== "production" && r.borderColor === "auto" && ar("borderColor: 'auto'", "borderColor: 'inherit'"), r.borderColor = c);
  }
}
function W1(r, t) {
  var e = t && t.getModel("textStyle");
  return ti([
    // FIXME in node-canvas fontWeight is before fontStyle
    r.fontStyle || e && e.getShallow("fontStyle") || "",
    r.fontWeight || e && e.getShallow("fontWeight") || "",
    (r.fontSize || e && e.getShallow("fontSize") || 12) + "px",
    r.fontFamily || e && e.getShallow("fontFamily") || "sans-serif"
  ].join(" "));
}
var Tc = ee();
function MN(r, t, e, n) {
  if (r) {
    var i = Tc(r);
    i.prevValue = i.value, i.value = e;
    var a = t.normal;
    i.valueAnimation = a.get("valueAnimation"), i.valueAnimation && (i.precision = a.get("precision"), i.defaultInterpolatedText = n, i.statesModels = t);
  }
}
function TN(r, t, e, n, i) {
  var a = Tc(r);
  if (!a.valueAnimation || a.prevValue === a.value)
    return;
  var o = a.defaultInterpolatedText, s = bt(a.interpolatedValue, a.prevValue), l = a.value;
  function u(c) {
    var f = VP(e, a.precision, s, l, c);
    a.interpolatedValue = c === 1 ? null : f;
    var h = Ox({
      labelDataIndex: t,
      labelFetcher: i,
      defaultText: o ? o(f) : f + ""
    }, a.statesModels, f);
    wN(r, h);
  }
  r.percent = 0, (a.prevValue == null ? ze : ve)(r, {
    // percent is used to prevent animation from being aborted #15916
    percent: 1
  }, n, t, null, u);
}
var ku = {
  minMargin: 1,
  textMargin: 2
}, Q7 = ["textStyle", "color"], Ky = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "padding", "lineHeight", "rich", "width", "height", "overflow"], jy = new pe(), t9 = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getTextColor = function(t) {
      var e = this.ecModel;
      return this.getShallow("color") || (!t && e ? e.get(Q7) : null);
    }, r.prototype.getFont = function() {
      return W1({
        fontStyle: this.getShallow("fontStyle"),
        fontWeight: this.getShallow("fontWeight"),
        fontSize: this.getShallow("fontSize"),
        fontFamily: this.getShallow("fontFamily")
      }, this.ecModel);
    }, r.prototype.getTextRect = function(t) {
      for (var e = {
        text: t,
        verticalAlign: this.getShallow("verticalAlign") || this.getShallow("baseline")
      }, n = 0; n < Ky.length; n++)
        e[Ky[n]] = this.getShallow(Ky[n]);
      return jy.useStyle(e), jy.update(), jy.getBoundingRect();
    }, r;
  }()
), AN = [
  ["lineWidth", "width"],
  ["stroke", "color"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "type"],
  ["lineDashOffset", "dashOffset"],
  ["lineCap", "cap"],
  ["lineJoin", "join"],
  ["miterLimit"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], e9 = pl(AN), r9 = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getLineStyle = function(t) {
      return e9(this, t);
    }, r;
  }()
), EN = [
  ["fill", "color"],
  ["stroke", "borderColor"],
  ["lineWidth", "borderWidth"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "borderType"],
  ["lineDashOffset", "borderDashOffset"],
  ["lineCap", "borderCap"],
  ["lineJoin", "borderJoin"],
  ["miterLimit", "borderMiterLimit"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], n9 = pl(EN), i9 = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getItemStyle = function(t, e) {
      return n9(this, t, e);
    }, r;
  }()
), ue = (
  /** @class */
  function() {
    function r(t, e, n) {
      this.parentModel = e, this.ecModel = n, this.option = t;
    }
    return r.prototype.init = function(t, e, n) {
    }, r.prototype.mergeOption = function(t, e) {
      qt(this.option, t, !0);
    }, r.prototype.get = function(t, e) {
      return t == null ? this.option : this._doGet(this.parsePath(t), !e && this.parentModel);
    }, r.prototype.getShallow = function(t, e) {
      var n = this.option, i = n == null ? n : n[t];
      if (i == null && !e) {
        var a = this.parentModel;
        a && (i = a.getShallow(t));
      }
      return i;
    }, r.prototype.getModel = function(t, e) {
      var n = t != null, i = n ? this.parsePath(t) : null, a = n ? this._doGet(i) : this.option;
      return e = e || this.parentModel && this.parentModel.getModel(this.resolveParentPath(i)), new r(a, e, this.ecModel);
    }, r.prototype.isEmpty = function() {
      return this.option == null;
    }, r.prototype.restoreData = function() {
    }, r.prototype.clone = function() {
      var t = this.constructor;
      return new t(Ct(this.option));
    }, r.prototype.parsePath = function(t) {
      return typeof t == "string" ? t.split(".") : t;
    }, r.prototype.resolveParentPath = function(t) {
      return t;
    }, r.prototype.isAnimationEnabled = function() {
      if (!oe.node && this.option) {
        if (this.option.animation != null)
          return !!this.option.animation;
        if (this.parentModel)
          return this.parentModel.isAnimationEnabled();
      }
    }, r.prototype._doGet = function(t, e) {
      var n = this.option;
      if (!t)
        return n;
      for (var i = 0; i < t.length && !(t[i] && (n = n && typeof n == "object" ? n[t[i]] : null, n == null)); i++)
        ;
      return n == null && e && (n = e._doGet(this.resolveParentPath(t), e.parentModel)), n;
    }, r;
  }()
);
R1(ue);
f6(ue);
hr(ue, r9);
hr(ue, i9);
hr(ue, g6);
hr(ue, t9);
var a9 = Math.round(Math.random() * 10);
function Ac(r) {
  return [r || "", a9++].join("_");
}
function o9(r) {
  var t = {};
  r.registerSubTypeDefaulter = function(e, n) {
    var i = $i(e);
    t[i.main] = n;
  }, r.determineSubType = function(e, n) {
    var i = n.type;
    if (!i) {
      var a = $i(e).main;
      r.hasSubTypes(e) && t[a] && (i = t[a](n));
    }
    return i;
  };
}
function s9(r, t) {
  r.topologicalTravel = function(a, o, s, l) {
    if (!a.length)
      return;
    var u = e(o), c = u.graph, f = u.noEntryList, h = {};
    for (L(a, function(y) {
      h[y] = !0;
    }); f.length; ) {
      var d = f.pop(), p = c[d], g = !!h[d];
      g && (s.call(l, d, p.originalDeps.slice()), delete h[d]), L(p.successor, g ? m : v);
    }
    L(h, function() {
      var y = "";
      throw process.env.NODE_ENV !== "production" && (y = hn("Circular dependency may exists: ", h, a, o)), new Error(y);
    });
    function v(y) {
      c[y].entryCount--, c[y].entryCount === 0 && f.push(y);
    }
    function m(y) {
      h[y] = !0, v(y);
    }
  };
  function e(a) {
    var o = {}, s = [];
    return L(a, function(l) {
      var u = n(o, l), c = u.originalDeps = t(l), f = i(c, a);
      u.entryCount = f.length, u.entryCount === 0 && s.push(l), L(f, function(h) {
        Zt(u.predecessor, h) < 0 && u.predecessor.push(h);
        var d = n(o, h);
        Zt(d.successor, h) < 0 && d.successor.push(l);
      });
    }), {
      graph: o,
      noEntryList: s
    };
  }
  function n(a, o) {
    return a[o] || (a[o] = {
      predecessor: [],
      successor: []
    }), a[o];
  }
  function i(a, o) {
    var s = [];
    return L(a, function(l) {
      Zt(o, l) >= 0 && s.push(l);
    }), s;
  }
}
function jo(r, t) {
  return qt(qt({}, r, !0), t, !0);
}
const l9 = {
  time: {
    month: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthAbbr: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    dayOfWeekAbbr: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
  },
  legend: {
    selector: {
      all: "All",
      inverse: "Inv"
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "Box Select",
        polygon: "Lasso Select",
        lineX: "Horizontally Select",
        lineY: "Vertically Select",
        keep: "Keep Selections",
        clear: "Clear Selections"
      }
    },
    dataView: {
      title: "Data View",
      lang: ["Data View", "Close", "Refresh"]
    },
    dataZoom: {
      title: {
        zoom: "Zoom",
        back: "Zoom Reset"
      }
    },
    magicType: {
      title: {
        line: "Switch to Line Chart",
        bar: "Switch to Bar Chart",
        stack: "Stack",
        tiled: "Tile"
      }
    },
    restore: {
      title: "Restore"
    },
    saveAsImage: {
      title: "Save as Image",
      lang: ["Right Click to Save Image"]
    }
  },
  series: {
    typeNames: {
      pie: "Pie chart",
      bar: "Bar chart",
      line: "Line chart",
      scatter: "Scatter plot",
      effectScatter: "Ripple scatter plot",
      radar: "Radar chart",
      tree: "Tree",
      treemap: "Treemap",
      boxplot: "Boxplot",
      candlestick: "Candlestick",
      k: "K line chart",
      heatmap: "Heat map",
      map: "Map",
      parallel: "Parallel coordinate map",
      lines: "Line graph",
      graph: "Relationship graph",
      sankey: "Sankey diagram",
      funnel: "Funnel chart",
      gauge: "Gauge",
      pictorialBar: "Pictorial bar",
      themeRiver: "Theme River Map",
      sunburst: "Sunburst",
      custom: "Custom chart",
      chart: "Chart"
    }
  },
  aria: {
    general: {
      withTitle: 'This is a chart about "{title}"',
      withoutTitle: "This is a chart"
    },
    series: {
      single: {
        prefix: "",
        withName: " with type {seriesType} named {seriesName}.",
        withoutName: " with type {seriesType}."
      },
      multiple: {
        prefix: ". It consists of {seriesCount} series count.",
        withName: " The {seriesId} series is a {seriesType} representing {seriesName}.",
        withoutName: " The {seriesId} series is a {seriesType}.",
        separator: {
          middle: "",
          end: ""
        }
      }
    },
    data: {
      allData: "The data is as follows: ",
      partialData: "The first {displayCnt} items are: ",
      withName: "the data for {name} is {value}",
      withoutName: "{value}",
      separator: {
        middle: ", ",
        end: ". "
      }
    }
  }
}, u9 = {
  time: {
    month: ["", "", "", "", "", "", "", "", "", "", "", ""],
    monthAbbr: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
    dayOfWeek: ["", "", "", "", "", "", ""],
    dayOfWeekAbbr: ["", "", "", "", "", "", ""]
  },
  legend: {
    selector: {
      all: "",
      inverse: ""
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "",
        polygon: "",
        lineX: "",
        lineY: "",
        keep: "",
        clear: ""
      }
    },
    dataView: {
      title: "",
      lang: ["", "", ""]
    },
    dataZoom: {
      title: {
        zoom: "",
        back: ""
      }
    },
    magicType: {
      title: {
        line: "",
        bar: "",
        stack: "",
        tiled: ""
      }
    },
    restore: {
      title: ""
    },
    saveAsImage: {
      title: "",
      lang: [""]
    }
  },
  series: {
    typeNames: {
      pie: "",
      bar: "",
      line: "",
      scatter: "",
      effectScatter: "",
      radar: "",
      tree: "",
      treemap: "",
      boxplot: "",
      candlestick: "K",
      k: "K",
      heatmap: "",
      map: "",
      parallel: "",
      lines: "",
      graph: "",
      sankey: "",
      funnel: "",
      gauge: "",
      pictorialBar: "",
      themeRiver: "",
      sunburst: "",
      custom: "",
      chart: ""
    }
  },
  aria: {
    general: {
      withTitle: "{title}",
      withoutTitle: ""
    },
    series: {
      single: {
        prefix: "",
        withName: "{seriesType}{seriesName}",
        withoutName: "{seriesType}"
      },
      multiple: {
        prefix: "{seriesCount}",
        withName: "{seriesId}{seriesName}{seriesType}",
        withoutName: "{seriesId}{seriesType}",
        separator: {
          middle: "",
          end: ""
        }
      }
    },
    data: {
      allData: "",
      partialData: "{displayCnt}",
      withName: "{name}{value}",
      withoutName: "{value}",
      separator: {
        middle: "",
        end: ""
      }
    }
  }
};
var kv = "ZH", X1 = "EN", Yu = X1, Kp = {}, Y1 = {}, CN = oe.domSupported ? function() {
  var r = (
    /* eslint-disable-next-line */
    (document.documentElement.lang || navigator.language || navigator.browserLanguage || Yu).toUpperCase()
  );
  return r.indexOf(kv) > -1 ? kv : Yu;
}() : Yu;
function DN(r, t) {
  r = r.toUpperCase(), Y1[r] = new ue(t), Kp[r] = t;
}
function c9(r) {
  if (pt(r)) {
    var t = Kp[r.toUpperCase()] || {};
    return r === kv || r === X1 ? Ct(t) : qt(Ct(t), Ct(Kp[Yu]), !1);
  } else
    return qt(Ct(r), Ct(Kp[Yu]), !1);
}
function kx(r) {
  return Y1[r];
}
function f9() {
  return Y1[Yu];
}
DN(X1, l9);
DN(kv, u9);
var Bx = null;
function h9(r) {
  Bx || (Bx = r);
}
function lr() {
  return Bx;
}
var $1 = 1e3, Z1 = $1 * 60, Yf = Z1 * 60, Qn = Yf * 24, WA = Qn * 365, d9 = {
  year: /({yyyy}|{yy})/,
  month: /({MMMM}|{MMM}|{MM}|{M})/,
  day: /({dd}|{d})/,
  hour: /({HH}|{H}|{hh}|{h})/,
  minute: /({mm}|{m})/,
  second: /({ss}|{s})/,
  millisecond: /({SSS}|{S})/
}, jp = {
  year: "{yyyy}",
  month: "{MMM}",
  day: "{d}",
  hour: "{HH}:{mm}",
  minute: "{HH}:{mm}",
  second: "{HH}:{mm}:{ss}",
  millisecond: "{HH}:{mm}:{ss} {SSS}"
}, p9 = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss} {SSS}", Wd = "{yyyy}-{MM}-{dd}", XA = {
  year: "{yyyy}",
  month: "{yyyy}-{MM}",
  day: Wd,
  hour: Wd + " " + jp.hour,
  minute: Wd + " " + jp.minute,
  second: Wd + " " + jp.second,
  millisecond: p9
}, Cn = ["year", "month", "day", "hour", "minute", "second", "millisecond"], v9 = ["year", "half-year", "quarter", "month", "week", "half-week", "day", "half-day", "quarter-day", "hour", "minute", "second", "millisecond"];
function g9(r) {
  return !pt(r) && !Tt(r) ? m9(r) : r;
}
function m9(r) {
  r = r || {};
  var t = {}, e = !0;
  return L(Cn, function(n) {
    e && (e = r[n] == null);
  }), L(Cn, function(n, i) {
    var a = r[n];
    t[n] = {};
    for (var o = null, s = i; s >= 0; s--) {
      var l = Cn[s], u = Dt(a) && !et(a) ? a[l] : a, c = void 0;
      et(u) ? (c = u.slice(), o = c[0] || "") : pt(u) ? (o = u, c = [o]) : (o == null ? o = jp[n] : d9[l].test(o) || (o = t[l][l][0] + " " + o), c = [o], e && (c[1] = "{primary|" + o + "}")), t[n][l] = c;
    }
  }), t;
}
function so(r, t) {
  return r += "", "0000".substr(0, t - r.length) + r;
}
function $f(r) {
  switch (r) {
    case "half-year":
    case "quarter":
      return "month";
    case "week":
    case "half-week":
      return "day";
    case "half-day":
    case "quarter-day":
      return "hour";
    default:
      return r;
  }
}
function y9(r) {
  return r === $f(r);
}
function _9(r) {
  switch (r) {
    case "year":
    case "month":
      return "day";
    case "millisecond":
      return "millisecond";
    default:
      return "second";
  }
}
function lm(r, t, e, n) {
  var i = Tl(r), a = i[LN(e)](), o = i[q1(e)]() + 1, s = Math.floor((o - 1) / 3) + 1, l = i[K1(e)](), u = i["get" + (e ? "UTC" : "") + "Day"](), c = i[j1(e)](), f = (c - 1) % 12 + 1, h = i[J1(e)](), d = i[Q1(e)](), p = i[tb(e)](), g = c >= 12 ? "pm" : "am", v = g.toUpperCase(), m = n instanceof ue ? n : kx(n || CN) || f9(), y = m.getModel("time"), _ = y.get("month"), x = y.get("monthAbbr"), b = y.get("dayOfWeek"), S = y.get("dayOfWeekAbbr");
  return (t || "").replace(/{a}/g, g + "").replace(/{A}/g, v + "").replace(/{yyyy}/g, a + "").replace(/{yy}/g, so(a % 100 + "", 2)).replace(/{Q}/g, s + "").replace(/{MMMM}/g, _[o - 1]).replace(/{MMM}/g, x[o - 1]).replace(/{MM}/g, so(o, 2)).replace(/{M}/g, o + "").replace(/{dd}/g, so(l, 2)).replace(/{d}/g, l + "").replace(/{eeee}/g, b[u]).replace(/{ee}/g, S[u]).replace(/{e}/g, u + "").replace(/{HH}/g, so(c, 2)).replace(/{H}/g, c + "").replace(/{hh}/g, so(f + "", 2)).replace(/{h}/g, f + "").replace(/{mm}/g, so(h, 2)).replace(/{m}/g, h + "").replace(/{ss}/g, so(d, 2)).replace(/{s}/g, d + "").replace(/{SSS}/g, so(p, 3)).replace(/{S}/g, p + "");
}
function x9(r, t, e, n, i) {
  var a = null;
  if (pt(e))
    a = e;
  else if (Tt(e)) {
    var o = {
      time: r.time,
      level: r.time.level
    }, s = lr();
    s && s.makeAxisLabelFormatterParamBreak(o, r.break), a = e(r.value, t, o);
  } else {
    var l = r.time;
    if (l) {
      var u = e[l.lowerTimeUnit][l.upperTimeUnit];
      a = u[Math.min(l.level, u.length - 1)] || "";
    } else {
      var c = Bu(r.value, i);
      a = e[c][c][0];
    }
  }
  return lm(new Date(r.value), a, i, n);
}
function Bu(r, t) {
  var e = Tl(r), n = e[q1(t)]() + 1, i = e[K1(t)](), a = e[j1(t)](), o = e[J1(t)](), s = e[Q1(t)](), l = e[tb(t)](), u = l === 0, c = u && s === 0, f = c && o === 0, h = f && a === 0, d = h && i === 1, p = d && n === 1;
  return p ? "year" : d ? "month" : h ? "day" : f ? "hour" : c ? "minute" : u ? "second" : "millisecond";
}
function Vx(r, t, e) {
  switch (t) {
    case "year":
      r[RN(e)](0);
    case "month":
      r[IN(e)](1);
    case "day":
      r[PN(e)](0);
    case "hour":
      r[NN(e)](0);
    case "minute":
      r[ON(e)](0);
    case "second":
      r[kN(e)](0);
  }
  return r;
}
function LN(r) {
  return r ? "getUTCFullYear" : "getFullYear";
}
function q1(r) {
  return r ? "getUTCMonth" : "getMonth";
}
function K1(r) {
  return r ? "getUTCDate" : "getDate";
}
function j1(r) {
  return r ? "getUTCHours" : "getHours";
}
function J1(r) {
  return r ? "getUTCMinutes" : "getMinutes";
}
function Q1(r) {
  return r ? "getUTCSeconds" : "getSeconds";
}
function tb(r) {
  return r ? "getUTCMilliseconds" : "getMilliseconds";
}
function S9(r) {
  return r ? "setUTCFullYear" : "setFullYear";
}
function RN(r) {
  return r ? "setUTCMonth" : "setMonth";
}
function IN(r) {
  return r ? "setUTCDate" : "setDate";
}
function PN(r) {
  return r ? "setUTCHours" : "setHours";
}
function NN(r) {
  return r ? "setUTCMinutes" : "setMinutes";
}
function ON(r) {
  return r ? "setUTCSeconds" : "setSeconds";
}
function kN(r) {
  return r ? "setUTCMilliseconds" : "setMilliseconds";
}
function BN(r) {
  if (!C1(r))
    return pt(r) ? r : "-";
  var t = (r + "").split(".");
  return t[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (t.length > 1 ? "." + t[1] : "");
}
function VN(r, t) {
  return r = (r || "").toLowerCase().replace(/-(.)/g, function(e, n) {
    return n.toUpperCase();
  }), t && r && (r = r.charAt(0).toUpperCase() + r.slice(1)), r;
}
var Fh = Fg;
function Fx(r, t, e) {
  var n = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}";
  function i(c) {
    return c && ti(c) ? c : "-";
  }
  function a(c) {
    return !!(c != null && !isNaN(c) && isFinite(c));
  }
  var o = t === "time", s = r instanceof Date;
  if (o || s) {
    var l = o ? Tl(r) : r;
    if (isNaN(+l)) {
      if (s)
        return "-";
    } else
      return lm(l, n, e);
  }
  if (t === "ordinal")
    return mv(r) ? i(r) : fe(r) && a(r) ? r + "" : "-";
  var u = Ga(r);
  return a(u) ? BN(u) : mv(r) ? i(r) : typeof r == "boolean" ? r + "" : "-";
}
var YA = ["a", "b", "c", "d", "e", "f", "g"], Jy = function(r, t) {
  return "{" + r + (t ?? "") + "}";
};
function FN(r, t, e) {
  et(t) || (t = [t]);
  var n = t.length;
  if (!n)
    return "";
  for (var i = t[0].$vars || [], a = 0; a < i.length; a++) {
    var o = YA[a];
    r = r.replace(Jy(o), Jy(o, 0));
  }
  for (var s = 0; s < n; s++)
    for (var l = 0; l < i.length; l++) {
      var u = t[s][i[l]];
      r = r.replace(Jy(YA[l], s), e ? on(u) : u);
    }
  return r;
}
function b9(r, t, e) {
  return L(t, function(n, i) {
    r = r.replace("{" + i + "}", n);
  }), r;
}
function w9(r, t) {
  var e = pt(r) ? {
    color: r,
    extraCssText: t
  } : r || {}, n = e.color, i = e.type;
  t = e.extraCssText;
  var a = e.renderMode || "html";
  if (!n)
    return "";
  if (a === "html")
    return i === "subItem" ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + on(n) + ";" + (t || "") + '"></span>' : '<span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + on(n) + ";" + (t || "") + '"></span>';
  var o = e.markerId || "markerX";
  return {
    renderMode: a,
    content: "{" + o + "|}  ",
    style: i === "subItem" ? {
      width: 4,
      height: 4,
      borderRadius: 2,
      backgroundColor: n
    } : {
      width: 10,
      height: 10,
      borderRadius: 5,
      backgroundColor: n
    }
  };
}
function yl(r, t) {
  return t = t || "transparent", pt(r) ? r : Dt(r) && r.colorStops && (r.colorStops[0] || {}).color || t;
}
function Bv(r, t) {
  if (t === "_blank" || t === "blank") {
    var e = window.open();
    e.opener = null, e.location.href = r;
  } else
    window.open(r, t);
}
var Jp = {}, Qy = {}, Ec = (
  /** @class */
  function() {
    function r() {
      this._normalMasterList = [], this._nonSeriesBoxMasterList = [];
    }
    return r.prototype.create = function(t, e) {
      this._nonSeriesBoxMasterList = n(Jp, !0), this._normalMasterList = n(Qy, !1);
      function n(i, a) {
        var o = [];
        return L(i, function(s, l) {
          var u = s.create(t, e);
          o = o.concat(u || []), process.env.NODE_ENV !== "production" && a && L(u, function(c) {
            return St(!c.update);
          });
        }), o;
      }
    }, r.prototype.update = function(t, e) {
      L(this._normalMasterList, function(n) {
        n.update && n.update(t, e);
      });
    }, r.prototype.getCoordinateSystems = function() {
      return this._normalMasterList.concat(this._nonSeriesBoxMasterList);
    }, r.register = function(t, e) {
      if (t === "matrix" || t === "calendar") {
        Jp[t] = e;
        return;
      }
      Qy[t] = e;
    }, r.get = function(t) {
      return Qy[t] || Jp[t];
    }, r;
  }()
);
function M9(r) {
  return !!Jp[r];
}
var zx = {
  // By default fetch coord from `model.get('coord')`.
  coord: 1,
  // Some model/series, such as pie, is allowed to also get coord from `model.get('center')`,
  // if cannot get from `model.get('coord')`. But historically pie use `center` option, but
  // geo use `layoutCenter` option to specify layout center; they are not able to be unified.
  // Therefor it is not recommended.
  coord2: 2
};
function T9(r) {
  process.env.NODE_ENV !== "production" && St(!Ux.get(r.fullType)), Ux.set(r.fullType, {
    getCoord2: void 0
  }).getCoord2 = r.getCoord2;
}
var Ux = wt();
function A9(r) {
  var t = r.getShallow("coord", !0), e = zx.coord;
  if (t == null) {
    var n = Ux.get(r.type);
    n && n.getCoord2 && (e = zx.coord2, t = n.getCoord2(r));
  }
  return {
    coord: t,
    from: e
  };
}
var Ui = {
  none: 0,
  dataCoordSys: 1,
  boxCoordSys: 2
};
function zN(r, t) {
  var e = r.getShallow("coordinateSystem"), n = r.getShallow("coordinateSystemUsage", !0), i = n != null, a = Ui.none;
  if (e) {
    var o = r.mainType === "series";
    n == null && (n = o ? "data" : "box"), n === "data" ? (a = Ui.dataCoordSys, o || (process.env.NODE_ENV !== "production" && i && t && ce('coordinateSystemUsage "data" is not supported in non-series components.'), a = Ui.none)) : n === "box" && (a = Ui.boxCoordSys, !o && !M9(e) && (process.env.NODE_ENV !== "production" && i && t && ce('coordinateSystem "' + e + '" cannot be used' + (' as coordinateSystemUsage "box" for "' + r.type + '" yet.')), a = Ui.none));
  }
  return {
    coordSysType: e,
    kind: a
  };
}
function zh(r) {
  var t = r.targetModel, e = r.coordSysType, n = r.coordSysProvider, i = r.isDefaultDataCoordSys, a = r.allowNotFound;
  process.env.NODE_ENV !== "production" && St(!!e);
  var o = zN(t, !0), s = o.kind, l = o.coordSysType;
  if (i && s !== Ui.dataCoordSys && (s = Ui.dataCoordSys, l = e), s === Ui.none || l !== e)
    return !1;
  var u = n(e, t);
  return u ? (s === Ui.dataCoordSys ? (process.env.NODE_ENV !== "production" && St(t.mainType === "series"), t.coordinateSystem = u) : t.boxCoordinateSystem = u, !0) : (process.env.NODE_ENV !== "production" && (a || ce(e + " cannot be found for" + (" " + t.type + " (index: " + t.componentIndex + ")."))), !1);
}
var UN = function(r, t) {
  var e = t.getReferringComponents(r, Ke).models[0];
  return e && e.coordinateSystem;
}, Qp = L, GN = ["left", "right", "top", "bottom", "width", "height"], js = [["width", "left", "right"], ["height", "top", "bottom"]];
function eb(r, t, e, n, i) {
  var a = 0, o = 0;
  n == null && (n = 1 / 0), i == null && (i = 1 / 0);
  var s = 0;
  t.eachChild(function(l, u) {
    var c = l.getBoundingRect(), f = t.childAt(u + 1), h = f && f.getBoundingRect(), d, p;
    if (r === "horizontal") {
      var g = c.width + (h ? -h.x + c.x : 0);
      d = a + g, d > n || l.newline ? (a = 0, d = g, o += s + e, s = c.height) : s = Math.max(s, c.height);
    } else {
      var v = c.height + (h ? -h.y + c.y : 0);
      p = o + v, p > i || l.newline ? (a += s + e, o = 0, p = v, s = c.width) : s = Math.max(s, c.width);
    }
    l.newline || (l.x = a, l.y = o, l.markRedraw(), r === "horizontal" ? a = d + e : o = p + e);
  });
}
var sl = eb;
Yt(eb, "vertical");
Yt(eb, "horizontal");
function HN(r, t) {
  return {
    left: r.getShallow("left", t),
    top: r.getShallow("top", t),
    right: r.getShallow("right", t),
    bottom: r.getShallow("bottom", t),
    width: r.getShallow("width", t),
    height: r.getShallow("height", t)
  };
}
function E9(r, t) {
  var e = xr(r, t, {
    enableLayoutOnlyByCenter: !0
  }), n = r.getBoxLayoutParams(), i, a;
  if (e.type === Rf.point)
    a = e.refPoint, i = He(n, {
      width: t.getWidth(),
      height: t.getHeight()
    });
  else {
    var o = r.get("center"), s = et(o) ? o : [o, o];
    i = He(n, e.refContainer), a = e.boxCoordFrom === zx.coord2 ? e.refPoint : [dt(s[0], i.width) + i.x, dt(s[1], i.height) + i.y];
  }
  return {
    viewRect: i,
    center: a
  };
}
function WN(r, t) {
  var e = E9(r, t), n = e.viewRect, i = e.center, a = r.get("radius");
  et(a) || (a = [0, a]);
  var o = dt(n.width, t.getWidth()), s = dt(n.height, t.getHeight()), l = Math.min(o, s), u = dt(a[0], l / 2), c = dt(a[1], l / 2);
  return {
    cx: i[0],
    cy: i[1],
    r0: u,
    r: c,
    viewRect: n
  };
}
function He(r, t, e) {
  e = Fh(e || 0);
  var n = t.width, i = t.height, a = dt(r.left, n), o = dt(r.top, i), s = dt(r.right, n), l = dt(r.bottom, i), u = dt(r.width, n), c = dt(r.height, i), f = e[2] + e[0], h = e[1] + e[3], d = r.aspect;
  switch (isNaN(u) && (u = n - s - h - a), isNaN(c) && (c = i - l - f - o), d != null && (isNaN(u) && isNaN(c) && (d > n / i ? u = n * 0.8 : c = i * 0.8), isNaN(u) && (u = d * c), isNaN(c) && (c = u / d)), isNaN(a) && (a = n - s - u - h), isNaN(o) && (o = i - l - c - f), r.left || r.right) {
    case "center":
      a = n / 2 - u / 2 - e[3];
      break;
    case "right":
      a = n - u - h;
      break;
  }
  switch (r.top || r.bottom) {
    case "middle":
    case "center":
      o = i / 2 - c / 2 - e[0];
      break;
    case "bottom":
      o = i - c - f;
      break;
  }
  a = a || 0, o = o || 0, isNaN(u) && (u = n - h - a - (s || 0)), isNaN(c) && (c = i - f - o - (l || 0));
  var p = new Bt((t.x || 0) + a + e[3], (t.y || 0) + o + e[0], u, c);
  return p.margin = e, p;
}
function XN(r, t, e) {
  var n = r.getShallow("preserveAspect", !0);
  if (!n)
    return t;
  var i = t.width / t.height;
  if (Math.abs(Math.atan(e) - Math.atan(i)) < 1e-9)
    return t;
  var a = r.getShallow("preserveAspectAlign", !0), o = r.getShallow("preserveAspectVerticalAlign", !0), s = {
    width: t.width,
    height: t.height
  }, l = n === "cover";
  return i > e && !l || i < e && l ? (s.width = t.height * e, a === "left" ? s.left = 0 : a === "right" ? s.right = 0 : s.left = "center") : (s.height = t.width / e, o === "top" ? s.top = 0 : o === "bottom" ? s.bottom = 0 : s.top = "middle"), He(s, t);
}
var Rf = {
  rect: 1,
  point: 2
};
function xr(r, t, e) {
  var n, i, a, o = r.boxCoordinateSystem, s;
  if (o) {
    var l = A9(r), u = l.coord, c = l.from;
    if (o.dataToLayout) {
      a = Rf.rect, s = c;
      var f = o.dataToLayout(u);
      n = f.contentRect || f.rect;
    } else
      e && e.enableLayoutOnlyByCenter && o.dataToPoint ? (a = Rf.point, s = c, i = o.dataToPoint(u)) : process.env.NODE_ENV !== "production" && ce(r.type + "[" + r.componentIndex + "]" + (" layout based on " + o.type + " is not supported."));
  }
  return a == null && (a = Rf.rect), a === Rf.rect && (n || (n = {
    x: 0,
    y: 0,
    width: t.getWidth(),
    height: t.getHeight()
  }), i = [n.x + n.width / 2, n.y + n.height / 2]), {
    type: a,
    refContainer: n,
    refPoint: i,
    boxCoordFrom: s
  };
}
function um(r, t, e, n, i, a) {
  var o = !i || !i.hv || i.hv[0], s = !i || !i.hv || i.hv[1], l = i && i.boundingMode || "all";
  if (a = a || r, a.x = r.x, a.y = r.y, !o && !s)
    return !1;
  var u;
  if (l === "raw")
    u = r.type === "group" ? new Bt(0, 0, +t.width || 0, +t.height || 0) : r.getBoundingRect();
  else if (u = r.getBoundingRect(), r.needLocalTransform()) {
    var c = r.getLocalTransform();
    u = u.clone(), u.applyTransform(c);
  }
  var f = He(kt({
    width: u.width,
    height: u.height
  }, t), e, n), h = o ? f.x - u.x : 0, d = s ? f.y - u.y : 0;
  return l === "raw" ? (a.x = h, a.y = d) : (a.x += h, a.y += d), a === r && r.markRedraw(), !0;
}
function C9(r, t) {
  return r[js[t][0]] != null || r[js[t][1]] != null && r[js[t][2]] != null;
}
function lh(r) {
  var t = r.layoutMode || r.constructor.layoutMode;
  return Dt(t) ? t : t ? {
    type: t
  } : null;
}
function oa(r, t, e) {
  var n = e && e.ignoreSize;
  !et(n) && (n = [n, n]);
  var i = o(js[0], 0), a = o(js[1], 1);
  l(js[0], r, i), l(js[1], r, a);
  function o(u, c) {
    var f = {}, h = 0, d = {}, p = 0, g = 2;
    if (Qp(u, function(y) {
      d[y] = r[y];
    }), Qp(u, function(y) {
      _t(t, y) && (f[y] = d[y] = t[y]), s(f, y) && h++, s(d, y) && p++;
    }), n[c])
      return s(t, u[1]) ? d[u[2]] = null : s(t, u[2]) && (d[u[1]] = null), d;
    if (p === g || !h)
      return d;
    if (h >= g)
      return f;
    for (var v = 0; v < u.length; v++) {
      var m = u[v];
      if (!_t(f, m) && _t(r, m)) {
        f[m] = r[m];
        break;
      }
    }
    return f;
  }
  function s(u, c) {
    return u[c] != null && u[c] !== "auto";
  }
  function l(u, c, f) {
    Qp(u, function(h) {
      c[h] = f[h];
    });
  }
}
function El(r) {
  return YN({}, r);
}
function YN(r, t) {
  return t && r && Qp(GN, function(e) {
    _t(t, e) && (r[e] = t[e]);
  }), r;
}
var D9 = ee(), re = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e, n, i) {
      var a = r.call(this, e, n, i) || this;
      return a.uid = Ac("ec_cpt_model"), a;
    }
    return t.prototype.init = function(e, n, i) {
      this.mergeDefaultAndTheme(e, i);
    }, t.prototype.mergeDefaultAndTheme = function(e, n) {
      var i = lh(this), a = i ? El(e) : {}, o = n.getTheme();
      qt(e, o.get(this.mainType)), qt(e, this.getDefaultOption()), i && oa(e, a, i);
    }, t.prototype.mergeOption = function(e, n) {
      qt(this.option, e, !0);
      var i = lh(this);
      i && oa(this.option, e, i);
    }, t.prototype.optionUpdated = function(e, n) {
    }, t.prototype.getDefaultOption = function() {
      var e = this.constructor;
      if (!l6(e))
        return e.defaultOption;
      var n = D9(this);
      if (!n.defaultOption) {
        for (var i = [], a = e; a; ) {
          var o = a.prototype.defaultOption;
          o && i.push(o), a = a.superClass;
        }
        for (var s = {}, l = i.length - 1; l >= 0; l--)
          s = qt(s, i[l], !0);
        n.defaultOption = s;
      }
      return n.defaultOption;
    }, t.prototype.getReferringComponents = function(e, n) {
      var i = e + "Index", a = e + "Id";
      return Sc(this.ecModel, e, {
        index: this.get(i, !0),
        id: this.get(a, !0)
      }, n);
    }, t.prototype.getBoxLayoutParams = function() {
      return HN(this, !1);
    }, t.prototype.getZLevelKey = function() {
      return "";
    }, t.prototype.setZLevel = function(e) {
      this.option.zlevel = e;
    }, t.protoInitialize = function() {
      var e = t.prototype;
      e.type = "component", e.id = "", e.name = "", e.mainType = "", e.subType = "", e.componentIndex = 0;
    }(), t;
  }(ue)
);
zP(re, ue);
Zg(re);
o9(re);
s9(re, L9);
function L9(r) {
  var t = [];
  return L(re.getClassesByMainType(r), function(e) {
    t = t.concat(e.dependencies || e.prototype.dependencies || []);
  }), t = rt(t, function(e) {
    return $i(e).main;
  }), r !== "dataset" && Zt(t, "dataset") <= 0 && t.unshift("dataset"), t;
}
var Y = {
  color: {},
  darkColor: {},
  size: {}
}, Je = Y.color = {
  theme: ["#5070dd", "#b6d634", "#505372", "#ff994d", "#0ca8df", "#ffd10a", "#fb628b", "#785db0", "#3fbe95"],
  neutral00: "#fff",
  neutral05: "#f4f7fd",
  neutral10: "#e8ebf0",
  neutral15: "#dbdee4",
  neutral20: "#cfd2d7",
  neutral25: "#c3c5cb",
  neutral30: "#b7b9be",
  neutral35: "#aaacb2",
  neutral40: "#9ea0a5",
  neutral45: "#929399",
  neutral50: "#86878c",
  neutral55: "#797b7f",
  neutral60: "#6d6e73",
  neutral65: "#616266",
  neutral70: "#54555a",
  neutral75: "#48494d",
  neutral80: "#3c3c41",
  neutral85: "#303034",
  neutral90: "#232328",
  neutral95: "#17171b",
  neutral99: "#000",
  accent05: "#eff1f9",
  accent10: "#e0e4f2",
  accent15: "#d0d6ec",
  accent20: "#c0c9e6",
  accent25: "#b1bbdf",
  accent30: "#a1aed9",
  accent35: "#91a0d3",
  accent40: "#8292cc",
  accent45: "#7285c6",
  accent50: "#6578ba",
  accent55: "#5c6da9",
  accent60: "#536298",
  accent65: "#4a5787",
  accent70: "#404c76",
  accent75: "#374165",
  accent80: "#2e3654",
  accent85: "#252b43",
  accent90: "#1b2032",
  accent95: "#121521",
  transparent: "rgba(0,0,0,0)",
  highlight: "rgba(255,231,130,0.8)"
};
J(Je, {
  primary: Je.neutral80,
  secondary: Je.neutral70,
  tertiary: Je.neutral60,
  quaternary: Je.neutral50,
  disabled: Je.neutral20,
  border: Je.neutral30,
  borderTint: Je.neutral20,
  borderShade: Je.neutral40,
  background: Je.neutral05,
  backgroundTint: "rgba(234,237,245,0.5)",
  backgroundTransparent: "rgba(255,255,255,0)",
  backgroundShade: Je.neutral10,
  shadow: "rgba(0,0,0,0.2)",
  shadowTint: "rgba(129,130,136,0.2)",
  axisLine: Je.neutral70,
  axisLineTint: Je.neutral40,
  axisTick: Je.neutral70,
  axisTickMinor: Je.neutral60,
  axisLabel: Je.neutral70,
  axisSplitLine: Je.neutral15,
  axisMinorSplitLine: Je.neutral05
});
for (var bs in Je)
  if (Je.hasOwnProperty(bs)) {
    var $A = Je[bs];
    bs === "theme" ? Y.darkColor.theme = Je.theme.slice() : bs === "highlight" ? Y.darkColor.highlight = "rgba(255,231,130,0.4)" : bs.indexOf("accent") === 0 ? Y.darkColor[bs] = No($A, null, function(r) {
      return r * 0.5;
    }, function(r) {
      return Math.min(1, 1.3 - r);
    }) : Y.darkColor[bs] = No($A, null, function(r) {
      return r * 0.9;
    }, function(r) {
      return 1 - Math.pow(r, 1.5);
    });
  }
Y.size = {
  xxs: 2,
  xs: 5,
  s: 10,
  m: 15,
  l: 20,
  xl: 30,
  xxl: 40,
  xxxl: 50
};
var $N = "";
typeof navigator < "u" && ($N = navigator.platform || "");
var au = "rgba(0, 0, 0, 0.2)", ZN = Y.color.theme[0], R9 = No(ZN, null, null, 0.9);
const I9 = {
  darkMode: "auto",
  // backgroundColor: 'rgba(0,0,0,0)',
  colorBy: "series",
  color: Y.color.theme,
  gradientColor: [R9, ZN],
  aria: {
    decal: {
      decals: [{
        color: au,
        dashArrayX: [1, 0],
        dashArrayY: [2, 5],
        symbolSize: 1,
        rotation: Math.PI / 6
      }, {
        color: au,
        symbol: "circle",
        dashArrayX: [[8, 8], [0, 8, 8, 0]],
        dashArrayY: [6, 0],
        symbolSize: 0.8
      }, {
        color: au,
        dashArrayX: [1, 0],
        dashArrayY: [4, 3],
        rotation: -Math.PI / 4
      }, {
        color: au,
        dashArrayX: [[6, 6], [0, 6, 6, 0]],
        dashArrayY: [6, 0]
      }, {
        color: au,
        dashArrayX: [[1, 0], [1, 6]],
        dashArrayY: [1, 0, 6, 0],
        rotation: Math.PI / 4
      }, {
        color: au,
        symbol: "triangle",
        dashArrayX: [[9, 9], [0, 9, 9, 0]],
        dashArrayY: [7, 2],
        symbolSize: 0.75
      }]
    }
  },
  // If xAxis and yAxis declared, grid is created by default.
  // grid: {},
  textStyle: {
    // color: '#000',
    // decoration: 'none',
    // PENDING
    fontFamily: $N.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
    // fontFamily: 'Arial, Verdana, sans-serif',
    fontSize: 12,
    fontStyle: "normal",
    fontWeight: "normal"
  },
  // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/
  // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
  // Default is source-over
  blendMode: null,
  stateAnimation: {
    duration: 300,
    easing: "cubicOut"
  },
  animation: "auto",
  animationDuration: 1e3,
  animationDurationUpdate: 500,
  animationEasing: "cubicInOut",
  animationEasingUpdate: "cubicInOut",
  animationThreshold: 2e3,
  // Configuration for progressive/incremental rendering
  progressiveThreshold: 3e3,
  progressive: 400,
  // Threshold of if use single hover layer to optimize.
  // It is recommended that `hoverLayerThreshold` is equivalent to or less than
  // `progressiveThreshold`, otherwise hover will cause restart of progressive,
  // which is unexpected.
  // see example <echarts/test/heatmap-large.html>.
  hoverLayerThreshold: 3e3,
  // See: module:echarts/scale/Time
  useUTC: !1
};
var Gx = wt(["tooltip", "label", "itemName", "itemId", "itemGroupId", "itemChildGroupId", "seriesName"]), Bn = "original", Br = "arrayRows", Vn = "objectRows", Ti = "keyedColumns", Na = "typedArray", qN = "unknown", _i = "column", Cl = "row", Fr = {
  Must: 1,
  Might: 2,
  Not: 3
  // Other cases
}, KN = ee();
function P9(r) {
  KN(r).datasetMap = wt();
}
function jN(r, t, e) {
  var n = {}, i = nb(t);
  if (!i || !r)
    return n;
  var a = [], o = [], s = t.ecModel, l = KN(s).datasetMap, u = i.uid + "_" + e.seriesLayoutBy, c, f;
  r = r.slice(), L(r, function(g, v) {
    var m = Dt(g) ? g : r[v] = {
      name: g
    };
    m.type === "ordinal" && c == null && (c = v, f = p(m)), n[m.name] = [];
  });
  var h = l.get(u) || l.set(u, {
    categoryWayDim: f,
    valueWayDim: 0
  });
  L(r, function(g, v) {
    var m = g.name, y = p(g);
    if (c == null) {
      var _ = h.valueWayDim;
      d(n[m], _, y), d(o, _, y), h.valueWayDim += y;
    } else if (c === v)
      d(n[m], 0, y), d(a, 0, y);
    else {
      var _ = h.categoryWayDim;
      d(n[m], _, y), d(o, _, y), h.categoryWayDim += y;
    }
  });
  function d(g, v, m) {
    for (var y = 0; y < m; y++)
      g.push(v + y);
  }
  function p(g) {
    var v = g.dimsDef;
    return v ? v.length : 1;
  }
  return a.length && (n.itemName = a), o.length && (n.seriesName = o), n;
}
function rb(r, t, e) {
  var n = {}, i = nb(r);
  if (!i)
    return n;
  var a = t.sourceFormat, o = t.dimensionsDefine, s;
  (a === Vn || a === Ti) && L(o, function(c, f) {
    (Dt(c) ? c.name : c) === "name" && (s = f);
  });
  var l = function() {
    for (var c = {}, f = {}, h = [], d = 0, p = Math.min(5, e); d < p; d++) {
      var g = QN(t.data, a, t.seriesLayoutBy, o, t.startIndex, d);
      h.push(g);
      var v = g === Fr.Not;
      if (v && c.v == null && d !== s && (c.v = d), (c.n == null || c.n === c.v || !v && h[c.n] === Fr.Not) && (c.n = d), m(c) && h[c.n] !== Fr.Not)
        return c;
      v || (g === Fr.Might && f.v == null && d !== s && (f.v = d), (f.n == null || f.n === f.v) && (f.n = d));
    }
    function m(y) {
      return y.v != null && y.n != null;
    }
    return m(c) ? c : m(f) ? f : null;
  }();
  if (l) {
    n.value = [l.v];
    var u = s ?? l.n;
    n.itemName = [u], n.seriesName = [u];
  }
  return n;
}
function nb(r) {
  var t = r.get("data", !0);
  if (!t)
    return Sc(r.ecModel, "dataset", {
      index: r.get("datasetIndex", !0),
      id: r.get("datasetId", !0)
    }, Ke).models[0];
}
function N9(r) {
  return !r.get("transform", !0) && !r.get("fromTransformResult", !0) ? [] : Sc(r.ecModel, "dataset", {
    index: r.get("fromDatasetIndex", !0),
    id: r.get("fromDatasetId", !0)
  }, Ke).models;
}
function JN(r, t) {
  return QN(r.data, r.sourceFormat, r.seriesLayoutBy, r.dimensionsDefine, r.startIndex, t);
}
function QN(r, t, e, n, i, a) {
  var o, s = 5;
  if (fn(r))
    return Fr.Not;
  var l, u;
  if (n) {
    var c = n[a];
    Dt(c) ? (l = c.name, u = c.type) : pt(c) && (l = c);
  }
  if (u != null)
    return u === "ordinal" ? Fr.Must : Fr.Not;
  if (t === Br) {
    var f = r;
    if (e === Cl) {
      for (var h = f[a], d = 0; d < (h || []).length && d < s; d++)
        if ((o = x(h[i + d])) != null)
          return o;
    } else
      for (var d = 0; d < f.length && d < s; d++) {
        var p = f[i + d];
        if (p && (o = x(p[a])) != null)
          return o;
      }
  } else if (t === Vn) {
    var g = r;
    if (!l)
      return Fr.Not;
    for (var d = 0; d < g.length && d < s; d++) {
      var v = g[d];
      if (v && (o = x(v[l])) != null)
        return o;
    }
  } else if (t === Ti) {
    var m = r;
    if (!l)
      return Fr.Not;
    var h = m[l];
    if (!h || fn(h))
      return Fr.Not;
    for (var d = 0; d < h.length && d < s; d++)
      if ((o = x(h[d])) != null)
        return o;
  } else if (t === Bn)
    for (var y = r, d = 0; d < y.length && d < s; d++) {
      var v = y[d], _ = xc(v);
      if (!et(_))
        return Fr.Not;
      if ((o = x(_[a])) != null)
        return o;
    }
  function x(b) {
    var S = pt(b);
    if (b != null && Number.isFinite(Number(b)) && b !== "")
      return S ? Fr.Might : Fr.Not;
    if (S && b !== "-")
      return Fr.Must;
  }
  return Fr.Not;
}
var Hx = wt();
function O9(r, t) {
  St(Hx.get(r) == null && t), Hx.set(r, t);
}
function k9(r, t, e) {
  var n = Hx.get(t);
  if (!n)
    return e;
  var i = n(r);
  if (!i)
    return e;
  if (process.env.NODE_ENV !== "production")
    for (var a = 0; a < i.length; a++)
      St(ec(i[a]));
  return e.concat(i);
}
var ZA = ee(), B9 = ee(), ib = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getColorFromPalette = function(t, e, n) {
      var i = Ie(this.get("color", !0)), a = this.get("colorLayer", !0);
      return tO(this, ZA, i, a, t, e, n);
    }, r.prototype.clearColorPalette = function() {
      F9(this, ZA);
    }, r;
  }()
);
function Wx(r, t, e, n) {
  var i = Ie(r.get(["aria", "decal", "decals"]));
  return tO(r, B9, i, null, t, e, n);
}
function V9(r, t) {
  for (var e = r.length, n = 0; n < e; n++)
    if (r[n].length > t)
      return r[n];
  return r[e - 1];
}
function tO(r, t, e, n, i, a, o) {
  a = a || r;
  var s = t(a), l = s.paletteIdx || 0, u = s.paletteNameMap = s.paletteNameMap || {};
  if (u.hasOwnProperty(i))
    return u[i];
  var c = o == null || !n ? e : V9(n, o);
  if (c = c || e, !(!c || !c.length)) {
    var f = c[l];
    return i && (u[i] = f), s.paletteIdx = (l + 1) % c.length, f;
  }
}
function F9(r, t) {
  t(r).paletteIdx = 0, t(r).paletteNameMap = {};
}
var Xd, jc, qA, t0 = "\0_ec_inner", KA = 1, z9 = {
  grid: "GridComponent",
  polar: "PolarComponent",
  geo: "GeoComponent",
  singleAxis: "SingleAxisComponent",
  parallel: "ParallelComponent",
  calendar: "CalendarComponent",
  matrix: "MatrixComponent",
  graphic: "GraphicComponent",
  toolbox: "ToolboxComponent",
  tooltip: "TooltipComponent",
  axisPointer: "AxisPointerComponent",
  brush: "BrushComponent",
  title: "TitleComponent",
  timeline: "TimelineComponent",
  markPoint: "MarkPointComponent",
  markLine: "MarkLineComponent",
  markArea: "MarkAreaComponent",
  legend: "LegendComponent",
  dataZoom: "DataZoomComponent",
  visualMap: "VisualMapComponent",
  // aria: 'AriaComponent',
  // dataset: 'DatasetComponent',
  // Dependencies
  xAxis: "GridComponent",
  yAxis: "GridComponent",
  angleAxis: "PolarComponent",
  radiusAxis: "PolarComponent"
}, U9 = {
  line: "LineChart",
  bar: "BarChart",
  pie: "PieChart",
  scatter: "ScatterChart",
  radar: "RadarChart",
  map: "MapChart",
  tree: "TreeChart",
  treemap: "TreemapChart",
  graph: "GraphChart",
  chord: "ChordChart",
  gauge: "GaugeChart",
  funnel: "FunnelChart",
  parallel: "ParallelChart",
  sankey: "SankeyChart",
  boxplot: "BoxplotChart",
  candlestick: "CandlestickChart",
  effectScatter: "EffectScatterChart",
  lines: "LinesChart",
  heatmap: "HeatmapChart",
  pictorialBar: "PictorialBarChart",
  themeRiver: "ThemeRiverChart",
  sunburst: "SunburstChart",
  custom: "CustomChart"
}, Vv = {};
function G9(r) {
  L(r, function(t, e) {
    if (!re.hasClass(e)) {
      var n = z9[e];
      n && !Vv[n] && (ce("Component " + e + ` is used but not imported.
import { ` + n + ` } from 'echarts/components';
echarts.use([` + n + "]);"), Vv[n] = !0);
    }
  });
}
var ab = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t.prototype.init = function(e, n, i, a, o, s) {
      a = a || {}, this.option = null, this._theme = new ue(a), this._locale = new ue(o), this._optionManager = s;
    }, t.prototype.setOption = function(e, n, i) {
      process.env.NODE_ENV !== "production" && (St(e != null, "option is null/undefined"), St(e[t0] !== KA, "please use chart.getOption()"));
      var a = QA(n);
      this._optionManager.setOption(e, i, a), this._resetOption(null, a);
    }, t.prototype.resetOption = function(e, n) {
      return this._resetOption(e, QA(n));
    }, t.prototype._resetOption = function(e, n) {
      var i = !1, a = this._optionManager;
      if (!e || e === "recreate") {
        var o = a.mountOption(e === "recreate");
        process.env.NODE_ENV !== "production" && G9(o), !this.option || e === "recreate" ? qA(this, o) : (this.restoreData(), this._mergeOption(o, n)), i = !0;
      }
      if ((e === "timeline" || e === "media") && this.restoreData(), !e || e === "recreate" || e === "timeline") {
        var s = a.getTimelineOption(this);
        s && (i = !0, this._mergeOption(s, n));
      }
      if (!e || e === "recreate" || e === "media") {
        var l = a.getMediaOption(this);
        l.length && L(l, function(u) {
          i = !0, this._mergeOption(u, n);
        }, this);
      }
      return i;
    }, t.prototype.mergeOption = function(e) {
      this._mergeOption(e, null);
    }, t.prototype._mergeOption = function(e, n) {
      var i = this.option, a = this._componentsMap, o = this._componentsCount, s = [], l = wt(), u = n && n.replaceMergeMainTypeMap;
      P9(this), L(e, function(f, h) {
        f != null && (re.hasClass(h) ? h && (s.push(h), l.set(h, !0)) : i[h] = i[h] == null ? Ct(f) : qt(i[h], f, !0));
      }), u && u.each(function(f, h) {
        re.hasClass(h) && !l.get(h) && (s.push(h), l.set(h, !0));
      }), re.topologicalTravel(s, re.getAllClassMainTypes(), c, this);
      function c(f) {
        var h = k9(this, f, Ie(e[f])), d = a.get(f), p = (
          // `!oldCmptList` means init. See the comment in `mappingToExists`
          d ? u && u.get(f) ? "replaceMerge" : "normalMerge" : "replaceAll"
        ), g = OP(d, h, p);
        Q8(g, f, re), i[f] = null, a.set(f, null), o.set(f, 0);
        var v = [], m = [], y = 0, _, x;
        L(g, function(b, S) {
          var w = b.existing, A = b.newOption;
          if (!A)
            w && (w.mergeOption({}, this), w.optionUpdated({}, !1));
          else {
            var T = f === "series", M = re.getClass(
              f,
              b.keyInfo.subType,
              !T
              // Give a more detailed warn later if series don't exists
            );
            if (!M) {
              if (process.env.NODE_ENV !== "production") {
                var E = b.keyInfo.subType, R = U9[E];
                Vv[E] || (Vv[E] = !0, ce(R ? "Series " + E + ` is used but not imported.
import { ` + R + ` } from 'echarts/charts';
echarts.use([` + R + "]);" : "Unknown series " + E));
              }
              return;
            }
            if (f === "tooltip") {
              if (_) {
                process.env.NODE_ENV !== "production" && (x || (Xe("Currently only one tooltip component is allowed."), x = !0));
                return;
              }
              _ = !0;
            }
            if (w && w.constructor === M)
              w.name = b.keyInfo.name, w.mergeOption(A, this), w.optionUpdated(A, !1);
            else {
              var C = J({
                componentIndex: S
              }, b.keyInfo);
              w = new M(A, this, this, C), J(w, C), b.brandNew && (w.__requireNewView = !0), w.init(A, this, this), w.optionUpdated(null, !0);
            }
          }
          w ? (v.push(w.option), m.push(w), y++) : (v.push(void 0), m.push(void 0));
        }, this), i[f] = v, a.set(f, m), o.set(f, y), f === "series" && Xd(this);
      }
      this._seriesIndices || Xd(this);
    }, t.prototype.getOption = function() {
      var e = Ct(this.option);
      return L(e, function(n, i) {
        if (re.hasClass(i)) {
          for (var a = Ie(n), o = a.length, s = !1, l = o - 1; l >= 0; l--)
            a[l] && !ec(a[l]) ? s = !0 : (a[l] = null, !s && o--);
          a.length = o, e[i] = a;
        }
      }), delete e[t0], e;
    }, t.prototype.setTheme = function(e) {
      this._theme = new ue(e), this._resetOption("recreate", null);
    }, t.prototype.getTheme = function() {
      return this._theme;
    }, t.prototype.getLocaleModel = function() {
      return this._locale;
    }, t.prototype.setUpdatePayload = function(e) {
      this._payload = e;
    }, t.prototype.getUpdatePayload = function() {
      return this._payload;
    }, t.prototype.getComponent = function(e, n) {
      var i = this._componentsMap.get(e);
      if (i) {
        var a = i[n || 0];
        if (a)
          return a;
        if (n == null) {
          for (var o = 0; o < i.length; o++)
            if (i[o])
              return i[o];
        }
      }
    }, t.prototype.queryComponents = function(e) {
      var n = e.mainType;
      if (!n)
        return [];
      var i = e.index, a = e.id, o = e.name, s = this._componentsMap.get(n);
      if (!s || !s.length)
        return [];
      var l;
      return i != null ? (l = [], L(Ie(i), function(u) {
        s[u] && l.push(s[u]);
      })) : a != null ? l = jA("id", a, s) : o != null ? l = jA("name", o, s) : l = Te(s, function(u) {
        return !!u;
      }), JA(l, e);
    }, t.prototype.findComponents = function(e) {
      var n = e.query, i = e.mainType, a = s(n), o = a ? this.queryComponents(a) : Te(this._componentsMap.get(i), function(u) {
        return !!u;
      });
      return l(JA(o, e));
      function s(u) {
        var c = i + "Index", f = i + "Id", h = i + "Name";
        return u && (u[c] != null || u[f] != null || u[h] != null) ? {
          mainType: i,
          // subType will be filtered finally.
          index: u[c],
          id: u[f],
          name: u[h]
        } : null;
      }
      function l(u) {
        return e.filter ? Te(u, e.filter) : u;
      }
    }, t.prototype.eachComponent = function(e, n, i) {
      var a = this._componentsMap;
      if (Tt(e)) {
        var o = n, s = e;
        a.each(function(f, h) {
          for (var d = 0; f && d < f.length; d++) {
            var p = f[d];
            p && s.call(o, h, p, p.componentIndex);
          }
        });
      } else
        for (var l = pt(e) ? a.get(e) : Dt(e) ? this.findComponents(e) : null, u = 0; l && u < l.length; u++) {
          var c = l[u];
          c && n.call(i, c, c.componentIndex);
        }
    }, t.prototype.getSeriesByName = function(e) {
      var n = mr(e, null);
      return Te(this._componentsMap.get("series"), function(i) {
        return !!i && n != null && i.name === n;
      });
    }, t.prototype.getSeriesByIndex = function(e) {
      return this._componentsMap.get("series")[e];
    }, t.prototype.getSeriesByType = function(e) {
      return Te(this._componentsMap.get("series"), function(n) {
        return !!n && n.subType === e;
      });
    }, t.prototype.getSeries = function() {
      return Te(this._componentsMap.get("series"), function(e) {
        return !!e;
      });
    }, t.prototype.getSeriesCount = function() {
      return this._componentsCount.get("series");
    }, t.prototype.eachSeries = function(e, n) {
      jc(this), L(this._seriesIndices, function(i) {
        var a = this._componentsMap.get("series")[i];
        e.call(n, a, i);
      }, this);
    }, t.prototype.eachRawSeries = function(e, n) {
      L(this._componentsMap.get("series"), function(i) {
        i && e.call(n, i, i.componentIndex);
      });
    }, t.prototype.eachSeriesByType = function(e, n, i) {
      jc(this), L(this._seriesIndices, function(a) {
        var o = this._componentsMap.get("series")[a];
        o.subType === e && n.call(i, o, a);
      }, this);
    }, t.prototype.eachRawSeriesByType = function(e, n, i) {
      return L(this.getSeriesByType(e), n, i);
    }, t.prototype.isSeriesFiltered = function(e) {
      return jc(this), this._seriesIndicesMap.get(e.componentIndex) == null;
    }, t.prototype.getCurrentSeriesIndices = function() {
      return (this._seriesIndices || []).slice();
    }, t.prototype.filterSeries = function(e, n) {
      jc(this);
      var i = [];
      L(this._seriesIndices, function(a) {
        var o = this._componentsMap.get("series")[a];
        e.call(n, o, a) && i.push(a);
      }, this), this._seriesIndices = i, this._seriesIndicesMap = wt(i);
    }, t.prototype.restoreData = function(e) {
      Xd(this);
      var n = this._componentsMap, i = [];
      n.each(function(a, o) {
        re.hasClass(o) && i.push(o);
      }), re.topologicalTravel(i, re.getAllClassMainTypes(), function(a) {
        L(n.get(a), function(o) {
          o && (a !== "series" || !H9(o, e)) && o.restoreData();
        });
      });
    }, t.internalField = function() {
      Xd = function(e) {
        var n = e._seriesIndices = [];
        L(e._componentsMap.get("series"), function(i) {
          i && n.push(i.componentIndex);
        }), e._seriesIndicesMap = wt(n);
      }, jc = function(e) {
        if (process.env.NODE_ENV !== "production" && !e._seriesIndices)
          throw new Error("Option should contains series.");
      }, qA = function(e, n) {
        e.option = {}, e.option[t0] = KA, e._componentsMap = wt({
          series: []
        }), e._componentsCount = wt();
        var i = n.aria;
        Dt(i) && i.enabled == null && (i.enabled = !0), W9(n, e._theme.option), qt(n, I9, !1), e._mergeOption(n, null);
      };
    }(), t;
  }(ue)
);
function H9(r, t) {
  if (t) {
    var e = t.seriesIndex, n = t.seriesId, i = t.seriesName;
    return e != null && r.componentIndex !== e || n != null && r.id !== n || i != null && r.name !== i;
  }
}
function W9(r, t) {
  var e = r.color && !r.colorLayer;
  L(t, function(n, i) {
    i === "colorLayer" && e || i === "color" && r.color || re.hasClass(i) || (typeof n == "object" ? r[i] = r[i] ? qt(r[i], n, !1) : Ct(n) : r[i] == null && (r[i] = n));
  });
}
function jA(r, t, e) {
  if (et(t)) {
    var n = wt();
    return L(t, function(a) {
      if (a != null) {
        var o = mr(a, null);
        o != null && n.set(a, !0);
      }
    }), Te(e, function(a) {
      return a && n.get(a[r]);
    });
  } else {
    var i = mr(t, null);
    return Te(e, function(a) {
      return a && i != null && a[r] === i;
    });
  }
}
function JA(r, t) {
  return t.hasOwnProperty("subType") ? Te(r, function(e) {
    return e && e.subType === t.subType;
  }) : r;
}
function QA(r) {
  var t = wt();
  return r && L(Ie(r.replaceMerge), function(e) {
    process.env.NODE_ENV !== "production" && St(re.hasClass(e), '"' + e + '" is not valid component main type in "replaceMerge"'), t.set(e, !0);
  }), {
    replaceMergeMainTypeMap: t
  };
}
hr(ab, ib);
var X9 = [
  "getDom",
  "getZr",
  "getWidth",
  "getHeight",
  "getDevicePixelRatio",
  "dispatchAction",
  "isSSR",
  "isDisposed",
  "on",
  "off",
  "getDataURL",
  "getConnectedDataURL",
  // 'getModel',
  "getOption",
  // 'getViewOfComponentModel',
  // 'getViewOfSeriesModel',
  "getId",
  "updateLabelLayout"
], eO = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(t) {
      L(X9, function(e) {
        this[e] = mt(t[e], t);
      }, this);
    }
    return r;
  }()
), Y9 = /^(min|max)?(.+)$/, $9 = (
  /** @class */
  function() {
    function r(t) {
      this._timelineOptions = [], this._mediaList = [], this._currentMediaIndices = [], this._api = t;
    }
    return r.prototype.setOption = function(t, e, n) {
      t && (L(Ie(t.series), function(o) {
        o && o.data && fn(o.data) && yv(o.data);
      }), L(Ie(t.dataset), function(o) {
        o && o.source && fn(o.source) && yv(o.source);
      })), t = Ct(t);
      var i = this._optionBackup, a = Z9(t, e, !i);
      this._newBaseOption = a.baseOption, i ? (a.timelineOptions.length && (i.timelineOptions = a.timelineOptions), a.mediaList.length && (i.mediaList = a.mediaList), a.mediaDefault && (i.mediaDefault = a.mediaDefault)) : this._optionBackup = a;
    }, r.prototype.mountOption = function(t) {
      var e = this._optionBackup;
      return this._timelineOptions = e.timelineOptions, this._mediaList = e.mediaList, this._mediaDefault = e.mediaDefault, this._currentMediaIndices = [], Ct(t ? e.baseOption : this._newBaseOption);
    }, r.prototype.getTimelineOption = function(t) {
      var e, n = this._timelineOptions;
      if (n.length) {
        var i = t.getComponent("timeline");
        i && (e = Ct(
          // FIXME:TS as TimelineModel or quivlant interface
          n[i.getCurrentIndex()]
        ));
      }
      return e;
    }, r.prototype.getMediaOption = function(t) {
      var e = this._api.getWidth(), n = this._api.getHeight(), i = this._mediaList, a = this._mediaDefault, o = [], s = [];
      if (!i.length && !a)
        return s;
      for (var l = 0, u = i.length; l < u; l++)
        q9(i[l].query, e, n) && o.push(l);
      return !o.length && a && (o = [-1]), o.length && !j9(o, this._currentMediaIndices) && (s = rt(o, function(c) {
        return Ct(c === -1 ? a.option : i[c].option);
      })), this._currentMediaIndices = o, s;
    }, r;
  }()
);
function Z9(r, t, e) {
  var n = [], i, a, o = r.baseOption, s = r.timeline, l = r.options, u = r.media, c = !!r.media, f = !!(l || s || o && o.timeline);
  o ? (a = o, a.timeline || (a.timeline = s)) : ((f || c) && (r.options = r.media = null), a = r), c && (et(u) ? L(u, function(d) {
    process.env.NODE_ENV !== "production" && d && !d.option && Dt(d.query) && Dt(d.query.option) && ce("Illegal media option. Must be like { media: [ { query: {}, option: {} } ] }"), d && d.option && (d.query ? n.push(d) : i || (i = d));
  }) : process.env.NODE_ENV !== "production" && ce("Illegal media option. Must be an array. Like { media: [ {...}, {...} ] }")), h(a), L(l, function(d) {
    return h(d);
  }), L(n, function(d) {
    return h(d.option);
  });
  function h(d) {
    L(t, function(p) {
      p(d, e);
    });
  }
  return {
    baseOption: a,
    timelineOptions: l || [],
    mediaDefault: i,
    mediaList: n
  };
}
function q9(r, t, e) {
  var n = {
    width: t,
    height: e,
    aspectratio: t / e
    // lower case for convenience.
  }, i = !0;
  return L(r, function(a, o) {
    var s = o.match(Y9);
    if (!(!s || !s[1] || !s[2])) {
      var l = s[1], u = s[2].toLowerCase();
      K9(n[u], a, l) || (i = !1);
    }
  }), i;
}
function K9(r, t, e) {
  return e === "min" ? r >= t : e === "max" ? r <= t : r === t;
}
function j9(r, t) {
  return r.join(",") === t.join(",");
}
var Un = L, uh = Dt, tE = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];
function e0(r) {
  var t = r && r.itemStyle;
  if (t)
    for (var e = 0, n = tE.length; e < n; e++) {
      var i = tE[e], a = t.normal, o = t.emphasis;
      a && a[i] && (process.env.NODE_ENV !== "production" && ar("itemStyle.normal." + i, i), r[i] = r[i] || {}, r[i].normal ? qt(r[i].normal, a[i]) : r[i].normal = a[i], a[i] = null), o && o[i] && (process.env.NODE_ENV !== "production" && ar("itemStyle.emphasis." + i, "emphasis." + i), r[i] = r[i] || {}, r[i].emphasis ? qt(r[i].emphasis, o[i]) : r[i].emphasis = o[i], o[i] = null);
    }
}
function Zr(r, t, e) {
  if (r && r[t] && (r[t].normal || r[t].emphasis)) {
    var n = r[t].normal, i = r[t].emphasis;
    n && (process.env.NODE_ENV !== "production" && ia("'normal' hierarchy in " + t + " has been removed since 4.0. All style properties are configured in " + t + " directly now."), e ? (r[t].normal = r[t].emphasis = null, kt(r[t], n)) : r[t] = n), i && (process.env.NODE_ENV !== "production" && ia(t + ".emphasis has been changed to emphasis." + t + " since 4.0"), r.emphasis = r.emphasis || {}, r.emphasis[t] = i, i.focus && (r.emphasis.focus = i.focus), i.blurScope && (r.emphasis.blurScope = i.blurScope));
  }
}
function If(r) {
  Zr(r, "itemStyle"), Zr(r, "lineStyle"), Zr(r, "areaStyle"), Zr(r, "label"), Zr(r, "labelLine"), Zr(r, "upperLabel"), Zr(r, "edgeLabel");
}
function ir(r, t) {
  var e = uh(r) && r[t], n = uh(e) && e.textStyle;
  if (n) {
    process.env.NODE_ENV !== "production" && ia("textStyle hierarchy in " + t + " has been removed since 4.0. All textStyle properties are configured in " + t + " directly now.");
    for (var i = 0, a = eA.length; i < a; i++) {
      var o = eA[i];
      n.hasOwnProperty(o) && (e[o] = n[o]);
    }
  }
}
function $n(r) {
  r && (If(r), ir(r, "label"), r.emphasis && ir(r.emphasis, "label"));
}
function J9(r) {
  if (uh(r)) {
    e0(r), If(r), ir(r, "label"), ir(r, "upperLabel"), ir(r, "edgeLabel"), r.emphasis && (ir(r.emphasis, "label"), ir(r.emphasis, "upperLabel"), ir(r.emphasis, "edgeLabel"));
    var t = r.markPoint;
    t && (e0(t), $n(t));
    var e = r.markLine;
    e && (e0(e), $n(e));
    var n = r.markArea;
    n && $n(n);
    var i = r.data;
    if (r.type === "graph") {
      i = i || r.nodes;
      var a = r.links || r.edges;
      if (a && !fn(a))
        for (var o = 0; o < a.length; o++)
          $n(a[o]);
      L(r.categories, function(u) {
        If(u);
      });
    }
    if (i && !fn(i))
      for (var o = 0; o < i.length; o++)
        $n(i[o]);
    if (t = r.markPoint, t && t.data)
      for (var s = t.data, o = 0; o < s.length; o++)
        $n(s[o]);
    if (e = r.markLine, e && e.data)
      for (var l = e.data, o = 0; o < l.length; o++)
        et(l[o]) ? ($n(l[o][0]), $n(l[o][1])) : $n(l[o]);
    r.type === "gauge" ? (ir(r, "axisLabel"), ir(r, "title"), ir(r, "detail")) : r.type === "treemap" ? (Zr(r.breadcrumb, "itemStyle"), L(r.levels, function(u) {
      If(u);
    })) : r.type === "tree" && If(r.leaves);
  }
}
function ya(r) {
  return et(r) ? r : r ? [r] : [];
}
function eE(r) {
  return (et(r) ? r[0] : r) || {};
}
function Q9(r, t) {
  Un(ya(r.series), function(n) {
    uh(n) && J9(n);
  });
  var e = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"];
  t && e.push("valueAxis", "categoryAxis", "logAxis", "timeAxis"), Un(e, function(n) {
    Un(ya(r[n]), function(i) {
      i && (ir(i, "axisLabel"), ir(i.axisPointer, "label"));
    });
  }), Un(ya(r.parallel), function(n) {
    var i = n && n.parallelAxisDefault;
    ir(i, "axisLabel"), ir(i && i.axisPointer, "label");
  }), Un(ya(r.calendar), function(n) {
    Zr(n, "itemStyle"), ir(n, "dayLabel"), ir(n, "monthLabel"), ir(n, "yearLabel");
  }), Un(ya(r.radar), function(n) {
    ir(n, "name"), n.name && n.axisName == null && (n.axisName = n.name, delete n.name, process.env.NODE_ENV !== "production" && ia("name property in radar component has been changed to axisName")), n.nameGap != null && n.axisNameGap == null && (n.axisNameGap = n.nameGap, delete n.nameGap, process.env.NODE_ENV !== "production" && ia("nameGap property in radar component has been changed to axisNameGap")), process.env.NODE_ENV !== "production" && Un(n.indicator, function(i) {
      i.text && ar("text", "name", "radar.indicator");
    });
  }), Un(ya(r.geo), function(n) {
    uh(n) && ($n(n), Un(ya(n.regions), function(i) {
      $n(i);
    }));
  }), Un(ya(r.timeline), function(n) {
    $n(n), Zr(n, "label"), Zr(n, "itemStyle"), Zr(n, "controlStyle", !0);
    var i = n.data;
    et(i) && L(i, function(a) {
      Dt(a) && (Zr(a, "label"), Zr(a, "itemStyle"));
    });
  }), Un(ya(r.toolbox), function(n) {
    Zr(n, "iconStyle"), Un(n.feature, function(i) {
      Zr(i, "iconStyle");
    });
  }), ir(eE(r.axisPointer), "label"), ir(eE(r.tooltip).axisPointer, "label");
}
function tX(r, t) {
  for (var e = t.split(","), n = r, i = 0; i < e.length && (n = n && n[e[i]], n != null); i++)
    ;
  return n;
}
function eX(r, t, e, n) {
  for (var i = t.split(","), a = r, o, s = 0; s < i.length - 1; s++)
    o = i[s], a[o] == null && (a[o] = {}), a = a[o];
  a[i[s]] == null && (a[i[s]] = e);
}
function rE(r) {
  r && L(rX, function(t) {
    t[0] in r && !(t[1] in r) && (r[t[1]] = r[t[0]]);
  });
}
var rX = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", "bottom"]], nX = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"], r0 = [["borderRadius", "barBorderRadius"], ["borderColor", "barBorderColor"], ["borderWidth", "barBorderWidth"]];
function Jc(r) {
  var t = r && r.itemStyle;
  if (t)
    for (var e = 0; e < r0.length; e++) {
      var n = r0[e][1], i = r0[e][0];
      t[n] != null && (t[i] = t[n], process.env.NODE_ENV !== "production" && ar(n, i));
    }
}
function nE(r) {
  r && r.alignTo === "edge" && r.margin != null && r.edgeDistance == null && (process.env.NODE_ENV !== "production" && ar("label.margin", "label.edgeDistance", "pie"), r.edgeDistance = r.margin);
}
function iE(r) {
  r && r.downplay && !r.blur && (r.blur = r.downplay, process.env.NODE_ENV !== "production" && ar("downplay", "blur", "sunburst"));
}
function iX(r) {
  r && r.focusNodeAdjacency != null && (r.emphasis = r.emphasis || {}, r.emphasis.focus == null && (process.env.NODE_ENV !== "production" && ar("focusNodeAdjacency", "emphasis: { focus: 'adjacency'}", "graph/sankey"), r.emphasis.focus = "adjacency"));
}
function rO(r, t) {
  if (r)
    for (var e = 0; e < r.length; e++)
      t(r[e]), r[e] && rO(r[e].children, t);
}
function nO(r, t) {
  Q9(r, t), r.series = Ie(r.series), L(r.series, function(e) {
    if (Dt(e)) {
      var n = e.type;
      if (n === "line")
        e.clipOverflow != null && (e.clip = e.clipOverflow, process.env.NODE_ENV !== "production" && ar("clipOverflow", "clip", "line"));
      else if (n === "pie" || n === "gauge") {
        e.clockWise != null && (e.clockwise = e.clockWise, process.env.NODE_ENV !== "production" && ar("clockWise", "clockwise")), nE(e.label);
        var i = e.data;
        if (i && !fn(i))
          for (var a = 0; a < i.length; a++)
            nE(i[a]);
        e.hoverOffset != null && (e.emphasis = e.emphasis || {}, (e.emphasis.scaleSize = null) && (process.env.NODE_ENV !== "production" && ar("hoverOffset", "emphasis.scaleSize"), e.emphasis.scaleSize = e.hoverOffset));
      } else if (n === "gauge") {
        var o = tX(e, "pointer.color");
        o != null && eX(e, "itemStyle.color", o);
      } else if (n === "bar") {
        Jc(e), Jc(e.backgroundStyle), Jc(e.emphasis);
        var i = e.data;
        if (i && !fn(i))
          for (var a = 0; a < i.length; a++)
            typeof i[a] == "object" && (Jc(i[a]), Jc(i[a] && i[a].emphasis));
      } else if (n === "sunburst") {
        var s = e.highlightPolicy;
        s && (e.emphasis = e.emphasis || {}, e.emphasis.focus || (e.emphasis.focus = s, process.env.NODE_ENV !== "production" && ar("highlightPolicy", "emphasis.focus", "sunburst"))), iE(e), rO(e.data, iE);
      } else
        n === "graph" || n === "sankey" ? iX(e) : n === "map" && (e.mapType && !e.map && (process.env.NODE_ENV !== "production" && ar("mapType", "map", "map"), e.map = e.mapType), e.mapLocation && (process.env.NODE_ENV !== "production" && ia("`mapLocation` is not used anymore."), kt(e, e.mapLocation)));
      e.hoverAnimation != null && (e.emphasis = e.emphasis || {}, e.emphasis && e.emphasis.scale == null && (process.env.NODE_ENV !== "production" && ar("hoverAnimation", "emphasis.scale"), e.emphasis.scale = e.hoverAnimation)), rE(e);
    }
  }), r.dataRange && (r.visualMap = r.dataRange), L(nX, function(e) {
    var n = r[e];
    n && (et(n) || (n = [n]), L(n, function(i) {
      rE(i);
    }));
  });
}
function aX(r) {
  var t = wt();
  r.eachSeries(function(e) {
    var n = e.get("stack");
    if (n) {
      var i = t.get(n) || t.set(n, []), a = e.getData(), o = {
        // Used for calculate axis extent automatically.
        // TODO: Type getCalculationInfo return more specific type?
        stackResultDimension: a.getCalculationInfo("stackResultDimension"),
        stackedOverDimension: a.getCalculationInfo("stackedOverDimension"),
        stackedDimension: a.getCalculationInfo("stackedDimension"),
        stackedByDimension: a.getCalculationInfo("stackedByDimension"),
        isStackedByIndex: a.getCalculationInfo("isStackedByIndex"),
        data: a,
        seriesModel: e
      };
      if (!o.stackedDimension || !(o.isStackedByIndex || o.stackedByDimension))
        return;
      i.push(o);
    }
  }), t.each(function(e) {
    if (e.length !== 0) {
      var n = e[0].seriesModel, i = n.get("stackOrder") || "seriesAsc";
      i === "seriesDesc" && e.reverse(), L(e, function(a, o) {
        a.data.setCalculationInfo("stackedOnSeries", o > 0 ? e[o - 1].seriesModel : null);
      }), oX(e);
    }
  });
}
function oX(r) {
  L(r, function(t, e) {
    var n = [], i = [NaN, NaN], a = [t.stackResultDimension, t.stackedOverDimension], o = t.data, s = t.isStackedByIndex, l = t.seriesModel.get("stackStrategy") || "samesign";
    o.modify(a, function(u, c, f) {
      var h = o.get(t.stackedDimension, f);
      if (isNaN(h))
        return i;
      var d, p;
      s ? p = o.getRawIndex(f) : d = o.get(t.stackedByDimension, f);
      for (var g = NaN, v = e - 1; v >= 0; v--) {
        var m = r[v];
        if (s || (p = m.data.rawIndexOf(m.stackedByDimension, d)), p >= 0) {
          var y = m.data.getByRawIndex(m.stackResultDimension, p);
          if (l === "all" || l === "positive" && y > 0 || l === "negative" && y < 0 || l === "samesign" && h >= 0 && y > 0 || l === "samesign" && h <= 0 && y < 0) {
            h = z8(h, y), g = y;
            break;
          }
        }
      }
      return n[0] = h, n[1] = g, n;
    });
  });
}
var cm = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(t) {
      this.data = t.data || (t.sourceFormat === Ti ? {} : []), this.sourceFormat = t.sourceFormat || qN, this.seriesLayoutBy = t.seriesLayoutBy || _i, this.startIndex = t.startIndex || 0, this.dimensionsDetectedCount = t.dimensionsDetectedCount, this.metaRawOption = t.metaRawOption;
      var e = this.dimensionsDefine = t.dimensionsDefine;
      if (e)
        for (var n = 0; n < e.length; n++) {
          var i = e[n];
          i.type == null && JN(this, n) === Fr.Must && (i.type = "ordinal");
        }
    }
    return r;
  }()
);
function ob(r) {
  return r instanceof cm;
}
function Xx(r, t, e) {
  e = e || iO(r);
  var n = t.seriesLayoutBy, i = lX(r, e, n, t.sourceHeader, t.dimensions), a = new cm({
    data: r,
    sourceFormat: e,
    seriesLayoutBy: n,
    dimensionsDefine: i.dimensionsDefine,
    startIndex: i.startIndex,
    dimensionsDetectedCount: i.dimensionsDetectedCount,
    metaRawOption: Ct(t)
  });
  return a;
}
function sb(r) {
  return new cm({
    data: r,
    sourceFormat: fn(r) ? Na : Bn
  });
}
function sX(r) {
  return new cm({
    data: r.data,
    sourceFormat: r.sourceFormat,
    seriesLayoutBy: r.seriesLayoutBy,
    dimensionsDefine: Ct(r.dimensionsDefine),
    startIndex: r.startIndex,
    dimensionsDetectedCount: r.dimensionsDetectedCount
  });
}
function iO(r) {
  var t = qN;
  if (fn(r))
    t = Na;
  else if (et(r)) {
    r.length === 0 && (t = Br);
    for (var e = 0, n = r.length; e < n; e++) {
      var i = r[e];
      if (i != null) {
        if (et(i) || fn(i)) {
          t = Br;
          break;
        } else if (Dt(i)) {
          t = Vn;
          break;
        }
      }
    }
  } else if (Dt(r)) {
    for (var a in r)
      if (_t(r, a) && qr(r[a])) {
        t = Ti;
        break;
      }
  }
  return t;
}
function lX(r, t, e, n, i) {
  var a, o;
  if (!r)
    return {
      dimensionsDefine: aE(i),
      startIndex: o,
      dimensionsDetectedCount: a
    };
  if (t === Br) {
    var s = r;
    n === "auto" || n == null ? oE(function(u) {
      u != null && u !== "-" && (pt(u) ? o == null && (o = 1) : o = 0);
    }, e, s, 10) : o = fe(n) ? n : n ? 1 : 0, !i && o === 1 && (i = [], oE(function(u, c) {
      i[c] = u != null ? u + "" : "";
    }, e, s, 1 / 0)), a = i ? i.length : e === Cl ? s.length : s[0] ? s[0].length : null;
  } else if (t === Vn)
    i || (i = uX(r));
  else if (t === Ti)
    i || (i = [], L(r, function(u, c) {
      i.push(c);
    }));
  else if (t === Bn) {
    var l = xc(r[0]);
    a = et(l) && l.length || 1;
  } else
    t === Na && process.env.NODE_ENV !== "production" && St(!!i, "dimensions must be given if data is TypedArray.");
  return {
    startIndex: o,
    dimensionsDefine: aE(i),
    dimensionsDetectedCount: a
  };
}
function uX(r) {
  for (var t = 0, e; t < r.length && !(e = r[t++]); )
    ;
  if (e)
    return se(e);
}
function aE(r) {
  if (r) {
    var t = wt();
    return rt(r, function(e, n) {
      e = Dt(e) ? e : {
        name: e
      };
      var i = {
        name: e.name,
        displayName: e.displayName,
        type: e.type
      };
      if (i.name == null)
        return i;
      i.name += "", i.displayName == null && (i.displayName = i.name);
      var a = t.get(i.name);
      return a ? i.name += "-" + a.count++ : t.set(i.name, {
        count: 1
      }), i;
    });
  }
}
function oE(r, t, e, n) {
  if (t === Cl)
    for (var i = 0; i < e.length && i < n; i++)
      r(e[i] ? e[i][0] : null, i);
  else
    for (var a = e[0] || [], i = 0; i < a.length && i < n; i++)
      r(a[i], i);
}
function aO(r) {
  var t = r.sourceFormat;
  return t === Vn || t === Ti;
}
var ws, Ms, Ts, As, sE, lE, oO = (
  /** @class */
  function() {
    function r(t, e) {
      var n = ob(t) ? t : sb(t);
      this._source = n;
      var i = this._data = n.data, a = n.sourceFormat, o = n.seriesLayoutBy;
      if (a === Na) {
        if (process.env.NODE_ENV !== "production" && e == null)
          throw new Error("Typed array data must specify dimension size");
        this._offset = 0, this._dimSize = e, this._data = i;
      }
      if (process.env.NODE_ENV !== "production") {
        var s = cX[Fv(a, o)];
        s && s(i, n.dimensionsDefine);
      }
      lE(this, i, n);
    }
    return r.prototype.getSource = function() {
      return this._source;
    }, r.prototype.count = function() {
      return 0;
    }, r.prototype.getItem = function(t, e) {
    }, r.prototype.appendData = function(t) {
    }, r.prototype.clean = function() {
    }, r.protoInitialize = function() {
      var t = r.prototype;
      t.pure = !1, t.persistent = !0;
    }(), r.internalField = function() {
      var t;
      lE = function(o, s, l) {
        var u = l.sourceFormat, c = l.seriesLayoutBy, f = l.startIndex, h = l.dimensionsDefine, d = sE[Fv(u, c)];
        if (process.env.NODE_ENV !== "production" && St(d, "Invalide sourceFormat: " + u), J(o, d), u === Na)
          o.getItem = e, o.count = i, o.fillStorage = n;
        else {
          var p = sO(u, c);
          o.getItem = mt(p, null, s, f, h);
          var g = lO(u, c);
          o.count = mt(g, null, s, f, h);
        }
      };
      var e = function(o, s) {
        o = o - this._offset, s = s || [];
        for (var l = this._data, u = this._dimSize, c = u * o, f = 0; f < u; f++)
          s[f] = l[c + f];
        return s;
      }, n = function(o, s, l, u) {
        for (var c = this._data, f = this._dimSize, h = 0; h < f; h++) {
          for (var d = u[h], p = d[0] == null ? 1 / 0 : d[0], g = d[1] == null ? -1 / 0 : d[1], v = s - o, m = l[h], y = 0; y < v; y++) {
            var _ = c[y * f + h];
            m[o + y] = _, _ < p && (p = _), _ > g && (g = _);
          }
          d[0] = p, d[1] = g;
        }
      }, i = function() {
        return this._data ? this._data.length / this._dimSize : 0;
      };
      sE = (t = {}, t[Br + "_" + _i] = {
        pure: !0,
        appendData: a
      }, t[Br + "_" + Cl] = {
        pure: !0,
        appendData: function() {
          throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
        }
      }, t[Vn] = {
        pure: !0,
        appendData: a
      }, t[Ti] = {
        pure: !0,
        appendData: function(o) {
          var s = this._data;
          L(o, function(l, u) {
            for (var c = s[u] || (s[u] = []), f = 0; f < (l || []).length; f++)
              c.push(l[f]);
          });
        }
      }, t[Bn] = {
        appendData: a
      }, t[Na] = {
        persistent: !1,
        pure: !0,
        appendData: function(o) {
          process.env.NODE_ENV !== "production" && St(fn(o), "Added data must be TypedArray if data in initialization is TypedArray"), this._data = o;
        },
        // Clean self if data is already used.
        clean: function() {
          this._offset += this.count(), this._data = null;
        }
      }, t);
      function a(o) {
        for (var s = 0; s < o.length; s++)
          this._data.push(o[s]);
      }
    }(), r;
  }()
), Yd = function(r) {
  et(r) || ce("series.data or dataset.source must be an array.");
}, cX = (ws = {}, ws[Br + "_" + _i] = Yd, ws[Br + "_" + Cl] = Yd, ws[Vn] = Yd, ws[Ti] = function(r, t) {
  for (var e = 0; e < t.length; e++) {
    var n = t[e].name;
    n == null && ce("dimension name must not be null/undefined.");
  }
}, ws[Bn] = Yd, ws), uE = function(r, t, e, n) {
  return r[n];
}, fX = (Ms = {}, Ms[Br + "_" + _i] = function(r, t, e, n) {
  return r[n + t];
}, Ms[Br + "_" + Cl] = function(r, t, e, n, i) {
  n += t;
  for (var a = i || [], o = r, s = 0; s < o.length; s++) {
    var l = o[s];
    a[s] = l ? l[n] : null;
  }
  return a;
}, Ms[Vn] = uE, Ms[Ti] = function(r, t, e, n, i) {
  for (var a = i || [], o = 0; o < e.length; o++) {
    var s = e[o].name, l = s != null ? r[s] : null;
    a[o] = l ? l[n] : null;
  }
  return a;
}, Ms[Bn] = uE, Ms);
function sO(r, t) {
  var e = fX[Fv(r, t)];
  return process.env.NODE_ENV !== "production" && St(e, 'Do not support get item on "' + r + '", "' + t + '".'), e;
}
var cE = function(r, t, e) {
  return r.length;
}, hX = (Ts = {}, Ts[Br + "_" + _i] = function(r, t, e) {
  return Math.max(0, r.length - t);
}, Ts[Br + "_" + Cl] = function(r, t, e) {
  var n = r[0];
  return n ? Math.max(0, n.length - t) : 0;
}, Ts[Vn] = cE, Ts[Ti] = function(r, t, e) {
  var n = e[0].name, i = n != null ? r[n] : null;
  return i ? i.length : 0;
}, Ts[Bn] = cE, Ts);
function lO(r, t) {
  var e = hX[Fv(r, t)];
  return process.env.NODE_ENV !== "production" && St(e, 'Do not support count on "' + r + '", "' + t + '".'), e;
}
var n0 = function(r, t, e) {
  return r[t];
}, dX = (As = {}, As[Br] = n0, As[Vn] = function(r, t, e) {
  return r[e];
}, As[Ti] = n0, As[Bn] = function(r, t, e) {
  var n = xc(r);
  return n instanceof Array ? n[t] : n;
}, As[Na] = n0, As);
function uO(r) {
  var t = dX[r];
  return process.env.NODE_ENV !== "production" && St(t, 'Do not support get value on "' + r + '".'), t;
}
function Fv(r, t) {
  return r === Br ? r + "_" + t : r;
}
function ic(r, t, e) {
  if (r) {
    var n = r.getRawDataItem(t);
    if (n != null) {
      var i = r.getStore(), a = i.getSource().sourceFormat;
      if (e != null) {
        var o = r.getDimensionIndex(e), s = i.getDimensionProperty(o);
        return uO(a)(n, o, s);
      } else {
        var l = n;
        return a === Bn && (l = xc(n)), l;
      }
    }
  }
}
var pX = /\{@(.+?)\}/g, fm = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getDataParams = function(t, e) {
      var n = this.getData(e), i = this.getRawValue(t, e), a = n.getRawIndex(t), o = n.getName(t), s = n.getRawDataItem(t), l = n.getItemVisual(t, "style"), u = l && l[n.getItemVisual(t, "drawType") || "fill"], c = l && l.stroke, f = this.mainType, h = f === "series", d = n.userOutput && n.userOutput.get();
      return {
        componentType: f,
        componentSubType: this.subType,
        componentIndex: this.componentIndex,
        seriesType: h ? this.subType : null,
        seriesIndex: this.seriesIndex,
        seriesId: h ? this.id : null,
        seriesName: h ? this.name : null,
        name: o,
        dataIndex: a,
        data: s,
        dataType: e,
        value: i,
        color: u,
        borderColor: c,
        dimensionNames: d ? d.fullDimensions : null,
        encode: d ? d.encode : null,
        // Param name list for mapping `a`, `b`, `c`, `d`, `e`
        $vars: ["seriesName", "name", "value"]
      };
    }, r.prototype.getFormattedLabel = function(t, e, n, i, a, o) {
      e = e || "normal";
      var s = this.getData(n), l = this.getDataParams(t, n);
      if (o && (l.value = o.interpolatedValue), i != null && et(l.value) && (l.value = l.value[i]), !a) {
        var u = s.getItemModel(t);
        a = u.get(e === "normal" ? ["label", "formatter"] : [e, "label", "formatter"]);
      }
      if (Tt(a))
        return l.status = e, l.dimensionIndex = i, a(l);
      if (pt(a)) {
        var c = FN(a, l);
        return c.replace(pX, function(f, h) {
          var d = h.length, p = h;
          p.charAt(0) === "[" && p.charAt(d - 1) === "]" && (p = +p.slice(1, d - 1), process.env.NODE_ENV !== "production" && isNaN(p) && ce("Invalide label formatter: @" + h + ", only support @[0], @[1], @[2], ..."));
          var g = ic(s, t, p);
          if (o && et(o.interpolatedValue)) {
            var v = s.getDimensionIndex(p);
            v >= 0 && (g = o.interpolatedValue[v]);
          }
          return g != null ? g + "" : "";
        });
      }
    }, r.prototype.getRawValue = function(t, e) {
      return ic(this.getData(e), t);
    }, r.prototype.formatTooltip = function(t, e, n) {
    }, r;
  }()
);
function fE(r) {
  var t, e;
  return Dt(r) ? r.type ? e = r : process.env.NODE_ENV !== "production" && console.warn("The return type of `formatTooltip` is not supported: " + hn(r)) : t = r, {
    text: t,
    // markers: markers || markersExisting,
    frag: e
  };
}
function Zf(r) {
  return new vX(r);
}
var vX = (
  /** @class */
  function() {
    function r(t) {
      t = t || {}, this._reset = t.reset, this._plan = t.plan, this._count = t.count, this._onDirty = t.onDirty, this._dirty = !0;
    }
    return r.prototype.perform = function(t) {
      var e = this._upstream, n = t && t.skip;
      if (this._dirty && e) {
        var i = this.context;
        i.data = i.outputData = e.context.outputData;
      }
      this.__pipeline && (this.__pipeline.currentTask = this);
      var a;
      this._plan && !n && (a = this._plan(this.context));
      var o = c(this._modBy), s = this._modDataCount || 0, l = c(t && t.modBy), u = t && t.modDataCount || 0;
      (o !== l || s !== u) && (a = "reset");
      function c(y) {
        return !(y >= 1) && (y = 1), y;
      }
      var f;
      (this._dirty || a === "reset") && (this._dirty = !1, f = this._doReset(n)), this._modBy = l, this._modDataCount = u;
      var h = t && t.step;
      if (e ? (process.env.NODE_ENV !== "production" && St(e._outputDueEnd != null), this._dueEnd = e._outputDueEnd) : (process.env.NODE_ENV !== "production" && St(!this._progress || this._count), this._dueEnd = this._count ? this._count(this.context) : 1 / 0), this._progress) {
        var d = this._dueIndex, p = Math.min(h != null ? this._dueIndex + h : 1 / 0, this._dueEnd);
        if (!n && (f || d < p)) {
          var g = this._progress;
          if (et(g))
            for (var v = 0; v < g.length; v++)
              this._doProgress(g[v], d, p, l, u);
          else
            this._doProgress(g, d, p, l, u);
        }
        this._dueIndex = p;
        var m = this._settedOutputEnd != null ? this._settedOutputEnd : p;
        process.env.NODE_ENV !== "production" && St(m >= this._outputDueEnd), this._outputDueEnd = m;
      } else
        this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
      return this.unfinished();
    }, r.prototype.dirty = function() {
      this._dirty = !0, this._onDirty && this._onDirty(this.context);
    }, r.prototype._doProgress = function(t, e, n, i, a) {
      hE.reset(e, n, i, a), this._callingProgress = t, this._callingProgress({
        start: e,
        end: n,
        count: n - e,
        next: hE.next
      }, this.context);
    }, r.prototype._doReset = function(t) {
      this._dueIndex = this._outputDueEnd = this._dueEnd = 0, this._settedOutputEnd = null;
      var e, n;
      !t && this._reset && (e = this._reset(this.context), e && e.progress && (n = e.forceFirstProgress, e = e.progress), et(e) && !e.length && (e = null)), this._progress = e, this._modBy = this._modDataCount = null;
      var i = this._downstream;
      return i && i.dirty(), n;
    }, r.prototype.unfinished = function() {
      return this._progress && this._dueIndex < this._dueEnd;
    }, r.prototype.pipe = function(t) {
      process.env.NODE_ENV !== "production" && St(t && !t._disposed && t !== this), (this._downstream !== t || this._dirty) && (this._downstream = t, t._upstream = this, t.dirty());
    }, r.prototype.dispose = function() {
      this._disposed || (this._upstream && (this._upstream._downstream = null), this._downstream && (this._downstream._upstream = null), this._dirty = !1, this._disposed = !0);
    }, r.prototype.getUpstream = function() {
      return this._upstream;
    }, r.prototype.getDownstream = function() {
      return this._downstream;
    }, r.prototype.setOutputEnd = function(t) {
      this._outputDueEnd = this._settedOutputEnd = t;
    }, r;
  }()
), hE = /* @__PURE__ */ function() {
  var r, t, e, n, i, a = {
    reset: function(l, u, c, f) {
      t = l, r = u, e = c, n = f, i = Math.ceil(n / e), a.next = e > 1 && n > 0 ? s : o;
    }
  };
  return a;
  function o() {
    return t < r ? t++ : null;
  }
  function s() {
    var l = t % i * e + Math.ceil(t / i), u = t >= r ? null : l < n ? l : t;
    return t++, u;
  }
}();
function ko(r, t) {
  var e = t && t.type;
  return e === "ordinal" ? r : (e === "time" && !fe(r) && r != null && r !== "-" && (r = +Tl(r)), r == null || r === "" ? NaN : Number(r));
}
var gX = wt({
  number: function(r) {
    return parseFloat(r);
  },
  time: function(r) {
    return +Tl(r);
  },
  trim: function(r) {
    return pt(r) ? ti(r) : r;
  }
});
function cO(r) {
  return gX.get(r);
}
var fO = {
  lt: function(r, t) {
    return r < t;
  },
  lte: function(r, t) {
    return r <= t;
  },
  gt: function(r, t) {
    return r > t;
  },
  gte: function(r, t) {
    return r >= t;
  }
}, mX = (
  /** @class */
  function() {
    function r(t, e) {
      if (!fe(e)) {
        var n = "";
        process.env.NODE_ENV !== "production" && (n = 'rvalue of "<", ">", "<=", ">=" can only be number in filter.'), we(n);
      }
      this._opFn = fO[t], this._rvalFloat = Ga(e);
    }
    return r.prototype.evaluate = function(t) {
      return fe(t) ? this._opFn(t, this._rvalFloat) : this._opFn(Ga(t), this._rvalFloat);
    }, r;
  }()
), hO = (
  /** @class */
  function() {
    function r(t, e) {
      var n = t === "desc";
      this._resultLT = n ? 1 : -1, e == null && (e = n ? "min" : "max"), this._incomparable = e === "min" ? -1 / 0 : 1 / 0;
    }
    return r.prototype.evaluate = function(t, e) {
      var n = fe(t) ? t : Ga(t), i = fe(e) ? e : Ga(e), a = isNaN(n), o = isNaN(i);
      if (a && (n = this._incomparable), o && (i = this._incomparable), a && o) {
        var s = pt(t), l = pt(e);
        s && (n = l ? t : 0), l && (i = s ? e : 0);
      }
      return n < i ? this._resultLT : n > i ? -this._resultLT : 0;
    }, r;
  }()
), yX = (
  /** @class */
  function() {
    function r(t, e) {
      this._rval = e, this._isEQ = t, this._rvalTypeof = typeof e, this._rvalFloat = Ga(e);
    }
    return r.prototype.evaluate = function(t) {
      var e = t === this._rval;
      if (!e) {
        var n = typeof t;
        n !== this._rvalTypeof && (n === "number" || this._rvalTypeof === "number") && (e = Ga(t) === this._rvalFloat);
      }
      return this._isEQ ? e : !e;
    }, r;
  }()
);
function _X(r, t) {
  return r === "eq" || r === "ne" ? new yX(r === "eq", t) : _t(fO, r) ? new mX(r, t) : null;
}
var xX = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getRawData = function() {
      throw new Error("not supported");
    }, r.prototype.getRawDataItem = function(t) {
      throw new Error("not supported");
    }, r.prototype.cloneRawData = function() {
    }, r.prototype.getDimensionInfo = function(t) {
    }, r.prototype.cloneAllDimensionInfo = function() {
    }, r.prototype.count = function() {
    }, r.prototype.retrieveValue = function(t, e) {
    }, r.prototype.retrieveValueFromItem = function(t, e) {
    }, r.prototype.convertValue = function(t, e) {
      return ko(t, e);
    }, r;
  }()
);
function SX(r, t) {
  var e = new xX(), n = r.data, i = e.sourceFormat = r.sourceFormat, a = r.startIndex, o = "";
  r.seriesLayoutBy !== _i && (process.env.NODE_ENV !== "production" && (o = '`seriesLayoutBy` of upstream dataset can only be "column" in data transform.'), we(o));
  var s = [], l = {}, u = r.dimensionsDefine;
  if (u)
    L(u, function(g, v) {
      var m = g.name, y = {
        index: v,
        name: m,
        displayName: g.displayName
      };
      if (s.push(y), m != null) {
        var _ = "";
        _t(l, m) && (process.env.NODE_ENV !== "production" && (_ = 'dimension name "' + m + '" duplicated.'), we(_)), l[m] = y;
      }
    });
  else
    for (var c = 0; c < r.dimensionsDetectedCount; c++)
      s.push({
        index: c
      });
  var f = sO(i, _i);
  t.__isBuiltIn && (e.getRawDataItem = function(g) {
    return f(n, a, s, g);
  }, e.getRawData = mt(bX, null, r)), e.cloneRawData = mt(wX, null, r);
  var h = lO(i, _i);
  e.count = mt(h, null, n, a, s);
  var d = uO(i);
  e.retrieveValue = function(g, v) {
    var m = f(n, a, s, g);
    return p(m, v);
  };
  var p = e.retrieveValueFromItem = function(g, v) {
    if (g != null) {
      var m = s[v];
      if (m)
        return d(g, v, m.name);
    }
  };
  return e.getDimensionInfo = mt(MX, null, s, l), e.cloneAllDimensionInfo = mt(TX, null, s), e;
}
function bX(r) {
  var t = r.sourceFormat;
  if (!lb(t)) {
    var e = "";
    process.env.NODE_ENV !== "production" && (e = "`getRawData` is not supported in source format " + t), we(e);
  }
  return r.data;
}
function wX(r) {
  var t = r.sourceFormat, e = r.data;
  if (!lb(t)) {
    var n = "";
    process.env.NODE_ENV !== "production" && (n = "`cloneRawData` is not supported in source format " + t), we(n);
  }
  if (t === Br) {
    for (var i = [], a = 0, o = e.length; a < o; a++)
      i.push(e[a].slice());
    return i;
  } else if (t === Vn) {
    for (var i = [], a = 0, o = e.length; a < o; a++)
      i.push(J({}, e[a]));
    return i;
  }
}
function MX(r, t, e) {
  if (e != null) {
    if (fe(e) || !isNaN(e) && !_t(t, e))
      return r[e];
    if (_t(t, e))
      return t[e];
  }
}
function TX(r) {
  return Ct(r);
}
var dO = wt();
function AX(r) {
  r = Ct(r);
  var t = r.type, e = "";
  t || (process.env.NODE_ENV !== "production" && (e = "Must have a `type` when `registerTransform`."), we(e));
  var n = t.split(":");
  n.length !== 2 && (process.env.NODE_ENV !== "production" && (e = 'Name must include namespace like "ns:regression".'), we(e));
  var i = !1;
  n[0] === "echarts" && (t = n[1], i = !0), r.__isBuiltIn = i, dO.set(t, r);
}
function EX(r, t, e) {
  var n = Ie(r), i = n.length, a = "";
  i || (process.env.NODE_ENV !== "production" && (a = "If `transform` declared, it should at least contain one transform."), we(a));
  for (var o = 0, s = i; o < s; o++) {
    var l = n[o];
    t = CX(l, t, e, i === 1 ? null : o), o !== s - 1 && (t.length = Math.max(t.length, 1));
  }
  return t;
}
function CX(r, t, e, n) {
  var i = "";
  t.length || (process.env.NODE_ENV !== "production" && (i = "Must have at least one upstream dataset."), we(i)), Dt(r) || (process.env.NODE_ENV !== "production" && (i = "transform declaration must be an object rather than " + typeof r + "."), we(i));
  var a = r.type, o = dO.get(a);
  o || (process.env.NODE_ENV !== "production" && (i = 'Can not find transform on type "' + a + '".'), we(i));
  var s = rt(t, function(c) {
    return SX(c, o);
  }), l = Ie(o.transform({
    upstream: s[0],
    upstreamList: s,
    config: Ct(r.config)
  }));
  if (process.env.NODE_ENV !== "production" && r.print) {
    var u = rt(l, function(c) {
      var f = n != null ? " === pipe index: " + n : "";
      return ["=== dataset index: " + e.datasetIndex + f + " ===", "- transform result data:", hn(c.data), "- transform result dimensions:", hn(c.dimensions)].join(`
`);
    }).join(`
`);
    IP(u);
  }
  return rt(l, function(c, f) {
    var h = "";
    Dt(c) || (process.env.NODE_ENV !== "production" && (h = "A transform should not return some empty results."), we(h)), c.data || (process.env.NODE_ENV !== "production" && (h = "Transform result data should be not be null or undefined"), we(h));
    var d = iO(c.data);
    lb(d) || (process.env.NODE_ENV !== "production" && (h = "Transform result data should be array rows or object rows."), we(h));
    var p, g = t[0];
    if (g && f === 0 && !c.dimensions) {
      var v = g.startIndex;
      v && (c.data = g.data.slice(0, v).concat(c.data)), p = {
        seriesLayoutBy: _i,
        sourceHeader: v,
        dimensions: g.metaRawOption.dimensions
      };
    } else
      p = {
        seriesLayoutBy: _i,
        sourceHeader: 0,
        dimensions: c.dimensions
      };
    return Xx(c.data, p, null);
  });
}
function lb(r) {
  return r === Br || r === Vn;
}
var hm = "undefined", DX = typeof Uint32Array === hm ? Array : Uint32Array, LX = typeof Uint16Array === hm ? Array : Uint16Array, pO = typeof Int32Array === hm ? Array : Int32Array, dE = typeof Float64Array === hm ? Array : Float64Array, vO = {
  float: dE,
  int: pO,
  // Ordinal data type can be string or int
  ordinal: Array,
  number: Array,
  time: dE
}, i0;
function ou(r) {
  return r > 65535 ? DX : LX;
}
function su() {
  return [1 / 0, -1 / 0];
}
function RX(r) {
  var t = r.constructor;
  return t === Array ? r.slice() : new t(r);
}
function pE(r, t, e, n, i) {
  var a = vO[e || "float"];
  if (i) {
    var o = r[t], s = o && o.length;
    if (s !== n) {
      for (var l = new a(n), u = 0; u < s; u++)
        l[u] = o[u];
      r[t] = l;
    }
  } else
    r[t] = new a(n);
}
var Yx = (
  /** @class */
  function() {
    function r() {
      this._chunks = [], this._rawExtent = [], this._extent = [], this._count = 0, this._rawCount = 0, this._calcDimNameToIdx = wt();
    }
    return r.prototype.initData = function(t, e, n) {
      process.env.NODE_ENV !== "production" && St(Tt(t.getItem) && Tt(t.count), "Invalid data provider."), this._provider = t, this._chunks = [], this._indices = null, this.getRawIndex = this._getRawIdxIdentity;
      var i = t.getSource(), a = this.defaultDimValueGetter = i0[i.sourceFormat];
      this._dimValueGetter = n || a, this._rawExtent = [];
      var o = aO(i);
      this._dimensions = rt(e, function(s) {
        return process.env.NODE_ENV !== "production" && o && St(s.property != null), {
          // Only pick these two props. Not leak other properties like orderMeta.
          type: s.type,
          property: s.property
        };
      }), this._initDataFromProvider(0, t.count());
    }, r.prototype.getProvider = function() {
      return this._provider;
    }, r.prototype.getSource = function() {
      return this._provider.getSource();
    }, r.prototype.ensureCalculationDimension = function(t, e) {
      var n = this._calcDimNameToIdx, i = this._dimensions, a = n.get(t);
      if (a != null) {
        if (i[a].type === e)
          return a;
      } else
        a = i.length;
      return i[a] = {
        type: e
      }, n.set(t, a), this._chunks[a] = new vO[e || "float"](this._rawCount), this._rawExtent[a] = su(), a;
    }, r.prototype.collectOrdinalMeta = function(t, e) {
      var n = this._chunks[t], i = this._dimensions[t], a = this._rawExtent, o = i.ordinalOffset || 0, s = n.length;
      o === 0 && (a[t] = su());
      for (var l = a[t], u = o; u < s; u++) {
        var c = n[u] = e.parseAndCollect(n[u]);
        isNaN(c) || (l[0] = Math.min(c, l[0]), l[1] = Math.max(c, l[1]));
      }
      i.ordinalMeta = e, i.ordinalOffset = s, i.type = "ordinal";
    }, r.prototype.getOrdinalMeta = function(t) {
      var e = this._dimensions[t], n = e.ordinalMeta;
      return n;
    }, r.prototype.getDimensionProperty = function(t) {
      var e = this._dimensions[t];
      return e && e.property;
    }, r.prototype.appendData = function(t) {
      process.env.NODE_ENV !== "production" && St(!this._indices, "appendData can only be called on raw data.");
      var e = this._provider, n = this.count();
      e.appendData(t);
      var i = e.count();
      return e.persistent || (i += n), n < i && this._initDataFromProvider(n, i, !0), [n, i];
    }, r.prototype.appendValues = function(t, e) {
      for (var n = this._chunks, i = this._dimensions, a = i.length, o = this._rawExtent, s = this.count(), l = s + Math.max(t.length, e || 0), u = 0; u < a; u++) {
        var c = i[u];
        pE(n, u, c.type, l, !0);
      }
      for (var f = [], h = s; h < l; h++)
        for (var d = h - s, p = 0; p < a; p++) {
          var c = i[p], g = i0.arrayRows.call(this, t[d] || f, c.property, d, p);
          n[p][h] = g;
          var v = o[p];
          g < v[0] && (v[0] = g), g > v[1] && (v[1] = g);
        }
      return this._rawCount = this._count = l, {
        start: s,
        end: l
      };
    }, r.prototype._initDataFromProvider = function(t, e, n) {
      for (var i = this._provider, a = this._chunks, o = this._dimensions, s = o.length, l = this._rawExtent, u = rt(o, function(y) {
        return y.property;
      }), c = 0; c < s; c++) {
        var f = o[c];
        l[c] || (l[c] = su()), pE(a, c, f.type, e, n);
      }
      if (i.fillStorage)
        i.fillStorage(t, e, a, l);
      else
        for (var h = [], d = t; d < e; d++) {
          h = i.getItem(d, h);
          for (var p = 0; p < s; p++) {
            var g = a[p], v = this._dimValueGetter(h, u[p], d, p);
            g[d] = v;
            var m = l[p];
            v < m[0] && (m[0] = v), v > m[1] && (m[1] = v);
          }
        }
      !i.persistent && i.clean && i.clean(), this._rawCount = this._count = e, this._extent = [];
    }, r.prototype.count = function() {
      return this._count;
    }, r.prototype.get = function(t, e) {
      if (!(e >= 0 && e < this._count))
        return NaN;
      var n = this._chunks[t];
      return n ? n[this.getRawIndex(e)] : NaN;
    }, r.prototype.getValues = function(t, e) {
      var n = [], i = [];
      if (e == null) {
        e = t, t = [];
        for (var a = 0; a < this._dimensions.length; a++)
          i.push(a);
      } else
        i = t;
      for (var a = 0, o = i.length; a < o; a++)
        n.push(this.get(i[a], e));
      return n;
    }, r.prototype.getByRawIndex = function(t, e) {
      if (!(e >= 0 && e < this._rawCount))
        return NaN;
      var n = this._chunks[t];
      return n ? n[e] : NaN;
    }, r.prototype.getSum = function(t) {
      var e = this._chunks[t], n = 0;
      if (e)
        for (var i = 0, a = this.count(); i < a; i++) {
          var o = this.get(t, i);
          isNaN(o) || (n += o);
        }
      return n;
    }, r.prototype.getMedian = function(t) {
      var e = [];
      this.each([t], function(a) {
        isNaN(a) || e.push(a);
      });
      var n = e.sort(function(a, o) {
        return a - o;
      }), i = this.count();
      return i === 0 ? 0 : i % 2 === 1 ? n[(i - 1) / 2] : (n[i / 2] + n[i / 2 - 1]) / 2;
    }, r.prototype.indexOfRawIndex = function(t) {
      if (t >= this._rawCount || t < 0)
        return -1;
      if (!this._indices)
        return t;
      var e = this._indices, n = e[t];
      if (n != null && n < this._count && n === t)
        return t;
      for (var i = 0, a = this._count - 1; i <= a; ) {
        var o = (i + a) / 2 | 0;
        if (e[o] < t)
          i = o + 1;
        else if (e[o] > t)
          a = o - 1;
        else
          return o;
      }
      return -1;
    }, r.prototype.getIndices = function() {
      var t, e = this._indices;
      if (e) {
        var n = e.constructor, i = this._count;
        if (n === Array) {
          t = new n(i);
          for (var a = 0; a < i; a++)
            t[a] = e[a];
        } else
          t = new n(e.buffer, 0, i);
      } else {
        var n = ou(this._rawCount);
        t = new n(this.count());
        for (var a = 0; a < t.length; a++)
          t[a] = a;
      }
      return t;
    }, r.prototype.filter = function(t, e) {
      if (!this._count)
        return this;
      for (var n = this.clone(), i = n.count(), a = ou(n._rawCount), o = new a(i), s = [], l = t.length, u = 0, c = t[0], f = n._chunks, h = 0; h < i; h++) {
        var d = void 0, p = n.getRawIndex(h);
        if (l === 0)
          d = e(h);
        else if (l === 1) {
          var g = f[c][p];
          d = e(g, h);
        } else {
          for (var v = 0; v < l; v++)
            s[v] = f[t[v]][p];
          s[v] = h, d = e.apply(null, s);
        }
        d && (o[u++] = p);
      }
      return u < i && (n._indices = o), n._count = u, n._extent = [], n._updateGetRawIdx(), n;
    }, r.prototype.selectRange = function(t) {
      var e = this.clone(), n = e._count;
      if (!n)
        return this;
      var i = se(t), a = i.length;
      if (!a)
        return this;
      var o = e.count(), s = ou(e._rawCount), l = new s(o), u = 0, c = i[0], f = t[c][0], h = t[c][1], d = e._chunks, p = !1;
      if (!e._indices) {
        var g = 0;
        if (a === 1) {
          for (var v = d[i[0]], m = 0; m < n; m++) {
            var y = v[m];
            (y >= f && y <= h || isNaN(y)) && (l[u++] = g), g++;
          }
          p = !0;
        } else if (a === 2) {
          for (var v = d[i[0]], _ = d[i[1]], x = t[i[1]][0], b = t[i[1]][1], m = 0; m < n; m++) {
            var y = v[m], S = _[m];
            (y >= f && y <= h || isNaN(y)) && (S >= x && S <= b || isNaN(S)) && (l[u++] = g), g++;
          }
          p = !0;
        }
      }
      if (!p)
        if (a === 1)
          for (var m = 0; m < o; m++) {
            var w = e.getRawIndex(m), y = d[i[0]][w];
            (y >= f && y <= h || isNaN(y)) && (l[u++] = w);
          }
        else
          for (var m = 0; m < o; m++) {
            for (var A = !0, w = e.getRawIndex(m), T = 0; T < a; T++) {
              var M = i[T], y = d[M][w];
              (y < t[M][0] || y > t[M][1]) && (A = !1);
            }
            A && (l[u++] = e.getRawIndex(m));
          }
      return u < o && (e._indices = l), e._count = u, e._extent = [], e._updateGetRawIdx(), e;
    }, r.prototype.map = function(t, e) {
      var n = this.clone(t);
      return this._updateDims(n, t, e), n;
    }, r.prototype.modify = function(t, e) {
      this._updateDims(this, t, e);
    }, r.prototype._updateDims = function(t, e, n) {
      for (var i = t._chunks, a = [], o = e.length, s = t.count(), l = [], u = t._rawExtent, c = 0; c < e.length; c++)
        u[e[c]] = su();
      for (var f = 0; f < s; f++) {
        for (var h = t.getRawIndex(f), d = 0; d < o; d++)
          l[d] = i[e[d]][h];
        l[o] = f;
        var p = n && n.apply(null, l);
        if (p != null) {
          typeof p != "object" && (a[0] = p, p = a);
          for (var c = 0; c < p.length; c++) {
            var g = e[c], v = p[c], m = u[g], y = i[g];
            y && (y[h] = v), v < m[0] && (m[0] = v), v > m[1] && (m[1] = v);
          }
        }
      }
    }, r.prototype.lttbDownSample = function(t, e) {
      var n = this.clone([t], !0), i = n._chunks, a = i[t], o = this.count(), s = 0, l = Math.floor(1 / e), u = this.getRawIndex(0), c, f, h, d = new (ou(this._rawCount))(Math.min((Math.ceil(o / l) + 2) * 2, o));
      d[s++] = u;
      for (var p = 1; p < o - 1; p += l) {
        for (var g = Math.min(p + l, o - 1), v = Math.min(p + l * 2, o), m = (v + g) / 2, y = 0, _ = g; _ < v; _++) {
          var x = this.getRawIndex(_), b = a[x];
          isNaN(b) || (y += b);
        }
        y /= v - g;
        var S = p, w = Math.min(p + l, o), A = p - 1, T = a[u];
        c = -1, h = S;
        for (var M = -1, E = 0, _ = S; _ < w; _++) {
          var x = this.getRawIndex(_), b = a[x];
          if (isNaN(b)) {
            E++, M < 0 && (M = x);
            continue;
          }
          f = Math.abs((A - m) * (b - T) - (A - _) * (y - T)), f > c && (c = f, h = x);
        }
        E > 0 && E < w - S && (d[s++] = Math.min(M, h), h = Math.max(M, h)), d[s++] = h, u = h;
      }
      return d[s++] = this.getRawIndex(o - 1), n._count = s, n._indices = d, n.getRawIndex = this._getRawIdx, n;
    }, r.prototype.minmaxDownSample = function(t, e) {
      for (var n = this.clone([t], !0), i = n._chunks, a = Math.floor(1 / e), o = i[t], s = this.count(), l = new (ou(this._rawCount))(Math.ceil(s / a) * 2), u = 0, c = 0; c < s; c += a) {
        var f = c, h = o[this.getRawIndex(f)], d = c, p = o[this.getRawIndex(d)], g = a;
        c + a > s && (g = s - c);
        for (var v = 0; v < g; v++) {
          var m = this.getRawIndex(c + v), y = o[m];
          y < h && (h = y, f = c + v), y > p && (p = y, d = c + v);
        }
        var _ = this.getRawIndex(f), x = this.getRawIndex(d);
        f < d ? (l[u++] = _, l[u++] = x) : (l[u++] = x, l[u++] = _);
      }
      return n._count = u, n._indices = l, n._updateGetRawIdx(), n;
    }, r.prototype.downSample = function(t, e, n, i) {
      for (var a = this.clone([t], !0), o = a._chunks, s = [], l = Math.floor(1 / e), u = o[t], c = this.count(), f = a._rawExtent[t] = su(), h = new (ou(this._rawCount))(Math.ceil(c / l)), d = 0, p = 0; p < c; p += l) {
        l > c - p && (l = c - p, s.length = l);
        for (var g = 0; g < l; g++) {
          var v = this.getRawIndex(p + g);
          s[g] = u[v];
        }
        var m = n(s), y = this.getRawIndex(Math.min(p + i(s, m) || 0, c - 1));
        u[y] = m, m < f[0] && (f[0] = m), m > f[1] && (f[1] = m), h[d++] = y;
      }
      return a._count = d, a._indices = h, a._updateGetRawIdx(), a;
    }, r.prototype.each = function(t, e) {
      if (this._count)
        for (var n = t.length, i = this._chunks, a = 0, o = this.count(); a < o; a++) {
          var s = this.getRawIndex(a);
          switch (n) {
            case 0:
              e(a);
              break;
            case 1:
              e(i[t[0]][s], a);
              break;
            case 2:
              e(i[t[0]][s], i[t[1]][s], a);
              break;
            default:
              for (var l = 0, u = []; l < n; l++)
                u[l] = i[t[l]][s];
              u[l] = a, e.apply(null, u);
          }
        }
    }, r.prototype.getDataExtent = function(t) {
      var e = this._chunks[t], n = su();
      if (!e)
        return n;
      var i = this.count(), a = !this._indices, o;
      if (a)
        return this._rawExtent[t].slice();
      if (o = this._extent[t], o)
        return o.slice();
      o = n;
      for (var s = o[0], l = o[1], u = 0; u < i; u++) {
        var c = this.getRawIndex(u), f = e[c];
        f < s && (s = f), f > l && (l = f);
      }
      return o = [s, l], this._extent[t] = o, o;
    }, r.prototype.getRawDataItem = function(t) {
      var e = this.getRawIndex(t);
      if (this._provider.persistent)
        return this._provider.getItem(e);
      for (var n = [], i = this._chunks, a = 0; a < i.length; a++)
        n.push(i[a][e]);
      return n;
    }, r.prototype.clone = function(t, e) {
      var n = new r(), i = this._chunks, a = t && ea(t, function(s, l) {
        return s[l] = !0, s;
      }, {});
      if (a)
        for (var o = 0; o < i.length; o++)
          n._chunks[o] = a[o] ? RX(i[o]) : i[o];
      else
        n._chunks = i;
      return this._copyCommonProps(n), e || (n._indices = this._cloneIndices()), n._updateGetRawIdx(), n;
    }, r.prototype._copyCommonProps = function(t) {
      t._count = this._count, t._rawCount = this._rawCount, t._provider = this._provider, t._dimensions = this._dimensions, t._extent = Ct(this._extent), t._rawExtent = Ct(this._rawExtent);
    }, r.prototype._cloneIndices = function() {
      if (this._indices) {
        var t = this._indices.constructor, e = void 0;
        if (t === Array) {
          var n = this._indices.length;
          e = new t(n);
          for (var i = 0; i < n; i++)
            e[i] = this._indices[i];
        } else
          e = new t(this._indices);
        return e;
      }
      return null;
    }, r.prototype._getRawIdxIdentity = function(t) {
      return t;
    }, r.prototype._getRawIdx = function(t) {
      return t < this._count && t >= 0 ? this._indices[t] : -1;
    }, r.prototype._updateGetRawIdx = function() {
      this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;
    }, r.internalField = function() {
      function t(e, n, i, a) {
        return ko(e[a], this._dimensions[a]);
      }
      i0 = {
        arrayRows: t,
        objectRows: function(e, n, i, a) {
          return ko(e[n], this._dimensions[a]);
        },
        keyedColumns: t,
        original: function(e, n, i, a) {
          var o = e && (e.value == null ? e : e.value);
          return ko(o instanceof Array ? o[a] : o, this._dimensions[a]);
        },
        typedArray: function(e, n, i, a) {
          return e[a];
        }
      };
    }(), r;
  }()
), gO = (
  /** @class */
  function() {
    function r(t) {
      this._sourceList = [], this._storeList = [], this._upstreamSignList = [], this._versionSignBase = 0, this._dirty = !0, this._sourceHost = t;
    }
    return r.prototype.dirty = function() {
      this._setLocalSource([], []), this._storeList = [], this._dirty = !0;
    }, r.prototype._setLocalSource = function(t, e) {
      this._sourceList = t, this._upstreamSignList = e, this._versionSignBase++, this._versionSignBase > 9e10 && (this._versionSignBase = 0);
    }, r.prototype._getVersionSign = function() {
      return this._sourceHost.uid + "_" + this._versionSignBase;
    }, r.prototype.prepareSource = function() {
      this._isDirty() && (this._createSource(), this._dirty = !1);
    }, r.prototype._createSource = function() {
      this._setLocalSource([], []);
      var t = this._sourceHost, e = this._getUpstreamSourceManagers(), n = !!e.length, i, a;
      if (Qc(t)) {
        var o = t, s = void 0, l = void 0, u = void 0;
        if (n) {
          var c = e[0];
          c.prepareSource(), u = c.getSource(), s = u.data, l = u.sourceFormat, a = [c._getVersionSign()];
        } else
          s = o.get("data", !0), l = fn(s) ? Na : Bn, a = [];
        var f = this._getSourceMetaRawOption() || {}, h = u && u.metaRawOption || {}, d = bt(f.seriesLayoutBy, h.seriesLayoutBy) || null, p = bt(f.sourceHeader, h.sourceHeader), g = bt(f.dimensions, h.dimensions), v = d !== h.seriesLayoutBy || !!p != !!h.sourceHeader || g;
        i = v ? [Xx(s, {
          seriesLayoutBy: d,
          sourceHeader: p,
          dimensions: g
        }, l)] : [];
      } else {
        var m = t;
        if (n) {
          var y = this._applyTransform(e);
          i = y.sourceList, a = y.upstreamSignList;
        } else {
          var _ = m.get("source", !0);
          i = [Xx(_, this._getSourceMetaRawOption(), null)], a = [];
        }
      }
      process.env.NODE_ENV !== "production" && St(i && a), this._setLocalSource(i, a);
    }, r.prototype._applyTransform = function(t) {
      var e = this._sourceHost, n = e.get("transform", !0), i = e.get("fromTransformResult", !0);
      if (process.env.NODE_ENV !== "production" && St(i != null || n != null), i != null) {
        var a = "";
        t.length !== 1 && (process.env.NODE_ENV !== "production" && (a = "When using `fromTransformResult`, there should be only one upstream dataset"), gE(a));
      }
      var o, s = [], l = [];
      return L(t, function(u) {
        u.prepareSource();
        var c = u.getSource(i || 0), f = "";
        i != null && !c && (process.env.NODE_ENV !== "production" && (f = "Can not retrieve result by `fromTransformResult`: " + i), gE(f)), s.push(c), l.push(u._getVersionSign());
      }), n ? o = EX(n, s, {
        datasetIndex: e.componentIndex
      }) : i != null && (o = [sX(s[0])]), {
        sourceList: o,
        upstreamSignList: l
      };
    }, r.prototype._isDirty = function() {
      if (this._dirty)
        return !0;
      for (var t = this._getUpstreamSourceManagers(), e = 0; e < t.length; e++) {
        var n = t[e];
        if (
          // Consider the case that there is ancestor diry, call it recursively.
          // The performance is probably not an issue because usually the chain is not long.
          n._isDirty() || this._upstreamSignList[e] !== n._getVersionSign()
        )
          return !0;
      }
    }, r.prototype.getSource = function(t) {
      t = t || 0;
      var e = this._sourceList[t];
      if (!e) {
        var n = this._getUpstreamSourceManagers();
        return n[0] && n[0].getSource(t);
      }
      return e;
    }, r.prototype.getSharedDataStore = function(t) {
      process.env.NODE_ENV !== "production" && St(Qc(this._sourceHost), "Can only call getDataStore on series source manager.");
      var e = t.makeStoreSchema();
      return this._innerGetDataStore(e.dimensions, t.source, e.hash);
    }, r.prototype._innerGetDataStore = function(t, e, n) {
      var i = 0, a = this._storeList, o = a[i];
      o || (o = a[i] = {});
      var s = o[n];
      if (!s) {
        var l = this._getUpstreamSourceManagers()[0];
        Qc(this._sourceHost) && l ? s = l._innerGetDataStore(t, e, n) : (s = new Yx(), s.initData(new oO(e, t.length), t)), o[n] = s;
      }
      return s;
    }, r.prototype._getUpstreamSourceManagers = function() {
      var t = this._sourceHost;
      if (Qc(t)) {
        var e = nb(t);
        return e ? [e.getSourceManager()] : [];
      } else
        return rt(N9(t), function(n) {
          return n.getSourceManager();
        });
    }, r.prototype._getSourceMetaRawOption = function() {
      var t = this._sourceHost, e, n, i;
      if (Qc(t))
        e = t.get("seriesLayoutBy", !0), n = t.get("sourceHeader", !0), i = t.get("dimensions", !0);
      else if (!this._getUpstreamSourceManagers().length) {
        var a = t;
        e = a.get("seriesLayoutBy", !0), n = a.get("sourceHeader", !0), i = a.get("dimensions", !0);
      }
      return {
        seriesLayoutBy: e,
        sourceHeader: n,
        dimensions: i
      };
    }, r;
  }()
);
function vE(r) {
  var t = r.option.transform;
  t && yv(r.option.transform);
}
function Qc(r) {
  return r.mainType === "series";
}
function gE(r) {
  throw new Error(r);
}
var IX = "line-height:1";
function mO(r) {
  var t = r.lineHeight;
  return t == null ? IX : "line-height:" + on(t + "") + "px";
}
function yO(r, t) {
  var e = r.color || Y.color.tertiary, n = r.fontSize || 12, i = r.fontWeight || "400", a = r.color || Y.color.secondary, o = r.fontSize || 14, s = r.fontWeight || "900";
  return t === "html" ? {
    // eslint-disable-next-line max-len
    nameStyle: "font-size:" + on(n + "") + "px;color:" + on(e) + ";font-weight:" + on(i + ""),
    // eslint-disable-next-line max-len
    valueStyle: "font-size:" + on(o + "") + "px;color:" + on(a) + ";font-weight:" + on(s + "")
  } : {
    nameStyle: {
      fontSize: n,
      fill: e,
      fontWeight: i
    },
    valueStyle: {
      fontSize: o,
      fill: a,
      fontWeight: s
    }
  };
}
var PX = [0, 10, 20, 30], NX = ["", `
`, `

`, `


`];
function cr(r, t) {
  return t.type = r, t;
}
function $x(r) {
  return r.type === "section";
}
function _O(r) {
  return $x(r) ? OX : kX;
}
function xO(r) {
  if ($x(r)) {
    var t = 0, e = r.blocks.length, n = e > 1 || e > 0 && !r.noHeader;
    return L(r.blocks, function(i) {
      var a = xO(i);
      a >= t && (t = a + +(n && // 0 always can not be readable gap level.
      (!a || $x(i) && !i.noHeader)));
    }), t;
  }
  return 0;
}
function OX(r, t, e, n) {
  var i = t.noHeader, a = BX(xO(t)), o = [], s = t.blocks || [];
  St(!s || et(s)), s = s || [];
  var l = r.orderMode;
  if (t.sortBlocks && l) {
    s = s.slice();
    var u = {
      valueAsc: "asc",
      valueDesc: "desc"
    };
    if (_t(u, l)) {
      var c = new hO(u[l], null);
      s.sort(function(g, v) {
        return c.evaluate(g.sortParam, v.sortParam);
      });
    } else
      l === "seriesDesc" && s.reverse();
  }
  L(s, function(g, v) {
    var m = t.valueFormatter, y = _O(g)(
      // Inherit valueFormatter
      m ? J(J({}, r), {
        valueFormatter: m
      }) : r,
      g,
      v > 0 ? a.html : 0,
      n
    );
    y != null && o.push(y);
  });
  var f = r.renderMode === "richText" ? o.join(a.richText) : Zx(n, o.join(""), i ? e : a.html);
  if (i)
    return f;
  var h = Fx(t.header, "ordinal", r.useUTC), d = yO(n, r.renderMode).nameStyle, p = mO(n);
  return r.renderMode === "richText" ? SO(r, h, d) + a.richText + f : Zx(n, '<div style="' + d + ";" + p + ';">' + on(h) + "</div>" + f, e);
}
function kX(r, t, e, n) {
  var i = r.renderMode, a = t.noName, o = t.noValue, s = !t.markerType, l = t.name, u = r.useUTC, c = t.valueFormatter || r.valueFormatter || function(x) {
    return x = et(x) ? x : [x], rt(x, function(b, S) {
      return Fx(b, et(d) ? d[S] : d, u);
    });
  };
  if (!(a && o)) {
    var f = s ? "" : r.markupStyleCreator.makeTooltipMarker(t.markerType, t.markerColor || Y.color.secondary, i), h = a ? "" : Fx(l, "ordinal", u), d = t.valueType, p = o ? [] : c(t.value, t.dataIndex), g = !s || !a, v = !s && a, m = yO(n, i), y = m.nameStyle, _ = m.valueStyle;
    return i === "richText" ? (s ? "" : f) + (a ? "" : SO(r, h, y)) + (o ? "" : zX(r, p, g, v, _)) : Zx(n, (s ? "" : f) + (a ? "" : VX(h, !s, y)) + (o ? "" : FX(p, g, v, _)), e);
  }
}
function mE(r, t, e, n, i, a) {
  if (r) {
    var o = _O(r), s = {
      useUTC: i,
      renderMode: e,
      orderMode: n,
      markupStyleCreator: t,
      valueFormatter: r.valueFormatter
    };
    return o(s, r, 0, a);
  }
}
function BX(r) {
  return {
    html: PX[r],
    richText: NX[r]
  };
}
function Zx(r, t, e) {
  var n = '<div style="clear:both"></div>', i = "margin: " + e + "px 0 0", a = mO(r);
  return '<div style="' + i + ";" + a + ';">' + t + n + "</div>";
}
function VX(r, t, e) {
  var n = t ? "margin-left:2px" : "";
  return '<span style="' + e + ";" + n + '">' + on(r) + "</span>";
}
function FX(r, t, e, n) {
  var i = e ? "10px" : "20px", a = t ? "float:right;margin-left:" + i : "";
  return r = et(r) ? r : [r], '<span style="' + a + ";" + n + '">' + rt(r, function(o) {
    return on(o);
  }).join("&nbsp;&nbsp;") + "</span>";
}
function SO(r, t, e) {
  return r.markupStyleCreator.wrapRichTextStyle(t, e);
}
function zX(r, t, e, n, i) {
  var a = [i], o = n ? 10 : 20;
  return e && a.push({
    padding: [0, 0, 0, o],
    align: "right"
  }), r.markupStyleCreator.wrapRichTextStyle(et(t) ? t.join("  ") : t, a);
}
function bO(r, t) {
  var e = r.getData().getItemVisual(t, "style"), n = e[r.visualDrawType];
  return yl(n);
}
function wO(r, t) {
  var e = r.get("padding");
  return e ?? (t === "richText" ? [8, 10] : 10);
}
var a0 = (
  /** @class */
  function() {
    function r() {
      this.richTextStyles = {}, this._nextStyleNameId = LP();
    }
    return r.prototype._generateStyleName = function() {
      return "__EC_aUTo_" + this._nextStyleNameId++;
    }, r.prototype.makeTooltipMarker = function(t, e, n) {
      var i = n === "richText" ? this._generateStyleName() : null, a = w9({
        color: e,
        type: t,
        renderMode: n,
        markerId: i
      });
      return pt(a) ? a : (process.env.NODE_ENV !== "production" && St(i), this.richTextStyles[i] = a.style, a.content);
    }, r.prototype.wrapRichTextStyle = function(t, e) {
      var n = {};
      et(e) ? L(e, function(a) {
        return J(n, a);
      }) : J(n, e);
      var i = this._generateStyleName();
      return this.richTextStyles[i] = n, "{" + i + "|" + t + "}";
    }, r;
  }()
);
function MO(r) {
  var t = r.series, e = r.dataIndex, n = r.multipleSeries, i = t.getData(), a = i.mapDimensionsAll("defaultedTooltip"), o = a.length, s = t.getRawValue(e), l = et(s), u = bO(t, e), c, f, h, d;
  if (o > 1 || l && !o) {
    var p = UX(s, t, e, a, u);
    c = p.inlineValues, f = p.inlineValueTypes, h = p.blocks, d = p.inlineValues[0];
  } else if (o) {
    var g = i.getDimensionInfo(a[0]);
    d = c = ic(i, e, a[0]), f = g.type;
  } else
    d = c = l ? s[0] : s;
  var v = D1(t), m = v && t.name || "", y = i.getName(e), _ = n ? m : y;
  return cr("section", {
    header: m,
    // When series name is not specified, do not show a header line with only '-'.
    // This case always happens in tooltip.trigger: 'item'.
    noHeader: n || !v,
    sortParam: d,
    blocks: [cr("nameValue", {
      markerType: "item",
      markerColor: u,
      // Do not mix display seriesName and itemName in one tooltip,
      // which might confuses users.
      name: _,
      // name dimension might be auto assigned, where the name might
      // be not readable. So we check trim here.
      noName: !ti(_),
      value: c,
      valueType: f,
      dataIndex: e
    })].concat(h || [])
  });
}
function UX(r, t, e, n, i) {
  var a = t.getData(), o = ea(r, function(f, h, d) {
    var p = a.getDimensionInfo(d);
    return f = f || p && p.tooltip !== !1 && p.displayName != null;
  }, !1), s = [], l = [], u = [];
  n.length ? L(n, function(f) {
    c(ic(a, e, f), f);
  }) : L(r, c);
  function c(f, h) {
    var d = a.getDimensionInfo(h);
    !d || d.otherDims.tooltip === !1 || (o ? u.push(cr("nameValue", {
      markerType: "subItem",
      markerColor: i,
      name: d.displayName,
      value: f,
      valueType: d.type
    })) : (s.push(f), l.push(d.type)));
  }
  return {
    inlineValues: s,
    inlineValueTypes: l,
    blocks: u
  };
}
var lo = ee();
function $d(r, t) {
  return r.getName(t) || r.getId(t);
}
var tv = "__universalTransitionEnabled", ke = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e._selectedDataIndicesMap = {}, e;
    }
    return t.prototype.init = function(e, n, i) {
      this.seriesIndex = this.componentIndex, this.dataTask = Zf({
        count: HX,
        reset: WX
      }), this.dataTask.context = {
        model: this
      }, this.mergeDefaultAndTheme(e, i);
      var a = lo(this).sourceManager = new gO(this);
      a.prepareSource();
      var o = this.getInitialData(e, i);
      _E(o, this), this.dataTask.context.data = o, process.env.NODE_ENV !== "production" && St(o, "getInitialData returned invalid data."), lo(this).dataBeforeProcessed = o, yE(this), this._initSelectedMapFromData(o);
    }, t.prototype.mergeDefaultAndTheme = function(e, n) {
      var i = lh(this), a = i ? El(e) : {}, o = this.subType;
      re.hasClass(o) && (o += "Series"), qt(e, n.getTheme().get(this.subType)), qt(e, this.getDefaultOption()), hl(e, "label", ["show"]), this.fillDataTextStyle(e.data), i && oa(e, a, i);
    }, t.prototype.mergeOption = function(e, n) {
      e = qt(this.option, e, !0), this.fillDataTextStyle(e.data);
      var i = lh(this);
      i && oa(this.option, e, i);
      var a = lo(this).sourceManager;
      a.dirty(), a.prepareSource();
      var o = this.getInitialData(e, n);
      _E(o, this), this.dataTask.dirty(), this.dataTask.context.data = o, lo(this).dataBeforeProcessed = o, yE(this), this._initSelectedMapFromData(o);
    }, t.prototype.fillDataTextStyle = function(e) {
      if (e && !fn(e))
        for (var n = ["show"], i = 0; i < e.length; i++)
          e[i] && e[i].label && hl(e[i], "label", n);
    }, t.prototype.getInitialData = function(e, n) {
    }, t.prototype.appendData = function(e) {
      var n = this.getRawData();
      n.appendData(e.data);
    }, t.prototype.getData = function(e) {
      var n = qx(this);
      if (n) {
        var i = n.context.data;
        return e == null || !i.getLinkedData ? i : i.getLinkedData(e);
      } else
        return lo(this).data;
    }, t.prototype.getAllData = function() {
      var e = this.getData();
      return e && e.getLinkedDataAll ? e.getLinkedDataAll() : [{
        data: e
      }];
    }, t.prototype.setData = function(e) {
      var n = qx(this);
      if (n) {
        var i = n.context;
        i.outputData = e, n !== this.dataTask && (i.data = e);
      }
      lo(this).data = e;
    }, t.prototype.getEncode = function() {
      var e = this.get("encode", !0);
      if (e)
        return wt(e);
    }, t.prototype.getSourceManager = function() {
      return lo(this).sourceManager;
    }, t.prototype.getSource = function() {
      return this.getSourceManager().getSource();
    }, t.prototype.getRawData = function() {
      return lo(this).dataBeforeProcessed;
    }, t.prototype.getColorBy = function() {
      var e = this.get("colorBy");
      return e || "series";
    }, t.prototype.isColorBySeries = function() {
      return this.getColorBy() === "series";
    }, t.prototype.getBaseAxis = function() {
      var e = this.coordinateSystem;
      return e && e.getBaseAxis && e.getBaseAxis();
    }, t.prototype.indicesOfNearest = function(e, n, i, a) {
      var o = this.getData(), s = this.coordinateSystem, l = s && s.getAxis(e);
      if (!s || !l)
        return [];
      var u = l.dataToCoord(i);
      a == null && (a = 1 / 0);
      var c = [], f = 1 / 0, h = -1, d = 0;
      return o.each(n, function(p, g) {
        var v = l.dataToCoord(p), m = u - v, y = Math.abs(m);
        y <= a && ((y < f || y === f && m >= 0 && h < 0) && (f = y, h = m, d = 0), m === h && (c[d++] = g));
      }), c.length = d, c;
    }, t.prototype.formatTooltip = function(e, n, i) {
      return MO({
        series: this,
        dataIndex: e,
        multipleSeries: n
      });
    }, t.prototype.isAnimationEnabled = function() {
      var e = this.ecModel;
      if (oe.node && !(e && e.ssr))
        return !1;
      var n = this.getShallow("animation");
      return n && this.getData().count() > this.getShallow("animationThreshold") && (n = !1), !!n;
    }, t.prototype.restoreData = function() {
      this.dataTask.dirty();
    }, t.prototype.getColorFromPalette = function(e, n, i) {
      var a = this.ecModel, o = ib.prototype.getColorFromPalette.call(this, e, n, i);
      return o || (o = a.getColorFromPalette(e, n, i)), o;
    }, t.prototype.coordDimToDataDim = function(e) {
      return this.getRawData().mapDimensionsAll(e);
    }, t.prototype.getProgressive = function() {
      return this.get("progressive");
    }, t.prototype.getProgressiveThreshold = function() {
      return this.get("progressiveThreshold");
    }, t.prototype.select = function(e, n) {
      this._innerSelect(this.getData(n), e);
    }, t.prototype.unselect = function(e, n) {
      var i = this.option.selectedMap;
      if (i) {
        var a = this.option.selectedMode, o = this.getData(n);
        if (a === "series" || i === "all") {
          this.option.selectedMap = {}, this._selectedDataIndicesMap = {};
          return;
        }
        for (var s = 0; s < e.length; s++) {
          var l = e[s], u = $d(o, l);
          i[u] = !1, this._selectedDataIndicesMap[u] = -1;
        }
      }
    }, t.prototype.toggleSelect = function(e, n) {
      for (var i = [], a = 0; a < e.length; a++)
        i[0] = e[a], this.isSelected(e[a], n) ? this.unselect(i, n) : this.select(i, n);
    }, t.prototype.getSelectedDataIndices = function() {
      if (this.option.selectedMap === "all")
        return [].slice.call(this.getData().getIndices());
      for (var e = this._selectedDataIndicesMap, n = se(e), i = [], a = 0; a < n.length; a++) {
        var o = e[n[a]];
        o >= 0 && i.push(o);
      }
      return i;
    }, t.prototype.isSelected = function(e, n) {
      var i = this.option.selectedMap;
      if (!i)
        return !1;
      var a = this.getData(n);
      return (i === "all" || i[$d(a, e)]) && !a.getItemModel(e).get(["select", "disabled"]);
    }, t.prototype.isUniversalTransitionEnabled = function() {
      if (this[tv])
        return !0;
      var e = this.option.universalTransition;
      return e ? e === !0 ? !0 : e && e.enabled : !1;
    }, t.prototype._innerSelect = function(e, n) {
      var i, a, o = this.option, s = o.selectedMode, l = n.length;
      if (!(!s || !l)) {
        if (s === "series")
          o.selectedMap = "all";
        else if (s === "multiple") {
          Dt(o.selectedMap) || (o.selectedMap = {});
          for (var u = o.selectedMap, c = 0; c < l; c++) {
            var f = n[c], h = $d(e, f);
            u[h] = !0, this._selectedDataIndicesMap[h] = e.getRawIndex(f);
          }
        } else if (s === "single" || s === !0) {
          var d = n[l - 1], h = $d(e, d);
          o.selectedMap = (i = {}, i[h] = !0, i), this._selectedDataIndicesMap = (a = {}, a[h] = e.getRawIndex(d), a);
        }
      }
    }, t.prototype._initSelectedMapFromData = function(e) {
      if (!this.option.selectedMap) {
        var n = [];
        e.hasItemOption && e.each(function(i) {
          var a = e.getRawDataItem(i);
          a && a.selected && n.push(i);
        }), n.length > 0 && this._innerSelect(e, n);
      }
    }, t.registerClass = function(e) {
      return re.registerClass(e);
    }, t.protoInitialize = function() {
      var e = t.prototype;
      e.type = "series.__base__", e.seriesIndex = 0, e.ignoreStyleOnData = !1, e.hasSymbolVisual = !1, e.defaultSymbol = "circle", e.visualStyleAccessPath = "itemStyle", e.visualDrawType = "fill";
    }(), t;
  }(re)
);
hr(ke, fm);
hr(ke, ib);
zP(ke, re);
function yE(r) {
  var t = r.name;
  D1(r) || (r.name = GX(r) || t);
}
function GX(r) {
  var t = r.getRawData(), e = t.mapDimensionsAll("seriesName"), n = [];
  return L(e, function(i) {
    var a = t.getDimensionInfo(i);
    a.displayName && n.push(a.displayName);
  }), n.join(" ");
}
function HX(r) {
  return r.model.getRawData().count();
}
function WX(r) {
  var t = r.model;
  return t.setData(t.getRawData().cloneShallow()), XX;
}
function XX(r, t) {
  t.outputData && r.end > t.outputData.count() && t.model.getRawData().cloneShallow(t.outputData);
}
function _E(r, t) {
  L(th(r.CHANGABLE_METHODS, r.DOWNSAMPLE_METHODS), function(e) {
    r.wrapMethod(e, Yt(YX, t));
  });
}
function YX(r, t) {
  var e = qx(r);
  return e && e.setOutputEnd((t || this).count()), t;
}
function qx(r) {
  var t = (r.ecModel || {}).scheduler, e = t && t.getPipeline(r.uid);
  if (e) {
    var n = e.currentTask;
    if (n) {
      var i = n.agentStubMap;
      i && (n = i.get(r.uid));
    }
    return n;
  }
}
var Ue = (
  /** @class */
  function() {
    function r() {
      this.group = new Et(), this.uid = Ac("viewComponent");
    }
    return r.prototype.init = function(t, e) {
    }, r.prototype.render = function(t, e, n, i) {
    }, r.prototype.dispose = function(t, e) {
    }, r.prototype.updateView = function(t, e, n, i) {
    }, r.prototype.updateLayout = function(t, e, n, i) {
    }, r.prototype.updateVisual = function(t, e, n, i) {
    }, r.prototype.toggleBlurSeries = function(t, e, n) {
    }, r.prototype.eachRendered = function(t) {
      var e = this.group;
      e && e.traverse(t);
    }, r;
  }()
);
R1(Ue);
Zg(Ue);
function Cc() {
  var r = ee();
  return function(t) {
    var e = r(t), n = t.pipelineContext, i = !!e.large, a = !!e.progressiveRender, o = e.large = !!(n && n.large), s = e.progressiveRender = !!(n && n.progressiveRender);
    return (i !== o || a !== s) && "reset";
  };
}
var TO = ee(), $X = Cc(), Re = (
  /** @class */
  function() {
    function r() {
      this.group = new Et(), this.uid = Ac("viewChart"), this.renderTask = Zf({
        plan: ZX,
        reset: qX
      }), this.renderTask.context = {
        view: this
      };
    }
    return r.prototype.init = function(t, e) {
    }, r.prototype.render = function(t, e, n, i) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("render method must been implemented");
    }, r.prototype.highlight = function(t, e, n, i) {
      var a = t.getData(i && i.dataType);
      if (!a) {
        process.env.NODE_ENV !== "production" && ce("Unknown dataType " + i.dataType);
        return;
      }
      SE(a, i, "emphasis");
    }, r.prototype.downplay = function(t, e, n, i) {
      var a = t.getData(i && i.dataType);
      if (!a) {
        process.env.NODE_ENV !== "production" && ce("Unknown dataType " + i.dataType);
        return;
      }
      SE(a, i, "normal");
    }, r.prototype.remove = function(t, e) {
      this.group.removeAll();
    }, r.prototype.dispose = function(t, e) {
    }, r.prototype.updateView = function(t, e, n, i) {
      this.render(t, e, n, i);
    }, r.prototype.updateLayout = function(t, e, n, i) {
      this.render(t, e, n, i);
    }, r.prototype.updateVisual = function(t, e, n, i) {
      this.render(t, e, n, i);
    }, r.prototype.eachRendered = function(t) {
      Ko(this.group, t);
    }, r.markUpdateMethod = function(t, e) {
      TO(t).updateMethod = e;
    }, r.protoInitialize = function() {
      var t = r.prototype;
      t.type = "chart";
    }(), r;
  }()
);
function xE(r, t, e) {
  r && Uo(r) && (t === "emphasis" ? Ha : Wa)(r, e);
}
function SE(r, t, e) {
  var n = dl(r, t), i = t && t.highlightKey != null ? g7(t.highlightKey) : null;
  n != null ? L(Ie(n), function(a) {
    xE(r.getItemGraphicEl(a), e, i);
  }) : r.eachItemGraphicEl(function(a) {
    xE(a, e, i);
  });
}
R1(Re, ["dispose"]);
Zg(Re);
function ZX(r) {
  return $X(r.model);
}
function qX(r) {
  var t = r.model, e = r.ecModel, n = r.api, i = r.payload, a = t.pipelineContext.progressiveRender, o = r.view, s = i && TO(i).updateMethod, l = a ? "incrementalPrepareRender" : s && o[s] ? s : "render";
  return l !== "render" && o[l](t, e, n, i), KX[l];
}
var KX = {
  incrementalPrepareRender: {
    progress: function(r, t) {
      t.view.incrementalRender(r, t.model, t.ecModel, t.api, t.payload);
    }
  },
  render: {
    // Put view.render in `progress` to support appendData. But in this case
    // view.render should not be called in reset, otherwise it will be called
    // twise. Use `forceFirstProgress` to make sure that view.render is called
    // in any cases.
    forceFirstProgress: !0,
    progress: function(r, t) {
      t.view.render(t.model, t.ecModel, t.api, t.payload);
    }
  }
}, zv = "\0__throttleOriginMethod", bE = "\0__throttleRate", wE = "\0__throttleType";
function ub(r, t, e) {
  var n, i = 0, a = 0, o = null, s, l, u, c;
  t = t || 0;
  function f() {
    a = (/* @__PURE__ */ new Date()).getTime(), o = null, r.apply(l, u || []);
  }
  var h = function() {
    for (var d = [], p = 0; p < arguments.length; p++)
      d[p] = arguments[p];
    n = (/* @__PURE__ */ new Date()).getTime(), l = this, u = d;
    var g = c || t, v = c || e;
    c = null, s = n - (v ? i : a) - g, clearTimeout(o), v ? o = setTimeout(f, g) : s >= 0 ? f() : o = setTimeout(f, -s), i = n;
  };
  return h.clear = function() {
    o && (clearTimeout(o), o = null);
  }, h.debounceNextCall = function(d) {
    c = d;
  }, h;
}
function Dc(r, t, e, n) {
  var i = r[t];
  if (i) {
    var a = i[zv] || i, o = i[wE], s = i[bE];
    if (s !== e || o !== n) {
      if (e == null || !n)
        return r[t] = a;
      i = r[t] = ub(a, e, n === "debounce"), i[zv] = a, i[wE] = n, i[bE] = e;
    }
    return i;
  }
}
function ch(r, t) {
  var e = r[t];
  e && e[zv] && (e.clear && e.clear(), r[t] = e[zv]);
}
var ME = ee(), TE = {
  itemStyle: pl(EN, !0),
  lineStyle: pl(AN, !0)
}, jX = {
  lineStyle: "stroke",
  itemStyle: "fill"
};
function AO(r, t) {
  var e = r.visualStyleMapper || TE[t];
  return e || (console.warn("Unknown style type '" + t + "'."), TE.itemStyle);
}
function EO(r, t) {
  var e = r.visualDrawType || jX[t];
  return e || (console.warn("Unknown style type '" + t + "'."), "fill");
}
var JX = {
  createOnAllSeries: !0,
  performRawSeries: !0,
  reset: function(r, t) {
    var e = r.getData(), n = r.visualStyleAccessPath || "itemStyle", i = r.getModel(n), a = AO(r, n), o = a(i), s = i.getShallow("decal");
    s && (e.setVisual("decal", s), s.dirty = !0);
    var l = EO(r, n), u = o[l], c = Tt(u) ? u : null, f = o.fill === "auto" || o.stroke === "auto";
    if (!o[l] || c || f) {
      var h = r.getColorFromPalette(
        // TODO series count changed.
        r.name,
        null,
        t.getSeriesCount()
      );
      o[l] || (o[l] = h, e.setVisual("colorFromPalette", !0)), o.fill = o.fill === "auto" || Tt(o.fill) ? h : o.fill, o.stroke = o.stroke === "auto" || Tt(o.stroke) ? h : o.stroke;
    }
    if (e.setVisual("style", o), e.setVisual("drawType", l), !t.isSeriesFiltered(r) && c)
      return e.setVisual("colorFromPalette", !1), {
        dataEach: function(d, p) {
          var g = r.getDataParams(p), v = J({}, o);
          v[l] = c(g), d.setItemVisual(p, "style", v);
        }
      };
  }
}, tf = new ue(), QX = {
  createOnAllSeries: !0,
  performRawSeries: !0,
  reset: function(r, t) {
    if (!(r.ignoreStyleOnData || t.isSeriesFiltered(r))) {
      var e = r.getData(), n = r.visualStyleAccessPath || "itemStyle", i = AO(r, n), a = e.getVisual("drawType");
      return {
        dataEach: e.hasItemOption ? function(o, s) {
          var l = o.getRawDataItem(s);
          if (l && l[n]) {
            tf.option = l[n];
            var u = i(tf), c = o.ensureUniqueItemVisual(s, "style");
            J(c, u), tf.option.decal && (o.setItemVisual(s, "decal", tf.option.decal), tf.option.decal.dirty = !0), a in u && o.setItemVisual(s, "colorFromPalette", !1);
          }
        } : null
      };
    }
  }
}, tY = {
  performRawSeries: !0,
  overallReset: function(r) {
    var t = wt();
    r.eachSeries(function(e) {
      var n = e.getColorBy();
      if (!e.isColorBySeries()) {
        var i = e.type + "-" + n, a = t.get(i);
        a || (a = {}, t.set(i, a)), ME(e).scope = a;
      }
    }), r.eachSeries(function(e) {
      if (!(e.isColorBySeries() || r.isSeriesFiltered(e))) {
        var n = e.getRawData(), i = {}, a = e.getData(), o = ME(e).scope, s = e.visualStyleAccessPath || "itemStyle", l = EO(e, s);
        a.each(function(u) {
          var c = a.getRawIndex(u);
          i[c] = u;
        }), n.each(function(u) {
          var c = i[u], f = a.getItemVisual(c, "colorFromPalette");
          if (f) {
            var h = a.ensureUniqueItemVisual(c, "style"), d = n.getName(u) || u + "", p = n.count();
            h[l] = e.getColorFromPalette(d, o, p);
          }
        });
      }
    });
  }
}, Zd = Math.PI;
function eY(r, t) {
  t = t || {}, kt(t, {
    text: "loading",
    textColor: Y.color.primary,
    fontSize: 12,
    fontWeight: "normal",
    fontStyle: "normal",
    fontFamily: "sans-serif",
    maskColor: "rgba(255,255,255,0.8)",
    showSpinner: !0,
    color: Y.color.theme[0],
    spinnerRadius: 10,
    lineWidth: 5,
    zlevel: 0
  });
  var e = new Et(), n = new te({
    style: {
      fill: t.maskColor
    },
    zlevel: t.zlevel,
    z: 1e4
  });
  e.add(n);
  var i = new pe({
    style: {
      text: t.text,
      fill: t.textColor,
      fontSize: t.fontSize,
      fontWeight: t.fontWeight,
      fontStyle: t.fontStyle,
      fontFamily: t.fontFamily
    },
    zlevel: t.zlevel,
    z: 10001
  }), a = new te({
    style: {
      fill: "none"
    },
    textContent: i,
    textConfig: {
      position: "right",
      distance: 10
    },
    zlevel: t.zlevel,
    z: 10001
  });
  e.add(a);
  var o;
  return t.showSpinner && (o = new nm({
    shape: {
      startAngle: -Zd / 2,
      endAngle: -Zd / 2 + 0.1,
      r: t.spinnerRadius
    },
    style: {
      stroke: t.color,
      lineCap: "round",
      lineWidth: t.lineWidth
    },
    zlevel: t.zlevel,
    z: 10001
  }), o.animateShape(!0).when(1e3, {
    endAngle: Zd * 3 / 2
  }).start("circularInOut"), o.animateShape(!0).when(1e3, {
    startAngle: Zd * 3 / 2
  }).delay(300).start("circularInOut"), e.add(o)), e.resize = function() {
    var s = i.getBoundingRect().width, l = t.showSpinner ? t.spinnerRadius : 0, u = (r.getWidth() - l * 2 - (t.showSpinner && s ? 10 : 0) - s) / 2 - (t.showSpinner && s ? 0 : 5 + s / 2) + (t.showSpinner ? 0 : s / 2) + (s ? 0 : l), c = r.getHeight() / 2;
    t.showSpinner && o.setShape({
      cx: u,
      cy: c
    }), a.setShape({
      x: u - l,
      y: c - l,
      width: l * 2,
      height: l * 2
    }), n.setShape({
      x: 0,
      y: 0,
      width: r.getWidth(),
      height: r.getHeight()
    });
  }, e.resize(), e;
}
var CO = (
  /** @class */
  function() {
    function r(t, e, n, i) {
      this._stageTaskMap = wt(), this.ecInstance = t, this.api = e, n = this._dataProcessorHandlers = n.slice(), i = this._visualHandlers = i.slice(), this._allHandlers = n.concat(i);
    }
    return r.prototype.restoreData = function(t, e) {
      t.restoreData(e), this._stageTaskMap.each(function(n) {
        var i = n.overallTask;
        i && i.dirty();
      });
    }, r.prototype.getPerformArgs = function(t, e) {
      if (t.__pipeline) {
        var n = this._pipelineMap.get(t.__pipeline.id), i = n.context, a = !e && n.progressiveEnabled && (!i || i.progressiveRender) && t.__idxInPipeline > n.blockIndex, o = a ? n.step : null, s = i && i.modDataCount, l = s != null ? Math.ceil(s / o) : null;
        return {
          step: o,
          modBy: l,
          modDataCount: s
        };
      }
    }, r.prototype.getPipeline = function(t) {
      return this._pipelineMap.get(t);
    }, r.prototype.updateStreamModes = function(t, e) {
      var n = this._pipelineMap.get(t.uid), i = t.getData(), a = i.count(), o = n.progressiveEnabled && e.incrementalPrepareRender && a >= n.threshold, s = t.get("large") && a >= t.get("largeThreshold"), l = t.get("progressiveChunkMode") === "mod" ? a : null;
      t.pipelineContext = n.context = {
        progressiveRender: o,
        modDataCount: l,
        large: s
      };
    }, r.prototype.restorePipelines = function(t) {
      var e = this, n = e._pipelineMap = wt();
      t.eachSeries(function(i) {
        var a = i.getProgressive(), o = i.uid;
        n.set(o, {
          id: o,
          head: null,
          tail: null,
          threshold: i.getProgressiveThreshold(),
          progressiveEnabled: a && !(i.preventIncremental && i.preventIncremental()),
          blockIndex: -1,
          step: Math.round(a || 700),
          count: 0
        }), e._pipe(i, i.dataTask);
      });
    }, r.prototype.prepareStageTasks = function() {
      var t = this._stageTaskMap, e = this.api.getModel(), n = this.api;
      L(this._allHandlers, function(i) {
        var a = t.get(i.uid) || t.set(i.uid, {}), o = "";
        process.env.NODE_ENV !== "production" && (o = '"reset" and "overallReset" must not be both specified.'), St(!(i.reset && i.overallReset), o), i.reset && this._createSeriesStageTask(i, a, e, n), i.overallReset && this._createOverallStageTask(i, a, e, n);
      }, this);
    }, r.prototype.prepareView = function(t, e, n, i) {
      var a = t.renderTask, o = a.context;
      o.model = e, o.ecModel = n, o.api = i, a.__block = !t.incrementalPrepareRender, this._pipe(e, a);
    }, r.prototype.performDataProcessorTasks = function(t, e) {
      this._performStageTasks(this._dataProcessorHandlers, t, e, {
        block: !0
      });
    }, r.prototype.performVisualTasks = function(t, e, n) {
      this._performStageTasks(this._visualHandlers, t, e, n);
    }, r.prototype._performStageTasks = function(t, e, n, i) {
      i = i || {};
      var a = !1, o = this;
      L(t, function(l, u) {
        if (!(i.visualType && i.visualType !== l.visualType)) {
          var c = o._stageTaskMap.get(l.uid), f = c.seriesTaskMap, h = c.overallTask;
          if (h) {
            var d, p = h.agentStubMap;
            p.each(function(v) {
              s(i, v) && (v.dirty(), d = !0);
            }), d && h.dirty(), o.updatePayload(h, n);
            var g = o.getPerformArgs(h, i.block);
            p.each(function(v) {
              v.perform(g);
            }), h.perform(g) && (a = !0);
          } else
            f && f.each(function(v, m) {
              s(i, v) && v.dirty();
              var y = o.getPerformArgs(v, i.block);
              y.skip = !l.performRawSeries && e.isSeriesFiltered(v.context.model), o.updatePayload(v, n), v.perform(y) && (a = !0);
            });
        }
      });
      function s(l, u) {
        return l.setDirty && (!l.dirtyMap || l.dirtyMap.get(u.__pipeline.id));
      }
      this.unfinished = a || this.unfinished;
    }, r.prototype.performSeriesTasks = function(t) {
      var e;
      t.eachSeries(function(n) {
        e = n.dataTask.perform() || e;
      }), this.unfinished = e || this.unfinished;
    }, r.prototype.plan = function() {
      this._pipelineMap.each(function(t) {
        var e = t.tail;
        do {
          if (e.__block) {
            t.blockIndex = e.__idxInPipeline;
            break;
          }
          e = e.getUpstream();
        } while (e);
      });
    }, r.prototype.updatePayload = function(t, e) {
      e !== "remain" && (t.context.payload = e);
    }, r.prototype._createSeriesStageTask = function(t, e, n, i) {
      var a = this, o = e.seriesTaskMap, s = e.seriesTaskMap = wt(), l = t.seriesType, u = t.getTargetSeries;
      t.createOnAllSeries ? n.eachRawSeries(c) : l ? n.eachRawSeriesByType(l, c) : u && u(n, i).each(c);
      function c(f) {
        var h = f.uid, d = s.set(h, o && o.get(h) || Zf({
          plan: oY,
          reset: sY,
          count: uY
        }));
        d.context = {
          model: f,
          ecModel: n,
          api: i,
          // PENDING: `useClearVisual` not used?
          useClearVisual: t.isVisual && !t.isLayout,
          plan: t.plan,
          reset: t.reset,
          scheduler: a
        }, a._pipe(f, d);
      }
    }, r.prototype._createOverallStageTask = function(t, e, n, i) {
      var a = this, o = e.overallTask = e.overallTask || Zf({
        reset: rY
      });
      o.context = {
        ecModel: n,
        api: i,
        overallReset: t.overallReset,
        scheduler: a
      };
      var s = o.agentStubMap, l = o.agentStubMap = wt(), u = t.seriesType, c = t.getTargetSeries, f = !0, h = !1, d = "";
      process.env.NODE_ENV !== "production" && (d = '"createOnAllSeries" is not supported for "overallReset", because it will block all streams.'), St(!t.createOnAllSeries, d), u ? n.eachRawSeriesByType(u, p) : c ? c(n, i).each(p) : (f = !1, L(n.getSeries(), p));
      function p(g) {
        var v = g.uid, m = l.set(v, s && s.get(v) || // When the result of `getTargetSeries` changed, the overallTask
        // should be set as dirty and re-performed.
        (h = !0, Zf({
          reset: nY,
          onDirty: aY
        })));
        m.context = {
          model: g,
          overallProgress: f
          // FIXME:TS never used, so comment it
          // modifyOutputEnd: modifyOutputEnd
        }, m.agent = o, m.__block = f, a._pipe(g, m);
      }
      h && o.dirty();
    }, r.prototype._pipe = function(t, e) {
      var n = t.uid, i = this._pipelineMap.get(n);
      !i.head && (i.head = e), i.tail && i.tail.pipe(e), i.tail = e, e.__idxInPipeline = i.count++, e.__pipeline = i;
    }, r.wrapStageHandler = function(t, e) {
      return Tt(t) && (t = {
        overallReset: t,
        seriesType: cY(t)
      }), t.uid = Ac("stageHandler"), e && (t.visualType = e), t;
    }, r;
  }()
);
function rY(r) {
  r.overallReset(r.ecModel, r.api, r.payload);
}
function nY(r) {
  return r.overallProgress && iY;
}
function iY() {
  this.agent.dirty(), this.getDownstream().dirty();
}
function aY() {
  this.agent && this.agent.dirty();
}
function oY(r) {
  return r.plan ? r.plan(r.model, r.ecModel, r.api, r.payload) : null;
}
function sY(r) {
  r.useClearVisual && r.data.clearAllVisual();
  var t = r.resetDefines = Ie(r.reset(r.model, r.ecModel, r.api, r.payload));
  return t.length > 1 ? rt(t, function(e, n) {
    return DO(n);
  }) : lY;
}
var lY = DO(0);
function DO(r) {
  return function(t, e) {
    var n = e.data, i = e.resetDefines[r];
    if (i && i.dataEach)
      for (var a = t.start; a < t.end; a++)
        i.dataEach(n, a);
    else
      i && i.progress && i.progress(t, n);
  };
}
function uY(r) {
  return r.data.count();
}
function cY(r) {
  Uv = null;
  try {
    r(fh, LO);
  } catch {
  }
  return Uv;
}
var fh = {}, LO = {}, Uv;
RO(fh, ab);
RO(LO, eO);
fh.eachSeriesByType = fh.eachRawSeriesByType = function(r) {
  Uv = r;
};
fh.eachComponent = function(r) {
  r.mainType === "series" && r.subType && (Uv = r.subType);
};
function RO(r, t) {
  for (var e in t.prototype)
    r[e] = er;
}
var Pt = Y.darkColor, fY = Pt.background, ef = function() {
  return {
    axisLine: {
      lineStyle: {
        color: Pt.axisLine
      }
    },
    splitLine: {
      lineStyle: {
        color: Pt.axisSplitLine
      }
    },
    splitArea: {
      areaStyle: {
        color: [Pt.backgroundTint, Pt.backgroundTransparent]
      }
    },
    minorSplitLine: {
      lineStyle: {
        color: Pt.axisMinorSplitLine
      }
    },
    axisLabel: {
      color: Pt.axisLabel
    },
    axisName: {}
  };
}, AE = {
  label: {
    color: Pt.secondary
  },
  itemStyle: {
    borderColor: Pt.borderTint
  },
  dividerLineStyle: {
    color: Pt.border
  }
}, IO = {
  darkMode: !0,
  color: Pt.theme,
  backgroundColor: fY,
  axisPointer: {
    lineStyle: {
      color: Pt.border
    },
    crossStyle: {
      color: Pt.borderShade
    },
    label: {
      color: Pt.tertiary
    }
  },
  legend: {
    textStyle: {
      color: Pt.secondary
    },
    pageTextStyle: {
      color: Pt.tertiary
    }
  },
  textStyle: {
    color: Pt.secondary
  },
  title: {
    textStyle: {
      color: Pt.primary
    },
    subtextStyle: {
      color: Pt.quaternary
    }
  },
  toolbox: {
    iconStyle: {
      borderColor: Pt.accent50
    }
  },
  tooltip: {
    backgroundColor: Pt.neutral20,
    defaultBorderColor: Pt.border,
    textStyle: {
      color: Pt.tertiary
    }
  },
  dataZoom: {
    borderColor: Pt.accent10,
    textStyle: {
      color: Pt.tertiary
    },
    brushStyle: {
      color: Pt.backgroundTint
    },
    handleStyle: {
      color: Pt.neutral00,
      borderColor: Pt.accent20
    },
    moveHandleStyle: {
      color: Pt.accent40
    },
    emphasis: {
      handleStyle: {
        borderColor: Pt.accent50
      }
    },
    dataBackground: {
      lineStyle: {
        color: Pt.accent30
      },
      areaStyle: {
        color: Pt.accent20
      }
    },
    selectedDataBackground: {
      lineStyle: {
        color: Pt.accent50
      },
      areaStyle: {
        color: Pt.accent30
      }
    }
  },
  visualMap: {
    textStyle: {
      color: Pt.secondary
    },
    handleStyle: {
      borderColor: Pt.neutral30
    }
  },
  timeline: {
    lineStyle: {
      color: Pt.accent10
    },
    label: {
      color: Pt.tertiary
    },
    controlStyle: {
      color: Pt.accent30,
      borderColor: Pt.accent30
    }
  },
  calendar: {
    itemStyle: {
      color: Pt.neutral00,
      borderColor: Pt.neutral20
    },
    dayLabel: {
      color: Pt.tertiary
    },
    monthLabel: {
      color: Pt.secondary
    },
    yearLabel: {
      color: Pt.secondary
    }
  },
  matrix: {
    x: AE,
    y: AE,
    backgroundColor: {
      borderColor: Pt.axisLine
    },
    body: {
      itemStyle: {
        borderColor: Pt.borderTint
      }
    }
  },
  timeAxis: ef(),
  logAxis: ef(),
  valueAxis: ef(),
  categoryAxis: ef(),
  line: {
    symbol: "circle"
  },
  graph: {
    color: Pt.theme
  },
  gauge: {
    title: {
      color: Pt.secondary
    },
    axisLine: {
      lineStyle: {
        color: [[1, Pt.neutral05]]
      }
    },
    axisLabel: {
      color: Pt.axisLabel
    },
    detail: {
      color: Pt.primary
    }
  },
  candlestick: {
    itemStyle: {
      color: "#f64e56",
      color0: "#54ea92",
      borderColor: "#f64e56",
      borderColor0: "#54ea92"
      // borderColor: '#ca2824',
      // borderColor0: '#09a443'
    }
  },
  funnel: {
    itemStyle: {
      borderColor: Pt.background
    }
  },
  radar: function() {
    var r = ef();
    return r.axisName = {
      color: Pt.axisLabel
    }, r.axisLine.lineStyle.color = Pt.neutral20, r;
  }(),
  treemap: {
    breadcrumb: {
      itemStyle: {
        color: Pt.neutral20,
        textStyle: {
          color: Pt.secondary
        }
      },
      emphasis: {
        itemStyle: {
          color: Pt.neutral30
        }
      }
    }
  },
  sunburst: {
    itemStyle: {
      borderColor: Pt.background
    }
  },
  map: {
    itemStyle: {
      borderColor: Pt.border,
      areaColor: Pt.neutral10
    },
    label: {
      color: Pt.tertiary
    },
    emphasis: {
      label: {
        color: Pt.primary
      },
      itemStyle: {
        areaColor: Pt.highlight
      }
    },
    select: {
      label: {
        color: Pt.primary
      },
      itemStyle: {
        areaColor: Pt.highlight
      }
    }
  },
  geo: {
    itemStyle: {
      borderColor: Pt.border,
      areaColor: Pt.neutral10
    },
    emphasis: {
      label: {
        color: Pt.primary
      },
      itemStyle: {
        areaColor: Pt.highlight
      }
    },
    select: {
      label: {
        color: Pt.primary
      },
      itemStyle: {
        color: Pt.highlight
      }
    }
  }
};
IO.categoryAxis.splitLine.show = !1;
var hY = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.normalizeQuery = function(t) {
      var e = {}, n = {}, i = {};
      if (pt(t)) {
        var a = $i(t);
        e.mainType = a.main || null, e.subType = a.sub || null;
      } else {
        var o = ["Index", "Name", "Id"], s = {
          name: 1,
          dataIndex: 1,
          dataType: 1
        };
        L(t, function(l, u) {
          for (var c = !1, f = 0; f < o.length; f++) {
            var h = o[f], d = u.lastIndexOf(h);
            if (d > 0 && d === u.length - h.length) {
              var p = u.slice(0, d);
              p !== "data" && (e.mainType = p, e[h.toLowerCase()] = l, c = !0);
            }
          }
          s.hasOwnProperty(u) && (n[u] = l, c = !0), c || (i[u] = l);
        });
      }
      return {
        cptQuery: e,
        dataQuery: n,
        otherQuery: i
      };
    }, r.prototype.filter = function(t, e) {
      var n = this.eventInfo;
      if (!n)
        return !0;
      var i = n.targetEl, a = n.packedEvent, o = n.model, s = n.view;
      if (!o || !s)
        return !0;
      var l = e.cptQuery, u = e.dataQuery;
      return c(l, o, "mainType") && c(l, o, "subType") && c(l, o, "index", "componentIndex") && c(l, o, "name") && c(l, o, "id") && c(u, a, "name") && c(u, a, "dataIndex") && c(u, a, "dataType") && (!s.filterForExposedEvent || s.filterForExposedEvent(t, e.otherQuery, i, a));
      function c(f, h, d, p) {
        return f[d] == null || h[p || d] === f[d];
      }
    }, r.prototype.afterTrigger = function() {
      this.eventInfo = null;
    }, r;
  }()
), Kx = ["symbol", "symbolSize", "symbolRotate", "symbolOffset"], EE = Kx.concat(["symbolKeepAspect"]), dY = {
  createOnAllSeries: !0,
  // For legend.
  performRawSeries: !0,
  reset: function(r, t) {
    var e = r.getData();
    if (r.legendIcon && e.setVisual("legendIcon", r.legendIcon), !r.hasSymbolVisual)
      return;
    for (var n = {}, i = {}, a = !1, o = 0; o < Kx.length; o++) {
      var s = Kx[o], l = r.get(s);
      Tt(l) ? (a = !0, i[s] = l) : n[s] = l;
    }
    if (n.symbol = n.symbol || r.defaultSymbol, e.setVisual(J({
      legendIcon: r.legendIcon || n.symbol,
      symbolKeepAspect: r.get("symbolKeepAspect")
    }, n)), t.isSeriesFiltered(r))
      return;
    var u = se(i);
    function c(f, h) {
      for (var d = r.getRawValue(h), p = r.getDataParams(h), g = 0; g < u.length; g++) {
        var v = u[g];
        f.setItemVisual(h, v, i[v](d, p));
      }
    }
    return {
      dataEach: a ? c : null
    };
  }
}, pY = {
  createOnAllSeries: !0,
  // For legend.
  performRawSeries: !0,
  reset: function(r, t) {
    if (!r.hasSymbolVisual || t.isSeriesFiltered(r))
      return;
    var e = r.getData();
    function n(i, a) {
      for (var o = i.getItemModel(a), s = 0; s < EE.length; s++) {
        var l = EE[s], u = o.getShallow(l, !0);
        u != null && i.setItemVisual(a, l, u);
      }
    }
    return {
      dataEach: e.hasItemOption ? n : null
    };
  }
};
function cb(r, t, e) {
  switch (e) {
    case "color":
      var n = r.getItemVisual(t, "style");
      return n[r.getVisual("drawType")];
    case "opacity":
      return r.getItemVisual(t, "style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return r.getItemVisual(t, e);
    default:
      process.env.NODE_ENV !== "production" && console.warn("Unknown visual type " + e);
  }
}
function Uh(r, t) {
  switch (t) {
    case "color":
      var e = r.getVisual("style");
      return e[r.getVisual("drawType")];
    case "opacity":
      return r.getVisual("style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return r.getVisual(t);
    default:
      process.env.NODE_ENV !== "production" && console.warn("Unknown visual type " + t);
  }
}
function PO(r, t, e, n) {
  switch (e) {
    case "color":
      var i = r.ensureUniqueItemVisual(t, "style");
      i[r.getVisual("drawType")] = n, r.setItemVisual(t, "colorFromPalette", !1);
      break;
    case "opacity":
      r.ensureUniqueItemVisual(t, "style").opacity = n;
      break;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      r.setItemVisual(t, e, n);
      break;
    default:
      process.env.NODE_ENV !== "production" && console.warn("Unknown visual type " + e);
  }
}
function NO(r, t) {
  function e(n, i) {
    var a = [];
    return n.eachComponent({
      mainType: "series",
      subType: r,
      query: i
    }, function(o) {
      a.push(o.seriesIndex);
    }), a;
  }
  L([[r + "ToggleSelect", "toggleSelect"], [r + "Select", "select"], [r + "UnSelect", "unselect"]], function(n) {
    t(n[0], function(i, a, o) {
      i = J({}, i), process.env.NODE_ENV !== "production" && ar(i.type, n[1]), o.dispatchAction(J(i, {
        type: n[1],
        seriesIndex: e(a, i)
      }));
    });
  });
}
function lu(r, t, e, n, i) {
  var a = r + t;
  e.isSilent(a) || (process.env.NODE_ENV !== "production" && ia("event " + a + " is deprecated."), n.eachComponent({
    mainType: "series",
    subType: "pie"
  }, function(o) {
    for (var s = o.seriesIndex, l = o.option.selectedMap, u = i.selected, c = 0; c < u.length; c++)
      if (u[c].seriesIndex === s) {
        var f = o.getData(), h = dl(f, i.fromActionPayload);
        e.trigger(a, {
          type: a,
          seriesId: o.id,
          name: et(h) ? f.getName(h[0]) : f.getName(h),
          selected: pt(l) ? l : J({}, l)
        });
      }
  }));
}
function vY(r, t, e) {
  r.on("selectchanged", function(n) {
    var i = e.getModel();
    n.isFromClick ? (lu("map", "selectchanged", t, i, n), lu("pie", "selectchanged", t, i, n)) : n.fromAction === "select" ? (lu("map", "selected", t, i, n), lu("pie", "selected", t, i, n)) : n.fromAction === "unselect" && (lu("map", "unselected", t, i, n), lu("pie", "unselected", t, i, n));
  });
}
function Js(r, t, e) {
  for (var n; r && !(t(r) && (n = r, e)); )
    r = r.__hostTarget || r.parent;
  return n;
}
var gY = Math.round(Math.random() * 9), mY = typeof Object.defineProperty == "function", yY = function() {
  function r() {
    this._id = "__ec_inner_" + gY++;
  }
  return r.prototype.get = function(t) {
    return this._guard(t)[this._id];
  }, r.prototype.set = function(t, e) {
    var n = this._guard(t);
    return mY ? Object.defineProperty(n, this._id, {
      value: e,
      enumerable: !1,
      configurable: !0
    }) : n[this._id] = e, this;
  }, r.prototype.delete = function(t) {
    return this.has(t) ? (delete this._guard(t)[this._id], !0) : !1;
  }, r.prototype.has = function(t) {
    return !!this._guard(t)[this._id];
  }, r.prototype._guard = function(t) {
    if (t !== Object(t))
      throw TypeError("Value of WeakMap is not a non-null object.");
    return t;
  }, r;
}(), _Y = ne.extend({
  type: "triangle",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(r, t) {
    var e = t.cx, n = t.cy, i = t.width / 2, a = t.height / 2;
    r.moveTo(e, n - a), r.lineTo(e + i, n + a), r.lineTo(e - i, n + a), r.closePath();
  }
}), xY = ne.extend({
  type: "diamond",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(r, t) {
    var e = t.cx, n = t.cy, i = t.width / 2, a = t.height / 2;
    r.moveTo(e, n - a), r.lineTo(e + i, n), r.lineTo(e, n + a), r.lineTo(e - i, n), r.closePath();
  }
}), SY = ne.extend({
  type: "pin",
  shape: {
    // x, y on the cusp
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(r, t) {
    var e = t.x, n = t.y, i = t.width / 5 * 3, a = Math.max(i, t.height), o = i / 2, s = o * o / (a - o), l = n - a + o + s, u = Math.asin(s / o), c = Math.cos(u) * o, f = Math.sin(u), h = Math.cos(u), d = o * 0.6, p = o * 0.7;
    r.moveTo(e - c, l + s), r.arc(e, l, o, Math.PI - u, Math.PI * 2 + u), r.bezierCurveTo(e + c - f * d, l + s + h * d, e, n - p, e, n), r.bezierCurveTo(e, n - p, e - c + f * d, l + s + h * d, e - c, l + s), r.closePath();
  }
}), bY = ne.extend({
  type: "arrow",
  shape: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(r, t) {
    var e = t.height, n = t.width, i = t.x, a = t.y, o = n / 3 * 2;
    r.moveTo(i, a), r.lineTo(i + o, a + e), r.lineTo(i, a + e / 4 * 3), r.lineTo(i - o, a + e), r.lineTo(i, a), r.closePath();
  }
}), wY = {
  line: sr,
  rect: te,
  roundRect: te,
  square: te,
  circle: qa,
  diamond: xY,
  pin: SY,
  arrow: bY,
  triangle: _Y
}, MY = {
  line: function(r, t, e, n, i) {
    i.x1 = r, i.y1 = t + n / 2, i.x2 = r + e, i.y2 = t + n / 2;
  },
  rect: function(r, t, e, n, i) {
    i.x = r, i.y = t, i.width = e, i.height = n;
  },
  roundRect: function(r, t, e, n, i) {
    i.x = r, i.y = t, i.width = e, i.height = n, i.r = Math.min(e, n) / 4;
  },
  square: function(r, t, e, n, i) {
    var a = Math.min(e, n);
    i.x = r, i.y = t, i.width = a, i.height = a;
  },
  circle: function(r, t, e, n, i) {
    i.cx = r + e / 2, i.cy = t + n / 2, i.r = Math.min(e, n) / 2;
  },
  diamond: function(r, t, e, n, i) {
    i.cx = r + e / 2, i.cy = t + n / 2, i.width = e, i.height = n;
  },
  pin: function(r, t, e, n, i) {
    i.x = r + e / 2, i.y = t + n / 2, i.width = e, i.height = n;
  },
  arrow: function(r, t, e, n, i) {
    i.x = r + e / 2, i.y = t + n / 2, i.width = e, i.height = n;
  },
  triangle: function(r, t, e, n, i) {
    i.cx = r + e / 2, i.cy = t + n / 2, i.width = e, i.height = n;
  }
}, Gv = {};
L(wY, function(r, t) {
  Gv[t] = new r();
});
var TY = ne.extend({
  type: "symbol",
  shape: {
    symbolType: "",
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  calculateTextPosition: function(r, t, e) {
    var n = Cv(r, t, e), i = this.shape;
    return i && i.symbolType === "pin" && t.position === "inside" && (n.y = e.y + e.height * 0.4), n;
  },
  buildPath: function(r, t, e) {
    var n = t.symbolType;
    if (n !== "none") {
      var i = Gv[n];
      i || (n = "rect", i = Gv[n]), MY[n](t.x, t.y, t.width, t.height, i.shape), i.buildPath(r, i.shape, e);
    }
  }
});
function AY(r, t) {
  if (this.type !== "image") {
    var e = this.style;
    this.__isEmptyBrush ? (e.stroke = r, e.fill = t || Y.color.neutral00, e.lineWidth = 2) : this.shape.symbolType === "line" ? e.stroke = r : e.fill = r, this.markRedraw();
  }
}
function fr(r, t, e, n, i, a, o) {
  var s = r.indexOf("empty") === 0;
  s && (r = r.substr(5, 1).toLowerCase() + r.substr(6));
  var l;
  return r.indexOf("image://") === 0 ? l = gN(r.slice(8), new Bt(t, e, n, i), o ? "center" : "cover") : r.indexOf("path://") === 0 ? l = oh(r.slice(7), {}, new Bt(t, e, n, i), o ? "center" : "cover") : l = new TY({
    shape: {
      symbolType: r,
      x: t,
      y: e,
      width: n,
      height: i
    }
  }), l.__isEmptyBrush = s, l.setColor = AY, a && l.setColor(a), l;
}
function Lc(r) {
  return et(r) || (r = [+r, +r]), [r[0] || 0, r[1] || 0];
}
function Dl(r, t) {
  if (r != null)
    return et(r) || (r = [r, r]), [dt(r[0], t[0]) || 0, dt(bt(r[1], r[0]), t[1]) || 0];
}
function Qs(r) {
  return isFinite(r);
}
function EY(r, t, e) {
  var n = t.x == null ? 0 : t.x, i = t.x2 == null ? 1 : t.x2, a = t.y == null ? 0 : t.y, o = t.y2 == null ? 0 : t.y2;
  t.global || (n = n * e.width + e.x, i = i * e.width + e.x, a = a * e.height + e.y, o = o * e.height + e.y), n = Qs(n) ? n : 0, i = Qs(i) ? i : 1, a = Qs(a) ? a : 0, o = Qs(o) ? o : 0;
  var s = r.createLinearGradient(n, a, i, o);
  return s;
}
function CY(r, t, e) {
  var n = e.width, i = e.height, a = Math.min(n, i), o = t.x == null ? 0.5 : t.x, s = t.y == null ? 0.5 : t.y, l = t.r == null ? 0.5 : t.r;
  t.global || (o = o * n + e.x, s = s * i + e.y, l = l * a), o = Qs(o) ? o : 0.5, s = Qs(s) ? s : 0.5, l = l >= 0 && Qs(l) ? l : 0.5;
  var u = r.createRadialGradient(o, s, 0, o, s, l);
  return u;
}
function jx(r, t, e) {
  for (var n = t.type === "radial" ? CY(r, t, e) : EY(r, t, e), i = t.colorStops, a = 0; a < i.length; a++)
    n.addColorStop(i[a].offset, i[a].color);
  return n;
}
function DY(r, t) {
  if (r === t || !r && !t)
    return !1;
  if (!r || !t || r.length !== t.length)
    return !0;
  for (var e = 0; e < r.length; e++)
    if (r[e] !== t[e])
      return !0;
  return !1;
}
function qd(r) {
  return parseInt(r, 10);
}
function Vu(r, t, e) {
  var n = ["width", "height"][t], i = ["clientWidth", "clientHeight"][t], a = ["paddingLeft", "paddingTop"][t], o = ["paddingRight", "paddingBottom"][t];
  if (e[n] != null && e[n] !== "auto")
    return parseFloat(e[n]);
  var s = document.defaultView.getComputedStyle(r);
  return (r[i] || qd(s[n]) || qd(r.style[n])) - (qd(s[a]) || 0) - (qd(s[o]) || 0) | 0;
}
function LY(r, t) {
  return !r || r === "solid" || !(t > 0) ? null : r === "dashed" ? [4 * t, 2 * t] : r === "dotted" ? [t] : fe(r) ? [r] : et(r) ? r : null;
}
function fb(r) {
  var t = r.style, e = t.lineDash && t.lineWidth > 0 && LY(t.lineDash, t.lineWidth), n = t.lineDashOffset;
  if (e) {
    var i = t.strokeNoScale && r.getLineScale ? r.getLineScale() : 1;
    i && i !== 1 && (e = rt(e, function(a) {
      return a / i;
    }), n /= i);
  }
  return [e, n];
}
var RY = new aa(!0);
function Hv(r) {
  var t = r.stroke;
  return !(t == null || t === "none" || !(r.lineWidth > 0));
}
function CE(r) {
  return typeof r == "string" && r !== "none";
}
function Wv(r) {
  var t = r.fill;
  return t != null && t !== "none";
}
function DE(r, t) {
  if (t.fillOpacity != null && t.fillOpacity !== 1) {
    var e = r.globalAlpha;
    r.globalAlpha = t.fillOpacity * t.opacity, r.fill(), r.globalAlpha = e;
  } else
    r.fill();
}
function LE(r, t) {
  if (t.strokeOpacity != null && t.strokeOpacity !== 1) {
    var e = r.globalAlpha;
    r.globalAlpha = t.strokeOpacity * t.opacity, r.stroke(), r.globalAlpha = e;
  } else
    r.stroke();
}
function Jx(r, t, e) {
  var n = I1(t.image, t.__image, e);
  if (qg(n)) {
    var i = r.createPattern(n, t.repeat || "repeat");
    if (typeof DOMMatrix == "function" && i && i.setTransform) {
      var a = new DOMMatrix();
      a.translateSelf(t.x || 0, t.y || 0), a.rotateSelf(0, 0, (t.rotation || 0) * Up), a.scaleSelf(t.scaleX || 1, t.scaleY || 1), i.setTransform(a);
    }
    return i;
  }
}
function IY(r, t, e, n) {
  var i, a = Hv(e), o = Wv(e), s = e.strokePercent, l = s < 1, u = !t.path;
  (!t.silent || l) && u && t.createPathProxy();
  var c = t.path || RY, f = t.__dirty;
  if (!n) {
    var h = e.fill, d = e.stroke, p = o && !!h.colorStops, g = a && !!d.colorStops, v = o && !!h.image, m = a && !!d.image, y = void 0, _ = void 0, x = void 0, b = void 0, S = void 0;
    (p || g) && (S = t.getBoundingRect()), p && (y = f ? jx(r, h, S) : t.__canvasFillGradient, t.__canvasFillGradient = y), g && (_ = f ? jx(r, d, S) : t.__canvasStrokeGradient, t.__canvasStrokeGradient = _), v && (x = f || !t.__canvasFillPattern ? Jx(r, h, t) : t.__canvasFillPattern, t.__canvasFillPattern = x), m && (b = f || !t.__canvasStrokePattern ? Jx(r, d, t) : t.__canvasStrokePattern, t.__canvasStrokePattern = b), p ? r.fillStyle = y : v && (x ? r.fillStyle = x : o = !1), g ? r.strokeStyle = _ : m && (b ? r.strokeStyle = b : a = !1);
  }
  var w = t.getGlobalScale();
  c.setScale(w[0], w[1], t.segmentIgnoreThreshold);
  var A, T;
  r.setLineDash && e.lineDash && (i = fb(t), A = i[0], T = i[1]);
  var M = !0;
  (u || f & Eu) && (c.setDPR(r.dpr), l ? c.setContext(null) : (c.setContext(r), M = !1), c.reset(), t.buildPath(c, t.shape, n), c.toStatic(), t.pathUpdated()), M && c.rebuildPath(r, l ? s : 1), A && (r.setLineDash(A), r.lineDashOffset = T), n || (e.strokeFirst ? (a && LE(r, e), o && DE(r, e)) : (o && DE(r, e), a && LE(r, e))), A && r.setLineDash([]);
}
function PY(r, t, e) {
  var n = t.__image = I1(e.image, t.__image, t, t.onload);
  if (!(!n || !qg(n))) {
    var i = e.x || 0, a = e.y || 0, o = t.getWidth(), s = t.getHeight(), l = n.width / n.height;
    if (o == null && s != null ? o = s * l : s == null && o != null ? s = o / l : o == null && s == null && (o = n.width, s = n.height), e.sWidth && e.sHeight) {
      var u = e.sx || 0, c = e.sy || 0;
      r.drawImage(n, u, c, e.sWidth, e.sHeight, i, a, o, s);
    } else if (e.sx && e.sy) {
      var u = e.sx, c = e.sy, f = o - u, h = s - c;
      r.drawImage(n, u, c, f, h, i, a, o, s);
    } else
      r.drawImage(n, i, a, o, s);
  }
}
function NY(r, t, e) {
  var n, i = e.text;
  if (i != null && (i += ""), i) {
    r.font = e.font || za, r.textAlign = e.textAlign, r.textBaseline = e.textBaseline;
    var a = void 0, o = void 0;
    r.setLineDash && e.lineDash && (n = fb(t), a = n[0], o = n[1]), a && (r.setLineDash(a), r.lineDashOffset = o), e.strokeFirst ? (Hv(e) && r.strokeText(i, e.x, e.y), Wv(e) && r.fillText(i, e.x, e.y)) : (Wv(e) && r.fillText(i, e.x, e.y), Hv(e) && r.strokeText(i, e.x, e.y)), a && r.setLineDash([]);
  }
}
var RE = ["shadowBlur", "shadowOffsetX", "shadowOffsetY"], IE = [
  ["lineCap", "butt"],
  ["lineJoin", "miter"],
  ["miterLimit", 10]
];
function OO(r, t, e, n, i) {
  var a = !1;
  if (!n && (e = e || {}, t === e))
    return !1;
  if (n || t.opacity !== e.opacity) {
    _n(r, i), a = !0;
    var o = Math.max(Math.min(t.opacity, 1), 0);
    r.globalAlpha = isNaN(o) ? nl.opacity : o;
  }
  (n || t.blend !== e.blend) && (a || (_n(r, i), a = !0), r.globalCompositeOperation = t.blend || nl.blend);
  for (var s = 0; s < RE.length; s++) {
    var l = RE[s];
    (n || t[l] !== e[l]) && (a || (_n(r, i), a = !0), r[l] = r.dpr * (t[l] || 0));
  }
  return (n || t.shadowColor !== e.shadowColor) && (a || (_n(r, i), a = !0), r.shadowColor = t.shadowColor || nl.shadowColor), a;
}
function PE(r, t, e, n, i) {
  var a = hh(t, i.inHover), o = n ? null : e && hh(e, i.inHover) || {};
  if (a === o)
    return !1;
  var s = OO(r, a, o, n, i);
  if ((n || a.fill !== o.fill) && (s || (_n(r, i), s = !0), CE(a.fill) && (r.fillStyle = a.fill)), (n || a.stroke !== o.stroke) && (s || (_n(r, i), s = !0), CE(a.stroke) && (r.strokeStyle = a.stroke)), (n || a.opacity !== o.opacity) && (s || (_n(r, i), s = !0), r.globalAlpha = a.opacity == null ? 1 : a.opacity), t.hasStroke()) {
    var l = a.lineWidth, u = l / (a.strokeNoScale && t.getLineScale ? t.getLineScale() : 1);
    r.lineWidth !== u && (s || (_n(r, i), s = !0), r.lineWidth = u);
  }
  for (var c = 0; c < IE.length; c++) {
    var f = IE[c], h = f[0];
    (n || a[h] !== o[h]) && (s || (_n(r, i), s = !0), r[h] = a[h] || f[1]);
  }
  return s;
}
function OY(r, t, e, n, i) {
  return OO(r, hh(t, i.inHover), e && hh(e, i.inHover), n, i);
}
function kO(r, t) {
  var e = t.transform, n = r.dpr || 1;
  e ? r.setTransform(n * e[0], n * e[1], n * e[2], n * e[3], n * e[4], n * e[5]) : r.setTransform(n, 0, 0, n, 0, 0);
}
function kY(r, t, e) {
  for (var n = !1, i = 0; i < r.length; i++) {
    var a = r[i];
    n = n || a.isZeroArea(), kO(t, a), t.beginPath(), a.buildPath(t, a.shape), t.clip();
  }
  e.allClipped = n;
}
function BY(r, t) {
  return r && t ? r[0] !== t[0] || r[1] !== t[1] || r[2] !== t[2] || r[3] !== t[3] || r[4] !== t[4] || r[5] !== t[5] : !(!r && !t);
}
var NE = 1, OE = 2, kE = 3, BE = 4;
function VY(r) {
  var t = Wv(r), e = Hv(r);
  return !(r.lineDash || !(+t ^ +e) || t && typeof r.fill != "string" || e && typeof r.stroke != "string" || r.strokePercent < 1 || r.strokeOpacity < 1 || r.fillOpacity < 1);
}
function _n(r, t) {
  t.batchFill && r.fill(), t.batchStroke && r.stroke(), t.batchFill = "", t.batchStroke = "";
}
function hh(r, t) {
  return t && r.__hoverStyle || r.style;
}
function BO(r, t) {
  tl(r, t, { inHover: !1, viewWidth: 0, viewHeight: 0 }, !0);
}
function tl(r, t, e, n) {
  var i = t.transform;
  if (!t.shouldBePainted(e.viewWidth, e.viewHeight, !1, !1)) {
    t.__dirty &= ~Rn, t.__isRendered = !1;
    return;
  }
  var a = t.__clipPaths, o = e.prevElClipPaths, s = !1, l = !1;
  if ((!o || DY(a, o)) && (o && o.length && (_n(r, e), r.restore(), l = s = !0, e.prevElClipPaths = null, e.allClipped = !1, e.prevEl = null), a && a.length && (_n(r, e), r.save(), kY(a, r, e), s = !0), e.prevElClipPaths = a), e.allClipped) {
    t.__isRendered = !1;
    return;
  }
  t.beforeBrush && t.beforeBrush(), t.innerBeforeBrush();
  var u = e.prevEl;
  u || (l = s = !0);
  var c = t instanceof ne && t.autoBatch && VY(t.style);
  s || BY(i, u.transform) ? (_n(r, e), kO(r, t)) : c || _n(r, e);
  var f = hh(t, e.inHover);
  t instanceof ne ? (e.lastDrawType !== NE && (l = !0, e.lastDrawType = NE), PE(r, t, u, l, e), (!c || !e.batchFill && !e.batchStroke) && r.beginPath(), IY(r, t, f, c), c && (e.batchFill = f.fill || "", e.batchStroke = f.stroke || "")) : t instanceof rc ? (e.lastDrawType !== kE && (l = !0, e.lastDrawType = kE), PE(r, t, u, l, e), NY(r, t, f)) : t instanceof Vr ? (e.lastDrawType !== OE && (l = !0, e.lastDrawType = OE), OY(r, t, u, l, e), PY(r, t, f)) : t.getTemporalDisplayables && (e.lastDrawType !== BE && (l = !0, e.lastDrawType = BE), FY(r, t, e)), c && n && _n(r, e), t.innerAfterBrush(), t.afterBrush && t.afterBrush(), e.prevEl = t, t.__dirty = 0, t.__isRendered = !0;
}
function FY(r, t, e) {
  var n = t.getDisplayables(), i = t.getTemporalDisplayables();
  r.save();
  var a = {
    prevElClipPaths: null,
    prevEl: null,
    allClipped: !1,
    viewWidth: e.viewWidth,
    viewHeight: e.viewHeight,
    inHover: e.inHover
  }, o, s;
  for (o = t.getCursor(), s = n.length; o < s; o++) {
    var l = n[o];
    l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), tl(r, l, a, o === s - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), a.prevEl = l;
  }
  for (var u = 0, c = i.length; u < c; u++) {
    var l = i[u];
    l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), tl(r, l, a, u === c - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), a.prevEl = l;
  }
  t.clearTemporalDisplayables(), t.notClear = !0, r.restore();
}
var o0 = new yY(), VE = new Qu(100), FE = ["symbol", "symbolSize", "symbolKeepAspect", "color", "backgroundColor", "dashArrayX", "dashArrayY", "maxTileWidth", "maxTileHeight"];
function ac(r, t) {
  if (r === "none")
    return null;
  var e = t.getDevicePixelRatio(), n = t.getZr(), i = n.painter.type === "svg";
  r.dirty && o0.delete(r);
  var a = o0.get(r);
  if (a)
    return a;
  var o = kt(r, {
    symbol: "rect",
    symbolSize: 1,
    symbolKeepAspect: !0,
    color: "rgba(0, 0, 0, 0.2)",
    backgroundColor: null,
    dashArrayX: 5,
    dashArrayY: 5,
    rotation: 0,
    maxTileWidth: 512,
    maxTileHeight: 512
  });
  o.backgroundColor === "none" && (o.backgroundColor = null);
  var s = {
    repeat: "repeat"
  };
  return l(s), s.rotation = o.rotation, s.scaleX = s.scaleY = i ? 1 : 1 / e, o0.set(r, s), r.dirty = !1, s;
  function l(u) {
    for (var c = [e], f = !0, h = 0; h < FE.length; ++h) {
      var d = o[FE[h]];
      if (d != null && !et(d) && !pt(d) && !fe(d) && typeof d != "boolean") {
        f = !1;
        break;
      }
      c.push(d);
    }
    var p;
    if (f) {
      p = c.join(",") + (i ? "-svg" : "");
      var g = VE.get(p);
      g && (i ? u.svgElement = g : u.image = g);
    }
    var v = FO(o.dashArrayX), m = zY(o.dashArrayY), y = VO(o.symbol), _ = UY(v), x = zO(m), b = !i && xi.createCanvas(), S = i && {
      tag: "g",
      attrs: {},
      key: "dcl",
      children: []
    }, w = T(), A;
    b && (b.width = w.width * e, b.height = w.height * e, A = b.getContext("2d")), M(), f && VE.put(p, b || S), u.image = b, u.svgElement = S, u.svgWidth = w.width, u.svgHeight = w.height;
    function T() {
      for (var E = 1, R = 0, C = _.length; R < C; ++R)
        E = JT(E, _[R]);
      for (var D = 1, R = 0, C = y.length; R < C; ++R)
        D = JT(D, y[R].length);
      E *= D;
      var I = x * _.length * y.length;
      if (process.env.NODE_ENV !== "production") {
        var P = function(O) {
          console.warn("Calculated decal size is greater than " + O + " due to decal option settings so " + O + " is used for the decal size. Please consider changing the decal option to make a smaller decal or set " + O + " to be larger to avoid incontinuity.");
        };
        E > o.maxTileWidth && P("maxTileWidth"), I > o.maxTileHeight && P("maxTileHeight");
      }
      return {
        width: Math.max(1, Math.min(E, o.maxTileWidth)),
        height: Math.max(1, Math.min(I, o.maxTileHeight))
      };
    }
    function M() {
      A && (A.clearRect(0, 0, b.width, b.height), o.backgroundColor && (A.fillStyle = o.backgroundColor, A.fillRect(0, 0, b.width, b.height)));
      for (var E = 0, R = 0; R < m.length; ++R)
        E += m[R];
      if (E <= 0)
        return;
      for (var C = -x, D = 0, I = 0, P = 0; C < w.height; ) {
        if (D % 2 === 0) {
          for (var O = I / 2 % y.length, N = 0, B = 0, F = 0; N < w.width * 2; ) {
            for (var G = 0, R = 0; R < v[P].length; ++R)
              G += v[P][R];
            if (G <= 0)
              break;
            if (B % 2 === 0) {
              var X = (1 - o.symbolSize) * 0.5, K = N + v[P][B] * X, U = C + m[D] * X, $ = v[P][B] * o.symbolSize, ct = m[D] * o.symbolSize, at = F / 2 % y[O].length;
              lt(K, U, $, ct, y[O][at]);
            }
            N += v[P][B], ++F, ++B, B === v[P].length && (B = 0);
          }
          ++P, P === v.length && (P = 0);
        }
        C += m[D], ++I, ++D, D === m.length && (D = 0);
      }
      function lt(ot, H, st, ut, Gt) {
        var gt = i ? 1 : e, Lt = fr(Gt, ot * gt, H * gt, st * gt, ut * gt, o.color, o.symbolKeepAspect);
        if (i) {
          var Vt = n.painter.renderOneToVNode(Lt);
          Vt && S.children.push(Vt);
        } else
          BO(A, Lt);
      }
    }
  }
}
function VO(r) {
  if (!r || r.length === 0)
    return [["rect"]];
  if (pt(r))
    return [[r]];
  for (var t = !0, e = 0; e < r.length; ++e)
    if (!pt(r[e])) {
      t = !1;
      break;
    }
  if (t)
    return VO([r]);
  for (var n = [], e = 0; e < r.length; ++e)
    pt(r[e]) ? n.push([r[e]]) : n.push(r[e]);
  return n;
}
function FO(r) {
  if (!r || r.length === 0)
    return [[0, 0]];
  if (fe(r)) {
    var t = Math.ceil(r);
    return [[t, t]];
  }
  for (var e = !0, n = 0; n < r.length; ++n)
    if (!fe(r[n])) {
      e = !1;
      break;
    }
  if (e)
    return FO([r]);
  for (var i = [], n = 0; n < r.length; ++n)
    if (fe(r[n])) {
      var t = Math.ceil(r[n]);
      i.push([t, t]);
    } else {
      var t = rt(r[n], function(s) {
        return Math.ceil(s);
      });
      t.length % 2 === 1 ? i.push(t.concat(t)) : i.push(t);
    }
  return i;
}
function zY(r) {
  if (!r || typeof r == "object" && r.length === 0)
    return [0, 0];
  if (fe(r)) {
    var t = Math.ceil(r);
    return [t, t];
  }
  var e = rt(r, function(n) {
    return Math.ceil(n);
  });
  return r.length % 2 ? e.concat(e) : e;
}
function UY(r) {
  return rt(r, function(t) {
    return zO(t);
  });
}
function zO(r) {
  for (var t = 0, e = 0; e < r.length; ++e)
    t += r[e];
  return r.length % 2 === 1 ? t * 2 : t;
}
function GY(r, t) {
  r.eachRawSeries(function(e) {
    if (!r.isSeriesFiltered(e)) {
      var n = e.getData();
      n.hasItemVisual() && n.each(function(o) {
        var s = n.getItemVisual(o, "decal");
        if (s) {
          var l = n.ensureUniqueItemVisual(o, "style");
          l.decal = ac(s, t);
        }
      });
      var i = n.getVisual("decal");
      if (i) {
        var a = n.getVisual("style");
        a.decal = ac(i, t);
      }
    }
  });
}
var hi = new oi(), Xv = {};
function HY(r, t) {
  process.env.NODE_ENV !== "production" && Xv[r] && ce("Already has an implementation of " + r + "."), Xv[r] = t;
}
function WY(r) {
  return process.env.NODE_ENV !== "production" && (Xv[r] || ce("Implementation of " + r + " doesn't exists.")), Xv[r];
}
var UO = {};
function XY(r, t) {
  UO[r] = t;
}
function YY(r) {
  return UO[r];
}
var $Y = 1, ZY = 800, qY = 900, KY = 1e3, jY = 2e3, JY = 5e3, GO = 1e3, QY = 1100, hb = 2e3, HO = 3e3, t$ = 4e3, dm = 4500, e$ = 4600, r$ = 5e3, n$ = 6e3, WO = 7e3, i$ = {
  PROCESSOR: {
    FILTER: KY,
    SERIES_FILTER: ZY,
    STATISTIC: JY
  },
  VISUAL: {
    LAYOUT: GO,
    PROGRESSIVE_LAYOUT: QY,
    GLOBAL: hb,
    CHART: HO,
    POST_CHART_LAYOUT: e$,
    COMPONENT: t$,
    BRUSH: r$,
    CHART_ITEM: dm,
    ARIA: n$,
    DECAL: WO
  }
}, vr = "__flagInMainProcess", Kd = "__mainProcessVersion", Dr = "__pendingUpdate", s0 = "__needsUpdateStatus", zE = /^[a-zA-Z0-9_]+$/, l0 = "__connectUpdateStatus", UE = 0, a$ = 1, o$ = 2;
function XO(r) {
  return function() {
    for (var t = [], e = 0; e < arguments.length; e++)
      t[e] = arguments[e];
    if (this.isDisposed()) {
      gn(this.id);
      return;
    }
    return $O(this, r, t);
  };
}
function YO(r) {
  return function() {
    for (var t = [], e = 0; e < arguments.length; e++)
      t[e] = arguments[e];
    return $O(this, r, t);
  };
}
function $O(r, t, e) {
  return e[0] = e[0] && e[0].toLowerCase(), oi.prototype[t].apply(r, e);
}
var ZO = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t;
  }(oi)
), qO = ZO.prototype;
qO.on = YO("on");
qO.off = YO("off");
var Es, u0, jd, _a, Jd, c0, f0, uu, cu, GE, HE, h0, WE, Qd, XE, KO, Gn, YE, fu, jO = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e, n, i) {
      var a = r.call(this, new hY()) || this;
      a._chartsViews = [], a._chartsMap = {}, a._componentsViews = [], a._componentsMap = {}, a._pendingActions = [], i = i || {}, a._dom = e;
      var o = "canvas", s = "auto", l = !1;
      if (a[Kd] = 1, process.env.NODE_ENV !== "production") {
        var u = (
          /* eslint-disable-next-line */
          oe.hasGlobalWindow ? window : global
        );
        u && (o = bt(u.__ECHARTS__DEFAULT__RENDERER__, o), s = bt(u.__ECHARTS__DEFAULT__COARSE_POINTER, s), l = bt(u.__ECHARTS__DEFAULT__USE_DIRTY_RECT__, l));
      }
      i.ssr && k8(function(d) {
        var p = zt(d), g = p.dataIndex;
        if (g != null) {
          var v = wt();
          return v.set("series_index", p.seriesIndex), v.set("data_index", g), p.ssrType && v.set("ssr_type", p.ssrType), v;
        }
      });
      var c = a._zr = ZT(e, {
        renderer: i.renderer || o,
        devicePixelRatio: i.devicePixelRatio,
        width: i.width,
        height: i.height,
        ssr: i.ssr,
        useDirtyRect: bt(i.useDirtyRect, l),
        useCoarsePointer: bt(i.useCoarsePointer, s),
        pointerSize: i.pointerSize
      });
      a._ssr = i.ssr, a._throttledZrFlush = ub(mt(c.flush, c), 17), a._updateTheme(n), a._locale = c9(i.locale || CN), a._coordSysMgr = new Ec();
      var f = a._api = XE(a);
      function h(d, p) {
        return d.__prio - p.__prio;
      }
      return Wp(Zv, h), Wp(tS, h), a._scheduler = new CO(a, f, tS, Zv), a._messageCenter = new ZO(), a._initEvents(), a.resize = mt(a.resize, a), c.animation.on("frame", a._onframe, a), GE(c, a), HE(c, a), yv(a), a;
    }
    return t.prototype._onframe = function() {
      if (!this._disposed) {
        YE(this);
        var e = this._scheduler;
        if (this[Dr]) {
          var n = this[Dr].silent;
          this[vr] = !0, fu(this);
          try {
            Es(this), _a.update.call(this, null, this[Dr].updateParams);
          } catch (l) {
            throw this[vr] = !1, this[Dr] = null, l;
          }
          this._zr.flush(), this[vr] = !1, this[Dr] = null, uu.call(this, n), cu.call(this, n);
        } else if (e.unfinished) {
          var i = $Y, a = this._model, o = this._api;
          e.unfinished = !1;
          do {
            var s = +/* @__PURE__ */ new Date();
            e.performSeriesTasks(a), e.performDataProcessorTasks(a), c0(this, a), e.performVisualTasks(a), Qd(this, this._model, o, "remain", {}), i -= +/* @__PURE__ */ new Date() - s;
          } while (i > 0 && e.unfinished);
          e.unfinished || this._zr.flush();
        }
      }
    }, t.prototype.getDom = function() {
      return this._dom;
    }, t.prototype.getId = function() {
      return this.id;
    }, t.prototype.getZr = function() {
      return this._zr;
    }, t.prototype.isSSR = function() {
      return this._ssr;
    }, t.prototype.setOption = function(e, n, i) {
      if (this[vr]) {
        process.env.NODE_ENV !== "production" && ce("`setOption` should not be called during main process.");
        return;
      }
      if (this._disposed) {
        gn(this.id);
        return;
      }
      var a, o, s;
      if (Dt(n) && (i = n.lazyUpdate, a = n.silent, o = n.replaceMerge, s = n.transition, n = n.notMerge), this[vr] = !0, fu(this), !this._model || n) {
        var l = new $9(this._api), u = this._theme, c = this._model = new ab();
        c.scheduler = this._scheduler, c.ssr = this._ssr, c.init(null, null, null, u, this._locale, l);
      }
      this._model.setOption(e, {
        replaceMerge: o
      }, eS);
      var f = {
        seriesTransition: s,
        optionChanged: !0
      };
      if (i)
        this[Dr] = {
          silent: a,
          updateParams: f
        }, this[vr] = !1, this.getZr().wakeUp();
      else {
        try {
          Es(this), _a.update.call(this, null, f);
        } catch (h) {
          throw this[Dr] = null, this[vr] = !1, h;
        }
        this._ssr || this._zr.flush(), this[Dr] = null, this[vr] = !1, uu.call(this, a), cu.call(this, a);
      }
    }, t.prototype.setTheme = function(e, n) {
      if (this[vr]) {
        process.env.NODE_ENV !== "production" && ce("`setTheme` should not be called during main process.");
        return;
      }
      if (this._disposed) {
        gn(this.id);
        return;
      }
      var i = this._model;
      if (i) {
        var a = n && n.silent, o = null;
        this[Dr] && (a == null && (a = this[Dr].silent), o = this[Dr].updateParams, this[Dr] = null), this[vr] = !0, fu(this);
        try {
          this._updateTheme(e), i.setTheme(this._theme), Es(this), _a.update.call(this, {
            type: "setTheme"
          }, o);
        } catch (s) {
          throw this[vr] = !1, s;
        }
        this[vr] = !1, uu.call(this, a), cu.call(this, a);
      }
    }, t.prototype._updateTheme = function(e) {
      pt(e) && (e = JO[e]), e && (e = Ct(e), e && nO(e, !0), this._theme = e);
    }, t.prototype.getModel = function() {
      return this._model;
    }, t.prototype.getOption = function() {
      return this._model && this._model.getOption();
    }, t.prototype.getWidth = function() {
      return this._zr.getWidth();
    }, t.prototype.getHeight = function() {
      return this._zr.getHeight();
    }, t.prototype.getDevicePixelRatio = function() {
      return this._zr.painter.dpr || oe.hasGlobalWindow && window.devicePixelRatio || 1;
    }, t.prototype.getRenderedCanvas = function(e) {
      return process.env.NODE_ENV !== "production" && ar("getRenderedCanvas", "renderToCanvas"), this.renderToCanvas(e);
    }, t.prototype.renderToCanvas = function(e) {
      e = e || {};
      var n = this._zr.painter;
      if (process.env.NODE_ENV !== "production" && n.type !== "canvas")
        throw new Error("renderToCanvas can only be used in the canvas renderer.");
      return n.getRenderedCanvas({
        backgroundColor: e.backgroundColor || this._model.get("backgroundColor"),
        pixelRatio: e.pixelRatio || this.getDevicePixelRatio()
      });
    }, t.prototype.renderToSVGString = function(e) {
      e = e || {};
      var n = this._zr.painter;
      if (process.env.NODE_ENV !== "production" && n.type !== "svg")
        throw new Error("renderToSVGString can only be used in the svg renderer.");
      return n.renderToString({
        useViewBox: e.useViewBox
      });
    }, t.prototype.getSvgDataURL = function() {
      var e = this._zr, n = e.storage.getDisplayList();
      return L(n, function(i) {
        i.stopAnimation(null, !0);
      }), e.painter.toDataURL();
    }, t.prototype.getDataURL = function(e) {
      if (this._disposed) {
        gn(this.id);
        return;
      }
      e = e || {};
      var n = e.excludeComponents, i = this._model, a = [], o = this;
      L(n, function(l) {
        i.eachComponent({
          mainType: l
        }, function(u) {
          var c = o._componentsMap[u.__viewId];
          c.group.ignore || (a.push(c), c.group.ignore = !0);
        });
      });
      var s = this._zr.painter.getType() === "svg" ? this.getSvgDataURL() : this.renderToCanvas(e).toDataURL("image/" + (e && e.type || "png"));
      return L(a, function(l) {
        l.group.ignore = !1;
      }), s;
    }, t.prototype.getConnectedDataURL = function(e) {
      if (this._disposed) {
        gn(this.id);
        return;
      }
      var n = e.type === "svg", i = this.group, a = Math.min, o = Math.max, s = 1 / 0;
      if ($E[i]) {
        var l = s, u = s, c = -s, f = -s, h = [], d = e && e.pixelRatio || this.getDevicePixelRatio();
        L(qf, function(_, x) {
          if (_.group === i) {
            var b = n ? _.getZr().painter.getSvgDom().innerHTML : _.renderToCanvas(Ct(e)), S = _.getDom().getBoundingClientRect();
            l = a(S.left, l), u = a(S.top, u), c = o(S.right, c), f = o(S.bottom, f), h.push({
              dom: b,
              left: S.left,
              top: S.top
            });
          }
        }), l *= d, u *= d, c *= d, f *= d;
        var p = c - l, g = f - u, v = xi.createCanvas(), m = ZT(v, {
          renderer: n ? "svg" : "canvas"
        });
        if (m.resize({
          width: p,
          height: g
        }), n) {
          var y = "";
          return L(h, function(_) {
            var x = _.left - l, b = _.top - u;
            y += '<g transform="translate(' + x + "," + b + ')">' + _.dom + "</g>";
          }), m.painter.getSvgRoot().innerHTML = y, e.connectedBackgroundColor && m.painter.setBackgroundColor(e.connectedBackgroundColor), m.refreshImmediately(), m.painter.toDataURL();
        } else
          return e.connectedBackgroundColor && m.add(new te({
            shape: {
              x: 0,
              y: 0,
              width: p,
              height: g
            },
            style: {
              fill: e.connectedBackgroundColor
            }
          })), L(h, function(_) {
            var x = new Vr({
              style: {
                x: _.left * d - l,
                y: _.top * d - u,
                image: _.dom
              }
            });
            m.add(x);
          }), m.refreshImmediately(), v.toDataURL("image/" + (e && e.type || "png"));
      } else
        return this.getDataURL(e);
    }, t.prototype.convertToPixel = function(e, n, i) {
      return Jd(this, "convertToPixel", e, n, i);
    }, t.prototype.convertToLayout = function(e, n, i) {
      return Jd(this, "convertToLayout", e, n, i);
    }, t.prototype.convertFromPixel = function(e, n, i) {
      return Jd(this, "convertFromPixel", e, n, i);
    }, t.prototype.containPixel = function(e, n) {
      if (this._disposed) {
        gn(this.id);
        return;
      }
      var i = this._model, a, o = Wu(i, e);
      return L(o, function(s, l) {
        l.indexOf("Models") >= 0 && L(s, function(u) {
          var c = u.coordinateSystem;
          if (c && c.containPoint)
            a = a || !!c.containPoint(n);
          else if (l === "seriesModels") {
            var f = this._chartsMap[u.__viewId];
            f && f.containPoint ? a = a || f.containPoint(n, u) : process.env.NODE_ENV !== "production" && Xe(l + ": " + (f ? "The found component do not support containPoint." : "No view mapping to the found component."));
          } else
            process.env.NODE_ENV !== "production" && Xe(l + ": containPoint is not supported");
        }, this);
      }, this), !!a;
    }, t.prototype.getVisual = function(e, n) {
      var i = this._model, a = Wu(i, e, {
        defaultMainType: "series"
      }), o = a.seriesModel;
      process.env.NODE_ENV !== "production" && (o || Xe("There is no specified series model"));
      var s = o.getData(), l = a.hasOwnProperty("dataIndexInside") ? a.dataIndexInside : a.hasOwnProperty("dataIndex") ? s.indexOfRawIndex(a.dataIndex) : null;
      return l != null ? cb(s, l, n) : Uh(s, n);
    }, t.prototype.getViewOfComponentModel = function(e) {
      return this._componentsMap[e.__viewId];
    }, t.prototype.getViewOfSeriesModel = function(e) {
      return this._chartsMap[e.__viewId];
    }, t.prototype._initEvents = function() {
      var e = this;
      L(s$, function(i) {
        var a = function(o) {
          var s = e.getModel(), l = o.target, u, c = i === "globalout";
          if (c ? u = {} : l && Js(l, function(g) {
            var v = zt(g);
            if (v && v.dataIndex != null) {
              var m = v.dataModel || s.getSeriesByIndex(v.seriesIndex);
              return u = m && m.getDataParams(v.dataIndex, v.dataType, l) || {}, !0;
            } else if (v.eventData)
              return u = J({}, v.eventData), !0;
          }, !0), u) {
            var f = u.componentType, h = u.componentIndex;
            (f === "markLine" || f === "markPoint" || f === "markArea") && (f = "series", h = u.seriesIndex);
            var d = f && h != null && s.getComponent(f, h), p = d && e[d.mainType === "series" ? "_chartsMap" : "_componentsMap"][d.__viewId];
            process.env.NODE_ENV !== "production" && !c && !(d && p) && Xe("model or view can not be found by params"), u.event = o, u.type = i, e._$eventProcessor.eventInfo = {
              targetEl: l,
              packedEvent: u,
              model: d,
              view: p
            }, e.trigger(i, u);
          }
        };
        a.zrEventfulCallAtLast = !0, e._zr.on(i, a, e);
      });
      var n = this._messageCenter;
      L(Qx, function(i, a) {
        n.on(a, function(o) {
          e.trigger(a, o);
        });
      }), vY(n, this, this._api);
    }, t.prototype.isDisposed = function() {
      return this._disposed;
    }, t.prototype.clear = function() {
      if (this._disposed) {
        gn(this.id);
        return;
      }
      this.setOption({
        series: []
      }, !0);
    }, t.prototype.dispose = function() {
      if (this._disposed) {
        gn(this.id);
        return;
      }
      this._disposed = !0;
      var e = this.getDom();
      e && BP(this.getDom(), pb, "");
      var n = this, i = n._api, a = n._model;
      L(n._componentsViews, function(o) {
        o.dispose(a, i);
      }), L(n._chartsViews, function(o) {
        o.dispose(a, i);
      }), n._zr.dispose(), n._dom = n._model = n._chartsMap = n._componentsMap = n._chartsViews = n._componentsViews = n._scheduler = n._api = n._zr = n._throttledZrFlush = n._theme = n._coordSysMgr = n._messageCenter = null, delete qf[n.id];
    }, t.prototype.resize = function(e) {
      if (this[vr]) {
        process.env.NODE_ENV !== "production" && ce("`resize` should not be called during main process.");
        return;
      }
      if (this._disposed) {
        gn(this.id);
        return;
      }
      this._zr.resize(e);
      var n = this._model;
      if (this._loadingFX && this._loadingFX.resize(), !!n) {
        var i = n.resetOption("media"), a = e && e.silent;
        this[Dr] && (a == null && (a = this[Dr].silent), i = !0, this[Dr] = null), this[vr] = !0, fu(this);
        try {
          i && Es(this), _a.update.call(this, {
            type: "resize",
            animation: J({
              // Disable animation
              duration: 0
            }, e && e.animation)
          });
        } catch (o) {
          throw this[vr] = !1, o;
        }
        this[vr] = !1, uu.call(this, a), cu.call(this, a);
      }
    }, t.prototype.showLoading = function(e, n) {
      if (this._disposed) {
        gn(this.id);
        return;
      }
      if (Dt(e) && (n = e, e = ""), e = e || "default", this.hideLoading(), !rS[e]) {
        process.env.NODE_ENV !== "production" && Xe("Loading effects " + e + " not exists.");
        return;
      }
      var i = rS[e](this._api, n), a = this._zr;
      this._loadingFX = i, a.add(i);
    }, t.prototype.hideLoading = function() {
      if (this._disposed) {
        gn(this.id);
        return;
      }
      this._loadingFX && this._zr.remove(this._loadingFX), this._loadingFX = null;
    }, t.prototype.makeActionFromEvent = function(e) {
      var n = J({}, e);
      return n.type = $v[e.type], n;
    }, t.prototype.dispatchAction = function(e, n) {
      if (this._disposed) {
        gn(this.id);
        return;
      }
      if (Dt(n) || (n = {
        silent: !!n
      }), !!Yv[e.type] && this._model) {
        if (this[vr]) {
          this._pendingActions.push(e);
          return;
        }
        var i = n.silent;
        f0.call(this, e, i);
        var a = n.flush;
        a ? this._zr.flush() : a !== !1 && oe.browser.weChat && this._throttledZrFlush(), uu.call(this, i), cu.call(this, i);
      }
    }, t.prototype.updateLabelLayout = function() {
      hi.trigger("series:layoutlabels", this._model, this._api, {
        // Not adding series labels.
        // TODO
        updatedSeries: []
      });
    }, t.prototype.appendData = function(e) {
      if (this._disposed) {
        gn(this.id);
        return;
      }
      var n = e.seriesIndex, i = this.getModel(), a = i.getSeriesByIndex(n);
      process.env.NODE_ENV !== "production" && St(e.data && a), a.appendData(e), this._scheduler.unfinished = !0, this.getZr().wakeUp();
    }, t.internalField = function() {
      Es = function(f) {
        var h = f._scheduler;
        h.restorePipelines(f._model), h.prepareStageTasks(), u0(f, !0), u0(f, !1), h.plan();
      }, u0 = function(f, h) {
        for (var d = f._model, p = f._scheduler, g = h ? f._componentsViews : f._chartsViews, v = h ? f._componentsMap : f._chartsMap, m = f._zr, y = f._api, _ = 0; _ < g.length; _++)
          g[_].__alive = !1;
        h ? d.eachComponent(function(S, w) {
          S !== "series" && x(w);
        }) : d.eachSeries(x);
        function x(S) {
          var w = S.__requireNewView;
          S.__requireNewView = !1;
          var A = "_ec_" + S.id + "_" + S.type, T = !w && v[A];
          if (!T) {
            var M = $i(S.type), E = h ? Ue.getClass(M.main, M.sub) : (
              // FIXME:TS
              // (ChartView as ChartViewConstructor).getClass('series', classType.sub)
              // For backward compat, still support a chart type declared as only subType
              // like "liquidfill", but recommend "series.liquidfill"
              // But need a base class to make a type series.
              Re.getClass(M.sub)
            );
            process.env.NODE_ENV !== "production" && St(E, M.sub + " does not exist."), T = new E(), T.init(d, y), v[A] = T, g.push(T), m.add(T.group);
          }
          S.__viewId = T.__id = A, T.__alive = !0, T.__model = S, T.group.__ecComponentInfo = {
            mainType: S.mainType,
            index: S.componentIndex
          }, !h && p.prepareView(T, S, d, y);
        }
        for (var _ = 0; _ < g.length; ) {
          var b = g[_];
          b.__alive ? _++ : (!h && b.renderTask.dispose(), m.remove(b.group), b.dispose(d, y), g.splice(_, 1), v[b.__id] === b && delete v[b.__id], b.__id = b.group.__ecComponentInfo = null);
        }
      }, jd = function(f, h, d, p, g) {
        var v = f._model;
        if (v.setUpdatePayload(d), !p) {
          L([].concat(f._componentsViews).concat(f._chartsViews), b);
          return;
        }
        var m = {};
        m[p + "Id"] = d[p + "Id"], m[p + "Index"] = d[p + "Index"], m[p + "Name"] = d[p + "Name"];
        var y = {
          mainType: p,
          query: m
        };
        g && (y.subType = g);
        var _ = d.excludeSeriesId, x;
        _ != null && (x = wt(), L(Ie(_), function(S) {
          var w = mr(S, null);
          w != null && x.set(w, !0);
        })), v && v.eachComponent(y, function(S) {
          var w = x && x.get(S.id) != null;
          if (!w)
            if (LA(d))
              if (S instanceof ke)
                d.type === il && !d.notBlur && !S.get(["emphasis", "disabled"]) && l7(S, d, f._api);
              else {
                var A = F1(S.mainType, S.componentIndex, d.name, f._api), T = A.focusSelf, M = A.dispatchers;
                d.type === il && T && !d.notBlur && Dx(S.mainType, S.componentIndex, f._api), M && L(M, function(E) {
                  d.type === il ? Ha(E) : Wa(E);
                });
              }
            else
              Rx(d) && S instanceof ke && (f7(S, d, f._api), CA(S), Gn(f));
        }, f), v && v.eachComponent(y, function(S) {
          var w = x && x.get(S.id) != null;
          w || b(f[p === "series" ? "_chartsMap" : "_componentsMap"][S.__viewId]);
        }, f);
        function b(S) {
          S && S.__alive && S[h] && S[h](S.__model, v, f._api, d);
        }
      }, _a = {
        prepareAndUpdate: function(f) {
          Es(this), _a.update.call(this, f, f && {
            // Needs to mark option changed if newOption is given.
            // It's from MagicType.
            // TODO If use a separate flag optionChanged in payload?
            optionChanged: f.newOption != null
          });
        },
        update: function(f, h) {
          var d = this._model, p = this._api, g = this._zr, v = this._coordSysMgr, m = this._scheduler;
          if (d) {
            d.setUpdatePayload(f), m.restoreData(d, f), m.performSeriesTasks(d), v.create(d, p), m.performDataProcessorTasks(d, f), c0(this, d), v.update(d, p), n(d), m.performVisualTasks(d, f);
            var y = d.get("backgroundColor") || "transparent";
            g.setBackgroundColor(y);
            var _ = d.get("darkMode");
            _ != null && _ !== "auto" && g.setDarkMode(_), h0(this, d, p, f, h), hi.trigger("afterupdate", d, p);
          }
        },
        updateTransform: function(f) {
          var h = this, d = this._model, p = this._api;
          if (d) {
            d.setUpdatePayload(f);
            var g = [];
            d.eachComponent(function(m, y) {
              if (m !== "series") {
                var _ = h.getViewOfComponentModel(y);
                if (_ && _.__alive)
                  if (_.updateTransform) {
                    var x = _.updateTransform(y, d, p, f);
                    x && x.update && g.push(_);
                  } else
                    g.push(_);
              }
            });
            var v = wt();
            d.eachSeries(function(m) {
              var y = h._chartsMap[m.__viewId];
              if (y.updateTransform) {
                var _ = y.updateTransform(m, d, p, f);
                _ && _.update && v.set(m.uid, 1);
              } else
                v.set(m.uid, 1);
            }), n(d), this._scheduler.performVisualTasks(d, f, {
              setDirty: !0,
              dirtyMap: v
            }), Qd(this, d, p, f, {}, v), hi.trigger("afterupdate", d, p);
          }
        },
        updateView: function(f) {
          var h = this._model;
          h && (h.setUpdatePayload(f), Re.markUpdateMethod(f, "updateView"), n(h), this._scheduler.performVisualTasks(h, f, {
            setDirty: !0
          }), h0(this, h, this._api, f, {}), hi.trigger("afterupdate", h, this._api));
        },
        updateVisual: function(f) {
          var h = this, d = this._model;
          d && (d.setUpdatePayload(f), d.eachSeries(function(p) {
            p.getData().clearAllVisual();
          }), Re.markUpdateMethod(f, "updateVisual"), n(d), this._scheduler.performVisualTasks(d, f, {
            visualType: "visual",
            setDirty: !0
          }), d.eachComponent(function(p, g) {
            if (p !== "series") {
              var v = h.getViewOfComponentModel(g);
              v && v.__alive && v.updateVisual(g, d, h._api, f);
            }
          }), d.eachSeries(function(p) {
            var g = h._chartsMap[p.__viewId];
            g.updateVisual(p, d, h._api, f);
          }), hi.trigger("afterupdate", d, this._api));
        },
        updateLayout: function(f) {
          _a.update.call(this, f);
        }
      };
      function e(f, h, d, p, g) {
        if (f._disposed) {
          gn(f.id);
          return;
        }
        for (var v = f._model, m = f._coordSysMgr.getCoordinateSystems(), y, _ = Wu(v, d), x = 0; x < m.length; x++) {
          var b = m[x];
          if (b[h] && (y = b[h](v, _, p, g)) != null)
            return y;
        }
        process.env.NODE_ENV !== "production" && Xe("No coordinate system that supports " + h + " found by the given finder.");
      }
      Jd = e, c0 = function(f, h) {
        var d = f._chartsMap, p = f._scheduler;
        h.eachSeries(function(g) {
          p.updateStreamModes(g, d[g.__viewId]);
        });
      }, f0 = function(f, h) {
        var d = this, p = this.getModel(), g = f.type, v = f.escapeConnect, m = Yv[g], y = (m.update || "update").split(":"), _ = y.pop(), x = y[0] != null && $i(y[0]);
        this[vr] = !0, fu(this);
        var b = [f], S = !1;
        f.batch && (S = !0, b = rt(f.batch, function(P) {
          return P = kt(J({}, P), f), P.batch = null, P;
        }));
        var w = [], A, T = [], M = m.nonRefinedEventType, E = Rx(f), R = LA(f);
        if (R && iN(this._api), L(b, function(P) {
          var O = m.action(P, p, d._api);
          if (m.refineEvent ? T.push(O) : A = O, A = A || J({}, P), A.type = M, w.push(A), R) {
            var N = L1(f), B = N.queryOptionMap, F = N.mainTypeSpecified, G = F ? B.keys()[0] : "series";
            jd(d, _, P, G), Gn(d);
          } else
            E ? (jd(d, _, P, "series"), Gn(d)) : x && jd(d, _, P, x.main, x.sub);
        }), _ !== "none" && !R && !E && !x)
          try {
            this[Dr] ? (Es(this), _a.update.call(this, f), this[Dr] = null) : _a[_].call(this, f);
          } catch (P) {
            throw this[vr] = !1, P;
          }
        if (S ? A = {
          type: M,
          escapeConnect: v,
          batch: w
        } : A = w[0], this[vr] = !1, !h) {
          var C = void 0;
          if (m.refineEvent) {
            var D = m.refineEvent(T, f, p, this._api).eventContent;
            St(Dt(D)), C = kt({
              type: m.refinedEventType
            }, D), C.fromAction = f.type, C.fromActionPayload = f, C.escapeConnect = !0;
          }
          var I = this._messageCenter;
          I.trigger(A.type, A), C && I.trigger(C.type, C);
        }
      }, uu = function(f) {
        for (var h = this._pendingActions; h.length; ) {
          var d = h.shift();
          f0.call(this, d, f);
        }
      }, cu = function(f) {
        !f && this.trigger("updated");
      }, GE = function(f, h) {
        f.on("rendered", function(d) {
          h.trigger("rendered", d), // Although zr is dirty if initial animation is not finished
          // and this checking is called on frame, we also check
          // animation finished for robustness.
          f.animation.isFinished() && !h[Dr] && !h._scheduler.unfinished && !h._pendingActions.length && h.trigger("finished");
        });
      }, HE = function(f, h) {
        f.on("mouseover", function(d) {
          var p = d.target, g = Js(p, Uo);
          g && (u7(g, d, h._api), Gn(h));
        }).on("mouseout", function(d) {
          var p = d.target, g = Js(p, Uo);
          g && (c7(g, d, h._api), Gn(h));
        }).on("click", function(d) {
          var p = d.target, g = Js(p, function(y) {
            return zt(y).dataIndex != null;
          }, !0);
          if (g) {
            var v = g.selected ? "unselect" : "select", m = zt(g);
            h._api.dispatchAction({
              type: v,
              dataType: m.dataType,
              dataIndexInside: m.dataIndex,
              seriesIndex: m.seriesIndex,
              isFromClick: !0
            });
          }
        });
      };
      function n(f) {
        f.clearColorPalette(), f.eachSeries(function(h) {
          h.clearColorPalette();
        });
      }
      function i(f) {
        var h = [], d = [], p = !1;
        if (f.eachComponent(function(y, _) {
          var x = _.get("zlevel") || 0, b = _.get("z") || 0, S = _.getZLevelKey();
          p = p || !!S, (y === "series" ? d : h).push({
            zlevel: x,
            z: b,
            idx: _.componentIndex,
            type: y,
            key: S
          });
        }), p) {
          var g = h.concat(d), v, m;
          Wp(g, function(y, _) {
            return y.zlevel === _.zlevel ? y.z - _.z : y.zlevel - _.zlevel;
          }), L(g, function(y) {
            var _ = f.getComponent(y.type, y.idx), x = y.zlevel, b = y.key;
            v != null && (x = Math.max(v, x)), b ? (x === v && b !== m && x++, m = b) : m && (x === v && x++, m = ""), v = x, _.setZLevel(x);
          });
        }
      }
      h0 = function(f, h, d, p, g) {
        i(h), WE(f, h, d, p, g), L(f._chartsViews, function(v) {
          v.__alive = !1;
        }), Qd(f, h, d, p, g), L(f._chartsViews, function(v) {
          v.__alive || v.remove(h, d);
        });
      }, WE = function(f, h, d, p, g, v) {
        L(v || f._componentsViews, function(m) {
          var y = m.__model;
          u(y, m), m.render(y, h, d, p), l(y, m), c(y, m);
        });
      }, Qd = function(f, h, d, p, g, v) {
        var m = f._scheduler;
        g = J(g || {}, {
          updatedSeries: h.getSeries()
        }), hi.trigger("series:beforeupdate", h, d, g);
        var y = !1;
        h.eachSeries(function(_) {
          var x = f._chartsMap[_.__viewId];
          x.__alive = !0;
          var b = x.renderTask;
          m.updatePayload(b, p), u(_, x), v && v.get(_.uid) && b.dirty(), b.perform(m.getPerformArgs(b)) && (y = !0), x.group.silent = !!_.get("silent"), s(_, x), CA(_);
        }), m.unfinished = y || m.unfinished, hi.trigger("series:layoutlabels", h, d, g), hi.trigger("series:transition", h, d, g), h.eachSeries(function(_) {
          var x = f._chartsMap[_.__viewId];
          l(_, x), c(_, x);
        }), o(f, h), hi.trigger("series:afterupdate", h, d, g);
      }, Gn = function(f) {
        f[s0] = !0, f.getZr().wakeUp();
      }, fu = function(f) {
        f[Kd] = (f[Kd] + 1) % 1e3;
      }, YE = function(f) {
        f[s0] && (f.getZr().storage.traverse(function(h) {
          Xu(h) || a(h);
        }), f[s0] = !1);
      };
      function a(f) {
        for (var h = [], d = f.currentStates, p = 0; p < d.length; p++) {
          var g = d[p];
          g === "emphasis" || g === "blur" || g === "select" || h.push(g);
        }
        f.selected && f.states.select && h.push("select"), f.hoverState === tm && f.states.emphasis ? h.push("emphasis") : f.hoverState === Nh && f.states.blur && h.push("blur"), f.useStates(h);
      }
      function o(f, h) {
        var d = f._zr, p = d.storage, g = 0;
        p.traverse(function(v) {
          v.isGroup || g++;
        }), g > h.get("hoverLayerThreshold") && !oe.node && !oe.worker && h.eachSeries(function(v) {
          if (!v.preventUsingHoverLayer) {
            var m = f._chartsMap[v.__viewId];
            m.__alive && m.eachRendered(function(y) {
              y.states.emphasis && (y.states.emphasis.hoverLayer = !0);
            });
          }
        });
      }
      function s(f, h) {
        var d = f.get("blendMode") || null;
        h.eachRendered(function(p) {
          p.isGroup || (p.style.blend = d);
        });
      }
      function l(f, h) {
        if (!f.preventAutoZ) {
          var d = ml(f);
          h.eachRendered(function(p) {
            return om(p, d.z, d.zlevel), !0;
          });
        }
      }
      function u(f, h) {
        h.eachRendered(function(d) {
          if (!Xu(d)) {
            var p = d.getTextContent(), g = d.getTextGuideLine();
            d.stateTransition && (d.stateTransition = null), p && p.stateTransition && (p.stateTransition = null), g && g.stateTransition && (g.stateTransition = null), d.hasState() ? (d.prevStates = d.currentStates, d.clearStates()) : d.prevStates && (d.prevStates = null);
          }
        });
      }
      function c(f, h) {
        var d = f.getModel("stateAnimation"), p = f.isAnimationEnabled(), g = d.get("duration"), v = g > 0 ? {
          duration: g,
          delay: d.get("delay"),
          easing: d.get("easing")
          // additive: stateAnimationModel.get('additive')
        } : null;
        h.eachRendered(function(m) {
          if (m.states && m.states.emphasis) {
            if (Xu(m))
              return;
            if (m instanceof ne && m7(m), m.__dirty) {
              var y = m.prevStates;
              y && m.useStates(y);
            }
            if (p) {
              m.stateTransition = v;
              var _ = m.getTextContent(), x = m.getTextGuideLine();
              _ && (_.stateTransition = v), x && (x.stateTransition = v);
            }
            m.__dirty && a(m);
          }
        });
      }
      XE = function(f) {
        return new /** @class */
        (function(h) {
          W(d, h);
          function d() {
            return h !== null && h.apply(this, arguments) || this;
          }
          return d.prototype.getCoordinateSystems = function() {
            return f._coordSysMgr.getCoordinateSystems();
          }, d.prototype.getComponentByElement = function(p) {
            for (; p; ) {
              var g = p.__ecComponentInfo;
              if (g != null)
                return f._model.getComponent(g.mainType, g.index);
              p = p.parent;
            }
          }, d.prototype.enterEmphasis = function(p, g) {
            Ha(p, g), Gn(f);
          }, d.prototype.leaveEmphasis = function(p, g) {
            Wa(p, g), Gn(f);
          }, d.prototype.enterBlur = function(p) {
            tN(p), Gn(f);
          }, d.prototype.leaveBlur = function(p) {
            V1(p), Gn(f);
          }, d.prototype.enterSelect = function(p) {
            eN(p), Gn(f);
          }, d.prototype.leaveSelect = function(p) {
            rN(p), Gn(f);
          }, d.prototype.getModel = function() {
            return f.getModel();
          }, d.prototype.getViewOfComponentModel = function(p) {
            return f.getViewOfComponentModel(p);
          }, d.prototype.getViewOfSeriesModel = function(p) {
            return f.getViewOfSeriesModel(p);
          }, d.prototype.getMainProcessVersion = function() {
            return f[Kd];
          }, d;
        }(eO))(f);
      }, KO = function(f) {
        function h(d, p) {
          for (var g = 0; g < d.length; g++) {
            var v = d[g];
            v[l0] = p;
          }
        }
        L($v, function(d, p) {
          f._messageCenter.on(p, function(g) {
            if ($E[f.group] && f[l0] !== UE) {
              if (g && g.escapeConnect)
                return;
              var v = f.makeActionFromEvent(g), m = [];
              L(qf, function(y) {
                y !== f && y.group === f.group && m.push(y);
              }), h(m, UE), L(m, function(y) {
                y[l0] !== a$ && y.dispatchAction(v);
              }), h(m, o$);
            }
          });
        });
      };
    }(), t;
  }(oi)
), db = jO.prototype;
db.on = XO("on");
db.off = XO("off");
db.one = function(r, t, e) {
  var n = this;
  ia("ECharts#one is deprecated.");
  function i() {
    for (var a = [], o = 0; o < arguments.length; o++)
      a[o] = arguments[o];
    t && t.apply && t.apply(this, a), n.off(r, i);
  }
  this.on.call(this, r, i, e);
};
var s$ = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"];
function gn(r) {
  process.env.NODE_ENV !== "production" && Xe("Instance " + r + " has been disposed");
}
var Yv = {}, $v = {}, Qx = {}, tS = [], eS = [], Zv = [], JO = {}, rS = {}, qf = {}, $E = {}, l$ = +/* @__PURE__ */ new Date() - 0, pb = "_echarts_instance_";
function u$(r, t, e) {
  {
    if (process.env.NODE_ENV !== "production" && !r)
      throw new Error("Initialize failed: invalid dom.");
    var n = c$(r);
    if (n)
      return process.env.NODE_ENV !== "production" && Xe("There is a chart instance already initialized on the dom."), n;
    process.env.NODE_ENV !== "production" && fl(r) && r.nodeName.toUpperCase() !== "CANVAS" && (!r.clientWidth && !e || !r.clientHeight && !e) && Xe("Can't get DOM width or height. Please check dom.clientWidth and dom.clientHeight. They should not be 0.For example, you may need to call this in the callback of window.onload.");
  }
  var i = new jO(r, t, e);
  return i.id = "ec_" + l$++, qf[i.id] = i, BP(r, pb, i.id), KO(i), hi.trigger("afterinit", i), i;
}
function c$(r) {
  return qf[i6(r, pb)];
}
function QO(r, t) {
  JO[r] = t;
}
function tk(r) {
  Zt(eS, r) < 0 && eS.push(r);
}
function ek(r, t) {
  gb(tS, r, t, jY);
}
function f$(r) {
  vb("afterinit", r);
}
function h$(r) {
  vb("afterupdate", r);
}
function vb(r, t) {
  hi.on(r, t);
}
function ca(r, t, e) {
  var n, i, a, o, s;
  Tt(t) && (e = t, t = ""), Dt(r) ? (n = r.type, i = r.event, o = r.update, s = r.publishNonRefinedEvent, e || (e = r.action), a = r.refineEvent) : (n = r, i = t);
  function l(c) {
    return c.toLowerCase();
  }
  i = l(i || n);
  var u = a ? l(n) : i;
  Yv[n] || (St(zE.test(n) && zE.test(i)), a && St(i !== n), Yv[n] = {
    actionType: n,
    refinedEventType: i,
    nonRefinedEventType: u,
    update: o,
    action: e,
    refineEvent: a
  }, Qx[i] = 1, a && s && (Qx[u] = 1), process.env.NODE_ENV !== "production" && $v[u] && ce(u + ' must not be shared; use "refineEvent" if you intend to share an event name.'), $v[u] = n);
}
function d$(r, t) {
  Ec.register(r, t);
}
function p$(r, t) {
  gb(Zv, r, t, GO, "layout");
}
function Ll(r, t) {
  gb(Zv, r, t, HO, "visual");
}
var ZE = [];
function gb(r, t, e, n, i) {
  if ((Tt(t) || Dt(t)) && (e = t, t = n), process.env.NODE_ENV !== "production") {
    if (isNaN(t) || t == null)
      throw new Error("Illegal priority");
    L(r, function(o) {
      St(o.__raw !== e);
    });
  }
  if (!(Zt(ZE, e) >= 0)) {
    ZE.push(e);
    var a = CO.wrapStageHandler(e, i);
    a.__prio = t, a.__raw = e, r.push(a);
  }
}
function rk(r, t) {
  rS[r] = t;
}
function v$(r, t, e) {
  var n = WY("registerMap");
  n && n(r, t, e);
}
var g$ = AX;
Ll(hb, JX);
Ll(dm, QX);
Ll(dm, tY);
Ll(hb, dY);
Ll(dm, pY);
Ll(WO, GY);
tk(nO);
ek(qY, aX);
rk("default", eY);
ca({
  type: il,
  event: il,
  update: il
}, er);
ca({
  type: Zp,
  event: Zp,
  update: Zp
}, er);
ca({
  type: Rv,
  event: k1,
  update: Rv,
  action: er,
  refineEvent: mb,
  publishNonRefinedEvent: !0
});
ca({
  type: Ex,
  event: k1,
  update: Ex,
  action: er,
  refineEvent: mb,
  publishNonRefinedEvent: !0
});
ca({
  type: Iv,
  event: k1,
  update: Iv,
  action: er,
  refineEvent: mb,
  publishNonRefinedEvent: !0
});
function mb(r, t, e, n) {
  return {
    eventContent: {
      selected: h7(e),
      isFromClick: t.isFromClick || !1
    }
  };
}
QO("default", {});
QO("dark", IO);
var qE = [], m$ = {
  registerPreprocessor: tk,
  registerProcessor: ek,
  registerPostInit: f$,
  registerPostUpdate: h$,
  registerUpdateLifecycle: vb,
  registerAction: ca,
  registerCoordinateSystem: d$,
  registerLayout: p$,
  registerVisual: Ll,
  registerTransform: g$,
  registerLoading: rk,
  registerMap: v$,
  registerImpl: HY,
  PRIORITY: i$,
  ComponentModel: re,
  ComponentView: Ue,
  SeriesModel: ke,
  ChartView: Re,
  // TODO Use ComponentModel and SeriesModel instead of Constructor
  registerComponentModel: function(r) {
    re.registerClass(r);
  },
  registerComponentView: function(r) {
    Ue.registerClass(r);
  },
  registerSeriesModel: function(r) {
    ke.registerClass(r);
  },
  registerChartView: function(r) {
    Re.registerClass(r);
  },
  registerCustomSeries: function(r, t) {
    XY(r, t);
  },
  registerSubTypeDefaulter: function(r, t) {
    re.registerSubTypeDefaulter(r, t);
  },
  registerPainter: function(r, t) {
    N8(r, t);
  }
};
function jt(r) {
  if (et(r)) {
    L(r, function(t) {
      jt(t);
    });
    return;
  }
  Zt(qE, r) >= 0 || (qE.push(r), Tt(r) && (r = {
    install: r
  }), r.install(m$));
}
function rf(r) {
  return r == null ? 0 : r.length || 1;
}
function KE(r) {
  return r;
}
var Xa = (
  /** @class */
  function() {
    function r(t, e, n, i, a, o) {
      this._old = t, this._new = e, this._oldKeyGetter = n || KE, this._newKeyGetter = i || KE, this.context = a, this._diffModeMultiple = o === "multiple";
    }
    return r.prototype.add = function(t) {
      return this._add = t, this;
    }, r.prototype.update = function(t) {
      return this._update = t, this;
    }, r.prototype.updateManyToOne = function(t) {
      return this._updateManyToOne = t, this;
    }, r.prototype.updateOneToMany = function(t) {
      return this._updateOneToMany = t, this;
    }, r.prototype.updateManyToMany = function(t) {
      return this._updateManyToMany = t, this;
    }, r.prototype.remove = function(t) {
      return this._remove = t, this;
    }, r.prototype.execute = function() {
      this[this._diffModeMultiple ? "_executeMultiple" : "_executeOneToOne"]();
    }, r.prototype._executeOneToOne = function() {
      var t = this._old, e = this._new, n = {}, i = new Array(t.length), a = new Array(e.length);
      this._initIndexMap(t, null, i, "_oldKeyGetter"), this._initIndexMap(e, n, a, "_newKeyGetter");
      for (var o = 0; o < t.length; o++) {
        var s = i[o], l = n[s], u = rf(l);
        if (u > 1) {
          var c = l.shift();
          l.length === 1 && (n[s] = l[0]), this._update && this._update(c, o);
        } else
          u === 1 ? (n[s] = null, this._update && this._update(l, o)) : this._remove && this._remove(o);
      }
      this._performRestAdd(a, n);
    }, r.prototype._executeMultiple = function() {
      var t = this._old, e = this._new, n = {}, i = {}, a = [], o = [];
      this._initIndexMap(t, n, a, "_oldKeyGetter"), this._initIndexMap(e, i, o, "_newKeyGetter");
      for (var s = 0; s < a.length; s++) {
        var l = a[s], u = n[l], c = i[l], f = rf(u), h = rf(c);
        if (f > 1 && h === 1)
          this._updateManyToOne && this._updateManyToOne(c, u), i[l] = null;
        else if (f === 1 && h > 1)
          this._updateOneToMany && this._updateOneToMany(c, u), i[l] = null;
        else if (f === 1 && h === 1)
          this._update && this._update(c, u), i[l] = null;
        else if (f > 1 && h > 1)
          this._updateManyToMany && this._updateManyToMany(c, u), i[l] = null;
        else if (f > 1)
          for (var d = 0; d < f; d++)
            this._remove && this._remove(u[d]);
        else
          this._remove && this._remove(u);
      }
      this._performRestAdd(o, i);
    }, r.prototype._performRestAdd = function(t, e) {
      for (var n = 0; n < t.length; n++) {
        var i = t[n], a = e[i], o = rf(a);
        if (o > 1)
          for (var s = 0; s < o; s++)
            this._add && this._add(a[s]);
        else
          o === 1 && this._add && this._add(a);
        e[i] = null;
      }
    }, r.prototype._initIndexMap = function(t, e, n, i) {
      for (var a = this._diffModeMultiple, o = 0; o < t.length; o++) {
        var s = "_ec_" + this[i](t[o], o);
        if (a || (n[o] = s), !!e) {
          var l = e[s], u = rf(l);
          u === 0 ? (e[s] = o, a && n.push(s)) : u === 1 ? e[s] = [l, o] : l.push(o);
        }
      }
    }, r;
  }()
), y$ = (
  /** @class */
  function() {
    function r(t, e) {
      this._encode = t, this._schema = e;
    }
    return r.prototype.get = function() {
      return {
        // Do not generate full dimension name until fist used.
        fullDimensions: this._getFullDimensionNames(),
        encode: this._encode
      };
    }, r.prototype._getFullDimensionNames = function() {
      return this._cachedDimNames || (this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : []), this._cachedDimNames;
    }, r;
  }()
);
function _$(r, t) {
  var e = {}, n = e.encode = {}, i = wt(), a = [], o = [], s = {};
  L(r.dimensions, function(h) {
    var d = r.getDimensionInfo(h), p = d.coordDim;
    if (p) {
      process.env.NODE_ENV !== "production" && St(Gx.get(p) == null);
      var g = d.coordDimIndex;
      d0(n, p)[g] = h, d.isExtraCoord || (i.set(p, 1), x$(d.type) && (a[0] = h), d0(s, p)[g] = r.getDimensionIndex(d.name)), d.defaultTooltip && o.push(h);
    }
    Gx.each(function(v, m) {
      var y = d0(n, m), _ = d.otherDims[m];
      _ != null && _ !== !1 && (y[_] = d.name);
    });
  });
  var l = [], u = {};
  i.each(function(h, d) {
    var p = n[d];
    u[d] = p[0], l = l.concat(p);
  }), e.dataDimsOnCoord = l, e.dataDimIndicesOnCoord = rt(l, function(h) {
    return r.getDimensionInfo(h).storeDimIndex;
  }), e.encodeFirstDimNotExtra = u;
  var c = n.label;
  c && c.length && (a = c.slice());
  var f = n.tooltip;
  return f && f.length ? o = f.slice() : o.length || (o = a.slice()), n.defaultedLabel = a, n.defaultedTooltip = o, e.userOutput = new y$(s, t), e;
}
function d0(r, t) {
  return r.hasOwnProperty(t) || (r[t] = []), r[t];
}
function qv(r) {
  return r === "category" ? "ordinal" : r === "time" ? "time" : "float";
}
function x$(r) {
  return !(r === "ordinal" || r === "time");
}
var ev = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(t) {
      this.otherDims = {}, t != null && J(this, t);
    }
    return r;
  }()
), S$ = ee(), b$ = {
  float: "f",
  int: "i",
  ordinal: "o",
  number: "n",
  time: "t"
}, nk = (
  /** @class */
  function() {
    function r(t) {
      this.dimensions = t.dimensions, this._dimOmitted = t.dimensionOmitted, this.source = t.source, this._fullDimCount = t.fullDimensionCount, this._updateDimOmitted(t.dimensionOmitted);
    }
    return r.prototype.isDimensionOmitted = function() {
      return this._dimOmitted;
    }, r.prototype._updateDimOmitted = function(t) {
      this._dimOmitted = t, t && (this._dimNameMap || (this._dimNameMap = ok(this.source)));
    }, r.prototype.getSourceDimensionIndex = function(t) {
      return bt(this._dimNameMap.get(t), -1);
    }, r.prototype.getSourceDimension = function(t) {
      var e = this.source.dimensionsDefine;
      if (e)
        return e[t];
    }, r.prototype.makeStoreSchema = function() {
      for (var t = this._fullDimCount, e = aO(this.source), n = !sk(t), i = "", a = [], o = 0, s = 0; o < t; o++) {
        var l = void 0, u = void 0, c = void 0, f = this.dimensions[s];
        if (f && f.storeDimIndex === o)
          l = e ? f.name : null, u = f.type, c = f.ordinalMeta, s++;
        else {
          var h = this.getSourceDimension(o);
          h && (l = e ? h.name : null, u = h.type);
        }
        a.push({
          property: l,
          type: u,
          ordinalMeta: c
        }), e && l != null && (!f || !f.isCalculationCoord) && (i += n ? l.replace(/\`/g, "`1").replace(/\$/g, "`2") : l), i += "$", i += b$[u] || "f", c && (i += c.uid), i += "$";
      }
      var d = this.source, p = [d.seriesLayoutBy, d.startIndex, i].join("$$");
      return {
        dimensions: a,
        hash: p
      };
    }, r.prototype.makeOutputDimensionNames = function() {
      for (var t = [], e = 0, n = 0; e < this._fullDimCount; e++) {
        var i = void 0, a = this.dimensions[n];
        if (a && a.storeDimIndex === e)
          a.isCalculationCoord || (i = a.name), n++;
        else {
          var o = this.getSourceDimension(e);
          o && (i = o.name);
        }
        t.push(i);
      }
      return t;
    }, r.prototype.appendCalculationDimension = function(t) {
      this.dimensions.push(t), t.isCalculationCoord = !0, this._fullDimCount++, this._updateDimOmitted(!0);
    }, r;
  }()
);
function ik(r) {
  return r instanceof nk;
}
function ak(r) {
  for (var t = wt(), e = 0; e < (r || []).length; e++) {
    var n = r[e], i = Dt(n) ? n.name : n;
    i != null && t.get(i) == null && t.set(i, e);
  }
  return t;
}
function ok(r) {
  var t = S$(r);
  return t.dimNameMap || (t.dimNameMap = ak(r.dimensionsDefine));
}
function sk(r) {
  return r > 30;
}
var nf = Dt, uo = rt, w$ = typeof Int32Array > "u" ? Array : Int32Array, M$ = "e\0\0", jE = -1, T$ = ["hasItemOption", "_nameList", "_idList", "_invertedIndicesMap", "_dimSummary", "userOutput", "_rawData", "_dimValueGetter", "_nameDimIdx", "_idDimIdx", "_nameRepeatCount"], A$ = ["_approximateExtent"], JE, tp, af, hu, p0, of, v0, un = (
  /** @class */
  function() {
    function r(t, e) {
      this.type = "list", this._dimOmitted = !1, this._nameList = [], this._idList = [], this._visual = {}, this._layout = {}, this._itemVisuals = [], this._itemLayouts = [], this._graphicEls = [], this._approximateExtent = {}, this._calculationInfo = {}, this.hasItemOption = !1, this.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "minmaxDownSample", "lttbDownSample", "map"], this.CHANGABLE_METHODS = ["filterSelf", "selectRange"], this.DOWNSAMPLE_METHODS = ["downSample", "minmaxDownSample", "lttbDownSample"];
      var n, i = !1;
      ik(t) ? (n = t.dimensions, this._dimOmitted = t.isDimensionOmitted(), this._schema = t) : (i = !0, n = t), n = n || ["x", "y"];
      for (var a = {}, o = [], s = {}, l = !1, u = {}, c = 0; c < n.length; c++) {
        var f = n[c], h = pt(f) ? new ev({
          name: f
        }) : f instanceof ev ? f : new ev(f), d = h.name;
        h.type = h.type || "float", h.coordDim || (h.coordDim = d, h.coordDimIndex = 0);
        var p = h.otherDims = h.otherDims || {};
        o.push(d), a[d] = h, u[d] != null && (l = !0), h.createInvertedIndices && (s[d] = []);
        var g = c;
        fe(h.storeDimIndex) && (g = h.storeDimIndex), p.itemName === 0 && (this._nameDimIdx = g), p.itemId === 0 && (this._idDimIdx = g), process.env.NODE_ENV !== "production" && St(i || h.storeDimIndex >= 0), i && (h.storeDimIndex = c);
      }
      if (this.dimensions = o, this._dimInfos = a, this._initGetDimensionInfo(l), this.hostModel = e, this._invertedIndicesMap = s, this._dimOmitted) {
        var v = this._dimIdxToName = wt();
        L(o, function(m) {
          v.set(a[m].storeDimIndex, m);
        });
      }
    }
    return r.prototype.getDimension = function(t) {
      var e = this._recognizeDimIndex(t);
      if (e == null)
        return t;
      if (e = t, !this._dimOmitted)
        return this.dimensions[e];
      var n = this._dimIdxToName.get(e);
      if (n != null)
        return n;
      var i = this._schema.getSourceDimension(e);
      if (i)
        return i.name;
    }, r.prototype.getDimensionIndex = function(t) {
      var e = this._recognizeDimIndex(t);
      if (e != null)
        return e;
      if (t == null)
        return -1;
      var n = this._getDimInfo(t);
      return n ? n.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(t) : -1;
    }, r.prototype._recognizeDimIndex = function(t) {
      if (fe(t) || t != null && !isNaN(t) && !this._getDimInfo(t) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(t) < 0))
        return +t;
    }, r.prototype._getStoreDimIndex = function(t) {
      var e = this.getDimensionIndex(t);
      if (process.env.NODE_ENV !== "production" && e == null)
        throw new Error("Unknown dimension " + t);
      return e;
    }, r.prototype.getDimensionInfo = function(t) {
      return this._getDimInfo(this.getDimension(t));
    }, r.prototype._initGetDimensionInfo = function(t) {
      var e = this._dimInfos;
      this._getDimInfo = t ? function(n) {
        return e.hasOwnProperty(n) ? e[n] : void 0;
      } : function(n) {
        return e[n];
      };
    }, r.prototype.getDimensionsOnCoord = function() {
      return this._dimSummary.dataDimsOnCoord.slice();
    }, r.prototype.mapDimension = function(t, e) {
      var n = this._dimSummary;
      if (e == null)
        return n.encodeFirstDimNotExtra[t];
      var i = n.encode[t];
      return i ? i[e] : null;
    }, r.prototype.mapDimensionsAll = function(t) {
      var e = this._dimSummary, n = e.encode[t];
      return (n || []).slice();
    }, r.prototype.getStore = function() {
      return this._store;
    }, r.prototype.initData = function(t, e, n) {
      var i = this, a;
      if (t instanceof Yx && (a = t), !a) {
        var o = this.dimensions, s = ob(t) || qr(t) ? new oO(t, o.length) : t;
        a = new Yx();
        var l = uo(o, function(u) {
          return {
            type: i._dimInfos[u].type,
            property: u
          };
        });
        a.initData(s, l, n);
      }
      this._store = a, this._nameList = (e || []).slice(), this._idList = [], this._nameRepeatCount = {}, this._doInit(0, a.count()), this._dimSummary = _$(this, this._schema), this.userOutput = this._dimSummary.userOutput;
    }, r.prototype.appendData = function(t) {
      var e = this._store.appendData(t);
      this._doInit(e[0], e[1]);
    }, r.prototype.appendValues = function(t, e) {
      var n = this._store.appendValues(t, e && e.length), i = n.start, a = n.end, o = this._shouldMakeIdFromName();
      if (this._updateOrdinalMeta(), e)
        for (var s = i; s < a; s++) {
          var l = s - i;
          this._nameList[s] = e[l], o && v0(this, s);
        }
    }, r.prototype._updateOrdinalMeta = function() {
      for (var t = this._store, e = this.dimensions, n = 0; n < e.length; n++) {
        var i = this._dimInfos[e[n]];
        i.ordinalMeta && t.collectOrdinalMeta(i.storeDimIndex, i.ordinalMeta);
      }
    }, r.prototype._shouldMakeIdFromName = function() {
      var t = this._store.getProvider();
      return this._idDimIdx == null && t.getSource().sourceFormat !== Na && !t.fillStorage;
    }, r.prototype._doInit = function(t, e) {
      if (!(t >= e)) {
        var n = this._store, i = n.getProvider();
        this._updateOrdinalMeta();
        var a = this._nameList, o = this._idList, s = i.getSource().sourceFormat, l = s === Bn;
        if (l && !i.pure)
          for (var u = [], c = t; c < e; c++) {
            var f = i.getItem(c, u);
            if (!this.hasItemOption && X8(f) && (this.hasItemOption = !0), f) {
              var h = f.name;
              a[c] == null && h != null && (a[c] = mr(h, null));
              var d = f.id;
              o[c] == null && d != null && (o[c] = mr(d, null));
            }
          }
        if (this._shouldMakeIdFromName())
          for (var c = t; c < e; c++)
            v0(this, c);
        JE(this);
      }
    }, r.prototype.getApproximateExtent = function(t) {
      return this._approximateExtent[t] || this._store.getDataExtent(this._getStoreDimIndex(t));
    }, r.prototype.setApproximateExtent = function(t, e) {
      e = this.getDimension(e), this._approximateExtent[e] = t.slice();
    }, r.prototype.getCalculationInfo = function(t) {
      return this._calculationInfo[t];
    }, r.prototype.setCalculationInfo = function(t, e) {
      nf(t) ? J(this._calculationInfo, t) : this._calculationInfo[t] = e;
    }, r.prototype.getName = function(t) {
      var e = this.getRawIndex(t), n = this._nameList[e];
      return n == null && this._nameDimIdx != null && (n = af(this, this._nameDimIdx, e)), n == null && (n = ""), n;
    }, r.prototype._getCategory = function(t, e) {
      var n = this._store.get(t, e), i = this._store.getOrdinalMeta(t);
      return i ? i.categories[n] : n;
    }, r.prototype.getId = function(t) {
      return tp(this, this.getRawIndex(t));
    }, r.prototype.count = function() {
      return this._store.count();
    }, r.prototype.get = function(t, e) {
      var n = this._store, i = this._dimInfos[t];
      if (i)
        return n.get(i.storeDimIndex, e);
    }, r.prototype.getByRawIndex = function(t, e) {
      var n = this._store, i = this._dimInfos[t];
      if (i)
        return n.getByRawIndex(i.storeDimIndex, e);
    }, r.prototype.getIndices = function() {
      return this._store.getIndices();
    }, r.prototype.getDataExtent = function(t) {
      return this._store.getDataExtent(this._getStoreDimIndex(t));
    }, r.prototype.getSum = function(t) {
      return this._store.getSum(this._getStoreDimIndex(t));
    }, r.prototype.getMedian = function(t) {
      return this._store.getMedian(this._getStoreDimIndex(t));
    }, r.prototype.getValues = function(t, e) {
      var n = this, i = this._store;
      return et(t) ? i.getValues(uo(t, function(a) {
        return n._getStoreDimIndex(a);
      }), e) : i.getValues(t);
    }, r.prototype.hasValue = function(t) {
      for (var e = this._dimSummary.dataDimIndicesOnCoord, n = 0, i = e.length; n < i; n++)
        if (isNaN(this._store.get(e[n], t)))
          return !1;
      return !0;
    }, r.prototype.indexOfName = function(t) {
      for (var e = 0, n = this._store.count(); e < n; e++)
        if (this.getName(e) === t)
          return e;
      return -1;
    }, r.prototype.getRawIndex = function(t) {
      return this._store.getRawIndex(t);
    }, r.prototype.indexOfRawIndex = function(t) {
      return this._store.indexOfRawIndex(t);
    }, r.prototype.rawIndexOf = function(t, e) {
      var n = t && this._invertedIndicesMap[t];
      if (process.env.NODE_ENV !== "production" && !n)
        throw new Error("Do not supported yet");
      var i = n && n[e];
      return i == null || isNaN(i) ? jE : i;
    }, r.prototype.each = function(t, e, n) {
      Tt(t) && (n = e, e = t, t = []);
      var i = n || this, a = uo(hu(t), this._getStoreDimIndex, this);
      this._store.each(a, i ? mt(e, i) : e);
    }, r.prototype.filterSelf = function(t, e, n) {
      Tt(t) && (n = e, e = t, t = []);
      var i = n || this, a = uo(hu(t), this._getStoreDimIndex, this);
      return this._store = this._store.filter(a, i ? mt(e, i) : e), this;
    }, r.prototype.selectRange = function(t) {
      var e = this, n = {}, i = se(t);
      return L(i, function(a) {
        var o = e._getStoreDimIndex(a);
        n[o] = t[a];
      }), this._store = this._store.selectRange(n), this;
    }, r.prototype.mapArray = function(t, e, n) {
      Tt(t) && (n = e, e = t, t = []), n = n || this;
      var i = [];
      return this.each(t, function() {
        i.push(e && e.apply(this, arguments));
      }, n), i;
    }, r.prototype.map = function(t, e, n, i) {
      var a = n || i || this, o = uo(hu(t), this._getStoreDimIndex, this), s = of(this);
      return s._store = this._store.map(o, a ? mt(e, a) : e), s;
    }, r.prototype.modify = function(t, e, n, i) {
      var a = this, o = n || i || this;
      process.env.NODE_ENV !== "production" && L(hu(t), function(l) {
        var u = a.getDimensionInfo(l);
        u.isCalculationCoord || console.error("Danger: only stack dimension can be modified");
      });
      var s = uo(hu(t), this._getStoreDimIndex, this);
      this._store.modify(s, o ? mt(e, o) : e);
    }, r.prototype.downSample = function(t, e, n, i) {
      var a = of(this);
      return a._store = this._store.downSample(this._getStoreDimIndex(t), e, n, i), a;
    }, r.prototype.minmaxDownSample = function(t, e) {
      var n = of(this);
      return n._store = this._store.minmaxDownSample(this._getStoreDimIndex(t), e), n;
    }, r.prototype.lttbDownSample = function(t, e) {
      var n = of(this);
      return n._store = this._store.lttbDownSample(this._getStoreDimIndex(t), e), n;
    }, r.prototype.getRawDataItem = function(t) {
      return this._store.getRawDataItem(t);
    }, r.prototype.getItemModel = function(t) {
      var e = this.hostModel, n = this.getRawDataItem(t);
      return new ue(n, e, e && e.ecModel);
    }, r.prototype.diff = function(t) {
      var e = this;
      return new Xa(t ? t.getStore().getIndices() : [], this.getStore().getIndices(), function(n) {
        return tp(t, n);
      }, function(n) {
        return tp(e, n);
      });
    }, r.prototype.getVisual = function(t) {
      var e = this._visual;
      return e && e[t];
    }, r.prototype.setVisual = function(t, e) {
      this._visual = this._visual || {}, nf(t) ? J(this._visual, t) : this._visual[t] = e;
    }, r.prototype.getItemVisual = function(t, e) {
      var n = this._itemVisuals[t], i = n && n[e];
      return i ?? this.getVisual(e);
    }, r.prototype.hasItemVisual = function() {
      return this._itemVisuals.length > 0;
    }, r.prototype.ensureUniqueItemVisual = function(t, e) {
      var n = this._itemVisuals, i = n[t];
      i || (i = n[t] = {});
      var a = i[e];
      return a == null && (a = this.getVisual(e), et(a) ? a = a.slice() : nf(a) && (a = J({}, a)), i[e] = a), a;
    }, r.prototype.setItemVisual = function(t, e, n) {
      var i = this._itemVisuals[t] || {};
      this._itemVisuals[t] = i, nf(e) ? J(i, e) : i[e] = n;
    }, r.prototype.clearAllVisual = function() {
      this._visual = {}, this._itemVisuals = [];
    }, r.prototype.setLayout = function(t, e) {
      nf(t) ? J(this._layout, t) : this._layout[t] = e;
    }, r.prototype.getLayout = function(t) {
      return this._layout[t];
    }, r.prototype.getItemLayout = function(t) {
      return this._itemLayouts[t];
    }, r.prototype.setItemLayout = function(t, e, n) {
      this._itemLayouts[t] = n ? J(this._itemLayouts[t] || {}, e) : e;
    }, r.prototype.clearItemLayouts = function() {
      this._itemLayouts.length = 0;
    }, r.prototype.setItemGraphicEl = function(t, e) {
      var n = this.hostModel && this.hostModel.seriesIndex;
      Ax(n, this.dataType, t, e), this._graphicEls[t] = e;
    }, r.prototype.getItemGraphicEl = function(t) {
      return this._graphicEls[t];
    }, r.prototype.eachItemGraphicEl = function(t, e) {
      L(this._graphicEls, function(n, i) {
        n && t && t.call(e, n, i);
      });
    }, r.prototype.cloneShallow = function(t) {
      return t || (t = new r(this._schema ? this._schema : uo(this.dimensions, this._getDimInfo, this), this.hostModel)), p0(t, this), t._store = this._store, t;
    }, r.prototype.wrapMethod = function(t, e) {
      var n = this[t];
      Tt(n) && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(t), this[t] = function() {
        var i = n.apply(this, arguments);
        return e.apply(this, [i].concat(S1(arguments)));
      });
    }, r.internalField = function() {
      JE = function(t) {
        var e = t._invertedIndicesMap;
        L(e, function(n, i) {
          var a = t._dimInfos[i], o = a.ordinalMeta, s = t._store;
          if (o) {
            n = e[i] = new w$(o.categories.length);
            for (var l = 0; l < n.length; l++)
              n[l] = jE;
            for (var l = 0; l < s.count(); l++)
              n[s.get(a.storeDimIndex, l)] = l;
          }
        });
      }, af = function(t, e, n) {
        return mr(t._getCategory(e, n), null);
      }, tp = function(t, e) {
        var n = t._idList[e];
        return n == null && t._idDimIdx != null && (n = af(t, t._idDimIdx, e)), n == null && (n = M$ + e), n;
      }, hu = function(t) {
        return et(t) || (t = t != null ? [t] : []), t;
      }, of = function(t) {
        var e = new r(t._schema ? t._schema : uo(t.dimensions, t._getDimInfo, t), t.hostModel);
        return p0(e, t), e;
      }, p0 = function(t, e) {
        L(T$.concat(e.__wrappedMethods || []), function(n) {
          e.hasOwnProperty(n) && (t[n] = e[n]);
        }), t.__wrappedMethods = e.__wrappedMethods, L(A$, function(n) {
          t[n] = Ct(e[n]);
        }), t._calculationInfo = J({}, e._calculationInfo);
      }, v0 = function(t, e) {
        var n = t._nameList, i = t._idList, a = t._nameDimIdx, o = t._idDimIdx, s = n[e], l = i[e];
        if (s == null && a != null && (n[e] = s = af(t, a, e)), l == null && o != null && (i[e] = l = af(t, o, e)), l == null && s != null) {
          var u = t._nameRepeatCount, c = u[s] = (u[s] || 0) + 1;
          l = s, c > 1 && (l += "__ec__" + c), i[e] = l;
        }
      };
    }(), r;
  }()
);
function Gh(r, t) {
  ob(r) || (r = sb(r)), t = t || {};
  var e = t.coordDimensions || [], n = t.dimensionsDefine || r.dimensionsDefine || [], i = wt(), a = [], o = C$(r, e, n, t.dimensionsCount), s = t.canOmitUnusedDimensions && sk(o), l = n === r.dimensionsDefine, u = l ? ok(r) : ak(n), c = t.encodeDefine;
  !c && t.encodeDefaulter && (c = t.encodeDefaulter(r, o));
  for (var f = wt(c), h = new pO(o), d = 0; d < h.length; d++)
    h[d] = -1;
  function p(T) {
    var M = h[T];
    if (M < 0) {
      var E = n[T], R = Dt(E) ? E : {
        name: E
      }, C = new ev(), D = R.name;
      D != null && u.get(D) != null && (C.name = C.displayName = D), R.type != null && (C.type = R.type), R.displayName != null && (C.displayName = R.displayName);
      var I = a.length;
      return h[T] = I, C.storeDimIndex = T, a.push(C), C;
    }
    return a[M];
  }
  if (!s)
    for (var d = 0; d < o; d++)
      p(d);
  f.each(function(T, M) {
    var E = Ie(T).slice();
    if (E.length === 1 && !pt(E[0]) && E[0] < 0) {
      f.set(M, !1);
      return;
    }
    var R = f.set(M, []);
    L(E, function(C, D) {
      var I = pt(C) ? u.get(C) : C;
      I != null && I < o && (R[D] = I, v(p(I), M, D));
    });
  });
  var g = 0;
  L(e, function(T) {
    var M, E, R, C;
    if (pt(T))
      M = T, C = {};
    else {
      C = T, M = C.name;
      var D = C.ordinalMeta;
      C.ordinalMeta = null, C = J({}, C), C.ordinalMeta = D, E = C.dimsDef, R = C.otherDims, C.name = C.coordDim = C.coordDimIndex = C.dimsDef = C.otherDims = null;
    }
    var I = f.get(M);
    if (I !== !1) {
      if (I = Ie(I), !I.length)
        for (var P = 0; P < (E && E.length || 1); P++) {
          for (; g < o && p(g).coordDim != null; )
            g++;
          g < o && I.push(g++);
        }
      L(I, function(O, N) {
        var B = p(O);
        if (l && C.type != null && (B.type = C.type), v(kt(B, C), M, N), B.name == null && E) {
          var F = E[N];
          !Dt(F) && (F = {
            name: F
          }), B.name = B.displayName = F.name, B.defaultTooltip = F.defaultTooltip;
        }
        R && kt(B.otherDims, R);
      });
    }
  });
  function v(T, M, E) {
    Gx.get(M) != null ? T.otherDims[M] = E : (T.coordDim = M, T.coordDimIndex = E, i.set(M, !0));
  }
  var m = t.generateCoord, y = t.generateCoordCount, _ = y != null;
  y = m ? y || 1 : 0;
  var x = m || "value";
  function b(T) {
    T.name == null && (T.name = T.coordDim);
  }
  if (s)
    L(a, function(T) {
      b(T);
    }), a.sort(function(T, M) {
      return T.storeDimIndex - M.storeDimIndex;
    });
  else
    for (var S = 0; S < o; S++) {
      var w = p(S), A = w.coordDim;
      A == null && (w.coordDim = D$(x, i, _), w.coordDimIndex = 0, (!m || y <= 0) && (w.isExtraCoord = !0), y--), b(w), w.type == null && (JN(r, S) === Fr.Must || w.isExtraCoord && (w.otherDims.itemName != null || w.otherDims.seriesName != null)) && (w.type = "ordinal");
    }
  return E$(a), new nk({
    source: r,
    dimensions: a,
    fullDimensionCount: o,
    dimensionOmitted: s
  });
}
function E$(r) {
  for (var t = wt(), e = 0; e < r.length; e++) {
    var n = r[e], i = n.name, a = t.get(i) || 0;
    a > 0 && (n.name = i + (a - 1)), a++, t.set(i, a);
  }
}
function C$(r, t, e, n) {
  var i = Math.max(r.dimensionsDetectedCount || 1, t.length, e.length, n || 0);
  return L(t, function(a) {
    var o;
    Dt(a) && (o = a.dimsDef) && (i = Math.max(i, o.length));
  }), i;
}
function D$(r, t, e) {
  if (e || t.hasKey(r)) {
    for (var n = 0; t.hasKey(r + n); )
      n++;
    r += n;
  }
  return t.set(r, !0), r;
}
var L$ = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(t) {
      this.coordSysDims = [], this.axisMap = wt(), this.categoryAxisMap = wt(), this.coordSysName = t;
    }
    return r;
  }()
);
function R$(r) {
  var t = r.get("coordinateSystem"), e = new L$(t), n = I$[t];
  if (n)
    return n(r, e, e.axisMap, e.categoryAxisMap), e;
}
var I$ = {
  cartesian2d: function(r, t, e, n) {
    var i = r.getReferringComponents("xAxis", Ke).models[0], a = r.getReferringComponents("yAxis", Ke).models[0];
    if (process.env.NODE_ENV !== "production") {
      if (!i)
        throw new Error('xAxis "' + gr(r.get("xAxisIndex"), r.get("xAxisId"), 0) + '" not found');
      if (!a)
        throw new Error('yAxis "' + gr(r.get("xAxisIndex"), r.get("yAxisId"), 0) + '" not found');
    }
    t.coordSysDims = ["x", "y"], e.set("x", i), e.set("y", a), du(i) && (n.set("x", i), t.firstCategoryDimIndex = 0), du(a) && (n.set("y", a), t.firstCategoryDimIndex == null && (t.firstCategoryDimIndex = 1));
  },
  singleAxis: function(r, t, e, n) {
    var i = r.getReferringComponents("singleAxis", Ke).models[0];
    if (process.env.NODE_ENV !== "production" && !i)
      throw new Error("singleAxis should be specified.");
    t.coordSysDims = ["single"], e.set("single", i), du(i) && (n.set("single", i), t.firstCategoryDimIndex = 0);
  },
  polar: function(r, t, e, n) {
    var i = r.getReferringComponents("polar", Ke).models[0], a = i.findAxisModel("radiusAxis"), o = i.findAxisModel("angleAxis");
    if (process.env.NODE_ENV !== "production") {
      if (!o)
        throw new Error("angleAxis option not found");
      if (!a)
        throw new Error("radiusAxis option not found");
    }
    t.coordSysDims = ["radius", "angle"], e.set("radius", a), e.set("angle", o), du(a) && (n.set("radius", a), t.firstCategoryDimIndex = 0), du(o) && (n.set("angle", o), t.firstCategoryDimIndex == null && (t.firstCategoryDimIndex = 1));
  },
  geo: function(r, t, e, n) {
    t.coordSysDims = ["lng", "lat"];
  },
  parallel: function(r, t, e, n) {
    var i = r.ecModel, a = i.getComponent("parallel", r.get("parallelIndex")), o = t.coordSysDims = a.dimensions.slice();
    L(a.parallelAxisIndex, function(s, l) {
      var u = i.getComponent("parallelAxis", s), c = o[l];
      e.set(c, u), du(u) && (n.set(c, u), t.firstCategoryDimIndex == null && (t.firstCategoryDimIndex = l));
    });
  },
  matrix: function(r, t, e, n) {
    var i = r.getReferringComponents("matrix", Ke).models[0];
    if (process.env.NODE_ENV !== "production" && !i)
      throw new Error("matrix coordinate system should be specified.");
    t.coordSysDims = ["x", "y"];
    var a = i.getDimensionModel("x"), o = i.getDimensionModel("y");
    e.set("x", a), e.set("y", o), n.set("x", a), n.set("y", o);
  }
};
function du(r) {
  return r.get("type") === "category";
}
function P$(r, t, e) {
  e = e || {};
  var n = e.byIndex, i = e.stackedCoordDimension, a, o, s;
  N$(t) ? a = t : (o = t.schema, a = o.dimensions, s = t.store);
  var l = !!(r && r.get("stack")), u, c, f, h;
  if (L(a, function(y, _) {
    pt(y) && (a[_] = y = {
      name: y
    }), l && !y.isExtraCoord && (!n && !u && y.ordinalMeta && (u = y), !c && y.type !== "ordinal" && y.type !== "time" && (!i || i === y.coordDim) && (c = y));
  }), c && !n && !u && (n = !0), c) {
    f = "__\0ecstackresult_" + r.id, h = "__\0ecstackedover_" + r.id, u && (u.createInvertedIndices = !0);
    var d = c.coordDim, p = c.type, g = 0;
    L(a, function(y) {
      y.coordDim === d && g++;
    });
    var v = {
      name: f,
      coordDim: d,
      coordDimIndex: g,
      type: p,
      isExtraCoord: !0,
      isCalculationCoord: !0,
      storeDimIndex: a.length
    }, m = {
      name: h,
      // This dimension contains stack base (generally, 0), so do not set it as
      // `stackedDimCoordDim` to avoid extent calculation, consider log scale.
      coordDim: h,
      coordDimIndex: g + 1,
      type: p,
      isExtraCoord: !0,
      isCalculationCoord: !0,
      storeDimIndex: a.length + 1
    };
    o ? (s && (v.storeDimIndex = s.ensureCalculationDimension(h, p), m.storeDimIndex = s.ensureCalculationDimension(f, p)), o.appendCalculationDimension(v), o.appendCalculationDimension(m)) : (a.push(v), a.push(m));
  }
  return {
    stackedDimension: c && c.name,
    stackedByDimension: u && u.name,
    isStackedByIndex: n,
    stackedOverDimension: h,
    stackResultDimension: f
  };
}
function N$(r) {
  return !ik(r.schema);
}
function Ho(r, t) {
  return !!t && t === r.getCalculationInfo("stackedDimension");
}
function lk(r, t) {
  return Ho(r, t) ? r.getCalculationInfo("stackResultDimension") : t;
}
function O$(r, t) {
  var e = r.get("coordinateSystem"), n = Ec.get(e), i;
  return t && t.coordSysDims && (i = rt(t.coordSysDims, function(a) {
    var o = {
      name: a
    }, s = t.axisMap.get(a);
    if (s) {
      var l = s.get("type");
      o.type = qv(l);
    }
    return o;
  })), i || (i = n && (n.getDimensionsInfo ? n.getDimensionsInfo() : n.dimensions.slice()) || ["x", "y"]), i;
}
function k$(r, t, e) {
  var n, i;
  return e && L(r, function(a, o) {
    var s = a.coordDim, l = e.categoryAxisMap.get(s);
    l && (n == null && (n = o), a.ordinalMeta = l.getOrdinalMeta(), t && (a.createInvertedIndices = !0)), a.otherDims.itemName != null && (i = !0);
  }), !i && n != null && (r[n].otherDims.itemName = 0), n;
}
function ja(r, t, e) {
  e = e || {};
  var n = t.getSourceManager(), i, a = !1;
  r ? (a = !0, i = sb(r)) : (i = n.getSource(), a = i.sourceFormat === Bn);
  var o = R$(t), s = O$(t, o), l = e.useEncodeDefaulter, u = Tt(l) ? l : l ? Yt(jN, s, t) : null, c = {
    coordDimensions: s,
    generateCoord: e.generateCoord,
    encodeDefine: t.getEncode(),
    encodeDefaulter: u,
    canOmitUnusedDimensions: !a
  }, f = Gh(i, c), h = k$(f.dimensions, e.createInvertedIndices, o), d = a ? null : n.getSharedDataStore(f), p = P$(t, {
    schema: f,
    store: d
  }), g = new un(f, t);
  g.setCalculationInfo(p);
  var v = h != null && B$(i) ? function(m, y, _, x) {
    return x === h ? _ : this.defaultDimValueGetter(m, y, _, x);
  } : null;
  return g.hasItemOption = !1, g.initData(
    // Try to reuse the data store in sourceManager if using dataset.
    a ? i : d,
    null,
    v
  ), g;
}
function B$(r) {
  if (r.sourceFormat === Bn) {
    var t = V$(r.data || []);
    return !et(xc(t));
  }
}
function V$(r) {
  for (var t = 0; t < r.length && r[t] == null; )
    t++;
  return r[t];
}
function F$(r) {
  var t = Math.pow(10, Yg(Math.abs(r))), e = Math.abs(r / t);
  return e === 0 || e === 1 || e === 2 || e === 3 || e === 5;
}
function nS(r) {
  return r.type === "interval" || r.type === "log";
}
function z$(r, t, e, n, i) {
  var a = {}, o = a.interval = DP(t / e);
  n != null && o < n && (o = a.interval = n), i != null && o > i && (o = a.interval = i);
  var s = a.intervalPrecision = dh(o), l = a.niceTickExtent = [or(Math.ceil(r[0] / o) * o, s), or(Math.floor(r[1] / o) * o, s)];
  return U$(l, r), a;
}
function g0(r) {
  var t = Math.pow(10, Yg(r)), e = r / t;
  return e ? e === 2 ? e = 3 : e === 3 ? e = 5 : e *= 2 : e = 1, or(e * t);
}
function dh(r) {
  return Yi(r) + 2;
}
function QE(r, t, e) {
  r[t] = Math.max(Math.min(r[t], e[1]), e[0]);
}
function U$(r, t) {
  !isFinite(r[0]) && (r[0] = t[0]), !isFinite(r[1]) && (r[1] = t[1]), QE(r, 0, t), QE(r, 1, t), r[0] > r[1] && (r[0] = r[1]);
}
function yb(r, t) {
  return r >= t[0] && r <= t[1];
}
var G$ = (
  /** @class */
  function() {
    function r() {
      this.normalize = tC, this.scale = eC;
    }
    return r.prototype.updateMethods = function(t) {
      t.hasBreaks() ? (this.normalize = mt(t.normalize, t), this.scale = mt(t.scale, t)) : (this.normalize = tC, this.scale = eC);
    }, r;
  }()
);
function tC(r, t) {
  return t[1] === t[0] ? 0.5 : (r - t[0]) / (t[1] - t[0]);
}
function eC(r, t) {
  return r * (t[1] - t[0]) + t[0];
}
function iS(r, t, e) {
  var n = Math.log(r);
  return [
    // log(negative) is NaN, so safe guard here.
    // PENDING: But even getting a -Infinity still does not make sense in extent.
    //  Just keep it as is, getting a NaN to make some previous cases works by coincidence.
    Math.log(e ? t[0] : Math.max(0, t[0])) / n,
    Math.log(e ? t[1] : Math.max(0, t[1])) / n
  ];
}
var Jo = (
  /** @class */
  function() {
    function r(t) {
      this._calculator = new G$(), this._setting = t || {}, this._extent = [1 / 0, -1 / 0];
      var e = lr();
      e && (this._brkCtx = e.createScaleBreakContext(), this._brkCtx.update(this._extent));
    }
    return r.prototype.getSetting = function(t) {
      return this._setting[t];
    }, r.prototype._innerUnionExtent = function(t) {
      var e = this._extent;
      this._innerSetExtent(t[0] < e[0] ? t[0] : e[0], t[1] > e[1] ? t[1] : e[1]);
    }, r.prototype.unionExtentFromData = function(t, e) {
      this._innerUnionExtent(t.getApproximateExtent(e));
    }, r.prototype.getExtent = function() {
      return this._extent.slice();
    }, r.prototype.setExtent = function(t, e) {
      this._innerSetExtent(t, e);
    }, r.prototype._innerSetExtent = function(t, e) {
      var n = this._extent;
      isNaN(t) || (n[0] = t), isNaN(e) || (n[1] = e), this._brkCtx && this._brkCtx.update(n);
    }, r.prototype.setBreaksFromOption = function(t) {
      var e = lr();
      e && this._innerSetBreak(e.parseAxisBreakOption(t, mt(this.parse, this)));
    }, r.prototype._innerSetBreak = function(t) {
      this._brkCtx && (this._brkCtx.setBreaks(t), this._calculator.updateMethods(this._brkCtx), this._brkCtx.update(this._extent));
    }, r.prototype._innerGetBreaks = function() {
      return this._brkCtx ? this._brkCtx.breaks : [];
    }, r.prototype.hasBreaks = function() {
      return this._brkCtx ? this._brkCtx.hasBreaks() : !1;
    }, r.prototype._getExtentSpanWithBreaks = function() {
      return this._brkCtx && this._brkCtx.hasBreaks() ? this._brkCtx.getExtentSpan() : this._extent[1] - this._extent[0];
    }, r.prototype.isInExtentRange = function(t) {
      return this._extent[0] <= t && this._extent[1] >= t;
    }, r.prototype.isBlank = function() {
      return this._isBlank;
    }, r.prototype.setBlank = function(t) {
      this._isBlank = t;
    }, r;
  }()
);
Zg(Jo);
var H$ = 0, ph = (
  /** @class */
  function() {
    function r(t) {
      this.categories = t.categories || [], this._needCollect = t.needCollect, this._deduplication = t.deduplication, this.uid = ++H$, this._onCollect = t.onCollect;
    }
    return r.createByAxisModel = function(t) {
      var e = t.option, n = e.data, i = n && rt(n, W$);
      return new r({
        categories: i,
        needCollect: !i,
        // deduplication is default in axis.
        deduplication: e.dedplication !== !1
      });
    }, r.prototype.getOrdinal = function(t) {
      return this._getOrCreateMap().get(t);
    }, r.prototype.parseAndCollect = function(t) {
      var e, n = this._needCollect;
      if (!pt(t) && !n)
        return t;
      if (n && !this._deduplication)
        return e = this.categories.length, this.categories[e] = t, this._onCollect && this._onCollect(t, e), e;
      var i = this._getOrCreateMap();
      return e = i.get(t), e == null && (n ? (e = this.categories.length, this.categories[e] = t, i.set(t, e), this._onCollect && this._onCollect(t, e)) : e = NaN), e;
    }, r.prototype._getOrCreateMap = function() {
      return this._map || (this._map = wt(this.categories));
    }, r;
  }()
);
function W$(r) {
  return Dt(r) && r.value != null ? r.value : r + "";
}
var oc = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e) {
      var n = r.call(this, e) || this;
      n.type = "ordinal";
      var i = n.getSetting("ordinalMeta");
      return i || (i = new ph({})), et(i) && (i = new ph({
        categories: rt(i, function(a) {
          return Dt(a) ? a.value : a;
        })
      })), n._ordinalMeta = i, n._extent = n.getSetting("extent") || [0, i.categories.length - 1], n;
    }
    return t.prototype.parse = function(e) {
      return e == null ? NaN : pt(e) ? this._ordinalMeta.getOrdinal(e) : Math.round(e);
    }, t.prototype.contain = function(e) {
      return yb(e, this._extent) && e >= 0 && e < this._ordinalMeta.categories.length;
    }, t.prototype.normalize = function(e) {
      return e = this._getTickNumber(e), this._calculator.normalize(e, this._extent);
    }, t.prototype.scale = function(e) {
      return e = Math.round(this._calculator.scale(e, this._extent)), this.getRawOrdinalNumber(e);
    }, t.prototype.getTicks = function() {
      for (var e = [], n = this._extent, i = n[0]; i <= n[1]; )
        e.push({
          value: i
        }), i++;
      return e;
    }, t.prototype.getMinorTicks = function(e) {
    }, t.prototype.setSortInfo = function(e) {
      if (e == null) {
        this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null;
        return;
      }
      for (var n = e.ordinalNumbers, i = this._ordinalNumbersByTick = [], a = this._ticksByOrdinalNumber = [], o = 0, s = this._ordinalMeta.categories.length, l = Math.min(s, n.length); o < l; ++o) {
        var u = n[o];
        i[o] = u, a[u] = o;
      }
      for (var c = 0; o < s; ++o) {
        for (; a[c] != null; )
          c++;
        i.push(c), a[c] = o;
      }
    }, t.prototype._getTickNumber = function(e) {
      var n = this._ticksByOrdinalNumber;
      return n && e >= 0 && e < n.length ? n[e] : e;
    }, t.prototype.getRawOrdinalNumber = function(e) {
      var n = this._ordinalNumbersByTick;
      return n && e >= 0 && e < n.length ? n[e] : e;
    }, t.prototype.getLabel = function(e) {
      if (!this.isBlank()) {
        var n = this.getRawOrdinalNumber(e.value), i = this._ordinalMeta.categories[n];
        return i == null ? "" : i + "";
      }
    }, t.prototype.count = function() {
      return this._extent[1] - this._extent[0] + 1;
    }, t.prototype.isInExtentRange = function(e) {
      return e = this._getTickNumber(e), this._extent[0] <= e && this._extent[1] >= e;
    }, t.prototype.getOrdinalMeta = function() {
      return this._ordinalMeta;
    }, t.prototype.calcNiceTicks = function() {
    }, t.prototype.calcNiceExtent = function() {
    }, t.type = "ordinal", t;
  }(Jo)
);
Jo.registerClass(oc);
var co = or, Ya = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = "interval", e._interval = 0, e._intervalPrecision = 2, e;
    }
    return t.prototype.parse = function(e) {
      return e == null || e === "" ? NaN : Number(e);
    }, t.prototype.contain = function(e) {
      return yb(e, this._extent);
    }, t.prototype.normalize = function(e) {
      return this._calculator.normalize(e, this._extent);
    }, t.prototype.scale = function(e) {
      return this._calculator.scale(e, this._extent);
    }, t.prototype.getInterval = function() {
      return this._interval;
    }, t.prototype.setInterval = function(e) {
      this._interval = e, this._niceExtent = this._extent.slice(), this._intervalPrecision = dh(e);
    }, t.prototype.getTicks = function(e) {
      e = e || {};
      var n = this._interval, i = this._extent, a = this._niceExtent, o = this._intervalPrecision, s = lr(), l = [];
      if (!n)
        return l;
      if (e.breakTicks === "only_break" && s)
        return s.addBreaksToTicks(l, this._brkCtx.breaks, this._extent), l;
      var u = 1e4;
      i[0] < a[0] && (e.expandToNicedExtent ? l.push({
        value: co(a[0] - n, o)
      }) : l.push({
        value: i[0]
      }));
      for (var c = function(p, g) {
        return Math.round((g - p) / n);
      }, f = a[0]; f <= a[1]; ) {
        if (l.push({
          value: f
        }), f = co(f + n, o), this._brkCtx) {
          var h = this._brkCtx.calcNiceTickMultiple(f, c);
          h >= 0 && (f = co(f + h * n, o));
        }
        if (l.length > 0 && f === l[l.length - 1].value)
          break;
        if (l.length > u)
          return [];
      }
      var d = l.length ? l[l.length - 1].value : a[1];
      return i[1] > d && (e.expandToNicedExtent ? l.push({
        value: co(d + n, o)
      }) : l.push({
        value: i[1]
      })), s && s.pruneTicksByBreak(e.pruneByBreak, l, this._brkCtx.breaks, function(p) {
        return p.value;
      }, this._interval, this._extent), e.breakTicks !== "none" && s && s.addBreaksToTicks(l, this._brkCtx.breaks, this._extent), l;
    }, t.prototype.getMinorTicks = function(e) {
      for (var n = this.getTicks({
        expandToNicedExtent: !0
      }), i = [], a = this.getExtent(), o = 1; o < n.length; o++) {
        var s = n[o], l = n[o - 1];
        if (!(l.break || s.break)) {
          for (var u = 0, c = [], f = s.value - l.value, h = f / e, d = dh(h); u < e - 1; ) {
            var p = co(l.value + (u + 1) * h, d);
            p > a[0] && p < a[1] && c.push(p), u++;
          }
          var g = lr();
          g && g.pruneTicksByBreak("auto", c, this._getNonTransBreaks(), function(v) {
            return v;
          }, this._interval, a), i.push(c);
        }
      }
      return i;
    }, t.prototype._getNonTransBreaks = function() {
      return this._brkCtx ? this._brkCtx.breaks : [];
    }, t.prototype.getLabel = function(e, n) {
      if (e == null)
        return "";
      var i = n && n.precision;
      i == null ? i = Yi(e.value) || 0 : i === "auto" && (i = this._intervalPrecision);
      var a = co(e.value, i, !0);
      return BN(a);
    }, t.prototype.calcNiceTicks = function(e, n, i) {
      e = e || 5;
      var a = this._extent.slice(), o = this._getExtentSpanWithBreaks();
      if (isFinite(o)) {
        o < 0 && (o = -o, a.reverse(), this._innerSetExtent(a[0], a[1]), a = this._extent.slice());
        var s = z$(a, o, e, n, i);
        this._intervalPrecision = s.intervalPrecision, this._interval = s.interval, this._niceExtent = s.niceTickExtent;
      }
    }, t.prototype.calcNiceExtent = function(e) {
      var n = this._extent.slice();
      if (n[0] === n[1])
        if (n[0] !== 0) {
          var i = Math.abs(n[0]);
          e.fixMax || (n[1] += i / 2), n[0] -= i / 2;
        } else
          n[1] = 1;
      var a = n[1] - n[0];
      isFinite(a) || (n[0] = 0, n[1] = 1), this._innerSetExtent(n[0], n[1]), n = this._extent.slice(), this.calcNiceTicks(e.splitNumber, e.minInterval, e.maxInterval);
      var o = this._interval, s = this._intervalPrecision;
      e.fixMin || (n[0] = co(Math.floor(n[0] / o) * o, s)), e.fixMax || (n[1] = co(Math.ceil(n[1] / o) * o, s)), this._innerSetExtent(n[0], n[1]);
    }, t.prototype.setNiceExtent = function(e, n) {
      this._niceExtent = [e, n];
    }, t.type = "interval", t;
  }(Jo)
);
Jo.registerClass(Ya);
var uk = typeof Float32Array < "u", X$ = uk ? Float32Array : Array;
function Zi(r) {
  return et(r) ? uk ? new Float32Array(r) : r : new X$(r);
}
var aS = "__ec_stack_";
function ck(r) {
  return r.get("stack") || aS + r.seriesIndex;
}
function _b(r) {
  return r.dim + r.index;
}
function Y$(r) {
  var t = [], e = r.axis, n = "axis0";
  if (e.type === "category") {
    for (var i = e.getBandWidth(), a = 0; a < r.count; a++)
      t.push(kt({
        bandWidth: i,
        axisKey: n,
        stackId: aS + a
      }, r));
    for (var o = dk(t), s = [], a = 0; a < r.count; a++) {
      var l = o[n][aS + a];
      l.offsetCenter = l.offset + l.width / 2, s.push(l);
    }
    return s;
  }
}
function fk(r, t) {
  var e = [];
  return t.eachSeriesByType(r, function(n) {
    gk(n) && e.push(n);
  }), e;
}
function $$(r) {
  var t = {};
  L(r, function(l) {
    var u = l.coordinateSystem, c = u.getBaseAxis();
    if (!(c.type !== "time" && c.type !== "value"))
      for (var f = l.getData(), h = c.dim + "_" + c.index, d = f.getDimensionIndex(f.mapDimension(c.dim)), p = f.getStore(), g = 0, v = p.count(); g < v; ++g) {
        var m = p.get(d, g);
        t[h] ? t[h].push(m) : t[h] = [m];
      }
  });
  var e = {};
  for (var n in t)
    if (t.hasOwnProperty(n)) {
      var i = t[n];
      if (i) {
        i.sort(function(l, u) {
          return l - u;
        });
        for (var a = null, o = 1; o < i.length; ++o) {
          var s = i[o] - i[o - 1];
          s > 0 && (a = a === null ? s : Math.min(a, s));
        }
        e[n] = a;
      }
    }
  return e;
}
function hk(r) {
  var t = $$(r), e = [];
  return L(r, function(n) {
    var i = n.coordinateSystem, a = i.getBaseAxis(), o = a.getExtent(), s;
    if (a.type === "category")
      s = a.getBandWidth();
    else if (a.type === "value" || a.type === "time") {
      var l = a.dim + "_" + a.index, u = t[l], c = Math.abs(o[1] - o[0]), f = a.scale.getExtent(), h = Math.abs(f[1] - f[0]);
      s = u ? c / h * u : c;
    } else {
      var d = n.getData();
      s = Math.abs(o[1] - o[0]) / d.count();
    }
    var p = dt(n.get("barWidth"), s), g = dt(n.get("barMaxWidth"), s), v = dt(
      // barMinWidth by default is 0.5 / 1 in cartesian. Because in value axis,
      // the auto-calculated bar width might be less than 0.5 / 1.
      n.get("barMinWidth") || (mk(n) ? 0.5 : 1),
      s
    ), m = n.get("barGap"), y = n.get("barCategoryGap"), _ = n.get("defaultBarGap");
    e.push({
      bandWidth: s,
      barWidth: p,
      barMaxWidth: g,
      barMinWidth: v,
      barGap: m,
      barCategoryGap: y,
      defaultBarGap: _,
      axisKey: _b(a),
      stackId: ck(n)
    });
  }), dk(e);
}
function dk(r) {
  var t = {};
  L(r, function(n, i) {
    var a = n.axisKey, o = n.bandWidth, s = t[a] || {
      bandWidth: o,
      remainedWidth: o,
      autoWidthCount: 0,
      categoryGap: null,
      gap: n.defaultBarGap || 0,
      stacks: {}
    }, l = s.stacks;
    t[a] = s;
    var u = n.stackId;
    l[u] || s.autoWidthCount++, l[u] = l[u] || {
      width: 0,
      maxWidth: 0
    };
    var c = n.barWidth;
    c && !l[u].width && (l[u].width = c, c = Math.min(s.remainedWidth, c), s.remainedWidth -= c);
    var f = n.barMaxWidth;
    f && (l[u].maxWidth = f);
    var h = n.barMinWidth;
    h && (l[u].minWidth = h);
    var d = n.barGap;
    d != null && (s.gap = d);
    var p = n.barCategoryGap;
    p != null && (s.categoryGap = p);
  });
  var e = {};
  return L(t, function(n, i) {
    e[i] = {};
    var a = n.stacks, o = n.bandWidth, s = n.categoryGap;
    if (s == null) {
      var l = se(a).length;
      s = Math.max(35 - l * 4, 15) + "%";
    }
    var u = dt(s, o), c = dt(n.gap, 1), f = n.remainedWidth, h = n.autoWidthCount, d = (f - u) / (h + (h - 1) * c);
    d = Math.max(d, 0), L(a, function(m) {
      var y = m.maxWidth, _ = m.minWidth;
      if (m.width) {
        var x = m.width;
        y && (x = Math.min(x, y)), _ && (x = Math.max(x, _)), m.width = x, f -= x + c * x, h--;
      } else {
        var x = d;
        y && y < x && (x = Math.min(y, f)), _ && _ > x && (x = _), x !== d && (m.width = x, f -= x + c * x, h--);
      }
    }), d = (f - u) / (h + (h - 1) * c), d = Math.max(d, 0);
    var p = 0, g;
    L(a, function(m, y) {
      m.width || (m.width = d), g = m, p += m.width * (1 + c);
    }), g && (p -= g.width * c);
    var v = -p / 2;
    L(a, function(m, y) {
      e[i][y] = e[i][y] || {
        bandWidth: o,
        offset: v,
        width: m.width
      }, v += m.width * (1 + c);
    });
  }), e;
}
function Z$(r, t, e) {
  if (r && t) {
    var n = r[_b(t)];
    return n;
  }
}
function pk(r, t) {
  var e = fk(r, t), n = hk(e);
  L(e, function(i) {
    var a = i.getData(), o = i.coordinateSystem, s = o.getBaseAxis(), l = ck(i), u = n[_b(s)][l], c = u.offset, f = u.width;
    a.setLayout({
      bandWidth: u.bandWidth,
      offset: c,
      size: f
    });
  });
}
function vk(r) {
  return {
    seriesType: r,
    plan: Cc(),
    reset: function(t) {
      if (gk(t)) {
        var e = t.getData(), n = t.coordinateSystem, i = n.getBaseAxis(), a = n.getOtherAxis(i), o = e.getDimensionIndex(e.mapDimension(a.dim)), s = e.getDimensionIndex(e.mapDimension(i.dim)), l = t.get("showBackground", !0), u = e.mapDimension(a.dim), c = e.getCalculationInfo("stackResultDimension"), f = Ho(e, u) && !!e.getCalculationInfo("stackedOnSeries"), h = a.isHorizontal(), d = q$(i, a), p = mk(t), g = t.get("barMinHeight") || 0, v = c && e.getDimensionIndex(c), m = e.getLayout("size"), y = e.getLayout("offset");
        return {
          progress: function(_, x) {
            for (var b = _.count, S = p && Zi(b * 3), w = p && l && Zi(b * 3), A = p && Zi(b), T = n.master.getRect(), M = h ? T.width : T.height, E, R = x.getStore(), C = 0; (E = _.next()) != null; ) {
              var D = R.get(f ? v : o, E), I = R.get(s, E), P = d, O = void 0;
              f && (O = +D - R.get(o, E));
              var N = void 0, B = void 0, F = void 0, G = void 0;
              if (h) {
                var X = n.dataToPoint([D, I]);
                if (f) {
                  var K = n.dataToPoint([O, I]);
                  P = K[0];
                }
                N = P, B = X[1] + y, F = X[0] - P, G = m, Math.abs(F) < g && (F = (F < 0 ? -1 : 1) * g);
              } else {
                var X = n.dataToPoint([I, D]);
                if (f) {
                  var K = n.dataToPoint([I, O]);
                  P = K[1];
                }
                N = X[0] + y, B = P, F = m, G = X[1] - P, Math.abs(G) < g && (G = (G <= 0 ? -1 : 1) * g);
              }
              p ? (S[C] = N, S[C + 1] = B, S[C + 2] = h ? F : G, w && (w[C] = h ? T.x : N, w[C + 1] = h ? B : T.y, w[C + 2] = M), A[E] = E) : x.setItemLayout(E, {
                x: N,
                y: B,
                width: F,
                height: G
              }), C += 3;
            }
            p && x.setLayout({
              largePoints: S,
              largeDataIndices: A,
              largeBackgroundPoints: w,
              valueAxisHorizontal: h
            });
          }
        };
      }
    }
  };
}
function gk(r) {
  return r.coordinateSystem && r.coordinateSystem.type === "cartesian2d";
}
function mk(r) {
  return r.pipelineContext && r.pipelineContext.large;
}
function q$(r, t) {
  var e = t.model.get("startValue");
  return e || (e = 0), t.toGlobalCoord(t.dataToCoord(t.type === "log" ? e > 0 ? e : 1 : e));
}
var K$ = function(r, t, e, n) {
  for (; e < n; ) {
    var i = e + n >>> 1;
    r[i][1] < t ? e = i + 1 : n = i;
  }
  return e;
}, xb = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e) {
      var n = r.call(this, e) || this;
      return n.type = "time", n;
    }
    return t.prototype.getLabel = function(e) {
      var n = this.getSetting("useUTC");
      return lm(e.value, XA[_9($f(this._minLevelUnit))] || XA.second, n, this.getSetting("locale"));
    }, t.prototype.getFormattedLabel = function(e, n, i) {
      var a = this.getSetting("useUTC"), o = this.getSetting("locale");
      return x9(e, n, i, o, a);
    }, t.prototype.getTicks = function(e) {
      e = e || {};
      var n = this._interval, i = this._extent, a = lr(), o = [];
      if (!n)
        return o;
      var s = this.getSetting("useUTC");
      if (a && e.breakTicks === "only_break")
        return lr().addBreaksToTicks(o, this._brkCtx.breaks, this._extent), o;
      var l = Bu(i[1], s);
      o.push({
        value: i[0],
        time: {
          level: 0,
          upperTimeUnit: l,
          lowerTimeUnit: l
        }
      });
      var u = nZ(this._minLevelUnit, this._approxInterval, s, i, this._getExtentSpanWithBreaks(), this._brkCtx);
      o = o.concat(u);
      var c = Bu(i[1], s);
      o.push({
        value: i[1],
        time: {
          level: 0,
          upperTimeUnit: c,
          lowerTimeUnit: c
        }
      });
      var f = this.getSetting("useUTC"), h = Cn.length - 1, d = 0;
      return L(o, function(p) {
        h = Math.min(h, Zt(Cn, p.time.upperTimeUnit)), d = Math.max(d, p.time.level);
      }), a && lr().pruneTicksByBreak(e.pruneByBreak, o, this._brkCtx.breaks, function(p) {
        return p.value;
      }, this._approxInterval, this._extent), a && e.breakTicks !== "none" && lr().addBreaksToTicks(o, this._brkCtx.breaks, this._extent, function(p) {
        for (var g = Math.max(Zt(Cn, Bu(p.vmin, f)), Zt(Cn, Bu(p.vmax, f))), v = 0, m = 0; m < Cn.length; m++)
          if (!yk(Cn[m], p.vmin, p.vmax, f)) {
            v = m;
            break;
          }
        var y = Math.min(v, h), _ = Math.max(y, g);
        return {
          level: d,
          lowerTimeUnit: Cn[_],
          upperTimeUnit: Cn[y]
        };
      }), o;
    }, t.prototype.calcNiceExtent = function(e) {
      var n = this.getExtent();
      if (n[0] === n[1] && (n[0] -= Qn, n[1] += Qn), n[1] === -1 / 0 && n[0] === 1 / 0) {
        var i = /* @__PURE__ */ new Date();
        n[1] = +new Date(i.getFullYear(), i.getMonth(), i.getDate()), n[0] = n[1] - Qn;
      }
      this._innerSetExtent(n[0], n[1]), this.calcNiceTicks(e.splitNumber, e.minInterval, e.maxInterval);
    }, t.prototype.calcNiceTicks = function(e, n, i) {
      e = e || 10;
      var a = this._getExtentSpanWithBreaks();
      this._approxInterval = a / e, n != null && this._approxInterval < n && (this._approxInterval = n), i != null && this._approxInterval > i && (this._approxInterval = i);
      var o = ep.length, s = Math.min(K$(ep, this._approxInterval, 0, o), o - 1);
      this._interval = ep[s][1], this._intervalPrecision = dh(this._interval), this._minLevelUnit = ep[Math.max(s - 1, 0)][0];
    }, t.prototype.parse = function(e) {
      return fe(e) ? e : +Tl(e);
    }, t.prototype.contain = function(e) {
      return yb(e, this._extent);
    }, t.prototype.normalize = function(e) {
      return this._calculator.normalize(e, this._extent);
    }, t.prototype.scale = function(e) {
      return this._calculator.scale(e, this._extent);
    }, t.type = "time", t;
  }(Ya)
), ep = [
  // Format                           interval
  ["second", $1],
  ["minute", Z1],
  ["hour", Yf],
  ["quarter-day", Yf * 6],
  ["half-day", Yf * 12],
  ["day", Qn * 1.2],
  ["half-week", Qn * 3.5],
  ["week", Qn * 7],
  ["month", Qn * 31],
  ["quarter", Qn * 95],
  ["half-year", WA / 2],
  ["year", WA]
  // 1Y
];
function yk(r, t, e, n) {
  return Vx(new Date(t), r, n).getTime() === Vx(new Date(e), r, n).getTime();
}
function j$(r, t) {
  return r /= Qn, r > 16 ? 16 : r > 7.5 ? 7 : r > 3.5 ? 4 : r > 1.5 ? 2 : 1;
}
function J$(r) {
  var t = 30 * Qn;
  return r /= t, r > 6 ? 6 : r > 3 ? 3 : r > 2 ? 2 : 1;
}
function Q$(r) {
  return r /= Yf, r > 12 ? 12 : r > 6 ? 6 : r > 3.5 ? 4 : r > 2 ? 2 : 1;
}
function rC(r, t) {
  return r /= t ? Z1 : $1, r > 30 ? 30 : r > 20 ? 20 : r > 15 ? 15 : r > 10 ? 10 : r > 5 ? 5 : r > 2 ? 2 : 1;
}
function tZ(r) {
  return DP(r);
}
function eZ(r, t, e) {
  var n = Math.max(0, Zt(Cn, t) - 1);
  return Vx(new Date(r), Cn[n], e).getTime();
}
function rZ(r, t) {
  var e = /* @__PURE__ */ new Date(0);
  e[r](1);
  var n = e.getTime();
  e[r](1 + t);
  var i = e.getTime() - n;
  return function(a, o) {
    return Math.max(0, Math.round((o - a) / i));
  };
}
function nZ(r, t, e, n, i, a) {
  var o = 1e4, s = v9, l = 0;
  function u(C, D, I, P, O, N, B) {
    for (var F = rZ(O, C), G = D, X = new Date(G); G < I && G <= n[1]; ) {
      if (B.push({
        value: G
      }), l++ > o) {
        process.env.NODE_ENV !== "production" && Xe("Exceed safe limit in time scale.");
        break;
      }
      if (X[O](X[P]() + C), G = X.getTime(), a) {
        var K = a.calcNiceTickMultiple(G, F);
        K > 0 && (X[O](X[P]() + K * C), G = X.getTime());
      }
    }
    B.push({
      value: G,
      notAdd: !0
    });
  }
  function c(C, D, I) {
    var P = [], O = !D.length;
    if (!yk($f(C), n[0], n[1], e)) {
      O && (D = [{
        value: eZ(n[0], C, e)
      }, {
        value: n[1]
      }]);
      for (var N = 0; N < D.length - 1; N++) {
        var B = D[N].value, F = D[N + 1].value;
        if (B !== F) {
          var G = void 0, X = void 0, K = void 0, U = !1;
          switch (C) {
            case "year":
              G = Math.max(1, Math.round(t / Qn / 365)), X = LN(e), K = S9(e);
              break;
            case "half-year":
            case "quarter":
            case "month":
              G = J$(t), X = q1(e), K = RN(e);
              break;
            case "week":
            case "half-week":
            case "day":
              G = j$(t), X = K1(e), K = IN(e), U = !0;
              break;
            case "half-day":
            case "quarter-day":
            case "hour":
              G = Q$(t), X = j1(e), K = PN(e);
              break;
            case "minute":
              G = rC(t, !0), X = J1(e), K = NN(e);
              break;
            case "second":
              G = rC(t, !1), X = Q1(e), K = ON(e);
              break;
            case "millisecond":
              G = tZ(t), X = tb(e), K = kN(e);
              break;
          }
          F >= n[0] && B <= n[1] && u(G, B, F, X, K, U, P), C === "year" && I.length > 1 && N === 0 && I.unshift({
            value: I[0].value - G
          });
        }
      }
      for (var N = 0; N < P.length; N++)
        I.push(P[N]);
    }
  }
  for (var f = [], h = [], d = 0, p = 0, g = 0; g < s.length; ++g) {
    var v = $f(s[g]);
    if (y9(s[g])) {
      c(s[g], f[f.length - 1] || [], h);
      var m = s[g + 1] ? $f(s[g + 1]) : null;
      if (v !== m) {
        if (h.length) {
          p = d, h.sort(function(C, D) {
            return C.value - D.value;
          });
          for (var y = [], _ = 0; _ < h.length; ++_) {
            var x = h[_].value;
            (_ === 0 || h[_ - 1].value !== x) && (y.push(h[_]), x >= n[0] && x <= n[1] && d++);
          }
          var b = i / t;
          if (d > b * 1.5 && p > b / 1.5 || (f.push(y), d > b || r === s[g]))
            break;
        }
        h = [];
      }
    }
  }
  for (var S = Te(rt(f, function(C) {
    return Te(C, function(D) {
      return D.value >= n[0] && D.value <= n[1] && !D.notAdd;
    });
  }), function(C) {
    return C.length > 0;
  }), w = [], A = S.length - 1, g = 0; g < S.length; ++g)
    for (var T = S[g], M = 0; M < T.length; ++M) {
      var E = Bu(T[M].value, e);
      w.push({
        value: T[M].value,
        time: {
          level: A - g,
          upperTimeUnit: E,
          lowerTimeUnit: E
        }
      });
    }
  w.sort(function(C, D) {
    return C.value - D.value;
  });
  for (var R = [], g = 0; g < w.length; ++g)
    (g === 0 || w[g].value !== w[g - 1].value) && R.push(w[g]);
  return R;
}
Jo.registerClass(xb);
var oS = or, iZ = Math.floor, aZ = Math.ceil, rp = Math.pow, np = Math.log, _k = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = "log", e.base = 10, e._originalScale = new Ya(), e;
    }
    return t.prototype.getTicks = function(e) {
      e = e || {};
      var n = this._extent.slice(), i = this._originalScale.getExtent(), a = r.prototype.getTicks.call(this, e), o = this.base, s = this._originalScale._innerGetBreaks(), l = lr();
      return rt(a, function(u) {
        var c = u.value, f = null, h = rp(o, c);
        c === n[0] && this._fixMin ? f = i[0] : c === n[1] && this._fixMax && (f = i[1]);
        var d;
        if (l) {
          var p = l.getTicksLogTransformBreak(u, o, s, ip);
          d = p.vBreak, f == null && (f = p.brkRoundingCriterion);
        }
        return f != null && (h = ip(h, f)), {
          value: h,
          break: d
        };
      }, this);
    }, t.prototype._getNonTransBreaks = function() {
      return this._originalScale._innerGetBreaks();
    }, t.prototype.setExtent = function(e, n) {
      this._originalScale.setExtent(e, n);
      var i = iS(this.base, [e, n]);
      r.prototype.setExtent.call(this, i[0], i[1]);
    }, t.prototype.getExtent = function() {
      var e = this.base, n = r.prototype.getExtent.call(this);
      n[0] = rp(e, n[0]), n[1] = rp(e, n[1]);
      var i = this._originalScale.getExtent();
      return this._fixMin && (n[0] = ip(n[0], i[0])), this._fixMax && (n[1] = ip(n[1], i[1])), n;
    }, t.prototype.unionExtentFromData = function(e, n) {
      this._originalScale.unionExtentFromData(e, n);
      var i = iS(this.base, e.getApproximateExtent(n), !0);
      this._innerUnionExtent(i);
    }, t.prototype.calcNiceTicks = function(e) {
      e = e || 10;
      var n = this._extent.slice(), i = this._getExtentSpanWithBreaks();
      if (!(!isFinite(i) || i <= 0)) {
        var a = G8(i), o = e / i * a;
        for (o <= 0.5 && (a *= 10); !isNaN(a) && Math.abs(a) < 1 && Math.abs(a) > 0; )
          a *= 10;
        var s = [oS(aZ(n[0] / a) * a), oS(iZ(n[1] / a) * a)];
        this._interval = a, this._intervalPrecision = dh(a), this._niceExtent = s;
      }
    }, t.prototype.calcNiceExtent = function(e) {
      r.prototype.calcNiceExtent.call(this, e), this._fixMin = e.fixMin, this._fixMax = e.fixMax;
    }, t.prototype.contain = function(e) {
      return e = np(e) / np(this.base), r.prototype.contain.call(this, e);
    }, t.prototype.normalize = function(e) {
      return e = np(e) / np(this.base), r.prototype.normalize.call(this, e);
    }, t.prototype.scale = function(e) {
      return e = r.prototype.scale.call(this, e), rp(this.base, e);
    }, t.prototype.setBreaksFromOption = function(e) {
      var n = lr();
      if (n) {
        var i = n.logarithmicParseBreaksFromOption(e, this.base, mt(this.parse, this)), a = i.parsedOriginal, o = i.parsedLogged;
        this._originalScale._innerSetBreak(a), this._innerSetBreak(o);
      }
    }, t.type = "log", t;
  }(Ya)
);
function ip(r, t) {
  return oS(r, Yi(t));
}
Jo.registerClass(_k);
var oZ = (
  /** @class */
  function() {
    function r(t, e, n) {
      this._prepareParams(t, e, n);
    }
    return r.prototype._prepareParams = function(t, e, n) {
      n[1] < n[0] && (n = [NaN, NaN]), this._dataMin = n[0], this._dataMax = n[1];
      var i = this._isOrdinal = t.type === "ordinal";
      this._needCrossZero = t.type === "interval" && e.getNeedCrossZero && e.getNeedCrossZero();
      var a = e.get("min", !0);
      a == null && (a = e.get("startValue", !0));
      var o = this._modelMinRaw = a;
      Tt(o) ? this._modelMinNum = ap(t, o({
        min: n[0],
        max: n[1]
      })) : o !== "dataMin" && (this._modelMinNum = ap(t, o));
      var s = this._modelMaxRaw = e.get("max", !0);
      if (Tt(s) ? this._modelMaxNum = ap(t, s({
        min: n[0],
        max: n[1]
      })) : s !== "dataMax" && (this._modelMaxNum = ap(t, s)), i)
        this._axisDataLen = e.getCategories().length;
      else {
        var l = e.get("boundaryGap"), u = et(l) ? l : [l || 0, l || 0];
        typeof u[0] == "boolean" || typeof u[1] == "boolean" ? (process.env.NODE_ENV !== "production" && console.warn('Boolean type for boundaryGap is only allowed for ordinal axis. Please use string in percentage instead, e.g., "20%". Currently, boundaryGap is set to be 0.'), this._boundaryGapInner = [0, 0]) : this._boundaryGapInner = [bi(u[0], 1), bi(u[1], 1)];
      }
    }, r.prototype.calculate = function() {
      var t = this._isOrdinal, e = this._dataMin, n = this._dataMax, i = this._axisDataLen, a = this._boundaryGapInner, o = t ? null : n - e || Math.abs(e), s = this._modelMinRaw === "dataMin" ? e : this._modelMinNum, l = this._modelMaxRaw === "dataMax" ? n : this._modelMaxNum, u = s != null, c = l != null;
      s == null && (s = t ? i ? 0 : NaN : e - a[0] * o), l == null && (l = t ? i ? i - 1 : NaN : n + a[1] * o), (s == null || !isFinite(s)) && (s = NaN), (l == null || !isFinite(l)) && (l = NaN);
      var f = Or(s) || Or(l) || t && !i;
      this._needCrossZero && (s > 0 && l > 0 && !u && (s = 0), s < 0 && l < 0 && !c && (l = 0));
      var h = this._determinedMin, d = this._determinedMax;
      return h != null && (s = h, u = !0), d != null && (l = d, c = !0), {
        min: s,
        max: l,
        minFixed: u,
        maxFixed: c,
        isBlank: f
      };
    }, r.prototype.modifyDataMinMax = function(t, e) {
      process.env.NODE_ENV !== "production" && St(!this.frozen), this[lZ[t]] = e;
    }, r.prototype.setDeterminedMinMax = function(t, e) {
      var n = sZ[t];
      process.env.NODE_ENV !== "production" && St(!this.frozen && this[n] == null), this[n] = e;
    }, r.prototype.freeze = function() {
      this.frozen = !0;
    }, r;
  }()
), sZ = {
  min: "_determinedMin",
  max: "_determinedMax"
}, lZ = {
  min: "_dataMin",
  max: "_dataMax"
};
function xk(r, t, e) {
  var n = r.rawExtentInfo;
  return n || (n = new oZ(r, t, e), r.rawExtentInfo = n, n);
}
function ap(r, t) {
  return t == null ? null : Or(t) ? NaN : r.parse(t);
}
function Sk(r, t) {
  var e = r.type, n = xk(r, t, r.getExtent()).calculate();
  r.setBlank(n.isBlank);
  var i = n.min, a = n.max, o = t.ecModel;
  if (o && e === "time") {
    var s = fk("bar", o), l = !1;
    if (L(s, function(f) {
      l = l || f.getBaseAxis() === t.axis;
    }), l) {
      var u = hk(s), c = uZ(i, a, t, u);
      i = c.min, a = c.max;
    }
  }
  return {
    extent: [i, a],
    // "fix" means "fixed", the value should not be
    // changed in the subsequent steps.
    fixMin: n.minFixed,
    fixMax: n.maxFixed
  };
}
function uZ(r, t, e, n) {
  var i = e.axis.getExtent(), a = Math.abs(i[1] - i[0]), o = Z$(n, e.axis);
  if (o === void 0)
    return {
      min: r,
      max: t
    };
  var s = 1 / 0;
  L(o, function(d) {
    s = Math.min(d.offset, s);
  });
  var l = -1 / 0;
  L(o, function(d) {
    l = Math.max(d.offset + d.width, l);
  }), s = Math.abs(s), l = Math.abs(l);
  var u = s + l, c = t - r, f = 1 - (s + l) / a, h = c / f - c;
  return t += h * (l / u), r -= h * (s / u), {
    min: r,
    max: t
  };
}
function sc(r, t) {
  var e = t, n = Sk(r, e), i = n.extent, a = e.get("splitNumber");
  r instanceof _k && (r.base = e.get("logBase"));
  var o = r.type, s = e.get("interval"), l = o === "interval" || o === "time";
  r.setBreaksFromOption(wk(e)), r.setExtent(i[0], i[1]), r.calcNiceExtent({
    splitNumber: a,
    fixMin: n.fixMin,
    fixMax: n.fixMax,
    minInterval: l ? e.get("minInterval") : null,
    maxInterval: l ? e.get("maxInterval") : null
  }), s != null && r.setInterval && r.setInterval(s);
}
function pm(r, t) {
  if (t = t || r.get("type"), t)
    switch (t) {
      case "category":
        return new oc({
          ordinalMeta: r.getOrdinalMeta ? r.getOrdinalMeta() : r.getCategories(),
          extent: [1 / 0, -1 / 0]
        });
      case "time":
        return new xb({
          locale: r.ecModel.getLocaleModel(),
          useUTC: r.ecModel.get("useUTC")
        });
      default:
        return new (Jo.getClass(t) || Ya)();
    }
}
function cZ(r) {
  var t = r.scale.getExtent(), e = t[0], n = t[1];
  return !(e > 0 && n > 0 || e < 0 && n < 0);
}
function Rc(r) {
  var t = r.getLabelModel().get("formatter");
  if (r.type === "time") {
    var e = g9(t);
    return function(i, a) {
      return r.scale.getFormattedLabel(i, a, e);
    };
  } else {
    if (pt(t))
      return function(i) {
        var a = r.scale.getLabel(i), o = t.replace("{value}", a ?? "");
        return o;
      };
    if (Tt(t)) {
      if (r.type === "category")
        return function(i, a) {
          return t(
            Kv(r, i),
            i.value - r.scale.getExtent()[0],
            null
            // Using `null` just for backward compat.
          );
        };
      var n = lr();
      return function(i, a) {
        var o = null;
        return n && (o = n.makeAxisLabelFormatterParamBreak(o, i.break)), t(Kv(r, i), a, o);
      };
    } else
      return function(i) {
        return r.scale.getLabel(i);
      };
  }
}
function Kv(r, t) {
  return r.type === "category" ? r.scale.getLabel(t) : t.value;
}
function Sb(r) {
  var t = r.get("interval");
  return t ?? "auto";
}
function bk(r) {
  return r.type === "category" && Sb(r.getLabelModel()) === 0;
}
function jv(r, t) {
  var e = {};
  return L(r.mapDimensionsAll(t), function(n) {
    e[lk(r, n)] = !0;
  }), se(e);
}
function fZ(r, t, e) {
  t && L(jv(t, e), function(n) {
    var i = t.getApproximateExtent(n);
    i[0] < r[0] && (r[0] = i[0]), i[1] > r[1] && (r[1] = i[1]);
  });
}
function lc(r) {
  return r === "middle" || r === "center";
}
function vh(r) {
  return r.getShallow("show");
}
function wk(r) {
  var t = r.get("breaks", !0);
  if (t != null) {
    if (!lr()) {
      process.env.NODE_ENV !== "production" && ce('Must `import {AxisBreak} from "echarts/features.js"; use(AxisBreak);` first if using breaks option.');
      return;
    }
    if (!hZ(r.axis)) {
      process.env.NODE_ENV !== "production" && ce("Axis '" + r.axis.dim + "'-'" + r.axis.type + "' does not support break.");
      return;
    }
    return t;
  }
}
function hZ(r) {
  return (r.dim === "x" || r.dim === "y" || r.dim === "z" || r.dim === "single") && r.type !== "category";
}
var Hh = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getNeedCrossZero = function() {
      var t = this.option;
      return !t.scale;
    }, r.prototype.getCoordSysModel = function() {
    }, r;
  }()
), dZ = 1e-8;
function nC(r, t) {
  return Math.abs(r - t) < dZ;
}
function Gs(r, t, e) {
  var n = 0, i = r[0];
  if (!i)
    return !1;
  for (var a = 1; a < r.length; a++) {
    var o = r[a];
    n += Ma(i[0], i[1], o[0], o[1], t, e), i = o;
  }
  var s = r[0];
  return (!nC(i[0], s[0]) || !nC(i[1], s[1])) && (n += Ma(i[0], i[1], s[0], s[1], t, e)), n !== 0;
}
var pZ = [];
function m0(r, t) {
  for (var e = 0; e < r.length; e++)
    rr(r[e], r[e], t);
}
function iC(r, t, e, n) {
  for (var i = 0; i < r.length; i++) {
    var a = r[i];
    n && (a = n.project(a)), a && isFinite(a[0]) && isFinite(a[1]) && (So(t, t, a), bo(e, e, a));
  }
}
function vZ(r) {
  for (var t = 0, e = 0, n = 0, i = r.length, a = r[i - 1][0], o = r[i - 1][1], s = 0; s < i; s++) {
    var l = r[s][0], u = r[s][1], c = a * u - l * o;
    t += c, e += (a + l) * c, n += (o + u) * c, a = l, o = u;
  }
  return t ? [e / t / 3, n / t / 3, t] : [r[0][0] || 0, r[0][1] || 0];
}
var Mk = (
  /** @class */
  function() {
    function r(t) {
      this.name = t;
    }
    return r.prototype.setCenter = function(t) {
      this._center = t;
    }, r.prototype.getCenter = function() {
      var t = this._center;
      return t || (t = this._center = this.calcCenter()), t;
    }, r;
  }()
), aC = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(t, e) {
      this.type = "polygon", this.exterior = t, this.interiors = e;
    }
    return r;
  }()
), oC = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(t) {
      this.type = "linestring", this.points = t;
    }
    return r;
  }()
), Tk = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e, n, i) {
      var a = r.call(this, e) || this;
      return a.type = "geoJSON", a.geometries = n, a._center = i && [i[0], i[1]], a;
    }
    return t.prototype.calcCenter = function() {
      for (var e = this.geometries, n, i = 0, a = 0; a < e.length; a++) {
        var o = e[a], s = o.exterior, l = s && s.length;
        l > i && (n = o, i = l);
      }
      if (n)
        return vZ(n.exterior);
      var u = this.getBoundingRect();
      return [u.x + u.width / 2, u.y + u.height / 2];
    }, t.prototype.getBoundingRect = function(e) {
      var n = this._rect;
      if (n && !e)
        return n;
      var i = [1 / 0, 1 / 0], a = [-1 / 0, -1 / 0], o = this.geometries;
      return L(o, function(s) {
        s.type === "polygon" ? iC(s.exterior, i, a, e) : L(s.points, function(l) {
          iC(l, i, a, e);
        });
      }), isFinite(i[0]) && isFinite(i[1]) && isFinite(a[0]) && isFinite(a[1]) || (i[0] = i[1] = a[0] = a[1] = 0), n = new Bt(i[0], i[1], a[0] - i[0], a[1] - i[1]), e || (this._rect = n), n;
    }, t.prototype.contain = function(e) {
      var n = this.getBoundingRect(), i = this.geometries;
      if (!n.contain(e[0], e[1]))
        return !1;
      t:
        for (var a = 0, o = i.length; a < o; a++) {
          var s = i[a];
          if (s.type === "polygon") {
            var l = s.exterior, u = s.interiors;
            if (Gs(l, e[0], e[1])) {
              for (var c = 0; c < (u ? u.length : 0); c++)
                if (Gs(u[c], e[0], e[1]))
                  continue t;
              return !0;
            }
          }
        }
      return !1;
    }, t.prototype.transformTo = function(e, n, i, a) {
      var o = this.getBoundingRect(), s = o.width / o.height;
      i ? a || (a = i / s) : i = s * a;
      for (var l = new Bt(e, n, i, a), u = o.calculateTransform(l), c = this.geometries, f = 0; f < c.length; f++) {
        var h = c[f];
        h.type === "polygon" ? (m0(h.exterior, u), L(h.interiors, function(d) {
          m0(d, u);
        })) : L(h.points, function(d) {
          m0(d, u);
        });
      }
      o = this._rect, o.copy(l), this._center = [o.x + o.width / 2, o.y + o.height / 2];
    }, t.prototype.cloneShallow = function(e) {
      e == null && (e = this.name);
      var n = new t(e, this.geometries, this._center);
      return n._rect = this._rect, n.transformTo = null, n;
    }, t;
  }(Mk)
), gZ = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e, n) {
      var i = r.call(this, e) || this;
      return i.type = "geoSVG", i._elOnlyForCalculate = n, i;
    }
    return t.prototype.calcCenter = function() {
      for (var e = this._elOnlyForCalculate, n = e.getBoundingRect(), i = [n.x + n.width / 2, n.y + n.height / 2], a = Ug(pZ), o = e; o && !o.isGeoSVGGraphicRoot; )
        ji(a, o.getLocalTransform(), a), o = o.parent;
      return Si(a, a), rr(i, i, a), i;
    }, t;
  }(Mk)
);
function mZ(r) {
  if (!r.UTF8Encoding)
    return r;
  var t = r, e = t.UTF8Scale;
  e == null && (e = 1024);
  var n = t.features;
  return L(n, function(i) {
    var a = i.geometry, o = a.encodeOffsets, s = a.coordinates;
    if (o)
      switch (a.type) {
        case "LineString":
          a.coordinates = Ak(s, o, e);
          break;
        case "Polygon":
          y0(s, o, e);
          break;
        case "MultiLineString":
          y0(s, o, e);
          break;
        case "MultiPolygon":
          L(s, function(l, u) {
            return y0(l, o[u], e);
          });
      }
  }), t.UTF8Encoding = !1, t;
}
function y0(r, t, e) {
  for (var n = 0; n < r.length; n++)
    r[n] = Ak(r[n], t[n], e);
}
function Ak(r, t, e) {
  for (var n = [], i = t[0], a = t[1], o = 0; o < r.length; o += 2) {
    var s = r.charCodeAt(o) - 64, l = r.charCodeAt(o + 1) - 64;
    s = s >> 1 ^ -(s & 1), l = l >> 1 ^ -(l & 1), s += i, l += a, i = s, a = l, n.push([s / e, l / e]);
  }
  return n;
}
function yZ(r, t) {
  return r = mZ(r), rt(Te(r.features, function(e) {
    return e.geometry && e.properties && e.geometry.coordinates.length > 0;
  }), function(e) {
    var n = e.properties, i = e.geometry, a = [];
    switch (i.type) {
      case "Polygon":
        var o = i.coordinates;
        a.push(new aC(o[0], o.slice(1)));
        break;
      case "MultiPolygon":
        L(i.coordinates, function(l) {
          l[0] && a.push(new aC(l[0], l.slice(1)));
        });
        break;
      case "LineString":
        a.push(new oC([i.coordinates]));
        break;
      case "MultiLineString":
        a.push(new oC(i.coordinates));
    }
    var s = new Tk(n[t || "name"], a, n.cp);
    return s.properties = n, s;
  });
}
var _Z = ee(), Kf = ee(), wi = {
  estimate: 1,
  determine: 2
};
function Jv(r) {
  return {
    out: {
      noPxChangeTryDetermine: []
    },
    kind: r
  };
}
function Ek(r, t) {
  var e = rt(t, function(n) {
    return r.scale.parse(n);
  });
  return r.type === "time" && e.length > 0 && (e.sort(), e.unshift(e[0]), e.push(e[e.length - 1])), e;
}
function xZ(r, t) {
  var e = r.getLabelModel().get("customValues");
  if (e) {
    var n = Rc(r), i = r.scale.getExtent(), a = Ek(r, e), o = Te(a, function(s) {
      return s >= i[0] && s <= i[1];
    });
    return {
      labels: rt(o, function(s) {
        var l = {
          value: s
        };
        return {
          formattedLabel: n(l),
          rawLabel: r.scale.getLabel(l),
          tickValue: s,
          time: void 0,
          break: void 0
        };
      })
    };
  }
  return r.type === "category" ? bZ(r, t) : MZ(r);
}
function SZ(r, t, e) {
  var n = r.getTickModel().get("customValues");
  if (n) {
    var i = r.scale.getExtent(), a = Ek(r, n);
    return {
      ticks: Te(a, function(o) {
        return o >= i[0] && o <= i[1];
      })
    };
  }
  return r.type === "category" ? wZ(r, t) : {
    ticks: rt(r.scale.getTicks(e), function(o) {
      return o.value;
    })
  };
}
function bZ(r, t) {
  var e = r.getLabelModel(), n = Ck(r, e, t);
  return !e.get("show") || r.scale.isBlank() ? {
    labels: []
  } : n;
}
function Ck(r, t, e) {
  var n = AZ(r), i = Sb(t), a = e.kind === wi.estimate;
  if (!a) {
    var o = Lk(n, i);
    if (o)
      return o;
  }
  var s, l;
  Tt(i) ? s = Pk(r, i) : (l = i === "auto" ? EZ(r, e) : i, s = Ik(r, l));
  var u = {
    labels: s,
    labelCategoryInterval: l
  };
  return a ? e.out.noPxChangeTryDetermine.push(function() {
    return sS(n, i, u), !0;
  }) : sS(n, i, u), u;
}
function wZ(r, t) {
  var e = TZ(r), n = Sb(t), i = Lk(e, n);
  if (i)
    return i;
  var a, o;
  if ((!t.get("show") || r.scale.isBlank()) && (a = []), Tt(n))
    a = Pk(r, n, !0);
  else if (n === "auto") {
    var s = Ck(r, r.getLabelModel(), Jv(wi.determine));
    o = s.labelCategoryInterval, a = rt(s.labels, function(l) {
      return l.tickValue;
    });
  } else
    o = n, a = Ik(r, o, !0);
  return sS(e, n, {
    ticks: a,
    tickCategoryInterval: o
  });
}
function MZ(r) {
  var t = r.scale.getTicks(), e = Rc(r);
  return {
    labels: rt(t, function(n, i) {
      return {
        formattedLabel: e(n, i),
        rawLabel: r.scale.getLabel(n),
        tickValue: n.value,
        time: n.time,
        break: n.break
      };
    })
  };
}
var TZ = Dk("axisTick"), AZ = Dk("axisLabel");
function Dk(r) {
  return function(e) {
    return Kf(e)[r] || (Kf(e)[r] = {
      list: []
    });
  };
}
function Lk(r, t) {
  for (var e = 0; e < r.list.length; e++)
    if (r.list[e].key === t)
      return r.list[e].value;
}
function sS(r, t, e) {
  return r.list.push({
    key: t,
    value: e
  }), e;
}
function EZ(r, t) {
  if (t.kind === wi.estimate) {
    var e = r.calculateCategoryInterval(t);
    return t.out.noPxChangeTryDetermine.push(function() {
      return Kf(r).autoInterval = e, !0;
    }), e;
  }
  var n = Kf(r).autoInterval;
  return n ?? (Kf(r).autoInterval = r.calculateCategoryInterval(t));
}
function CZ(r, t) {
  var e = t.kind, n = LZ(r), i = Rc(r), a = (n.axisRotate - n.labelRotate) / 180 * Math.PI, o = r.scale, s = o.getExtent(), l = o.count();
  if (s[1] - s[0] < 1)
    return 0;
  var u = 1, c = 40;
  l > c && (u = Math.max(1, Math.floor(l / c)));
  for (var f = s[0], h = r.dataToCoord(f + 1) - r.dataToCoord(f), d = Math.abs(h * Math.cos(a)), p = Math.abs(h * Math.sin(a)), g = 0, v = 0; f <= s[1]; f += u) {
    var m = 0, y = 0, _ = Wg(i({
      value: f
    }), n.font, "center", "top");
    m = _.width * 1.3, y = _.height * 1.3, g = Math.max(g, m, 7), v = Math.max(v, y, 7);
  }
  var x = g / d, b = v / p;
  isNaN(x) && (x = 1 / 0), isNaN(b) && (b = 1 / 0);
  var S = Math.max(0, Math.floor(Math.min(x, b)));
  if (e === wi.estimate)
    return t.out.noPxChangeTryDetermine.push(mt(DZ, null, r, S, l)), S;
  var w = Rk(r, S, l);
  return w ?? S;
}
function DZ(r, t, e) {
  return Rk(r, t, e) == null;
}
function Rk(r, t, e) {
  var n = _Z(r.model), i = r.getExtent(), a = n.lastAutoInterval, o = n.lastTickCount;
  if (a != null && o != null && Math.abs(a - t) <= 1 && Math.abs(o - e) <= 1 && a > t && n.axisExtent0 === i[0] && n.axisExtent1 === i[1])
    return a;
  n.lastTickCount = e, n.lastAutoInterval = t, n.axisExtent0 = i[0], n.axisExtent1 = i[1];
}
function LZ(r) {
  var t = r.getLabelModel();
  return {
    axisRotate: r.getRotate ? r.getRotate() : r.isHorizontal && !r.isHorizontal() ? 90 : 0,
    labelRotate: t.get("rotate") || 0,
    font: t.getFont()
  };
}
function Ik(r, t, e) {
  var n = Rc(r), i = r.scale, a = i.getExtent(), o = r.getLabelModel(), s = [], l = Math.max((t || 0) + 1, 1), u = a[0], c = i.count();
  u !== 0 && l > 1 && c / l > 2 && (u = Math.round(Math.ceil(u / l) * l));
  var f = bk(r), h = o.get("showMinLabel") || f, d = o.get("showMaxLabel") || f;
  h && u !== a[0] && g(a[0]);
  for (var p = u; p <= a[1]; p += l)
    g(p);
  d && p - l !== a[1] && g(a[1]);
  function g(v) {
    var m = {
      value: v
    };
    s.push(e ? v : {
      formattedLabel: n(m),
      rawLabel: i.getLabel(m),
      tickValue: v,
      time: void 0,
      break: void 0
    });
  }
  return s;
}
function Pk(r, t, e) {
  var n = r.scale, i = Rc(r), a = [];
  return L(n.getTicks(), function(o) {
    var s = n.getLabel(o), l = o.value;
    t(o.value, s) && a.push(e ? l : {
      formattedLabel: i(o),
      rawLabel: s,
      tickValue: l,
      time: void 0,
      break: void 0
    });
  }), a;
}
var sC = [0, 1], Ai = (
  /** @class */
  function() {
    function r(t, e, n) {
      this.onBand = !1, this.inverse = !1, this.dim = t, this.scale = e, this._extent = n || [0, 0];
    }
    return r.prototype.contain = function(t) {
      var e = this._extent, n = Math.min(e[0], e[1]), i = Math.max(e[0], e[1]);
      return t >= n && t <= i;
    }, r.prototype.containData = function(t) {
      return this.scale.contain(this.scale.parse(t));
    }, r.prototype.getExtent = function() {
      return this._extent.slice();
    }, r.prototype.getPixelPrecision = function(t) {
      return EP(t || this.scale.getExtent(), this._extent);
    }, r.prototype.setExtent = function(t, e) {
      var n = this._extent;
      n[0] = t, n[1] = e;
    }, r.prototype.dataToCoord = function(t, e) {
      var n = this._extent, i = this.scale;
      return t = i.normalize(i.parse(t)), this.onBand && i.type === "ordinal" && (n = n.slice(), lC(n, i.count())), Me(t, sC, n, e);
    }, r.prototype.coordToData = function(t, e) {
      var n = this._extent, i = this.scale;
      this.onBand && i.type === "ordinal" && (n = n.slice(), lC(n, i.count()));
      var a = Me(t, n, sC, e);
      return this.scale.scale(a);
    }, r.prototype.pointToData = function(t, e) {
    }, r.prototype.getTicksCoords = function(t) {
      t = t || {};
      var e = t.tickModel || this.getTickModel(), n = SZ(this, e, {
        breakTicks: t.breakTicks,
        pruneByBreak: t.pruneByBreak
      }), i = n.ticks, a = rt(i, function(s) {
        return {
          coord: this.dataToCoord(this.scale.type === "ordinal" ? this.scale.getRawOrdinalNumber(s) : s),
          tickValue: s
        };
      }, this), o = e.get("alignWithLabel");
      return RZ(this, a, o, t.clamp), a;
    }, r.prototype.getMinorTicksCoords = function() {
      if (this.scale.type === "ordinal")
        return [];
      var t = this.model.getModel("minorTick"), e = t.get("splitNumber");
      e > 0 && e < 100 || (e = 5);
      var n = this.scale.getMinorTicks(e), i = rt(n, function(a) {
        return rt(a, function(o) {
          return {
            coord: this.dataToCoord(o),
            tickValue: o
          };
        }, this);
      }, this);
      return i;
    }, r.prototype.getViewLabels = function(t) {
      return t = t || Jv(wi.determine), xZ(this, t).labels;
    }, r.prototype.getLabelModel = function() {
      return this.model.getModel("axisLabel");
    }, r.prototype.getTickModel = function() {
      return this.model.getModel("axisTick");
    }, r.prototype.getBandWidth = function() {
      var t = this._extent, e = this.scale.getExtent(), n = e[1] - e[0] + (this.onBand ? 1 : 0);
      n === 0 && (n = 1);
      var i = Math.abs(t[1] - t[0]);
      return Math.abs(i) / n;
    }, r.prototype.calculateCategoryInterval = function(t) {
      return t = t || Jv(wi.determine), CZ(this, t);
    }, r;
  }()
);
function lC(r, t) {
  var e = r[1] - r[0], n = t, i = e / n / 2;
  r[0] += i, r[1] -= i;
}
function RZ(r, t, e, n) {
  var i = t.length;
  if (!r.onBand || e || !i)
    return;
  var a = r.getExtent(), o, s;
  if (i === 1)
    t[0].coord = a[0], t[0].onBand = !0, o = t[1] = {
      coord: a[1],
      tickValue: t[0].tickValue,
      onBand: !0
    };
  else {
    var l = t[i - 1].tickValue - t[0].tickValue, u = (t[i - 1].coord - t[0].coord) / l;
    L(t, function(d) {
      d.coord -= u / 2, d.onBand = !0;
    });
    var c = r.scale.getExtent();
    s = 1 + c[1] - t[i - 1].tickValue, o = {
      coord: t[i - 1].coord + u * s,
      tickValue: c[1] + 1,
      onBand: !0
    }, t.push(o);
  }
  var f = a[0] > a[1];
  h(t[0].coord, a[0]) && (n ? t[0].coord = a[0] : t.shift()), n && h(a[0], t[0].coord) && t.unshift({
    coord: a[0],
    onBand: !0
  }), h(a[1], o.coord) && (n ? o.coord = a[1] : t.pop()), n && h(o.coord, a[1]) && t.push({
    coord: a[1],
    onBand: !0
  });
  function h(d, p) {
    return d = or(d), p = or(p), f ? d > p : d < p;
  }
}
var sf = Math.PI * 2, Cs = aa.CMD, IZ = ["top", "right", "bottom", "left"];
function PZ(r, t, e, n, i) {
  var a = e.width, o = e.height;
  switch (r) {
    case "top":
      n.set(e.x + a / 2, e.y - t), i.set(0, -1);
      break;
    case "bottom":
      n.set(e.x + a / 2, e.y + o + t), i.set(0, 1);
      break;
    case "left":
      n.set(e.x - t, e.y + o / 2), i.set(-1, 0);
      break;
    case "right":
      n.set(e.x + a + t, e.y + o / 2), i.set(1, 0);
      break;
  }
}
function NZ(r, t, e, n, i, a, o, s, l) {
  o -= r, s -= t;
  var u = Math.sqrt(o * o + s * s);
  o /= u, s /= u;
  var c = o * e + r, f = s * e + t;
  if (Math.abs(n - i) % sf < 1e-4)
    return l[0] = c, l[1] = f, u - e;
  if (a) {
    var h = n;
    n = Pn(i), i = Pn(h);
  } else
    n = Pn(n), i = Pn(i);
  n > i && (i += sf);
  var d = Math.atan2(s, o);
  if (d < 0 && (d += sf), d >= n && d <= i || d + sf >= n && d + sf <= i)
    return l[0] = c, l[1] = f, u - e;
  var p = e * Math.cos(n) + r, g = e * Math.sin(n) + t, v = e * Math.cos(i) + r, m = e * Math.sin(i) + t, y = (p - o) * (p - o) + (g - s) * (g - s), _ = (v - o) * (v - o) + (m - s) * (m - s);
  return y < _ ? (l[0] = p, l[1] = g, Math.sqrt(y)) : (l[0] = v, l[1] = m, Math.sqrt(_));
}
function Qv(r, t, e, n, i, a, o, s) {
  var l = i - r, u = a - t, c = e - r, f = n - t, h = Math.sqrt(c * c + f * f);
  c /= h, f /= h;
  var d = l * c + u * f, p = d / h;
  s && (p = Math.min(Math.max(p, 0), 1)), p *= h;
  var g = o[0] = r + p * c, v = o[1] = t + p * f;
  return Math.sqrt((g - i) * (g - i) + (v - a) * (v - a));
}
function Nk(r, t, e, n, i, a, o) {
  e < 0 && (r = r + e, e = -e), n < 0 && (t = t + n, n = -n);
  var s = r + e, l = t + n, u = o[0] = Math.min(Math.max(i, r), s), c = o[1] = Math.min(Math.max(a, t), l);
  return Math.sqrt((u - i) * (u - i) + (c - a) * (c - a));
}
var di = [];
function OZ(r, t, e) {
  var n = Nk(t.x, t.y, t.width, t.height, r.x, r.y, di);
  return e.set(di[0], di[1]), n;
}
function kZ(r, t, e) {
  for (var n = 0, i = 0, a = 0, o = 0, s, l, u = 1 / 0, c = t.data, f = r.x, h = r.y, d = 0; d < c.length; ) {
    var p = c[d++];
    d === 1 && (n = c[d], i = c[d + 1], a = n, o = i);
    var g = u;
    switch (p) {
      case Cs.M:
        a = c[d++], o = c[d++], n = a, i = o;
        break;
      case Cs.L:
        g = Qv(n, i, c[d], c[d + 1], f, h, di, !0), n = c[d++], i = c[d++];
        break;
      case Cs.C:
        g = uP(n, i, c[d++], c[d++], c[d++], c[d++], c[d], c[d + 1], f, h, di), n = c[d++], i = c[d++];
        break;
      case Cs.Q:
        g = fP(n, i, c[d++], c[d++], c[d], c[d + 1], f, h, di), n = c[d++], i = c[d++];
        break;
      case Cs.A:
        var v = c[d++], m = c[d++], y = c[d++], _ = c[d++], x = c[d++], b = c[d++];
        d += 1;
        var S = !!(1 - c[d++]);
        s = Math.cos(x) * y + v, l = Math.sin(x) * _ + m, d <= 1 && (a = s, o = l);
        var w = (f - v) * _ / y + v;
        g = NZ(v, m, _, x, x + b, S, w, h, di), n = Math.cos(x + b) * y + v, i = Math.sin(x + b) * _ + m;
        break;
      case Cs.R:
        a = n = c[d++], o = i = c[d++];
        var A = c[d++], T = c[d++];
        g = Nk(a, o, A, T, f, h, di);
        break;
      case Cs.Z:
        g = Qv(n, i, a, o, f, h, di, !0), n = a, i = o;
        break;
    }
    g < u && (u = g, e.set(di[0], di[1]));
  }
  return u;
}
var vi = new Nt(), Ve = new Nt(), Qe = new Nt(), qi = new Nt(), Gi = new Nt();
function uC(r, t) {
  if (r) {
    var e = r.getTextGuideLine(), n = r.getTextContent();
    if (n && e) {
      var i = r.textGuideLineConfig || {}, a = [[0, 0], [0, 0], [0, 0]], o = i.candidates || IZ, s = n.getBoundingRect().clone();
      s.applyTransform(n.getComputedTransform());
      var l = 1 / 0, u = i.anchor, c = r.getComputedTransform(), f = c && Si([], c), h = t.get("length2") || 0;
      u && Qe.copy(u);
      for (var d = 0; d < o.length; d++) {
        var p = o[d];
        PZ(p, 0, s, vi, qi), Nt.scaleAndAdd(Ve, vi, qi, h), Ve.transform(f);
        var g = r.getBoundingRect(), v = u ? u.distance(Ve) : r instanceof ne ? kZ(Ve, r.path, Qe) : OZ(Ve, g, Qe);
        v < l && (l = v, Ve.transform(c), Qe.transform(c), Qe.toArray(a[0]), Ve.toArray(a[1]), vi.toArray(a[2]));
      }
      Ok(a, t.get("minTurnAngle")), e.setShape({
        points: a
      });
    }
  }
}
var tg = [], nn = new Nt();
function Ok(r, t) {
  if (t <= 180 && t > 0) {
    t = t / 180 * Math.PI, vi.fromArray(r[0]), Ve.fromArray(r[1]), Qe.fromArray(r[2]), Nt.sub(qi, vi, Ve), Nt.sub(Gi, Qe, Ve);
    var e = qi.len(), n = Gi.len();
    if (!(e < 1e-3 || n < 1e-3)) {
      qi.scale(1 / e), Gi.scale(1 / n);
      var i = qi.dot(Gi), a = Math.cos(t);
      if (a < i) {
        var o = Qv(Ve.x, Ve.y, Qe.x, Qe.y, vi.x, vi.y, tg, !1);
        nn.fromArray(tg), nn.scaleAndAdd(Gi, o / Math.tan(Math.PI - t));
        var s = Qe.x !== Ve.x ? (nn.x - Ve.x) / (Qe.x - Ve.x) : (nn.y - Ve.y) / (Qe.y - Ve.y);
        if (isNaN(s))
          return;
        s < 0 ? Nt.copy(nn, Ve) : s > 1 && Nt.copy(nn, Qe), nn.toArray(r[1]);
      }
    }
  }
}
function BZ(r, t, e) {
  if (e <= 180 && e > 0) {
    e = e / 180 * Math.PI, vi.fromArray(r[0]), Ve.fromArray(r[1]), Qe.fromArray(r[2]), Nt.sub(qi, Ve, vi), Nt.sub(Gi, Qe, Ve);
    var n = qi.len(), i = Gi.len();
    if (!(n < 1e-3 || i < 1e-3)) {
      qi.scale(1 / n), Gi.scale(1 / i);
      var a = qi.dot(t), o = Math.cos(e);
      if (a < o) {
        var s = Qv(Ve.x, Ve.y, Qe.x, Qe.y, vi.x, vi.y, tg, !1);
        nn.fromArray(tg);
        var l = Math.PI / 2, u = Math.acos(Gi.dot(t)), c = l + u - e;
        if (c >= l)
          Nt.copy(nn, Qe);
        else {
          nn.scaleAndAdd(Gi, s / Math.tan(Math.PI / 2 - c));
          var f = Qe.x !== Ve.x ? (nn.x - Ve.x) / (Qe.x - Ve.x) : (nn.y - Ve.y) / (Qe.y - Ve.y);
          if (isNaN(f))
            return;
          f < 0 ? Nt.copy(nn, Ve) : f > 1 && Nt.copy(nn, Qe);
        }
        nn.toArray(r[1]);
      }
    }
  }
}
function _0(r, t, e, n) {
  var i = e === "normal", a = i ? r : r.ensureState(e);
  a.ignore = t;
  var o = n.get("smooth");
  o && o === !0 && (o = 0.3), a.shape = a.shape || {}, o > 0 && (a.shape.smooth = o);
  var s = n.getModel("lineStyle").getLineStyle();
  i ? r.useStyle(s) : a.style = s;
}
function VZ(r, t) {
  var e = t.smooth, n = t.points;
  if (n)
    if (r.moveTo(n[0][0], n[0][1]), e > 0 && n.length >= 3) {
      var i = xo(n[0], n[1]), a = xo(n[1], n[2]);
      if (!i || !a) {
        r.lineTo(n[1][0], n[1][1]), r.lineTo(n[2][0], n[2][1]);
        return;
      }
      var o = Math.min(i, a) * e, s = Hp([], n[1], n[0], o / i), l = Hp([], n[1], n[2], o / a), u = Hp([], s, l, 0.5);
      r.bezierCurveTo(s[0], s[1], s[0], s[1], u[0], u[1]), r.bezierCurveTo(l[0], l[1], l[0], l[1], n[2][0], n[2][1]);
    } else
      for (var c = 1; c < n.length; c++)
        r.lineTo(n[c][0], n[c][1]);
}
function bb(r, t, e) {
  var n = r.getTextGuideLine(), i = r.getTextContent();
  if (!i) {
    n && r.removeTextGuideLine();
    return;
  }
  for (var a = t.normal, o = a.get("show"), s = i.ignore, l = 0; l < ah.length; l++) {
    var u = ah[l], c = t[u], f = u === "normal";
    if (c) {
      var h = c.get("show"), d = f ? s : bt(i.states[u] && i.states[u].ignore, s);
      if (d || !bt(h, o)) {
        var p = f ? n : n && n.states[u];
        p && (p.ignore = !0), n && _0(n, !0, u, c);
        continue;
      }
      n || (n = new Ur(), r.setTextGuideLine(n), !f && (s || !o) && _0(n, !0, "normal", t.normal), r.stateProxy && (n.stateProxy = r.stateProxy)), _0(n, !1, u, c);
    }
  }
  if (n) {
    kt(n.style, e), n.style.fill = null;
    var g = a.get("showAbove"), v = r.textGuideLineConfig = r.textGuideLineConfig || {};
    v.showAbove = g || !1, n.buildPath = VZ;
  }
}
function wb(r, t) {
  t = t || "labelLine";
  for (var e = {
    normal: r.getModel(t)
  }, n = 0; n < dn.length; n++) {
    var i = dn[n];
    e[i] = r.getModel([i, t]);
  }
  return e;
}
var cC = ["label", "labelLine", "layoutOption", "priority", "defaultAttr", "marginForce", "minMarginForce", "marginDefault", "suggestIgnore"], FZ = 1, eg = 2, kk = FZ | eg;
function rg(r, t, e) {
  e = e || kk, t ? r.dirty |= e : r.dirty &= ~e;
}
function Bk(r, t) {
  return t = t || kk, r.dirty == null || !!(r.dirty & t);
}
function sa(r) {
  if (r)
    return Bk(r) && Vk(r, r.label, r), r;
}
function Vk(r, t, e) {
  var n = t.getComputedTransform();
  r.transform = H1(r.transform, n);
  var i = r.localRect = sh(r.localRect, t.getBoundingRect()), a = t.style, o = a.margin, s = e && e.marginForce, l = e && e.minMarginForce, u = e && e.marginDefault, c = a.__marginType;
  c == null && u && (o = u, c = ku.textMargin);
  for (var f = 0; f < 4; f++)
    x0[f] = c === ku.minMargin && l && l[f] != null ? l[f] : s && s[f] != null ? s[f] : o ? o[f] : 0;
  c === ku.textMargin && gl(i, x0, !1, !1);
  var h = r.rect = sh(r.rect, i);
  return n && h.applyTransform(n), c === ku.minMargin && gl(h, x0, !1, !1), r.axisAligned = G1(n), (r.label = r.label || {}).ignore = t.ignore, rg(r, !1), rg(r, !0, eg), r;
}
var x0 = [0, 0, 0, 0];
function zZ(r, t, e) {
  return r.transform = H1(r.transform, e), r.localRect = sh(r.localRect, t), r.rect = sh(r.rect, t), e && r.rect.applyTransform(e), r.axisAligned = G1(e), r.obb = void 0, (r.label = r.label || {}).ignore = !1, r;
}
function lS(r, t) {
  if (r) {
    r.label.x += t.x, r.label.y += t.y, r.label.markRedraw();
    var e = r.transform;
    e && (e[4] += t.x, e[5] += t.y);
    var n = r.rect;
    n && (n.x += t.x, n.y += t.y);
    var i = r.obb;
    i && i.fromBoundingRect(r.localRect, e);
  }
}
function uS(r, t) {
  for (var e = 0; e < cC.length; e++) {
    var n = cC[e];
    r[n] == null && (r[n] = t[n]);
  }
  return sa(r);
}
function fC(r) {
  var t = r.obb;
  return (!t || Bk(r, eg)) && (r.obb = t = t || new pN(), t.fromBoundingRect(r.localRect, r.transform), rg(r, !1, eg)), t;
}
function cS(r, t, e, n, i) {
  var a = r.length, o = Wt[t], s = ur[t];
  if (a < 2)
    return !1;
  r.sort(function(w, A) {
    return w.rect[o] - A.rect[o];
  });
  for (var l = 0, u, c = !1, f = 0; f < a; f++) {
    var h = r[f], d = h.rect;
    u = d[o] - l, u < 0 && (d[o] -= u, h.label[o] -= u, c = !0), l = d[o] + d[s];
  }
  var p = r[0], g = r[a - 1], v, m;
  y(), v < 0 && b(-v, 0.8), m < 0 && b(m, 0.8), y(), _(v, m, 1), _(m, v, -1), y(), v < 0 && S(-v), m < 0 && S(m);
  function y() {
    v = p.rect[o] - e, m = n - g.rect[o] - g.rect[s];
  }
  function _(w, A, T) {
    if (w < 0) {
      var M = Math.min(A, -w);
      if (M > 0) {
        x(M * T, 0, a);
        var E = M + w;
        E < 0 && b(-E * T, 1);
      } else
        b(-w * T, 1);
    }
  }
  function x(w, A, T) {
    w !== 0 && (c = !0);
    for (var M = A; M < T; M++) {
      var E = r[M], R = E.rect;
      R[o] += w, E.label[o] += w;
    }
  }
  function b(w, A) {
    for (var T = [], M = 0, E = 1; E < a; E++) {
      var R = r[E - 1].rect, C = Math.max(r[E].rect[o] - R[o] - R[s], 0);
      T.push(C), M += C;
    }
    if (M) {
      var D = Math.min(Math.abs(w) / M, A);
      if (w > 0)
        for (var E = 0; E < a - 1; E++) {
          var I = T[E] * D;
          x(I, 0, E + 1);
        }
      else
        for (var E = a - 1; E > 0; E--) {
          var I = T[E - 1] * D;
          x(-I, E, a);
        }
    }
  }
  function S(w) {
    var A = w < 0 ? -1 : 1;
    w = Math.abs(w);
    for (var T = Math.ceil(w / (a - 1)), M = 0; M < a - 1; M++)
      if (A > 0 ? x(T, 0, M + 1) : x(-T, a - M - 1, a), w -= T, w <= 0)
        return;
  }
  return c;
}
function UZ(r) {
  for (var t = 0; t < r.length; t++) {
    var e = r[t], n = e.defaultAttr, i = e.labelLine;
    e.label.attr("ignore", n.ignore), i && i.attr("ignore", n.labelGuideIgnore);
  }
}
function Fk(r) {
  var t = [];
  r.sort(function(u, c) {
    return (c.suggestIgnore ? 1 : 0) - (u.suggestIgnore ? 1 : 0) || c.priority - u.priority;
  });
  function e(u) {
    if (!u.ignore) {
      var c = u.ensureState("emphasis");
      c.ignore == null && (c.ignore = !1);
    }
    u.ignore = !0;
  }
  for (var n = 0; n < r.length; n++) {
    var i = sa(r[n]);
    if (!i.label.ignore) {
      for (var a = i.label, o = i.labelLine, s = !1, l = 0; l < t.length; l++)
        if (vm(i, t[l], null, {
          touchThreshold: 0.05
        })) {
          s = !0;
          break;
        }
      s ? (e(a), o && e(o)) : t.push(i);
    }
  }
}
function vm(r, t, e, n) {
  return !r || !t || r.label && r.label.ignore || t.label && t.label.ignore || !r.rect.intersect(t.rect, e, n) ? !1 : r.axisAligned && t.axisAligned ? !0 : fC(r).intersect(fC(t), e, n);
}
function GZ(r) {
  if (r) {
    for (var t = [], e = 0; e < r.length; e++)
      t.push(r[e].slice());
    return t;
  }
}
function HZ(r, t) {
  var e = r.label, n = t && t.getTextGuideLine();
  return {
    dataIndex: r.dataIndex,
    dataType: r.dataType,
    seriesIndex: r.seriesModel.seriesIndex,
    text: r.label.style.text,
    rect: r.hostRect,
    labelRect: r.rect,
    // x: labelAttr.x,
    // y: labelAttr.y,
    align: e.style.align,
    verticalAlign: e.style.verticalAlign,
    labelLinePoints: GZ(n && n.shape.points)
  };
}
var hC = ["align", "verticalAlign", "width", "height", "fontSize"], Qr = new Da(), S0 = ee(), WZ = ee();
function op(r, t, e) {
  for (var n = 0; n < e.length; n++) {
    var i = e[n];
    t[i] != null && (r[i] = t[i]);
  }
}
var sp = ["x", "y", "rotation"], XZ = (
  /** @class */
  function() {
    function r() {
      this._labelList = [], this._chartViewList = [];
    }
    return r.prototype.clearLabels = function() {
      this._labelList = [], this._chartViewList = [];
    }, r.prototype._addLabel = function(t, e, n, i, a) {
      var o = i.style, s = i.__hostTarget, l = s.textConfig || {}, u = i.getComputedTransform(), c = i.getBoundingRect().plain();
      Bt.applyTransform(c, c, u), u ? Qr.setLocalTransform(u) : (Qr.x = Qr.y = Qr.rotation = Qr.originX = Qr.originY = 0, Qr.scaleX = Qr.scaleY = 1), Qr.rotation = Pn(Qr.rotation);
      var f = i.__hostTarget, h;
      if (f) {
        h = f.getBoundingRect().plain();
        var d = f.getComputedTransform();
        Bt.applyTransform(h, h, d);
      }
      var p = h && f.getTextGuideLine();
      this._labelList.push({
        label: i,
        labelLine: p,
        seriesModel: n,
        dataIndex: t,
        dataType: e,
        layoutOptionOrCb: a,
        layoutOption: null,
        rect: c,
        hostRect: h,
        // Label with lower priority will be hidden when overlapped
        // Use rect size as default priority
        priority: h ? h.width * h.height : 0,
        // Save default label attributes.
        // For restore if developers want get back to default value in callback.
        defaultAttr: {
          ignore: i.ignore,
          labelGuideIgnore: p && p.ignore,
          x: Qr.x,
          y: Qr.y,
          scaleX: Qr.scaleX,
          scaleY: Qr.scaleY,
          rotation: Qr.rotation,
          style: {
            x: o.x,
            y: o.y,
            align: o.align,
            verticalAlign: o.verticalAlign,
            width: o.width,
            height: o.height,
            fontSize: o.fontSize
          },
          cursor: i.cursor,
          attachedPos: l.position,
          attachedRot: l.rotation
        }
      });
    }, r.prototype.addLabelsOfSeries = function(t) {
      var e = this;
      this._chartViewList.push(t);
      var n = t.__model, i = n.get("labelLayout");
      (Tt(i) || se(i).length) && t.group.traverse(function(a) {
        if (a.ignore)
          return !0;
        var o = a.getTextContent(), s = zt(a);
        o && !o.disableLabelLayout && e._addLabel(s.dataIndex, s.dataType, n, o, i);
      });
    }, r.prototype.updateLayoutConfig = function(t) {
      var e = t.getWidth(), n = t.getHeight();
      function i(_, x) {
        return function() {
          uC(_, x);
        };
      }
      for (var a = 0; a < this._labelList.length; a++) {
        var o = this._labelList[a], s = o.label, l = s.__hostTarget, u = o.defaultAttr, c = void 0;
        Tt(o.layoutOptionOrCb) ? c = o.layoutOptionOrCb(HZ(o, l)) : c = o.layoutOptionOrCb, c = c || {}, o.layoutOption = c;
        var f = Math.PI / 180;
        l && l.setTextConfig({
          // Force to set local false.
          local: !1,
          // Ignore position and rotation config on the host el if x or y is changed.
          position: c.x != null || c.y != null ? null : u.attachedPos,
          // Ignore rotation config on the host el if rotation is changed.
          rotation: c.rotate != null ? c.rotate * f : u.attachedRot,
          offset: [c.dx || 0, c.dy || 0]
        });
        var h = !1;
        if (c.x != null ? (s.x = dt(c.x, e), s.setStyle("x", 0), h = !0) : (s.x = u.x, s.setStyle("x", u.style.x)), c.y != null ? (s.y = dt(c.y, n), s.setStyle("y", 0), h = !0) : (s.y = u.y, s.setStyle("y", u.style.y)), c.labelLinePoints) {
          var d = l.getTextGuideLine();
          d && (d.setShape({
            points: c.labelLinePoints
          }), h = !1);
        }
        var p = S0(s);
        p.needsUpdateLabelLine = h, s.rotation = c.rotate != null ? c.rotate * f : u.rotation, s.scaleX = u.scaleX, s.scaleY = u.scaleY;
        for (var g = 0; g < hC.length; g++) {
          var v = hC[g];
          s.setStyle(v, c[v] != null ? c[v] : u.style[v]);
        }
        if (c.draggable) {
          if (s.draggable = !0, s.cursor = "move", l) {
            var m = o.seriesModel;
            if (o.dataIndex != null) {
              var y = o.seriesModel.getData(o.dataType);
              m = y.getItemModel(o.dataIndex);
            }
            s.on("drag", i(l, m.getModel("labelLine")));
          }
        } else
          s.off("drag"), s.cursor = u.cursor;
      }
    }, r.prototype.layout = function(t) {
      var e = t.getWidth(), n = t.getHeight(), i = [];
      L(this._labelList, function(l) {
        l.defaultAttr.ignore || i.push(uS({}, l));
      });
      var a = Te(i, function(l) {
        return l.layoutOption.moveOverlap === "shiftX";
      }), o = Te(i, function(l) {
        return l.layoutOption.moveOverlap === "shiftY";
      });
      cS(a, 0, 0, e), cS(o, 1, 0, n);
      var s = Te(i, function(l) {
        return l.layoutOption.hideOverlap;
      });
      UZ(s), Fk(s);
    }, r.prototype.processLabelsOverall = function() {
      var t = this;
      L(this._chartViewList, function(e) {
        var n = e.__model, i = e.ignoreLabelLineUpdate, a = n.isAnimationEnabled();
        e.group.traverse(function(o) {
          if (o.ignore && !o.forceLabelAnimation)
            return !0;
          var s = !i, l = o.getTextContent();
          !s && l && (s = S0(l).needsUpdateLabelLine), s && t._updateLabelLine(o, n), a && t._animateLabels(o, n);
        });
      });
    }, r.prototype._updateLabelLine = function(t, e) {
      var n = t.getTextContent(), i = zt(t), a = i.dataIndex;
      if (n && a != null) {
        var o = e.getData(i.dataType), s = o.getItemModel(a), l = {}, u = o.getItemVisual(a, "style");
        if (u) {
          var c = o.getVisual("drawType");
          l.stroke = u[c];
        }
        var f = s.getModel("labelLine");
        bb(t, wb(s), l), uC(t, f);
      }
    }, r.prototype._animateLabels = function(t, e) {
      var n = t.getTextContent(), i = t.getTextGuideLine();
      if (n && (t.forceLabelAnimation || !n.ignore && !n.invisible && !t.disableLabelAnimation && !Xu(t))) {
        var a = S0(n), o = a.oldLayout, s = zt(t), l = s.dataIndex, u = {
          x: n.x,
          y: n.y,
          rotation: n.rotation
        }, c = e.getData(s.dataType);
        if (o) {
          n.attr(o);
          var h = t.prevStates;
          h && (Zt(h, "select") >= 0 && n.attr(a.oldLayoutSelect), Zt(h, "emphasis") >= 0 && n.attr(a.oldLayoutEmphasis)), ve(n, u, e, l);
        } else if (n.attr(u), !Tc(n).valueAnimation) {
          var f = bt(n.style.opacity, 1);
          n.style.opacity = 0, ze(n, {
            style: {
              opacity: f
            }
          }, e, l);
        }
        if (a.oldLayout = u, n.states.select) {
          var d = a.oldLayoutSelect = {};
          op(d, u, sp), op(d, n.states.select, sp);
        }
        if (n.states.emphasis) {
          var p = a.oldLayoutEmphasis = {};
          op(p, u, sp), op(p, n.states.emphasis, sp);
        }
        TN(n, l, c, e, e);
      }
      if (i && !i.ignore && !i.invisible) {
        var a = WZ(i), o = a.oldLayout, g = {
          points: i.shape.points
        };
        o ? (i.attr({
          shape: o
        }), ve(i, {
          shape: g
        }, e)) : (i.setShape(g), i.style.strokePercent = 0, ze(i, {
          style: {
            strokePercent: 1
          }
        }, e)), a.oldLayout = g;
      }
    }, r;
  }()
), b0 = ee();
function YZ(r) {
  r.registerUpdateLifecycle("series:beforeupdate", function(t, e, n) {
    var i = b0(e).labelManager;
    i || (i = b0(e).labelManager = new XZ()), i.clearLabels();
  }), r.registerUpdateLifecycle("series:layoutlabels", function(t, e, n) {
    var i = b0(e).labelManager;
    n.updatedSeries.forEach(function(a) {
      i.addLabelsOfSeries(e.getViewOfSeriesModel(a));
    }), i.updateLayoutConfig(e), i.layout(e), i.processLabelsOverall();
  });
}
var w0 = Math.sin, M0 = Math.cos, zk = Math.PI, Ds = Math.PI * 2, $Z = 180 / zk, Uk = function() {
  function r() {
  }
  return r.prototype.reset = function(t) {
    this._start = !0, this._d = [], this._str = "", this._p = Math.pow(10, t || 4);
  }, r.prototype.moveTo = function(t, e) {
    this._add("M", t, e);
  }, r.prototype.lineTo = function(t, e) {
    this._add("L", t, e);
  }, r.prototype.bezierCurveTo = function(t, e, n, i, a, o) {
    this._add("C", t, e, n, i, a, o);
  }, r.prototype.quadraticCurveTo = function(t, e, n, i) {
    this._add("Q", t, e, n, i);
  }, r.prototype.arc = function(t, e, n, i, a, o) {
    this.ellipse(t, e, n, n, 0, i, a, o);
  }, r.prototype.ellipse = function(t, e, n, i, a, o, s, l) {
    var u = s - o, c = !l, f = Math.abs(u), h = To(f - Ds) || (c ? u >= Ds : -u >= Ds), d = u > 0 ? u % Ds : u % Ds + Ds, p = !1;
    h ? p = !0 : To(f) ? p = !1 : p = d >= zk == !!c;
    var g = t + n * M0(o), v = e + i * w0(o);
    this._start && this._add("M", g, v);
    var m = Math.round(a * $Z);
    if (h) {
      var y = 1 / this._p, _ = (c ? 1 : -1) * (Ds - y);
      this._add("A", n, i, m, 1, +c, t + n * M0(o + _), e + i * w0(o + _)), y > 0.01 && this._add("A", n, i, m, 0, +c, g, v);
    } else {
      var x = t + n * M0(s), b = e + i * w0(s);
      this._add("A", n, i, m, +p, +c, x, b);
    }
  }, r.prototype.rect = function(t, e, n, i) {
    this._add("M", t, e), this._add("l", n, 0), this._add("l", 0, i), this._add("l", -n, 0), this._add("Z");
  }, r.prototype.closePath = function() {
    this._d.length > 0 && this._add("Z");
  }, r.prototype._add = function(t, e, n, i, a, o, s, l, u) {
    for (var c = [], f = this._p, h = 1; h < arguments.length; h++) {
      var d = arguments[h];
      if (isNaN(d)) {
        this._invalid = !0;
        return;
      }
      c.push(Math.round(d * f) / f);
    }
    this._d.push(t + c.join(" ")), this._start = t === "Z";
  }, r.prototype.generateStr = function() {
    this._str = this._invalid ? "" : this._d.join(""), this._d = [];
  }, r.prototype.getStr = function() {
    return this._str;
  }, r;
}(), Mb = "none", ZZ = Math.round;
function qZ(r) {
  var t = r.fill;
  return t != null && t !== Mb;
}
function KZ(r) {
  var t = r.stroke;
  return t != null && t !== Mb;
}
var fS = ["lineCap", "miterLimit", "lineJoin"], jZ = rt(fS, function(r) {
  return "stroke-" + r.toLowerCase();
});
function JZ(r, t, e, n) {
  var i = t.opacity == null ? 1 : t.opacity;
  if (e instanceof Vr) {
    r("opacity", i);
    return;
  }
  if (qZ(t)) {
    var a = nh(t.fill);
    r("fill", a.color);
    var o = t.fillOpacity != null ? t.fillOpacity * a.opacity * i : a.opacity * i;
    o < 1 && r("fill-opacity", o);
  } else
    r("fill", Mb);
  if (KZ(t)) {
    var s = nh(t.stroke);
    r("stroke", s.color);
    var l = t.strokeNoScale ? e.getLineScale() : 1, u = l ? (t.lineWidth || 0) / l : 0, c = t.strokeOpacity != null ? t.strokeOpacity * s.opacity * i : s.opacity * i, f = t.strokeFirst;
    if (u !== 1 && r("stroke-width", u), f && r("paint-order", f ? "stroke" : "fill"), c < 1 && r("stroke-opacity", c), t.lineDash) {
      var h = fb(e), d = h[0], p = h[1];
      d && (p = ZZ(p || 0), r("stroke-dasharray", d.join(",")), (p || n) && r("stroke-dashoffset", p));
    }
    for (var g = 0; g < fS.length; g++) {
      var v = fS[g];
      if (t[v] !== Lv[v]) {
        var m = t[v] || Lv[v];
        m && r(jZ[g], m);
      }
    }
  }
}
var Gk = "http://www.w3.org/2000/svg", Hk = "http://www.w3.org/1999/xlink", QZ = "http://www.w3.org/2000/xmlns/", tq = "http://www.w3.org/XML/1998/namespace", dC = "ecmeta_";
function Wk(r) {
  return document.createElementNS(Gk, r);
}
function wr(r, t, e, n, i) {
  return {
    tag: r,
    attrs: e || {},
    children: n,
    text: i,
    key: t
  };
}
function eq(r, t) {
  var e = [];
  if (t)
    for (var n in t) {
      var i = t[n], a = n;
      i !== !1 && (i !== !0 && i != null && (a += '="' + i + '"'), e.push(a));
    }
  return "<" + r + " " + e.join(" ") + ">";
}
function rq(r) {
  return "</" + r + ">";
}
function Tb(r, t) {
  t = t || {};
  var e = t.newline ? `
` : "";
  function n(i) {
    var a = i.children, o = i.tag, s = i.attrs, l = i.text;
    return eq(o, s) + (o !== "style" ? on(l) : l || "") + (a ? "" + e + rt(a, function(u) {
      return n(u);
    }).join(e) + e : "") + rq(o);
  }
  return n(r);
}
function nq(r, t, e) {
  e = e || {};
  var n = e.newline ? `
` : "", i = " {" + n, a = n + "}", o = rt(se(r), function(l) {
    return l + i + rt(se(r[l]), function(u) {
      return u + ":" + r[l][u] + ";";
    }).join(n) + a;
  }).join(n), s = rt(se(t), function(l) {
    return "@keyframes " + l + i + rt(se(t[l]), function(u) {
      return u + i + rt(se(t[l][u]), function(c) {
        var f = t[l][u][c];
        return c === "d" && (f = 'path("' + f + '")'), c + ":" + f + ";";
      }).join(n) + a;
    }).join(n) + a;
  }).join(n);
  return !o && !s ? "" : ["<![CDATA[", o, s, "]]>"].join(n);
}
function hS(r) {
  return {
    zrId: r,
    shadowCache: {},
    patternCache: {},
    gradientCache: {},
    clipPathCache: {},
    defs: {},
    cssNodes: {},
    cssAnims: {},
    cssStyleCache: {},
    cssAnimIdx: 0,
    shadowIdx: 0,
    gradientIdx: 0,
    patternIdx: 0,
    clipPathIdx: 0
  };
}
function pC(r, t, e, n) {
  return wr("svg", "root", {
    width: r,
    height: t,
    xmlns: Gk,
    "xmlns:xlink": Hk,
    version: "1.1",
    baseProfile: "full",
    viewBox: n ? "0 0 " + r + " " + t : !1
  }, e);
}
var iq = 0;
function Xk() {
  return iq++;
}
var vC = {
  cubicIn: "0.32,0,0.67,0",
  cubicOut: "0.33,1,0.68,1",
  cubicInOut: "0.65,0,0.35,1",
  quadraticIn: "0.11,0,0.5,0",
  quadraticOut: "0.5,1,0.89,1",
  quadraticInOut: "0.45,0,0.55,1",
  quarticIn: "0.5,0,0.75,0",
  quarticOut: "0.25,1,0.5,1",
  quarticInOut: "0.76,0,0.24,1",
  quinticIn: "0.64,0,0.78,0",
  quinticOut: "0.22,1,0.36,1",
  quinticInOut: "0.83,0,0.17,1",
  sinusoidalIn: "0.12,0,0.39,0",
  sinusoidalOut: "0.61,1,0.88,1",
  sinusoidalInOut: "0.37,0,0.63,1",
  exponentialIn: "0.7,0,0.84,0",
  exponentialOut: "0.16,1,0.3,1",
  exponentialInOut: "0.87,0,0.13,1",
  circularIn: "0.55,0,1,0.45",
  circularOut: "0,0.55,0.45,1",
  circularInOut: "0.85,0,0.15,1"
}, Ns = "transform-origin";
function aq(r, t, e) {
  var n = J({}, r.shape);
  J(n, t), r.buildPath(e, n);
  var i = new Uk();
  return i.reset(yP(r)), e.rebuildPath(i, 1), i.generateStr(), i.getStr();
}
function oq(r, t) {
  var e = t.originX, n = t.originY;
  (e || n) && (r[Ns] = e + "px " + n + "px");
}
var sq = {
  fill: "fill",
  opacity: "opacity",
  lineWidth: "stroke-width",
  lineDashOffset: "stroke-dashoffset"
};
function Yk(r, t) {
  var e = t.zrId + "-ani-" + t.cssAnimIdx++;
  return t.cssAnims[e] = r, e;
}
function lq(r, t, e) {
  var n = r.shape.paths, i = {}, a, o;
  if (L(n, function(l) {
    var u = hS(e.zrId);
    u.animation = !0, gm(l, {}, u, !0);
    var c = u.cssAnims, f = u.cssNodes, h = se(c), d = h.length;
    if (d) {
      o = h[d - 1];
      var p = c[o];
      for (var g in p) {
        var v = p[g];
        i[g] = i[g] || { d: "" }, i[g].d += v.d || "";
      }
      for (var m in f) {
        var y = f[m].animation;
        y.indexOf(o) >= 0 && (a = y);
      }
    }
  }), !!a) {
    t.d = !1;
    var s = Yk(i, e);
    return a.replace(o, s);
  }
}
function gC(r) {
  return pt(r) ? vC[r] ? "cubic-bezier(" + vC[r] + ")" : T1(r) ? r : "" : "";
}
function gm(r, t, e, n) {
  var i = r.animators, a = i.length, o = [];
  if (r instanceof im) {
    var s = lq(r, t, e);
    if (s)
      o.push(s);
    else if (!a)
      return;
  } else if (!a)
    return;
  for (var l = {}, u = 0; u < a; u++) {
    var c = i[u], f = [c.getMaxTime() / 1e3 + "s"], h = gC(c.getClip().easing), d = c.getDelay();
    h ? f.push(h) : f.push("linear"), d && f.push(d / 1e3 + "s"), c.getLoop() && f.push("infinite");
    var p = f.join(" ");
    l[p] = l[p] || [p, []], l[p][1].push(c);
  }
  function g(y) {
    var _ = y[1], x = _.length, b = {}, S = {}, w = {}, A = "animation-timing-function";
    function T(lt, ot, H) {
      for (var st = lt.getTracks(), ut = lt.getMaxTime(), Gt = 0; Gt < st.length; Gt++) {
        var gt = st[Gt];
        if (gt.needsAnimate()) {
          var Lt = gt.keyframes, Vt = gt.propName;
          if (H && (Vt = H(Vt)), Vt)
            for (var Kt = 0; Kt < Lt.length; Kt++) {
              var Ae = Lt[Kt], z = Math.round(Ae.time / ut * 100) + "%", k = gC(Ae.easing), nt = Ae.rawValue;
              (pt(nt) || fe(nt)) && (ot[z] = ot[z] || {}, ot[z][Vt] = Ae.rawValue, k && (ot[z][A] = k));
            }
        }
      }
    }
    for (var M = 0; M < x; M++) {
      var E = _[M], R = E.targetName;
      R ? R === "shape" && T(E, S) : !n && T(E, b);
    }
    for (var C in b) {
      var D = {};
      Ev(D, r), J(D, b[C]);
      var I = _P(D), P = b[C][A];
      w[C] = I ? {
        transform: I
      } : {}, oq(w[C], D), P && (w[C][A] = P);
    }
    var O, N = !0;
    for (var C in S) {
      w[C] = w[C] || {};
      var B = !O, P = S[C][A];
      B && (O = new aa());
      var F = O.len();
      O.reset(), w[C].d = aq(r, S[C], O);
      var G = O.len();
      if (!B && F !== G) {
        N = !1;
        break;
      }
      P && (w[C][A] = P);
    }
    if (!N)
      for (var C in w)
        delete w[C].d;
    if (!n)
      for (var M = 0; M < x; M++) {
        var E = _[M], R = E.targetName;
        R === "style" && T(E, w, function(st) {
          return sq[st];
        });
      }
    for (var X = se(w), K = !0, U, M = 1; M < X.length; M++) {
      var $ = X[M - 1], ct = X[M];
      if (w[$][Ns] !== w[ct][Ns]) {
        K = !1;
        break;
      }
      U = w[$][Ns];
    }
    if (K && U) {
      for (var C in w)
        w[C][Ns] && delete w[C][Ns];
      t[Ns] = U;
    }
    if (Te(X, function(lt) {
      return se(w[lt]).length > 0;
    }).length) {
      var at = Yk(w, e);
      return at + " " + y[0] + " both";
    }
  }
  for (var v in l) {
    var s = g(l[v]);
    s && o.push(s);
  }
  if (o.length) {
    var m = e.zrId + "-cls-" + Xk();
    e.cssNodes["." + m] = {
      animation: o.join(",")
    }, t.class = m;
  }
}
function uq(r, t, e) {
  if (!r.ignore)
    if (r.isSilent()) {
      var n = {
        "pointer-events": "none"
      };
      mC(n, t, e);
    } else {
      var i = r.states.emphasis && r.states.emphasis.style ? r.states.emphasis.style : {}, a = i.fill;
      if (!a) {
        var o = r.style && r.style.fill, s = r.states.select && r.states.select.style && r.states.select.style.fill, l = r.currentStates.indexOf("select") >= 0 && s || o;
        l && (a = lx(l));
      }
      var u = i.lineWidth;
      if (u) {
        var c = !i.strokeNoScale && r.transform ? r.transform[0] : 1;
        u = u / c;
      }
      var n = {
        cursor: "pointer"
      };
      a && (n.fill = a), i.stroke && (n.stroke = i.stroke), u && (n["stroke-width"] = u), mC(n, t, e);
    }
}
function mC(r, t, e, n) {
  var i = JSON.stringify(r), a = e.cssStyleCache[i];
  a || (a = e.zrId + "-cls-" + Xk(), e.cssStyleCache[i] = a, e.cssNodes["." + a + ":hover"] = r), t.class = t.class ? t.class + " " + a : a;
}
var gh = Math.round;
function $k(r) {
  return r && pt(r.src);
}
function Zk(r) {
  return r && Tt(r.toDataURL);
}
function Ab(r, t, e, n) {
  JZ(function(i, a) {
    var o = i === "fill" || i === "stroke";
    o && mP(a) ? Kk(t, r, i, n) : o && A1(a) ? jk(e, r, i, n) : r[i] = a, o && n.ssr && a === "none" && (r["pointer-events"] = "visible");
  }, t, e, !1), gq(e, r, n);
}
function Eb(r, t) {
  var e = O8(t);
  e && (e.each(function(n, i) {
    n != null && (r[(dC + i).toLowerCase()] = n + "");
  }), t.isSilent() && (r[dC + "silent"] = "true"));
}
function yC(r) {
  return To(r[0] - 1) && To(r[1]) && To(r[2]) && To(r[3] - 1);
}
function cq(r) {
  return To(r[4]) && To(r[5]);
}
function Cb(r, t, e) {
  if (t && !(cq(t) && yC(t))) {
    var n = 1e4;
    r.transform = yC(t) ? "translate(" + gh(t[4] * n) / n + " " + gh(t[5] * n) / n + ")" : n8(t);
  }
}
function _C(r, t, e) {
  for (var n = r.points, i = [], a = 0; a < n.length; a++)
    i.push(gh(n[a][0] * e) / e), i.push(gh(n[a][1] * e) / e);
  t.points = i.join(" ");
}
function xC(r) {
  return !r.smooth;
}
function fq(r) {
  var t = rt(r, function(e) {
    return typeof e == "string" ? [e, e] : e;
  });
  return function(e, n, i) {
    for (var a = 0; a < t.length; a++) {
      var o = t[a], s = e[o[0]];
      s != null && (n[o[1]] = gh(s * i) / i);
    }
  };
}
var hq = {
  circle: [fq(["cx", "cy", "r"])],
  polyline: [_C, xC],
  polygon: [_C, xC]
};
function dq(r) {
  for (var t = r.animators, e = 0; e < t.length; e++)
    if (t[e].targetName === "shape")
      return !0;
  return !1;
}
function qk(r, t) {
  var e = r.style, n = r.shape, i = hq[r.type], a = {}, o = t.animation, s = "path", l = r.style.strokePercent, u = t.compress && yP(r) || 4;
  if (i && !t.willUpdate && !(i[1] && !i[1](n)) && !(o && dq(r)) && !(l < 1)) {
    s = r.type;
    var c = Math.pow(10, u);
    i[0](n, a, c);
  } else {
    var f = !r.path || r.shapeChanged();
    r.path || r.createPathProxy();
    var h = r.path;
    f && (h.beginPath(), r.buildPath(h, r.shape), r.pathUpdated());
    var d = h.getVersion(), p = r, g = p.__svgPathBuilder;
    (p.__svgPathVersion !== d || !g || l !== p.__svgPathStrokePercent) && (g || (g = p.__svgPathBuilder = new Uk()), g.reset(u), h.rebuildPath(g, l), g.generateStr(), p.__svgPathVersion = d, p.__svgPathStrokePercent = l), a.d = g.getStr();
  }
  return Cb(a, r.transform), Ab(a, e, r, t), Eb(a, r), t.animation && gm(r, a, t), t.emphasis && uq(r, a, t), wr(s, r.id + "", a);
}
function pq(r, t) {
  var e = r.style, n = e.image;
  if (n && !pt(n) && ($k(n) ? n = n.src : Zk(n) && (n = n.toDataURL())), !!n) {
    var i = e.x || 0, a = e.y || 0, o = e.width, s = e.height, l = {
      href: n,
      width: o,
      height: s
    };
    return i && (l.x = i), a && (l.y = a), Cb(l, r.transform), Ab(l, e, r, t), Eb(l, r), t.animation && gm(r, l, t), wr("image", r.id + "", l);
  }
}
function vq(r, t) {
  var e = r.style, n = e.text;
  if (n != null && (n += ""), !(!n || isNaN(e.x) || isNaN(e.y))) {
    var i = e.font || za, a = e.x || 0, o = a8(e.y || 0, Ph(i), e.textBaseline), s = i8[e.textAlign] || e.textAlign, l = {
      "dominant-baseline": "central",
      "text-anchor": s
    };
    if (qP(e)) {
      var u = "", c = e.fontStyle, f = ZP(e.fontSize);
      if (!parseFloat(f))
        return;
      var h = e.fontFamily || YI, d = e.fontWeight;
      u += "font-size:" + f + ";font-family:" + h + ";", c && c !== "normal" && (u += "font-style:" + c + ";"), d && d !== "normal" && (u += "font-weight:" + d + ";"), l.style = u;
    } else
      l.style = "font: " + i;
    return n.match(/\s/) && (l["xml:space"] = "preserve"), a && (l.x = a), o && (l.y = o), Cb(l, r.transform), Ab(l, e, r, t), Eb(l, r), t.animation && gm(r, l, t), wr("text", r.id + "", l, void 0, n);
  }
}
function SC(r, t) {
  if (r instanceof ne)
    return qk(r, t);
  if (r instanceof Vr)
    return pq(r, t);
  if (r instanceof rc)
    return vq(r, t);
}
function gq(r, t, e) {
  var n = r.style;
  if (o8(n)) {
    var i = s8(r), a = e.shadowCache, o = a[i];
    if (!o) {
      var s = r.getGlobalScale(), l = s[0], u = s[1];
      if (!l || !u)
        return;
      var c = n.shadowOffsetX || 0, f = n.shadowOffsetY || 0, h = n.shadowBlur, d = nh(n.shadowColor), p = d.opacity, g = d.color, v = h / 2 / l, m = h / 2 / u, y = v + " " + m;
      o = e.zrId + "-s" + e.shadowIdx++, e.defs[o] = wr("filter", o, {
        id: o,
        x: "-100%",
        y: "-100%",
        width: "300%",
        height: "300%"
      }, [
        wr("feDropShadow", "", {
          dx: c / l,
          dy: f / u,
          stdDeviation: y,
          "flood-color": g,
          "flood-opacity": p
        })
      ]), a[i] = o;
    }
    t.filter = Hg(o);
  }
}
function Kk(r, t, e, n) {
  var i = r[e], a, o = {
    gradientUnits: i.global ? "userSpaceOnUse" : "objectBoundingBox"
  };
  if (vP(i))
    a = "linearGradient", o.x1 = i.x, o.y1 = i.y, o.x2 = i.x2, o.y2 = i.y2;
  else if (gP(i))
    a = "radialGradient", o.cx = bt(i.x, 0.5), o.cy = bt(i.y, 0.5), o.r = bt(i.r, 0.5);
  else {
    process.env.NODE_ENV !== "production" && gi("Illegal gradient type.");
    return;
  }
  for (var s = i.colorStops, l = [], u = 0, c = s.length; u < c; ++u) {
    var f = ux(s[u].offset) * 100 + "%", h = s[u].color, d = nh(h), p = d.color, g = d.opacity, v = {
      offset: f
    };
    v["stop-color"] = p, g < 1 && (v["stop-opacity"] = g), l.push(wr("stop", u + "", v));
  }
  var m = wr(a, "", o, l), y = Tb(m), _ = n.gradientCache, x = _[y];
  x || (x = n.zrId + "-g" + n.gradientIdx++, _[y] = x, o.id = x, n.defs[x] = wr(a, x, o, l)), t[e] = Hg(x);
}
function jk(r, t, e, n) {
  var i = r.style[e], a = r.getBoundingRect(), o = {}, s = i.repeat, l = s === "no-repeat", u = s === "repeat-x", c = s === "repeat-y", f;
  if (pP(i)) {
    var h = i.imageWidth, d = i.imageHeight, p = void 0, g = i.image;
    if (pt(g) ? p = g : $k(g) ? p = g.src : Zk(g) && (p = g.toDataURL()), typeof Image > "u") {
      var v = "Image width/height must been given explictly in svg-ssr renderer.";
      St(h, v), St(d, v);
    } else if (h == null || d == null) {
      var m = function(M, E) {
        if (M) {
          var R = M.elm, C = h || E.width, D = d || E.height;
          M.tag === "pattern" && (u ? (D = 1, C /= a.width) : c && (C = 1, D /= a.height)), M.attrs.width = C, M.attrs.height = D, R && (R.setAttribute("width", C), R.setAttribute("height", D));
        }
      }, y = I1(p, null, r, function(M) {
        l || m(S, M), m(f, M);
      });
      y && y.width && y.height && (h = h || y.width, d = d || y.height);
    }
    f = wr("image", "img", {
      href: p,
      width: h,
      height: d
    }), o.width = h, o.height = d;
  } else
    i.svgElement && (f = Ct(i.svgElement), o.width = i.svgWidth, o.height = i.svgHeight);
  if (f) {
    var _, x;
    l ? _ = x = 1 : u ? (x = 1, _ = o.width / a.width) : c ? (_ = 1, x = o.height / a.height) : o.patternUnits = "userSpaceOnUse", _ != null && !isNaN(_) && (o.width = _), x != null && !isNaN(x) && (o.height = x);
    var b = _P(i);
    b && (o.patternTransform = b);
    var S = wr("pattern", "", o, [f]), w = Tb(S), A = n.patternCache, T = A[w];
    T || (T = n.zrId + "-p" + n.patternIdx++, A[w] = T, o.id = T, S = n.defs[T] = wr("pattern", T, o, [f])), t[e] = Hg(T);
  }
}
function mq(r, t, e) {
  var n = e.clipPathCache, i = e.defs, a = n[r.id];
  if (!a) {
    a = e.zrId + "-c" + e.clipPathIdx++;
    var o = {
      id: a
    };
    n[r.id] = a, i[a] = wr("clipPath", a, o, [qk(r, e)]);
  }
  t["clip-path"] = Hg(a);
}
function bC(r) {
  return document.createTextNode(r);
}
function Hs(r, t, e) {
  r.insertBefore(t, e);
}
function wC(r, t) {
  r.removeChild(t);
}
function MC(r, t) {
  r.appendChild(t);
}
function Jk(r) {
  return r.parentNode;
}
function Qk(r) {
  return r.nextSibling;
}
function T0(r, t) {
  r.textContent = t;
}
var TC = 58, yq = 120, _q = wr("", "");
function dS(r) {
  return r === void 0;
}
function Vi(r) {
  return r !== void 0;
}
function xq(r, t, e) {
  for (var n = {}, i = t; i <= e; ++i) {
    var a = r[i].key;
    a !== void 0 && (process.env.NODE_ENV !== "production" && n[a] != null && console.error("Duplicate key " + a), n[a] = i);
  }
  return n;
}
function Pf(r, t) {
  var e = r.key === t.key, n = r.tag === t.tag;
  return n && e;
}
function mh(r) {
  var t, e = r.children, n = r.tag;
  if (Vi(n)) {
    var i = r.elm = Wk(n);
    if (Db(_q, r), et(e))
      for (t = 0; t < e.length; ++t) {
        var a = e[t];
        a != null && MC(i, mh(a));
      }
    else
      Vi(r.text) && !Dt(r.text) && MC(i, bC(r.text));
  } else
    r.elm = bC(r.text);
  return r.elm;
}
function t3(r, t, e, n, i) {
  for (; n <= i; ++n) {
    var a = e[n];
    a != null && Hs(r, mh(a), t);
  }
}
function ng(r, t, e, n) {
  for (; e <= n; ++e) {
    var i = t[e];
    if (i != null)
      if (Vi(i.tag)) {
        var a = Jk(i.elm);
        wC(a, i.elm);
      } else
        wC(r, i.elm);
  }
}
function Db(r, t) {
  var e, n = t.elm, i = r && r.attrs || {}, a = t.attrs || {};
  if (i !== a) {
    for (e in a) {
      var o = a[e], s = i[e];
      s !== o && (o === !0 ? n.setAttribute(e, "") : o === !1 ? n.removeAttribute(e) : e === "style" ? n.style.cssText = o : e.charCodeAt(0) !== yq ? n.setAttribute(e, o) : e === "xmlns:xlink" || e === "xmlns" ? n.setAttributeNS(QZ, e, o) : e.charCodeAt(3) === TC ? n.setAttributeNS(tq, e, o) : e.charCodeAt(5) === TC ? n.setAttributeNS(Hk, e, o) : n.setAttribute(e, o));
    }
    for (e in i)
      e in a || n.removeAttribute(e);
  }
}
function Sq(r, t, e) {
  for (var n = 0, i = 0, a = t.length - 1, o = t[0], s = t[a], l = e.length - 1, u = e[0], c = e[l], f, h, d, p; n <= a && i <= l; )
    o == null ? o = t[++n] : s == null ? s = t[--a] : u == null ? u = e[++i] : c == null ? c = e[--l] : Pf(o, u) ? (Cu(o, u), o = t[++n], u = e[++i]) : Pf(s, c) ? (Cu(s, c), s = t[--a], c = e[--l]) : Pf(o, c) ? (Cu(o, c), Hs(r, o.elm, Qk(s.elm)), o = t[++n], c = e[--l]) : Pf(s, u) ? (Cu(s, u), Hs(r, s.elm, o.elm), s = t[--a], u = e[++i]) : (dS(f) && (f = xq(t, n, a)), h = f[u.key], dS(h) ? Hs(r, mh(u), o.elm) : (d = t[h], d.tag !== u.tag ? Hs(r, mh(u), o.elm) : (Cu(d, u), t[h] = void 0, Hs(r, d.elm, o.elm))), u = e[++i]);
  (n <= a || i <= l) && (n > a ? (p = e[l + 1] == null ? null : e[l + 1].elm, t3(r, p, e, i, l)) : ng(r, t, n, a));
}
function Cu(r, t) {
  var e = t.elm = r.elm, n = r.children, i = t.children;
  r !== t && (Db(r, t), dS(t.text) ? Vi(n) && Vi(i) ? n !== i && Sq(e, n, i) : Vi(i) ? (Vi(r.text) && T0(e, ""), t3(e, null, i, 0, i.length - 1)) : Vi(n) ? ng(e, n, 0, n.length - 1) : Vi(r.text) && T0(e, "") : r.text !== t.text && (Vi(n) && ng(e, n, 0, n.length - 1), T0(e, t.text)));
}
function bq(r, t) {
  if (Pf(r, t))
    Cu(r, t);
  else {
    var e = r.elm, n = Jk(e);
    mh(t), n !== null && (Hs(n, t.elm, Qk(e)), ng(n, [r], 0, 0));
  }
  return t;
}
var wq = 0, Mq = function() {
  function r(t, e, n) {
    if (this.type = "svg", this.refreshHover = AC("refreshHover"), this.configLayer = AC("configLayer"), this.storage = e, this._opts = n = J({}, n), this.root = t, this._id = "zr" + wq++, this._oldVNode = pC(n.width, n.height), t && !n.ssr) {
      var i = this._viewport = document.createElement("div");
      i.style.cssText = "position:relative;overflow:hidden";
      var a = this._svgDom = this._oldVNode.elm = Wk("svg");
      Db(null, this._oldVNode), i.appendChild(a), t.appendChild(i);
    }
    this.resize(n.width, n.height);
  }
  return r.prototype.getType = function() {
    return this.type;
  }, r.prototype.getViewportRoot = function() {
    return this._viewport;
  }, r.prototype.getViewportRootOffset = function() {
    var t = this.getViewportRoot();
    if (t)
      return {
        offsetLeft: t.offsetLeft || 0,
        offsetTop: t.offsetTop || 0
      };
  }, r.prototype.getSvgDom = function() {
    return this._svgDom;
  }, r.prototype.refresh = function() {
    if (this.root) {
      var t = this.renderToVNode({
        willUpdate: !0
      });
      t.attrs.style = "position:absolute;left:0;top:0;user-select:none", bq(this._oldVNode, t), this._oldVNode = t;
    }
  }, r.prototype.renderOneToVNode = function(t) {
    return SC(t, hS(this._id));
  }, r.prototype.renderToVNode = function(t) {
    t = t || {};
    var e = this.storage.getDisplayList(!0), n = this._width, i = this._height, a = hS(this._id);
    a.animation = t.animation, a.willUpdate = t.willUpdate, a.compress = t.compress, a.emphasis = t.emphasis, a.ssr = this._opts.ssr;
    var o = [], s = this._bgVNode = Tq(n, i, this._backgroundColor, a);
    s && o.push(s);
    var l = t.compress ? null : this._mainVNode = wr("g", "main", {}, []);
    this._paintList(e, a, l ? l.children : o), l && o.push(l);
    var u = rt(se(a.defs), function(h) {
      return a.defs[h];
    });
    if (u.length && o.push(wr("defs", "defs", {}, u)), t.animation) {
      var c = nq(a.cssNodes, a.cssAnims, { newline: !0 });
      if (c) {
        var f = wr("style", "stl", {}, [], c);
        o.push(f);
      }
    }
    return pC(n, i, o, t.useViewBox);
  }, r.prototype.renderToString = function(t) {
    return t = t || {}, Tb(this.renderToVNode({
      animation: bt(t.cssAnimation, !0),
      emphasis: bt(t.cssEmphasis, !0),
      willUpdate: !1,
      compress: !0,
      useViewBox: bt(t.useViewBox, !0)
    }), { newline: !0 });
  }, r.prototype.setBackgroundColor = function(t) {
    this._backgroundColor = t;
  }, r.prototype.getSvgRoot = function() {
    return this._mainVNode && this._mainVNode.elm;
  }, r.prototype._paintList = function(t, e, n) {
    for (var i = t.length, a = [], o = 0, s, l, u = 0, c = 0; c < i; c++) {
      var f = t[c];
      if (!f.invisible) {
        var h = f.__clipPaths, d = h && h.length || 0, p = l && l.length || 0, g = void 0;
        for (g = Math.max(d - 1, p - 1); g >= 0 && !(h && l && h[g] === l[g]); g--)
          ;
        for (var v = p - 1; v > g; v--)
          o--, s = a[o - 1];
        for (var m = g + 1; m < d; m++) {
          var y = {};
          mq(h[m], y, e);
          var _ = wr("g", "clip-g-" + u++, y, []);
          (s ? s.children : n).push(_), a[o++] = _, s = _;
        }
        l = h;
        var x = SC(f, e);
        x && (s ? s.children : n).push(x);
      }
    }
  }, r.prototype.resize = function(t, e) {
    var n = this._opts, i = this.root, a = this._viewport;
    if (t != null && (n.width = t), e != null && (n.height = e), i && a && (a.style.display = "none", t = Vu(i, 0, n), e = Vu(i, 1, n), a.style.display = ""), this._width !== t || this._height !== e) {
      if (this._width = t, this._height = e, a) {
        var o = a.style;
        o.width = t + "px", o.height = e + "px";
      }
      if (A1(this._backgroundColor))
        this.refresh();
      else {
        var s = this._svgDom;
        s && (s.setAttribute("width", t), s.setAttribute("height", e));
        var l = this._bgVNode && this._bgVNode.elm;
        l && (l.setAttribute("width", t), l.setAttribute("height", e));
      }
    }
  }, r.prototype.getWidth = function() {
    return this._width;
  }, r.prototype.getHeight = function() {
    return this._height;
  }, r.prototype.dispose = function() {
    this.root && (this.root.innerHTML = ""), this._svgDom = this._viewport = this.storage = this._oldVNode = this._bgVNode = this._mainVNode = null;
  }, r.prototype.clear = function() {
    this._svgDom && (this._svgDom.innerHTML = null), this._oldVNode = null;
  }, r.prototype.toDataURL = function(t) {
    var e = this.renderToString(), n = "data:image/svg+xml;";
    return t ? (e = u8(e), e && n + "base64," + e) : n + "charset=UTF-8," + encodeURIComponent(e);
  }, r;
}();
function AC(r) {
  return function() {
    process.env.NODE_ENV !== "production" && gi('In SVG mode painter not support method "' + r + '"');
  };
}
function Tq(r, t, e, n) {
  var i;
  if (e && e !== "none")
    if (i = wr("rect", "bg", {
      width: r,
      height: t,
      x: "0",
      y: "0"
    }), mP(e))
      Kk({ fill: e }, i.attrs, "fill", n);
    else if (A1(e))
      jk({
        style: {
          fill: e
        },
        dirty: er,
        getBoundingRect: function() {
          return { width: r, height: t };
        }
      }, i.attrs, "fill", n);
    else {
      var a = nh(e), o = a.color, s = a.opacity;
      i.attrs.fill = o, s < 1 && (i.attrs["fill-opacity"] = s);
    }
  return i;
}
function Aq(r) {
  r.registerPainter("svg", Mq);
}
function EC(r, t, e) {
  var n = xi.createCanvas(), i = t.getWidth(), a = t.getHeight(), o = n.style;
  return o && (o.position = "absolute", o.left = "0", o.top = "0", o.width = i + "px", o.height = a + "px", n.setAttribute("data-zr-dom-id", r)), n.width = i * e, n.height = a * e, n;
}
var A0 = function(r) {
  W(t, r);
  function t(e, n, i) {
    var a = r.call(this) || this;
    a.motionBlur = !1, a.lastFrameAlpha = 0.7, a.dpr = 1, a.virtual = !1, a.config = {}, a.incremental = !1, a.zlevel = 0, a.maxRepaintRectCount = 5, a.__dirty = !0, a.__firstTimePaint = !0, a.__used = !1, a.__drawIndex = 0, a.__startIndex = 0, a.__endIndex = 0, a.__prevStartIndex = null, a.__prevEndIndex = null;
    var o;
    i = i || Av, typeof e == "string" ? o = EC(e, n, i) : Dt(e) && (o = e, e = o.id), a.id = e, a.dom = o;
    var s = o.style;
    return s && (QI(o), o.onselectstart = function() {
      return !1;
    }, s.padding = "0", s.margin = "0", s.borderWidth = "0"), a.painter = n, a.dpr = i, a;
  }
  return t.prototype.getElementCount = function() {
    return this.__endIndex - this.__startIndex;
  }, t.prototype.afterBrush = function() {
    this.__prevStartIndex = this.__startIndex, this.__prevEndIndex = this.__endIndex;
  }, t.prototype.initContext = function() {
    this.ctx = this.dom.getContext("2d"), this.ctx.dpr = this.dpr;
  }, t.prototype.setUnpainted = function() {
    this.__firstTimePaint = !0;
  }, t.prototype.createBackBuffer = function() {
    var e = this.dpr;
    this.domBack = EC("back-" + this.id, this.painter, e), this.ctxBack = this.domBack.getContext("2d"), e !== 1 && this.ctxBack.scale(e, e);
  }, t.prototype.createRepaintRects = function(e, n, i, a) {
    if (this.__firstTimePaint)
      return this.__firstTimePaint = !1, null;
    var o = [], s = this.maxRepaintRectCount, l = !1, u = new Bt(0, 0, 0, 0);
    function c(y) {
      if (!(!y.isFinite() || y.isZero()))
        if (o.length === 0) {
          var _ = new Bt(0, 0, 0, 0);
          _.copy(y), o.push(_);
        } else {
          for (var x = !1, b = 1 / 0, S = 0, w = 0; w < o.length; ++w) {
            var A = o[w];
            if (A.intersect(y)) {
              var T = new Bt(0, 0, 0, 0);
              T.copy(A), T.union(y), o[w] = T, x = !0;
              break;
            } else if (l) {
              u.copy(y), u.union(A);
              var M = y.width * y.height, E = A.width * A.height, R = u.width * u.height, C = R - M - E;
              C < b && (b = C, S = w);
            }
          }
          if (l && (o[S].union(y), x = !0), !x) {
            var _ = new Bt(0, 0, 0, 0);
            _.copy(y), o.push(_);
          }
          l || (l = o.length >= s);
        }
    }
    for (var f = this.__startIndex; f < this.__endIndex; ++f) {
      var h = e[f];
      if (h) {
        var d = h.shouldBePainted(i, a, !0, !0), p = h.__isRendered && (h.__dirty & Rn || !d) ? h.getPrevPaintRect() : null;
        p && c(p);
        var g = d && (h.__dirty & Rn || !h.__isRendered) ? h.getPaintRect() : null;
        g && c(g);
      }
    }
    for (var f = this.__prevStartIndex; f < this.__prevEndIndex; ++f) {
      var h = n[f], d = h && h.shouldBePainted(i, a, !0, !0);
      if (h && (!d || !h.__zr) && h.__isRendered) {
        var p = h.getPrevPaintRect();
        p && c(p);
      }
    }
    var v;
    do {
      v = !1;
      for (var f = 0; f < o.length; ) {
        if (o[f].isZero()) {
          o.splice(f, 1);
          continue;
        }
        for (var m = f + 1; m < o.length; )
          o[f].intersect(o[m]) ? (v = !0, o[f].union(o[m]), o.splice(m, 1)) : m++;
        f++;
      }
    } while (v);
    return this._paintRects = o, o;
  }, t.prototype.debugGetPaintRects = function() {
    return (this._paintRects || []).slice();
  }, t.prototype.resize = function(e, n) {
    var i = this.dpr, a = this.dom, o = a.style, s = this.domBack;
    o && (o.width = e + "px", o.height = n + "px"), a.width = e * i, a.height = n * i, s && (s.width = e * i, s.height = n * i, i !== 1 && this.ctxBack.scale(i, i));
  }, t.prototype.clear = function(e, n, i) {
    var a = this.dom, o = this.ctx, s = a.width, l = a.height;
    n = n || this.clearColor;
    var u = this.motionBlur && !e, c = this.lastFrameAlpha, f = this.dpr, h = this;
    u && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(a, 0, 0, s / f, l / f));
    var d = this.domBack;
    function p(g, v, m, y) {
      if (o.clearRect(g, v, m, y), n && n !== "transparent") {
        var _ = void 0;
        if (Vg(n)) {
          var x = n.global || n.__width === m && n.__height === y;
          _ = x && n.__canvasGradient || jx(o, n, {
            x: 0,
            y: 0,
            width: m,
            height: y
          }), n.__canvasGradient = _, n.__width = m, n.__height = y;
        } else
          vW(n) && (n.scaleX = n.scaleX || f, n.scaleY = n.scaleY || f, _ = Jx(o, n, {
            dirty: function() {
              h.setUnpainted(), h.painter.refresh();
            }
          }));
        o.save(), o.fillStyle = _ || n, o.fillRect(g, v, m, y), o.restore();
      }
      u && (o.save(), o.globalAlpha = c, o.drawImage(d, g, v, m, y), o.restore());
    }
    !i || u ? p(0, 0, s, l) : i.length && L(i, function(g) {
      p(g.x * f, g.y * f, g.width * f, g.height * f);
    });
  }, t;
}(oi), CC = 1e5, Ls = 314159, lp = 0.01, Eq = 1e-3;
function Cq(r) {
  return r ? r.__builtin__ ? !0 : !(typeof r.resize != "function" || typeof r.refresh != "function") : !1;
}
function Dq(r, t) {
  var e = document.createElement("div");
  return e.style.cssText = [
    "position:relative",
    "width:" + r + "px",
    "height:" + t + "px",
    "padding:0",
    "margin:0",
    "border-width:0"
  ].join(";") + ";", e;
}
var Lq = function() {
  function r(t, e, n, i) {
    this.type = "canvas", this._zlevelList = [], this._prevDisplayList = [], this._layers = {}, this._layerConfig = {}, this._needsManuallyCompositing = !1, this.type = "canvas";
    var a = !t.nodeName || t.nodeName.toUpperCase() === "CANVAS";
    this._opts = n = J({}, n || {}), this.dpr = n.devicePixelRatio || Av, this._singleCanvas = a, this.root = t;
    var o = t.style;
    o && (QI(t), t.innerHTML = ""), this.storage = e;
    var s = this._zlevelList;
    this._prevDisplayList = [];
    var l = this._layers;
    if (a) {
      var c = t, f = c.width, h = c.height;
      n.width != null && (f = n.width), n.height != null && (h = n.height), this.dpr = n.devicePixelRatio || 1, c.width = f * this.dpr, c.height = h * this.dpr, this._width = f, this._height = h;
      var d = new A0(c, this, this.dpr);
      d.__builtin__ = !0, d.initContext(), l[Ls] = d, d.zlevel = Ls, s.push(Ls), this._domRoot = t;
    } else {
      this._width = Vu(t, 0, n), this._height = Vu(t, 1, n);
      var u = this._domRoot = Dq(this._width, this._height);
      t.appendChild(u);
    }
  }
  return r.prototype.getType = function() {
    return "canvas";
  }, r.prototype.isSingleCanvas = function() {
    return this._singleCanvas;
  }, r.prototype.getViewportRoot = function() {
    return this._domRoot;
  }, r.prototype.getViewportRootOffset = function() {
    var t = this.getViewportRoot();
    if (t)
      return {
        offsetLeft: t.offsetLeft || 0,
        offsetTop: t.offsetTop || 0
      };
  }, r.prototype.refresh = function(t) {
    var e = this.storage.getDisplayList(!0), n = this._prevDisplayList, i = this._zlevelList;
    this._redrawId = Math.random(), this._paintList(e, n, t, this._redrawId);
    for (var a = 0; a < i.length; a++) {
      var o = i[a], s = this._layers[o];
      if (!s.__builtin__ && s.refresh) {
        var l = a === 0 ? this._backgroundColor : null;
        s.refresh(l);
      }
    }
    return this._opts.useDirtyRect && (this._prevDisplayList = e.slice()), this;
  }, r.prototype.refreshHover = function() {
    this._paintHoverList(this.storage.getDisplayList(!1));
  }, r.prototype._paintHoverList = function(t) {
    var e = t.length, n = this._hoverlayer;
    if (n && n.clear(), !!e) {
      for (var i = {
        inHover: !0,
        viewWidth: this._width,
        viewHeight: this._height
      }, a, o = 0; o < e; o++) {
        var s = t[o];
        s.__inHover && (n || (n = this._hoverlayer = this.getLayer(CC)), a || (a = n.ctx, a.save()), tl(a, s, i, o === e - 1));
      }
      a && a.restore();
    }
  }, r.prototype.getHoverLayer = function() {
    return this.getLayer(CC);
  }, r.prototype.paintOne = function(t, e) {
    BO(t, e);
  }, r.prototype._paintList = function(t, e, n, i) {
    if (this._redrawId === i) {
      n = n || !1, this._updateLayerStatus(t);
      var a = this._doPaintList(t, e, n), o = a.finished, s = a.needsRefreshHover;
      if (this._needsManuallyCompositing && this._compositeManually(), s && this._paintHoverList(t), o)
        this.eachLayer(function(u) {
          u.afterBrush && u.afterBrush();
        });
      else {
        var l = this;
        xv(function() {
          l._paintList(t, e, n, i);
        });
      }
    }
  }, r.prototype._compositeManually = function() {
    var t = this.getLayer(Ls).ctx, e = this._domRoot.width, n = this._domRoot.height;
    t.clearRect(0, 0, e, n), this.eachBuiltinLayer(function(i) {
      i.virtual && t.drawImage(i.dom, 0, 0, e, n);
    });
  }, r.prototype._doPaintList = function(t, e, n) {
    for (var i = this, a = [], o = this._opts.useDirtyRect, s = 0; s < this._zlevelList.length; s++) {
      var l = this._zlevelList[s], u = this._layers[l];
      u.__builtin__ && u !== this._hoverlayer && (u.__dirty || n) && a.push(u);
    }
    for (var c = !0, f = !1, h = function(g) {
      var v = a[g], m = v.ctx, y = o && v.createRepaintRects(t, e, d._width, d._height), _ = n ? v.__startIndex : v.__drawIndex, x = !n && v.incremental && Date.now, b = x && Date.now(), S = v.zlevel === d._zlevelList[0] ? d._backgroundColor : null;
      if (v.__startIndex === v.__endIndex)
        v.clear(!1, S, y);
      else if (_ === v.__startIndex) {
        var w = t[_];
        (!w.incremental || !w.notClear || n) && v.clear(!1, S, y);
      }
      _ === -1 && (console.error("For some unknown reason. drawIndex is -1"), _ = v.__startIndex);
      var A, T = function(C) {
        var D = {
          inHover: !1,
          allClipped: !1,
          prevEl: null,
          viewWidth: i._width,
          viewHeight: i._height
        };
        for (A = _; A < v.__endIndex; A++) {
          var I = t[A];
          if (I.__inHover && (f = !0), i._doPaintEl(I, v, o, C, D, A === v.__endIndex - 1), x) {
            var P = Date.now() - b;
            if (P > 15)
              break;
          }
        }
        D.prevElClipPaths && m.restore();
      };
      if (y)
        if (y.length === 0)
          A = v.__endIndex;
        else
          for (var M = d.dpr, E = 0; E < y.length; ++E) {
            var R = y[E];
            m.save(), m.beginPath(), m.rect(R.x * M, R.y * M, R.width * M, R.height * M), m.clip(), T(R), m.restore();
          }
      else
        m.save(), T(), m.restore();
      v.__drawIndex = A, v.__drawIndex < v.__endIndex && (c = !1);
    }, d = this, p = 0; p < a.length; p++)
      h(p);
    return oe.wxa && L(this._layers, function(g) {
      g && g.ctx && g.ctx.draw && g.ctx.draw();
    }), {
      finished: c,
      needsRefreshHover: f
    };
  }, r.prototype._doPaintEl = function(t, e, n, i, a, o) {
    var s = e.ctx;
    if (n) {
      var l = t.getPaintRect();
      (!i || l && l.intersect(i)) && (tl(s, t, a, o), t.setPrevPaintRect(l));
    } else
      tl(s, t, a, o);
  }, r.prototype.getLayer = function(t, e) {
    this._singleCanvas && !this._needsManuallyCompositing && (t = Ls);
    var n = this._layers[t];
    return n || (n = new A0("zr_" + t, this, this.dpr), n.zlevel = t, n.__builtin__ = !0, this._layerConfig[t] ? qt(n, this._layerConfig[t], !0) : this._layerConfig[t - lp] && qt(n, this._layerConfig[t - lp], !0), e && (n.virtual = e), this.insertLayer(t, n), n.initContext()), n;
  }, r.prototype.insertLayer = function(t, e) {
    var n = this._layers, i = this._zlevelList, a = i.length, o = this._domRoot, s = null, l = -1;
    if (n[t]) {
      process.env.NODE_ENV !== "production" && gi("ZLevel " + t + " has been used already");
      return;
    }
    if (!Cq(e)) {
      process.env.NODE_ENV !== "production" && gi("Layer of zlevel " + t + " is not valid");
      return;
    }
    if (a > 0 && t > i[0]) {
      for (l = 0; l < a - 1 && !(i[l] < t && i[l + 1] > t); l++)
        ;
      s = n[i[l]];
    }
    if (i.splice(l + 1, 0, t), n[t] = e, !e.virtual)
      if (s) {
        var u = s.dom;
        u.nextSibling ? o.insertBefore(e.dom, u.nextSibling) : o.appendChild(e.dom);
      } else
        o.firstChild ? o.insertBefore(e.dom, o.firstChild) : o.appendChild(e.dom);
    e.painter || (e.painter = this);
  }, r.prototype.eachLayer = function(t, e) {
    for (var n = this._zlevelList, i = 0; i < n.length; i++) {
      var a = n[i];
      t.call(e, this._layers[a], a);
    }
  }, r.prototype.eachBuiltinLayer = function(t, e) {
    for (var n = this._zlevelList, i = 0; i < n.length; i++) {
      var a = n[i], o = this._layers[a];
      o.__builtin__ && t.call(e, o, a);
    }
  }, r.prototype.eachOtherLayer = function(t, e) {
    for (var n = this._zlevelList, i = 0; i < n.length; i++) {
      var a = n[i], o = this._layers[a];
      o.__builtin__ || t.call(e, o, a);
    }
  }, r.prototype.getLayers = function() {
    return this._layers;
  }, r.prototype._updateLayerStatus = function(t) {
    this.eachBuiltinLayer(function(f, h) {
      f.__dirty = f.__used = !1;
    });
    function e(f) {
      a && (a.__endIndex !== f && (a.__dirty = !0), a.__endIndex = f);
    }
    if (this._singleCanvas)
      for (var n = 1; n < t.length; n++) {
        var i = t[n];
        if (i.zlevel !== t[n - 1].zlevel || i.incremental) {
          this._needsManuallyCompositing = !0;
          break;
        }
      }
    var a = null, o = 0, s, l;
    for (l = 0; l < t.length; l++) {
      var i = t[l], u = i.zlevel, c = void 0;
      s !== u && (s = u, o = 0), i.incremental ? (c = this.getLayer(u + Eq, this._needsManuallyCompositing), c.incremental = !0, o = 1) : c = this.getLayer(u + (o > 0 ? lp : 0), this._needsManuallyCompositing), c.__builtin__ || gi("ZLevel " + u + " has been used by unkown layer " + c.id), c !== a && (c.__used = !0, c.__startIndex !== l && (c.__dirty = !0), c.__startIndex = l, c.incremental ? c.__drawIndex = -1 : c.__drawIndex = l, e(l), a = c), i.__dirty & Rn && !i.__inHover && (c.__dirty = !0, c.incremental && c.__drawIndex < 0 && (c.__drawIndex = l));
    }
    e(l), this.eachBuiltinLayer(function(f, h) {
      !f.__used && f.getElementCount() > 0 && (f.__dirty = !0, f.__startIndex = f.__endIndex = f.__drawIndex = 0), f.__dirty && f.__drawIndex < 0 && (f.__drawIndex = f.__startIndex);
    });
  }, r.prototype.clear = function() {
    return this.eachBuiltinLayer(this._clearLayer), this;
  }, r.prototype._clearLayer = function(t) {
    t.clear();
  }, r.prototype.setBackgroundColor = function(t) {
    this._backgroundColor = t, L(this._layers, function(e) {
      e.setUnpainted();
    });
  }, r.prototype.configLayer = function(t, e) {
    if (e) {
      var n = this._layerConfig;
      n[t] ? qt(n[t], e, !0) : n[t] = e;
      for (var i = 0; i < this._zlevelList.length; i++) {
        var a = this._zlevelList[i];
        if (a === t || a === t + lp) {
          var o = this._layers[a];
          qt(o, n[t], !0);
        }
      }
    }
  }, r.prototype.delLayer = function(t) {
    var e = this._layers, n = this._zlevelList, i = e[t];
    i && (i.dom.parentNode.removeChild(i.dom), delete e[t], n.splice(Zt(n, t), 1));
  }, r.prototype.resize = function(t, e) {
    if (this._domRoot.style) {
      var n = this._domRoot;
      n.style.display = "none";
      var i = this._opts, a = this.root;
      if (t != null && (i.width = t), e != null && (i.height = e), t = Vu(a, 0, i), e = Vu(a, 1, i), n.style.display = "", this._width !== t || e !== this._height) {
        n.style.width = t + "px", n.style.height = e + "px";
        for (var o in this._layers)
          this._layers.hasOwnProperty(o) && this._layers[o].resize(t, e);
        this.refresh(!0);
      }
      this._width = t, this._height = e;
    } else {
      if (t == null || e == null)
        return;
      this._width = t, this._height = e, this.getLayer(Ls).resize(t, e);
    }
    return this;
  }, r.prototype.clearLayer = function(t) {
    var e = this._layers[t];
    e && e.clear();
  }, r.prototype.dispose = function() {
    this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null;
  }, r.prototype.getRenderedCanvas = function(t) {
    if (t = t || {}, this._singleCanvas && !this._compositeManually)
      return this._layers[Ls].dom;
    var e = new A0("image", this, t.pixelRatio || this.dpr);
    e.initContext(), e.clear(!1, t.backgroundColor || this._backgroundColor);
    var n = e.ctx;
    if (t.pixelRatio <= this.dpr) {
      this.refresh();
      var i = e.dom.width, a = e.dom.height;
      this.eachLayer(function(f) {
        f.__builtin__ ? n.drawImage(f.dom, 0, 0, i, a) : f.renderToCanvas && (n.save(), f.renderToCanvas(n), n.restore());
      });
    } else
      for (var o = {
        inHover: !1,
        viewWidth: this._width,
        viewHeight: this._height
      }, s = this.storage.getDisplayList(!0), l = 0, u = s.length; l < u; l++) {
        var c = s[l];
        tl(n, c, o, l === u - 1);
      }
    return e.dom;
  }, r.prototype.getWidth = function() {
    return this._width;
  }, r.prototype.getHeight = function() {
    return this._height;
  }, r;
}();
function Rq(r) {
  r.registerPainter("canvas", Lq);
}
var Iq = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.hasSymbolVisual = !0, e;
    }
    return t.prototype.getInitialData = function(e) {
      if (process.env.NODE_ENV !== "production") {
        var n = e.coordinateSystem;
        if (n !== "polar" && n !== "cartesian2d")
          throw new Error("Line not support coordinateSystem besides cartesian and polar");
      }
      return ja(null, this, {
        useEncodeDefaulter: !0
      });
    }, t.prototype.getLegendIcon = function(e) {
      var n = new Et(), i = fr("line", 0, e.itemHeight / 2, e.itemWidth, 0, e.lineStyle.stroke, !1);
      n.add(i), i.setStyle(e.lineStyle);
      var a = this.getData().getVisual("symbol"), o = this.getData().getVisual("symbolRotate"), s = a === "none" ? "circle" : a, l = e.itemHeight * 0.8, u = fr(s, (e.itemWidth - l) / 2, (e.itemHeight - l) / 2, l, l, e.itemStyle.fill);
      n.add(u), u.setStyle(e.itemStyle);
      var c = e.iconRotate === "inherit" ? o : e.iconRotate || 0;
      return u.rotation = c * Math.PI / 180, u.setOrigin([e.itemWidth / 2, e.itemHeight / 2]), s.indexOf("empty") > -1 && (u.style.stroke = u.style.fill, u.style.fill = Y.color.neutral00, u.style.lineWidth = 2), n;
    }, t.type = "series.line", t.dependencies = ["grid", "polar"], t.defaultOption = {
      // zlevel: 0,
      z: 3,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      clip: !0,
      label: {
        position: "top"
      },
      // itemStyle: {
      // },
      endLabel: {
        show: !1,
        valueAnimation: !0,
        distance: 8
      },
      lineStyle: {
        width: 2,
        type: "solid"
      },
      emphasis: {
        scale: !0
      },
      // areaStyle: {
      // origin of areaStyle. Valid values:
      // `'auto'/null/undefined`: from axisLine to data
      // `'start'`: from min to data
      // `'end'`: from data to max
      // origin: 'auto'
      // },
      // false, 'start', 'end', 'middle'
      step: !1,
      // Disabled if step is true
      smooth: !1,
      smoothMonotone: null,
      symbol: "emptyCircle",
      symbolSize: 6,
      symbolRotate: null,
      showSymbol: !0,
      // `false`: follow the label interval strategy.
      // `true`: show all symbols.
      // `'auto'`: If possible, show all symbols, otherwise
      //           follow the label interval strategy.
      showAllSymbol: "auto",
      // Whether to connect break point.
      connectNulls: !1,
      // Sampling for large data. Can be: 'average', 'max', 'min', 'sum', 'lttb'.
      sampling: "none",
      animationEasing: "linear",
      // Disable progressive
      progressive: 0,
      hoverLayerThreshold: 1 / 0,
      universalTransition: {
        divideShape: "clone"
      },
      triggerLineEvent: !1
    }, t;
  }(ke)
);
function uc(r, t) {
  var e = r.mapDimensionsAll("defaultedLabel"), n = e.length;
  if (n === 1) {
    var i = ic(r, t, e[0]);
    return i != null ? i + "" : null;
  } else if (n) {
    for (var a = [], o = 0; o < e.length; o++)
      a.push(ic(r, t, e[o]));
    return a.join(" ");
  }
}
function e3(r, t) {
  var e = r.mapDimensionsAll("defaultedLabel");
  if (!et(t))
    return t + "";
  for (var n = [], i = 0; i < e.length; i++) {
    var a = r.getDimensionIndex(e[i]);
    a >= 0 && n.push(t[a]);
  }
  return n.join(" ");
}
var Wh = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e, n, i, a) {
      var o = r.call(this) || this;
      return o.updateData(e, n, i, a), o;
    }
    return t.prototype._createSymbol = function(e, n, i, a, o, s) {
      this.removeAll();
      var l = fr(e, -1, -1, 2, 2, null, s);
      l.attr({
        z2: bt(o, 100),
        culling: !0,
        scaleX: a[0] / 2,
        scaleY: a[1] / 2
      }), l.drift = Pq, this._symbolType = e, this.add(l);
    }, t.prototype.stopSymbolAnimation = function(e) {
      this.childAt(0).stopAnimation(null, e);
    }, t.prototype.getSymbolType = function() {
      return this._symbolType;
    }, t.prototype.getSymbolPath = function() {
      return this.childAt(0);
    }, t.prototype.highlight = function() {
      Ha(this.childAt(0));
    }, t.prototype.downplay = function() {
      Wa(this.childAt(0));
    }, t.prototype.setZ = function(e, n) {
      var i = this.childAt(0);
      i.zlevel = e, i.z = n;
    }, t.prototype.setDraggable = function(e, n) {
      var i = this.childAt(0);
      i.draggable = e, i.cursor = !n && e ? "move" : i.cursor;
    }, t.prototype.updateData = function(e, n, i, a) {
      this.silent = !1;
      var o = e.getItemVisual(n, "symbol") || "circle", s = e.hostModel, l = t.getSymbolSize(e, n), u = t.getSymbolZ2(e, n), c = o !== this._symbolType, f = a && a.disableAnimation;
      if (c) {
        var h = e.getItemVisual(n, "symbolKeepAspect");
        this._createSymbol(o, e, n, l, u, h);
      } else {
        var d = this.childAt(0);
        d.silent = !1;
        var p = {
          scaleX: l[0] / 2,
          scaleY: l[1] / 2
        };
        f ? d.attr(p) : ve(d, p, s, n), ai(d);
      }
      if (this._updateCommon(e, n, l, i, a), c) {
        var d = this.childAt(0);
        if (!f) {
          var p = {
            scaleX: this._sizeX,
            scaleY: this._sizeY,
            style: {
              // Always fadeIn. Because it has fadeOut animation when symbol is removed..
              opacity: d.style.opacity
            }
          };
          d.scaleX = d.scaleY = 0, d.style.opacity = 0, ze(d, p, s, n);
        }
      }
      f && this.childAt(0).stopAnimation("leave");
    }, t.prototype._updateCommon = function(e, n, i, a, o) {
      var s = this.childAt(0), l = e.hostModel, u, c, f, h, d, p, g, v, m;
      if (a && (u = a.emphasisItemStyle, c = a.blurItemStyle, f = a.selectItemStyle, h = a.focus, d = a.blurScope, g = a.labelStatesModels, v = a.hoverScale, m = a.cursorStyle, p = a.emphasisDisabled), !a || e.hasItemOption) {
        var y = a && a.itemModel ? a.itemModel : e.getItemModel(n), _ = y.getModel("emphasis");
        u = _.getModel("itemStyle").getItemStyle(), f = y.getModel(["select", "itemStyle"]).getItemStyle(), c = y.getModel(["blur", "itemStyle"]).getItemStyle(), h = _.get("focus"), d = _.get("blurScope"), p = _.get("disabled"), g = _r(y), v = _.getShallow("scale"), m = y.getShallow("cursor");
      }
      var x = e.getItemVisual(n, "symbolRotate");
      s.attr("rotation", (x || 0) * Math.PI / 180 || 0);
      var b = Dl(e.getItemVisual(n, "symbolOffset"), i);
      b && (s.x = b[0], s.y = b[1]), m && s.attr("cursor", m);
      var S = e.getItemVisual(n, "style"), w = S.fill;
      if (s instanceof Vr) {
        var A = s.style;
        s.useStyle(J({
          // TODO other properties like x, y ?
          image: A.image,
          x: A.x,
          y: A.y,
          width: A.width,
          height: A.height
        }, S));
      } else
        s.__isEmptyBrush ? s.useStyle(J({}, S)) : s.useStyle(S), s.style.decal = null, s.setColor(w, o && o.symbolInnerColor), s.style.strokeNoScale = !0;
      var T = e.getItemVisual(n, "liftZ"), M = this._z2;
      T != null ? M == null && (this._z2 = s.z2, s.z2 += T) : M != null && (s.z2 = M, this._z2 = null);
      var E = o && o.useNameLabel;
      Er(s, g, {
        labelFetcher: l,
        labelDataIndex: n,
        defaultText: R,
        inheritColor: w,
        defaultOpacity: S.opacity
      });
      function R(I) {
        return E ? e.getName(I) : uc(e, I);
      }
      this._sizeX = i[0] / 2, this._sizeY = i[1] / 2;
      var C = s.ensureState("emphasis");
      C.style = u, s.ensureState("select").style = f, s.ensureState("blur").style = c;
      var D = v == null || v === !0 ? Math.max(1.1, 3 / this._sizeY) : isFinite(v) && v > 0 ? +v : 1;
      C.scaleX = this._sizeX * D, C.scaleY = this._sizeY * D, this.setSymbolScale(1), Ge(this, h, d, p);
    }, t.prototype.setSymbolScale = function(e) {
      this.scaleX = this.scaleY = e;
    }, t.prototype.fadeOut = function(e, n, i) {
      var a = this.childAt(0), o = zt(this).dataIndex, s = i && i.animation;
      if (this.silent = a.silent = !0, i && i.fadeLabel) {
        var l = a.getTextContent();
        l && Go(l, {
          style: {
            opacity: 0
          }
        }, n, {
          dataIndex: o,
          removeOpt: s,
          cb: function() {
            a.removeTextContent();
          }
        });
      } else
        a.removeTextContent();
      Go(a, {
        style: {
          opacity: 0
        },
        scaleX: 0,
        scaleY: 0
      }, n, {
        dataIndex: o,
        cb: e,
        removeOpt: s
      });
    }, t.getSymbolSize = function(e, n) {
      return Lc(e.getItemVisual(n, "symbolSize"));
    }, t.getSymbolZ2 = function(e, n) {
      return e.getItemVisual(n, "z2");
    }, t;
  }(Et)
);
function Pq(r, t) {
  this.parent.drift(r, t);
}
function E0(r, t, e, n) {
  return t && !isNaN(t[0]) && !isNaN(t[1]) && !(n.isIgnore && n.isIgnore(e)) && !(n.clipShape && !n.clipShape.contain(t[0], t[1])) && r.getItemVisual(e, "symbol") !== "none";
}
function DC(r) {
  return r != null && !Dt(r) && (r = {
    isIgnore: r
  }), r || {};
}
function LC(r) {
  var t = r.hostModel, e = t.getModel("emphasis");
  return {
    emphasisItemStyle: e.getModel("itemStyle").getItemStyle(),
    blurItemStyle: t.getModel(["blur", "itemStyle"]).getItemStyle(),
    selectItemStyle: t.getModel(["select", "itemStyle"]).getItemStyle(),
    focus: e.get("focus"),
    blurScope: e.get("blurScope"),
    emphasisDisabled: e.get("disabled"),
    hoverScale: e.get("scale"),
    labelStatesModels: _r(t),
    cursorStyle: t.get("cursor")
  };
}
var Xh = (
  /** @class */
  function() {
    function r(t) {
      this.group = new Et(), this._SymbolCtor = t || Wh;
    }
    return r.prototype.updateData = function(t, e) {
      this._progressiveEls = null, e = DC(e);
      var n = this.group, i = t.hostModel, a = this._data, o = this._SymbolCtor, s = e.disableAnimation, l = LC(t), u = {
        disableAnimation: s
      }, c = e.getSymbolPoint || function(f) {
        return t.getItemLayout(f);
      };
      a || n.removeAll(), t.diff(a).add(function(f) {
        var h = c(f);
        if (E0(t, h, f, e)) {
          var d = new o(t, f, l, u);
          d.setPosition(h), t.setItemGraphicEl(f, d), n.add(d);
        }
      }).update(function(f, h) {
        var d = a.getItemGraphicEl(h), p = c(f);
        if (!E0(t, p, f, e)) {
          n.remove(d);
          return;
        }
        var g = t.getItemVisual(f, "symbol") || "circle", v = d && d.getSymbolType && d.getSymbolType();
        if (!d || v && v !== g)
          n.remove(d), d = new o(t, f, l, u), d.setPosition(p);
        else {
          d.updateData(t, f, l, u);
          var m = {
            x: p[0],
            y: p[1]
          };
          s ? d.attr(m) : ve(d, m, i);
        }
        n.add(d), t.setItemGraphicEl(f, d);
      }).remove(function(f) {
        var h = a.getItemGraphicEl(f);
        h && h.fadeOut(function() {
          n.remove(h);
        }, i);
      }).execute(), this._getSymbolPoint = c, this._data = t;
    }, r.prototype.updateLayout = function() {
      var t = this, e = this._data;
      e && e.eachItemGraphicEl(function(n, i) {
        var a = t._getSymbolPoint(i);
        n.setPosition(a), n.markRedraw();
      });
    }, r.prototype.incrementalPrepareUpdate = function(t) {
      this._seriesScope = LC(t), this._data = null, this.group.removeAll();
    }, r.prototype.incrementalUpdate = function(t, e, n) {
      this._progressiveEls = [], n = DC(n);
      function i(l) {
        l.isGroup || (l.incremental = !0, l.ensureState("emphasis").hoverLayer = !0);
      }
      for (var a = t.start; a < t.end; a++) {
        var o = e.getItemLayout(a);
        if (E0(e, o, a, n)) {
          var s = new this._SymbolCtor(e, a, this._seriesScope);
          s.traverse(i), s.setPosition(o), this.group.add(s), e.setItemGraphicEl(a, s), this._progressiveEls.push(s);
        }
      }
    }, r.prototype.eachRendered = function(t) {
      Ko(this._progressiveEls || this.group, t);
    }, r.prototype.remove = function(t) {
      var e = this.group, n = this._data;
      n && t ? n.eachItemGraphicEl(function(i) {
        i.fadeOut(function() {
          e.remove(i);
        }, n.hostModel);
      }) : e.removeAll();
    }, r;
  }()
);
function r3(r, t, e) {
  var n = r.getBaseAxis(), i = r.getOtherAxis(n), a = Nq(i, e), o = n.dim, s = i.dim, l = t.mapDimension(s), u = t.mapDimension(o), c = s === "x" || s === "radius" ? 1 : 0, f = rt(r.dimensions, function(p) {
    return t.mapDimension(p);
  }), h = !1, d = t.getCalculationInfo("stackResultDimension");
  return Ho(
    t,
    f[0]
    /* , dims[1] */
  ) && (h = !0, f[0] = d), Ho(
    t,
    f[1]
    /* , dims[0] */
  ) && (h = !0, f[1] = d), {
    dataDimsForPoint: f,
    valueStart: a,
    valueAxisDim: s,
    baseAxisDim: o,
    stacked: !!h,
    valueDim: l,
    baseDim: u,
    baseDataOffset: c,
    stackedOverDimension: t.getCalculationInfo("stackedOverDimension")
  };
}
function Nq(r, t) {
  var e = 0, n = r.scale.getExtent();
  return t === "start" ? e = n[0] : t === "end" ? e = n[1] : fe(t) && !isNaN(t) ? e = t : n[0] > 0 ? e = n[0] : n[1] < 0 && (e = n[1]), e;
}
function n3(r, t, e, n) {
  var i = NaN;
  r.stacked && (i = e.get(e.getCalculationInfo("stackedOverDimension"), n)), isNaN(i) && (i = r.valueStart);
  var a = r.baseDataOffset, o = [];
  return o[a] = e.get(r.baseDim, n), o[1 - a] = i, t.dataToPoint(o);
}
function Oq(r, t) {
  var e = [];
  return t.diff(r).add(function(n) {
    e.push({
      cmd: "+",
      idx: n
    });
  }).update(function(n, i) {
    e.push({
      cmd: "=",
      idx: i,
      idx1: n
    });
  }).remove(function(n) {
    e.push({
      cmd: "-",
      idx: n
    });
  }).execute(), e;
}
function kq(r, t, e, n, i, a, o, s) {
  for (var l = Oq(r, t), u = [], c = [], f = [], h = [], d = [], p = [], g = [], v = r3(i, t, o), m = r.getLayout("points") || [], y = t.getLayout("points") || [], _ = 0; _ < l.length; _++) {
    var x = l[_], b = !0, S = void 0, w = void 0;
    switch (x.cmd) {
      case "=":
        S = x.idx * 2, w = x.idx1 * 2;
        var A = m[S], T = m[S + 1], M = y[w], E = y[w + 1];
        (isNaN(A) || isNaN(T)) && (A = M, T = E), u.push(A, T), c.push(M, E), f.push(e[S], e[S + 1]), h.push(n[w], n[w + 1]), g.push(t.getRawIndex(x.idx1));
        break;
      case "+":
        var R = x.idx, C = v.dataDimsForPoint, D = i.dataToPoint([t.get(C[0], R), t.get(C[1], R)]);
        w = R * 2, u.push(D[0], D[1]), c.push(y[w], y[w + 1]);
        var I = n3(v, i, t, R);
        f.push(I[0], I[1]), h.push(n[w], n[w + 1]), g.push(t.getRawIndex(R));
        break;
      case "-":
        b = !1;
    }
    b && (d.push(x), p.push(p.length));
  }
  p.sort(function($, ct) {
    return g[$] - g[ct];
  });
  for (var P = u.length, O = Zi(P), N = Zi(P), B = Zi(P), F = Zi(P), G = [], _ = 0; _ < p.length; _++) {
    var X = p[_], K = _ * 2, U = X * 2;
    O[K] = u[U], O[K + 1] = u[U + 1], N[K] = c[U], N[K + 1] = c[U + 1], B[K] = f[U], B[K + 1] = f[U + 1], F[K] = h[U], F[K + 1] = h[U + 1], G[_] = d[X];
  }
  return {
    current: O,
    next: N,
    stackedOnCurrent: B,
    stackedOnNext: F,
    status: G
  };
}
var fo = Math.min, ho = Math.max;
function ll(r, t) {
  return isNaN(r) || isNaN(t);
}
function pS(r, t, e, n, i, a, o, s, l) {
  for (var u, c, f, h, d, p, g = e, v = 0; v < n; v++) {
    var m = t[g * 2], y = t[g * 2 + 1];
    if (g >= i || g < 0)
      break;
    if (ll(m, y)) {
      if (l) {
        g += a;
        continue;
      }
      break;
    }
    if (g === e)
      r[a > 0 ? "moveTo" : "lineTo"](m, y), f = m, h = y;
    else {
      var _ = m - u, x = y - c;
      if (_ * _ + x * x < 0.5) {
        g += a;
        continue;
      }
      if (o > 0) {
        for (var b = g + a, S = t[b * 2], w = t[b * 2 + 1]; S === m && w === y && v < n; )
          v++, b += a, g += a, S = t[b * 2], w = t[b * 2 + 1], m = t[g * 2], y = t[g * 2 + 1], _ = m - u, x = y - c;
        var A = v + 1;
        if (l)
          for (; ll(S, w) && A < n; )
            A++, b += a, S = t[b * 2], w = t[b * 2 + 1];
        var T = 0.5, M = 0, E = 0, R = void 0, C = void 0;
        if (A >= n || ll(S, w))
          d = m, p = y;
        else {
          M = S - u, E = w - c;
          var D = m - u, I = S - m, P = y - c, O = w - y, N = void 0, B = void 0;
          if (s === "x") {
            N = Math.abs(D), B = Math.abs(I);
            var F = M > 0 ? 1 : -1;
            d = m - F * N * o, p = y, R = m + F * B * o, C = y;
          } else if (s === "y") {
            N = Math.abs(P), B = Math.abs(O);
            var G = E > 0 ? 1 : -1;
            d = m, p = y - G * N * o, R = m, C = y + G * B * o;
          } else
            N = Math.sqrt(D * D + P * P), B = Math.sqrt(I * I + O * O), T = B / (B + N), d = m - M * o * (1 - T), p = y - E * o * (1 - T), R = m + M * o * T, C = y + E * o * T, R = fo(R, ho(S, m)), C = fo(C, ho(w, y)), R = ho(R, fo(S, m)), C = ho(C, fo(w, y)), M = R - m, E = C - y, d = m - M * N / B, p = y - E * N / B, d = fo(d, ho(u, m)), p = fo(p, ho(c, y)), d = ho(d, fo(u, m)), p = ho(p, fo(c, y)), M = m - d, E = y - p, R = m + M * B / N, C = y + E * B / N;
        }
        r.bezierCurveTo(f, h, d, p, m, y), f = R, h = C;
      } else
        r.lineTo(m, y);
    }
    u = m, c = y, g += a;
  }
  return v;
}
var i3 = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
      this.smooth = 0, this.smoothConstraint = !0;
    }
    return r;
  }()
), Bq = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e) {
      var n = r.call(this, e) || this;
      return n.type = "ec-polyline", n;
    }
    return t.prototype.getDefaultStyle = function() {
      return {
        stroke: Y.color.neutral99,
        fill: null
      };
    }, t.prototype.getDefaultShape = function() {
      return new i3();
    }, t.prototype.buildPath = function(e, n) {
      var i = n.points, a = 0, o = i.length / 2;
      if (n.connectNulls) {
        for (; o > 0 && ll(i[o * 2 - 2], i[o * 2 - 1]); o--)
          ;
        for (; a < o && ll(i[a * 2], i[a * 2 + 1]); a++)
          ;
      }
      for (; a < o; )
        a += pS(e, i, a, o, o, 1, n.smooth, n.smoothMonotone, n.connectNulls) + 1;
    }, t.prototype.getPointOn = function(e, n) {
      this.path || (this.createPathProxy(), this.buildPath(this.path, this.shape));
      for (var i = this.path, a = i.data, o = aa.CMD, s, l, u = n === "x", c = [], f = 0; f < a.length; ) {
        var h = a[f++], d = void 0, p = void 0, g = void 0, v = void 0, m = void 0, y = void 0, _ = void 0;
        switch (h) {
          case o.M:
            s = a[f++], l = a[f++];
            break;
          case o.L:
            if (d = a[f++], p = a[f++], _ = u ? (e - s) / (d - s) : (e - l) / (p - l), _ <= 1 && _ >= 0) {
              var x = u ? (p - l) * _ + l : (d - s) * _ + s;
              return u ? [e, x] : [x, e];
            }
            s = d, l = p;
            break;
          case o.C:
            d = a[f++], p = a[f++], g = a[f++], v = a[f++], m = a[f++], y = a[f++];
            var b = u ? bv(s, d, g, m, e, c) : bv(l, p, v, y, e, c);
            if (b > 0)
              for (var S = 0; S < b; S++) {
                var w = c[S];
                if (w <= 1 && w >= 0) {
                  var x = u ? br(l, p, v, y, w) : br(s, d, g, m, w);
                  return u ? [e, x] : [x, e];
                }
              }
            s = m, l = y;
            break;
        }
      }
    }, t;
  }(ne)
), Vq = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t;
  }(i3)
), a3 = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e) {
      var n = r.call(this, e) || this;
      return n.type = "ec-polygon", n;
    }
    return t.prototype.getDefaultShape = function() {
      return new Vq();
    }, t.prototype.buildPath = function(e, n) {
      var i = n.points, a = n.stackedOnPoints, o = 0, s = i.length / 2, l = n.smoothMonotone;
      if (n.connectNulls) {
        for (; s > 0 && ll(i[s * 2 - 2], i[s * 2 - 1]); s--)
          ;
        for (; o < s && ll(i[o * 2], i[o * 2 + 1]); o++)
          ;
      }
      for (; o < s; ) {
        var u = pS(e, i, o, s, s, 1, n.smooth, l, n.connectNulls);
        pS(e, a, o + u - 1, u, s, -1, n.stackedOnSmooth, l, n.connectNulls), o += u + 1, e.closePath();
      }
    }, t;
  }(ne)
);
function o3(r, t, e, n, i) {
  var a = r.getArea(), o = a.x, s = a.y, l = a.width, u = a.height, c = e.get(["lineStyle", "width"]) || 0;
  o -= c / 2, s -= c / 2, l += c, u += c, l = Math.ceil(l), o !== Math.floor(o) && (o = Math.floor(o), l++);
  var f = new te({
    shape: {
      x: o,
      y: s,
      width: l,
      height: u
    }
  });
  if (t) {
    var h = r.getBaseAxis(), d = h.isHorizontal(), p = h.inverse;
    d ? (p && (f.shape.x += l), f.shape.width = 0) : (p || (f.shape.y += u), f.shape.height = 0);
    var g = Tt(i) ? function(v) {
      i(v, f);
    } : null;
    ze(f, {
      shape: {
        width: l,
        height: u,
        x: o,
        y: s
      }
    }, e, null, n, g);
  }
  return f;
}
function s3(r, t, e) {
  var n = r.getArea(), i = or(n.r0, 1), a = or(n.r, 1), o = new Kr({
    shape: {
      cx: or(r.cx, 1),
      cy: or(r.cy, 1),
      r0: i,
      r: a,
      startAngle: n.startAngle,
      endAngle: n.endAngle,
      clockwise: n.clockwise
    }
  });
  if (t) {
    var s = r.getBaseAxis().dim === "angle";
    s ? o.shape.endAngle = n.startAngle : o.shape.r = i, ze(o, {
      shape: {
        endAngle: n.endAngle,
        r: a
      }
    }, e);
  }
  return o;
}
function Yh(r, t, e, n, i) {
  if (r) {
    if (r.type === "polar")
      return s3(r, t, e);
    if (r.type === "cartesian2d")
      return o3(r, t, e, n, i);
  } else
    return null;
  return null;
}
function Wo(r, t) {
  return r.type === t;
}
function RC(r, t) {
  if (r.length === t.length) {
    for (var e = 0; e < r.length; e++)
      if (r[e] !== t[e])
        return;
    return !0;
  }
}
function IC(r) {
  for (var t = 1 / 0, e = 1 / 0, n = -1 / 0, i = -1 / 0, a = 0; a < r.length; ) {
    var o = r[a++], s = r[a++];
    isNaN(o) || (t = Math.min(o, t), n = Math.max(o, n)), isNaN(s) || (e = Math.min(s, e), i = Math.max(s, i));
  }
  return [[t, e], [n, i]];
}
function PC(r, t) {
  var e = IC(r), n = e[0], i = e[1], a = IC(t), o = a[0], s = a[1];
  return Math.max(Math.abs(n[0] - o[0]), Math.abs(n[1] - o[1]), Math.abs(i[0] - s[0]), Math.abs(i[1] - s[1]));
}
function NC(r) {
  return fe(r) ? r : r ? 0.5 : 0;
}
function Fq(r, t, e) {
  if (!e.valueDim)
    return [];
  for (var n = t.count(), i = Zi(n * 2), a = 0; a < n; a++) {
    var o = n3(e, r, t, a);
    i[a * 2] = o[0], i[a * 2 + 1] = o[1];
  }
  return i;
}
function po(r, t, e, n, i) {
  var a = e.getBaseAxis(), o = a.dim === "x" || a.dim === "radius" ? 0 : 1, s = [], l = 0, u = [], c = [], f = [], h = [];
  if (i) {
    for (l = 0; l < r.length; l += 2) {
      var d = t || r;
      !isNaN(d[l]) && !isNaN(d[l + 1]) && h.push(r[l], r[l + 1]);
    }
    r = h;
  }
  for (l = 0; l < r.length - 2; l += 2)
    switch (f[0] = r[l + 2], f[1] = r[l + 3], c[0] = r[l], c[1] = r[l + 1], s.push(c[0], c[1]), n) {
      case "end":
        u[o] = f[o], u[1 - o] = c[1 - o], s.push(u[0], u[1]);
        break;
      case "middle":
        var p = (c[o] + f[o]) / 2, g = [];
        u[o] = g[o] = p, u[1 - o] = c[1 - o], g[1 - o] = f[1 - o], s.push(u[0], u[1]), s.push(g[0], g[1]);
        break;
      default:
        u[o] = c[o], u[1 - o] = f[1 - o], s.push(u[0], u[1]);
    }
  return s.push(r[l++], r[l++]), s;
}
function zq(r, t) {
  var e = [], n = r.length, i, a;
  function o(c, f, h) {
    var d = c.coord, p = (h - d) / (f.coord - d), g = r8(p, [c.color, f.color]);
    return {
      coord: h,
      color: g
    };
  }
  for (var s = 0; s < n; s++) {
    var l = r[s], u = l.coord;
    if (u < 0)
      i = l;
    else if (u > t) {
      a ? e.push(o(a, l, t)) : i && e.push(o(i, l, 0), o(i, l, t));
      break;
    } else
      i && (e.push(o(i, l, 0)), i = null), e.push(l), a = l;
  }
  return e;
}
function Uq(r, t, e) {
  var n = r.getVisual("visualMeta");
  if (!(!n || !n.length || !r.count())) {
    if (t.type !== "cartesian2d") {
      process.env.NODE_ENV !== "production" && console.warn("Visual map on line style is only supported on cartesian2d.");
      return;
    }
    for (var i, a, o = n.length - 1; o >= 0; o--) {
      var s = r.getDimensionInfo(n[o].dimension);
      if (i = s && s.coordDim, i === "x" || i === "y") {
        a = n[o];
        break;
      }
    }
    if (!a) {
      process.env.NODE_ENV !== "production" && console.warn("Visual map on line style only support x or y dimension.");
      return;
    }
    var l = t.getAxis(i), u = rt(a.stops, function(_) {
      return {
        coord: l.toGlobalCoord(l.dataToCoord(_.value)),
        color: _.color
      };
    }), c = u.length, f = a.outerColors.slice();
    c && u[0].coord > u[c - 1].coord && (u.reverse(), f.reverse());
    var h = zq(u, i === "x" ? e.getWidth() : e.getHeight()), d = h.length;
    if (!d && c)
      return u[0].coord < 0 ? f[1] ? f[1] : u[c - 1].color : f[0] ? f[0] : u[0].color;
    var p = 10, g = h[0].coord - p, v = h[d - 1].coord + p, m = v - g;
    if (m < 1e-3)
      return "transparent";
    L(h, function(_) {
      _.offset = (_.coord - g) / m;
    }), h.push({
      // NOTE: inRangeStopLen may still be 0 if stoplen is zero.
      offset: d ? h[d - 1].offset : 0.5,
      color: f[1] || "transparent"
    }), h.unshift({
      offset: d ? h[0].offset : 0.5,
      color: f[0] || "transparent"
    });
    var y = new wc(0, 0, 0, 0, h, !0);
    return y[i] = g, y[i + "2"] = v, y;
  }
}
function Gq(r, t, e) {
  var n = r.get("showAllSymbol"), i = n === "auto";
  if (!(n && !i)) {
    var a = e.getAxesByScale("ordinal")[0];
    if (a && !(i && Hq(a, t))) {
      var o = t.mapDimension(a.dim), s = {};
      return L(a.getViewLabels(), function(l) {
        var u = a.scale.getRawOrdinalNumber(l.tickValue);
        s[u] = 1;
      }), function(l) {
        return !s.hasOwnProperty(t.get(o, l));
      };
    }
  }
}
function Hq(r, t) {
  var e = r.getExtent(), n = Math.abs(e[1] - e[0]) / r.scale.count();
  isNaN(n) && (n = 0);
  for (var i = t.count(), a = Math.max(1, Math.round(i / 5)), o = 0; o < i; o += a)
    if (Wh.getSymbolSize(
      t,
      o
      // Only for cartesian, where `isHorizontal` exists.
    )[r.isHorizontal() ? 1 : 0] * 1.5 > n)
      return !1;
  return !0;
}
function Wq(r, t) {
  return isNaN(r) || isNaN(t);
}
function Xq(r) {
  for (var t = r.length / 2; t > 0 && Wq(r[t * 2 - 2], r[t * 2 - 1]); t--)
    ;
  return t - 1;
}
function OC(r, t) {
  return [r[t * 2], r[t * 2 + 1]];
}
function Yq(r, t, e) {
  for (var n = r.length / 2, i = e === "x" ? 0 : 1, a, o, s = 0, l = -1, u = 0; u < n; u++)
    if (o = r[u * 2 + i], !(isNaN(o) || isNaN(r[u * 2 + 1 - i]))) {
      if (u === 0) {
        a = o;
        continue;
      }
      if (a <= t && o >= t || a >= t && o <= t) {
        l = u;
        break;
      }
      s = u, a = o;
    }
  return {
    range: [s, l],
    t: (t - a) / (o - a)
  };
}
function l3(r) {
  if (r.get(["endLabel", "show"]))
    return !0;
  for (var t = 0; t < dn.length; t++)
    if (r.get([dn[t], "endLabel", "show"]))
      return !0;
  return !1;
}
function C0(r, t, e, n) {
  if (Wo(t, "cartesian2d")) {
    var i = n.getModel("endLabel"), a = i.get("valueAnimation"), o = n.getData(), s = {
      lastFrameIndex: 0
    }, l = l3(n) ? function(d, p) {
      r._endLabelOnDuring(d, p, o, s, a, i, t);
    } : null, u = t.getBaseAxis().isHorizontal(), c = o3(t, e, n, function() {
      var d = r._endLabel;
      d && e && s.originalX != null && d.attr({
        x: s.originalX,
        y: s.originalY
      });
    }, l);
    if (!n.get("clip", !0)) {
      var f = c.shape, h = Math.max(f.width, f.height);
      u ? (f.y -= h, f.height += h * 2) : (f.x -= h, f.width += h * 2);
    }
    return l && l(1, c), c;
  } else
    return process.env.NODE_ENV !== "production" && n.get(["endLabel", "show"]) && console.warn("endLabel is not supported for lines in polar systems."), s3(t, e, n);
}
function $q(r, t) {
  var e = t.getBaseAxis(), n = e.isHorizontal(), i = e.inverse, a = n ? i ? "right" : "left" : "center", o = n ? "middle" : i ? "top" : "bottom";
  return {
    normal: {
      align: r.get("align") || a,
      verticalAlign: r.get("verticalAlign") || o
    }
  };
}
var Zq = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t.prototype.init = function() {
      var e = new Et(), n = new Xh();
      this.group.add(n.group), this._symbolDraw = n, this._lineGroup = e, this._changePolyState = mt(this._changePolyState, this);
    }, t.prototype.render = function(e, n, i) {
      var a = e.coordinateSystem, o = this.group, s = e.getData(), l = e.getModel("lineStyle"), u = e.getModel("areaStyle"), c = s.getLayout("points") || [], f = a.type === "polar", h = this._coordSys, d = this._symbolDraw, p = this._polyline, g = this._polygon, v = this._lineGroup, m = !n.ssr && e.get("animation"), y = !u.isEmpty(), _ = u.get("origin"), x = r3(a, s, _), b = y && Fq(a, s, x), S = e.get("showSymbol"), w = e.get("connectNulls"), A = S && !f && Gq(e, s, a), T = this._data;
      T && T.eachItemGraphicEl(function($, ct) {
        $.__temp && (o.remove($), T.setItemGraphicEl(ct, null));
      }), S || d.remove(), o.add(v);
      var M = f ? !1 : e.get("step"), E;
      a && a.getArea && e.get("clip", !0) && (E = a.getArea(), E.width != null ? (E.x -= 0.1, E.y -= 0.1, E.width += 0.2, E.height += 0.2) : E.r0 && (E.r0 -= 0.5, E.r += 0.5)), this._clipShapeForSymbol = E;
      var R = Uq(s, a, i) || s.getVisual("style")[s.getVisual("drawType")];
      if (!(p && h.type === a.type && M === this._step))
        S && d.updateData(s, {
          isIgnore: A,
          clipShape: E,
          disableAnimation: !0,
          getSymbolPoint: function($) {
            return [c[$ * 2], c[$ * 2 + 1]];
          }
        }), m && this._initSymbolLabelAnimation(s, a, E), M && (b && (b = po(b, c, a, M, w)), c = po(c, null, a, M, w)), p = this._newPolyline(c), y ? g = this._newPolygon(c, b) : g && (v.remove(g), g = this._polygon = null), f || this._initOrUpdateEndLabel(e, a, yl(R)), v.setClipPath(C0(this, a, !0, e));
      else {
        y && !g ? g = this._newPolygon(c, b) : g && !y && (v.remove(g), g = this._polygon = null), f || this._initOrUpdateEndLabel(e, a, yl(R));
        var C = v.getClipPath();
        if (C) {
          var D = C0(this, a, !1, e);
          ze(C, {
            shape: D.shape
          }, e);
        } else
          v.setClipPath(C0(this, a, !0, e));
        S && d.updateData(s, {
          isIgnore: A,
          clipShape: E,
          disableAnimation: !0,
          getSymbolPoint: function($) {
            return [c[$ * 2], c[$ * 2 + 1]];
          }
        }), (!RC(this._stackedOnPoints, b) || !RC(this._points, c)) && (m ? this._doUpdateAnimation(s, b, a, i, M, _, w) : (M && (b && (b = po(b, c, a, M, w)), c = po(c, null, a, M, w)), p.setShape({
          points: c
        }), g && g.setShape({
          points: c,
          stackedOnPoints: b
        })));
      }
      var I = e.getModel("emphasis"), P = I.get("focus"), O = I.get("blurScope"), N = I.get("disabled");
      if (p.useStyle(kt(
        // Use color in lineStyle first
        l.getLineStyle(),
        {
          fill: "none",
          stroke: R,
          lineJoin: "bevel"
        }
      )), yr(p, e, "lineStyle"), p.style.lineWidth > 0 && e.get(["emphasis", "lineStyle", "width"]) === "bolder") {
        var B = p.getState("emphasis").style;
        B.lineWidth = +p.style.lineWidth + 1;
      }
      zt(p).seriesIndex = e.seriesIndex, Ge(p, P, O, N);
      var F = NC(e.get("smooth")), G = e.get("smoothMonotone");
      if (p.setShape({
        smooth: F,
        smoothMonotone: G,
        connectNulls: w
      }), g) {
        var X = s.getCalculationInfo("stackedOnSeries"), K = 0;
        g.useStyle(kt(u.getAreaStyle(), {
          fill: R,
          opacity: 0.7,
          lineJoin: "bevel",
          decal: s.getVisual("style").decal
        })), X && (K = NC(X.get("smooth"))), g.setShape({
          smooth: F,
          stackedOnSmooth: K,
          smoothMonotone: G,
          connectNulls: w
        }), yr(g, e, "areaStyle"), zt(g).seriesIndex = e.seriesIndex, Ge(g, P, O, N);
      }
      var U = this._changePolyState;
      s.eachItemGraphicEl(function($) {
        $ && ($.onHoverStateChange = U);
      }), this._polyline.onHoverStateChange = U, this._data = s, this._coordSys = a, this._stackedOnPoints = b, this._points = c, this._step = M, this._valueOrigin = _, e.get("triggerLineEvent") && (this.packEventData(e, p), g && this.packEventData(e, g));
    }, t.prototype.packEventData = function(e, n) {
      zt(n).eventData = {
        componentType: "series",
        componentSubType: "line",
        componentIndex: e.componentIndex,
        seriesIndex: e.seriesIndex,
        seriesName: e.name,
        seriesType: "line"
      };
    }, t.prototype.highlight = function(e, n, i, a) {
      var o = e.getData(), s = dl(o, a);
      if (this._changePolyState("emphasis"), !(s instanceof Array) && s != null && s >= 0) {
        var l = o.getLayout("points"), u = o.getItemGraphicEl(s);
        if (!u) {
          var c = l[s * 2], f = l[s * 2 + 1];
          if (isNaN(c) || isNaN(f) || this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(c, f))
            return;
          var h = e.get("zlevel") || 0, d = e.get("z") || 0;
          u = new Wh(o, s), u.x = c, u.y = f, u.setZ(h, d);
          var p = u.getSymbolPath().getTextContent();
          p && (p.zlevel = h, p.z = d, p.z2 = this._polyline.z2 + 1), u.__temp = !0, o.setItemGraphicEl(s, u), u.stopSymbolAnimation(!0), this.group.add(u);
        }
        u.highlight();
      } else
        Re.prototype.highlight.call(this, e, n, i, a);
    }, t.prototype.downplay = function(e, n, i, a) {
      var o = e.getData(), s = dl(o, a);
      if (this._changePolyState("normal"), s != null && s >= 0) {
        var l = o.getItemGraphicEl(s);
        l && (l.__temp ? (o.setItemGraphicEl(s, null), this.group.remove(l)) : l.downplay());
      } else
        Re.prototype.downplay.call(this, e, n, i, a);
    }, t.prototype._changePolyState = function(e) {
      var n = this._polygon;
      Pv(this._polyline, e), n && Pv(n, e);
    }, t.prototype._newPolyline = function(e) {
      var n = this._polyline;
      return n && this._lineGroup.remove(n), n = new Bq({
        shape: {
          points: e
        },
        segmentIgnoreThreshold: 2,
        z2: 10
      }), this._lineGroup.add(n), this._polyline = n, n;
    }, t.prototype._newPolygon = function(e, n) {
      var i = this._polygon;
      return i && this._lineGroup.remove(i), i = new a3({
        shape: {
          points: e,
          stackedOnPoints: n
        },
        segmentIgnoreThreshold: 2
      }), this._lineGroup.add(i), this._polygon = i, i;
    }, t.prototype._initSymbolLabelAnimation = function(e, n, i) {
      var a, o, s = n.getBaseAxis(), l = s.inverse;
      n.type === "cartesian2d" ? (a = s.isHorizontal(), o = !1) : n.type === "polar" && (a = s.dim === "angle", o = !0);
      var u = e.hostModel, c = u.get("animationDuration");
      Tt(c) && (c = c(null));
      var f = u.get("animationDelay") || 0, h = Tt(f) ? f(null) : f;
      e.eachItemGraphicEl(function(d, p) {
        var g = d;
        if (g) {
          var v = [d.x, d.y], m = void 0, y = void 0, _ = void 0;
          if (i)
            if (o) {
              var x = i, b = n.pointToCoord(v);
              a ? (m = x.startAngle, y = x.endAngle, _ = -b[1] / 180 * Math.PI) : (m = x.r0, y = x.r, _ = b[0]);
            } else {
              var S = i;
              a ? (m = S.x, y = S.x + S.width, _ = d.x) : (m = S.y + S.height, y = S.y, _ = d.y);
            }
          var w = y === m ? 0 : (_ - m) / (y - m);
          l && (w = 1 - w);
          var A = Tt(f) ? f(p) : c * w + h, T = g.getSymbolPath(), M = T.getTextContent();
          g.attr({
            scaleX: 0,
            scaleY: 0
          }), g.animateTo({
            scaleX: 1,
            scaleY: 1
          }, {
            duration: 200,
            setToFinal: !0,
            delay: A
          }), M && M.animateFrom({
            style: {
              opacity: 0
            }
          }, {
            duration: 300,
            delay: A
          }), T.disableLabelAnimation = !0;
        }
      });
    }, t.prototype._initOrUpdateEndLabel = function(e, n, i) {
      var a = e.getModel("endLabel");
      if (l3(e)) {
        var o = e.getData(), s = this._polyline, l = o.getLayout("points");
        if (!l) {
          s.removeTextContent(), this._endLabel = null;
          return;
        }
        var u = this._endLabel;
        u || (u = this._endLabel = new pe({
          z2: 200
          // should be higher than item symbol
        }), u.ignoreClip = !0, s.setTextContent(this._endLabel), s.disableLabelAnimation = !0);
        var c = Xq(l);
        c >= 0 && (Er(s, _r(e, "endLabel"), {
          inheritColor: i,
          labelFetcher: e,
          labelDataIndex: c,
          defaultText: function(f, h, d) {
            return d != null ? e3(o, d) : uc(o, f);
          },
          enableTextSetter: !0
        }, $q(a, n)), s.textConfig.position = null);
      } else
        this._endLabel && (this._polyline.removeTextContent(), this._endLabel = null);
    }, t.prototype._endLabelOnDuring = function(e, n, i, a, o, s, l) {
      var u = this._endLabel, c = this._polyline;
      if (u) {
        e < 1 && a.originalX == null && (a.originalX = u.x, a.originalY = u.y);
        var f = i.getLayout("points"), h = i.hostModel, d = h.get("connectNulls"), p = s.get("precision"), g = s.get("distance") || 0, v = l.getBaseAxis(), m = v.isHorizontal(), y = v.inverse, _ = n.shape, x = y ? m ? _.x : _.y + _.height : m ? _.x + _.width : _.y, b = (m ? g : 0) * (y ? -1 : 1), S = (m ? 0 : -g) * (y ? -1 : 1), w = m ? "x" : "y", A = Yq(f, x, w), T = A.range, M = T[1] - T[0], E = void 0;
        if (M >= 1) {
          if (M > 1 && !d) {
            var R = OC(f, T[0]);
            u.attr({
              x: R[0] + b,
              y: R[1] + S
            }), o && (E = h.getRawValue(T[0]));
          } else {
            var R = c.getPointOn(x, w);
            R && u.attr({
              x: R[0] + b,
              y: R[1] + S
            });
            var C = h.getRawValue(T[0]), D = h.getRawValue(T[1]);
            o && (E = VP(i, p, C, D, A.t));
          }
          a.lastFrameIndex = T[0];
        } else {
          var I = e === 1 || a.lastFrameIndex > 0 ? T[0] : 0, R = OC(f, I);
          o && (E = h.getRawValue(I)), u.attr({
            x: R[0] + b,
            y: R[1] + S
          });
        }
        if (o) {
          var P = Tc(u);
          typeof P.setLabelText == "function" && P.setLabelText(E);
        }
      }
    }, t.prototype._doUpdateAnimation = function(e, n, i, a, o, s, l) {
      var u = this._polyline, c = this._polygon, f = e.hostModel, h = kq(this._data, e, this._stackedOnPoints, n, this._coordSys, i, this._valueOrigin), d = h.current, p = h.stackedOnCurrent, g = h.next, v = h.stackedOnNext;
      if (o && (p = po(h.stackedOnCurrent, h.current, i, o, l), d = po(h.current, null, i, o, l), v = po(h.stackedOnNext, h.next, i, o, l), g = po(h.next, null, i, o, l)), PC(d, g) > 3e3 || c && PC(p, v) > 3e3) {
        u.stopAnimation(), u.setShape({
          points: g
        }), c && (c.stopAnimation(), c.setShape({
          points: g,
          stackedOnPoints: v
        }));
        return;
      }
      u.shape.__points = h.current, u.shape.points = d;
      var m = {
        shape: {
          points: g
        }
      };
      h.current !== d && (m.shape.__points = h.next), u.stopAnimation(), ve(u, m, f), c && (c.setShape({
        // Reuse the points with polyline.
        points: d,
        stackedOnPoints: p
      }), c.stopAnimation(), ve(c, {
        shape: {
          stackedOnPoints: v
        }
      }, f), u.shape.points !== c.shape.points && (c.shape.points = u.shape.points));
      for (var y = [], _ = h.status, x = 0; x < _.length; x++) {
        var b = _[x].cmd;
        if (b === "=") {
          var S = e.getItemGraphicEl(_[x].idx1);
          S && y.push({
            el: S,
            ptIdx: x
            // Index of points
          });
        }
      }
      u.animators && u.animators.length && u.animators[0].during(function() {
        c && c.dirtyShape();
        for (var w = u.shape.__points, A = 0; A < y.length; A++) {
          var T = y[A].el, M = y[A].ptIdx * 2;
          T.x = w[M], T.y = w[M + 1], T.markRedraw();
        }
      });
    }, t.prototype.remove = function(e) {
      var n = this.group, i = this._data;
      this._lineGroup.removeAll(), this._symbolDraw.remove(!0), i && i.eachItemGraphicEl(function(a, o) {
        a.__temp && (n.remove(a), i.setItemGraphicEl(o, null));
      }), this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._endLabel = this._data = null;
    }, t.type = "line", t;
  }(Re)
);
function $h(r, t) {
  return {
    seriesType: r,
    plan: Cc(),
    reset: function(e) {
      var n = e.getData(), i = e.coordinateSystem, a = e.pipelineContext, o = t || a.large;
      if (i) {
        var s = rt(i.dimensions, function(d) {
          return n.mapDimension(d);
        }).slice(0, 2), l = s.length, u = n.getCalculationInfo("stackResultDimension");
        Ho(n, s[0]) && (s[0] = u), Ho(n, s[1]) && (s[1] = u);
        var c = n.getStore(), f = n.getDimensionIndex(s[0]), h = n.getDimensionIndex(s[1]);
        return l && {
          progress: function(d, p) {
            for (var g = d.end - d.start, v = o && Zi(g * l), m = [], y = [], _ = d.start, x = 0; _ < d.end; _++) {
              var b = void 0;
              if (l === 1) {
                var S = c.get(f, _);
                b = i.dataToPoint(S, null, y);
              } else
                m[0] = c.get(f, _), m[1] = c.get(h, _), b = i.dataToPoint(m, null, y);
              o ? (v[x++] = b[0], v[x++] = b[1]) : p.setItemLayout(_, b.slice());
            }
            o && p.setLayout("points", v);
          }
        };
      }
    }
  };
}
var qq = {
  average: function(r) {
    for (var t = 0, e = 0, n = 0; n < r.length; n++)
      isNaN(r[n]) || (t += r[n], e++);
    return e === 0 ? NaN : t / e;
  },
  sum: function(r) {
    for (var t = 0, e = 0; e < r.length; e++)
      t += r[e] || 0;
    return t;
  },
  max: function(r) {
    for (var t = -1 / 0, e = 0; e < r.length; e++)
      r[e] > t && (t = r[e]);
    return isFinite(t) ? t : NaN;
  },
  min: function(r) {
    for (var t = 1 / 0, e = 0; e < r.length; e++)
      r[e] < t && (t = r[e]);
    return isFinite(t) ? t : NaN;
  },
  // TODO
  // Median
  nearest: function(r) {
    return r[0];
  }
}, Kq = function(r) {
  return Math.round(r.length / 2);
};
function u3(r) {
  return {
    seriesType: r,
    // FIXME:TS never used, so comment it
    // modifyOutputEnd: true,
    reset: function(t, e, n) {
      var i = t.getData(), a = t.get("sampling"), o = t.coordinateSystem, s = i.count();
      if (s > 10 && o.type === "cartesian2d" && a) {
        var l = o.getBaseAxis(), u = o.getOtherAxis(l), c = l.getExtent(), f = n.getDevicePixelRatio(), h = Math.abs(c[1] - c[0]) * (f || 1), d = Math.round(s / h);
        if (isFinite(d) && d > 1) {
          a === "lttb" ? t.setData(i.lttbDownSample(i.mapDimension(u.dim), 1 / d)) : a === "minmax" && t.setData(i.minmaxDownSample(i.mapDimension(u.dim), 1 / d));
          var p = void 0;
          pt(a) ? p = qq[a] : Tt(a) && (p = a), p && t.setData(i.downSample(i.mapDimension(u.dim), 1 / d, p, Kq));
        }
      }
    }
  };
}
function jq(r) {
  r.registerChartView(Zq), r.registerSeriesModel(Iq), r.registerLayout($h("line", !0)), r.registerVisual({
    seriesType: "line",
    reset: function(t) {
      var e = t.getData(), n = t.getModel("lineStyle").getLineStyle();
      n && !n.stroke && (n.stroke = e.getVisual("style").fill), e.setVisual("legendLineStyle", n);
    }
  }), r.registerProcessor(r.PRIORITY.PROCESSOR.STATISTIC, u3("line"));
}
var yh = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.getInitialData = function(e, n) {
      return ja(null, this, {
        useEncodeDefaulter: !0
      });
    }, t.prototype.getMarkerPosition = function(e, n, i) {
      var a = this.coordinateSystem;
      if (a && a.clampData) {
        var o = a.clampData(e), s = a.dataToPoint(o);
        if (i)
          L(a.getAxes(), function(h, d) {
            if (h.type === "category" && n != null) {
              var p = h.getTicksCoords(), g = h.getTickModel().get("alignWithLabel"), v = o[d], m = n[d] === "x1" || n[d] === "y1";
              if (m && !g && (v += 1), p.length < 2)
                return;
              if (p.length === 2) {
                s[d] = h.toGlobalCoord(h.getExtent()[m ? 1 : 0]);
                return;
              }
              for (var y = void 0, _ = void 0, x = 1, b = 0; b < p.length; b++) {
                var S = p[b].coord, w = b === p.length - 1 ? p[b - 1].tickValue + x : p[b].tickValue;
                if (w === v) {
                  _ = S;
                  break;
                } else if (w < v)
                  y = S;
                else if (y != null && w > v) {
                  _ = (S + y) / 2;
                  break;
                }
                b === 1 && (x = w - p[0].tickValue);
              }
              _ == null && (y ? y && (_ = p[p.length - 1].coord) : _ = p[0].coord), s[d] = h.toGlobalCoord(_);
            }
          });
        else {
          var l = this.getData(), u = l.getLayout("offset"), c = l.getLayout("size"), f = a.getBaseAxis().isHorizontal() ? 0 : 1;
          s[f] += u + c / 2;
        }
        return s;
      }
      return [NaN, NaN];
    }, t.type = "series.__base_bar__", t.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      // stack: null
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      barMinHeight: 0,
      barMinAngle: 0,
      // cursor: null,
      large: !1,
      largeThreshold: 400,
      progressive: 3e3,
      progressiveChunkMode: "mod",
      defaultBarGap: "10%"
    }, t;
  }(ke)
);
ke.registerClass(yh);
var Jq = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.getInitialData = function() {
      return ja(null, this, {
        useEncodeDefaulter: !0,
        createInvertedIndices: !!this.get("realtimeSort", !0) || null
      });
    }, t.prototype.getProgressive = function() {
      return this.get("large") ? this.get("progressive") : !1;
    }, t.prototype.getProgressiveThreshold = function() {
      var e = this.get("progressiveThreshold"), n = this.get("largeThreshold");
      return n > e && (e = n), e;
    }, t.prototype.brushSelector = function(e, n, i) {
      return i.rect(n.getItemLayout(e));
    }, t.type = "series.bar", t.dependencies = ["grid", "polar"], t.defaultOption = jo(yh.defaultOption, {
      // If clipped
      // Only available on cartesian2d
      clip: !0,
      roundCap: !1,
      showBackground: !1,
      backgroundStyle: {
        color: "rgba(180, 180, 180, 0.2)",
        borderColor: null,
        borderWidth: 0,
        borderType: "solid",
        borderRadius: 0,
        shadowBlur: 0,
        shadowColor: null,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        opacity: 1
      },
      select: {
        itemStyle: {
          borderColor: Y.color.primary,
          borderWidth: 2
        }
      },
      realtimeSort: !1
    }), t;
  }(yh)
), Qq = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
      this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0;
    }
    return r;
  }()
), ig = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e) {
      var n = r.call(this, e) || this;
      return n.type = "sausage", n;
    }
    return t.prototype.getDefaultShape = function() {
      return new Qq();
    }, t.prototype.buildPath = function(e, n) {
      var i = n.cx, a = n.cy, o = Math.max(n.r0 || 0, 0), s = Math.max(n.r, 0), l = (s - o) * 0.5, u = o + l, c = n.startAngle, f = n.endAngle, h = n.clockwise, d = Math.PI * 2, p = h ? f - c < d : c - f < d;
      p || (c = f - (h ? d : -d));
      var g = Math.cos(c), v = Math.sin(c), m = Math.cos(f), y = Math.sin(f);
      p ? (e.moveTo(g * o + i, v * o + a), e.arc(g * u + i, v * u + a, l, -Math.PI + c, c, !h)) : e.moveTo(g * s + i, v * s + a), e.arc(i, a, s, c, f, !h), e.arc(m * u + i, y * u + a, l, f - Math.PI * 2, f - Math.PI, !h), o !== 0 && e.arc(i, a, o, f, c, h);
    }, t;
  }(ne)
);
function tK(r, t) {
  t = t || {};
  var e = t.isRoundCap;
  return function(n, i, a) {
    var o = i.position;
    if (!o || o instanceof Array)
      return Cv(n, i, a);
    var s = r(o), l = i.distance != null ? i.distance : 5, u = this.shape, c = u.cx, f = u.cy, h = u.r, d = u.r0, p = (h + d) / 2, g = u.startAngle, v = u.endAngle, m = (g + v) / 2, y = e ? Math.abs(h - d) / 2 : 0, _ = Math.cos, x = Math.sin, b = c + h * _(g), S = f + h * x(g), w = "left", A = "top";
    switch (s) {
      case "startArc":
        b = c + (d - l) * _(m), S = f + (d - l) * x(m), w = "center", A = "top";
        break;
      case "insideStartArc":
        b = c + (d + l) * _(m), S = f + (d + l) * x(m), w = "center", A = "bottom";
        break;
      case "startAngle":
        b = c + p * _(g) + up(g, l + y, !1), S = f + p * x(g) + cp(g, l + y, !1), w = "right", A = "middle";
        break;
      case "insideStartAngle":
        b = c + p * _(g) + up(g, -l + y, !1), S = f + p * x(g) + cp(g, -l + y, !1), w = "left", A = "middle";
        break;
      case "middle":
        b = c + p * _(m), S = f + p * x(m), w = "center", A = "middle";
        break;
      case "endArc":
        b = c + (h + l) * _(m), S = f + (h + l) * x(m), w = "center", A = "bottom";
        break;
      case "insideEndArc":
        b = c + (h - l) * _(m), S = f + (h - l) * x(m), w = "center", A = "top";
        break;
      case "endAngle":
        b = c + p * _(v) + up(v, l + y, !0), S = f + p * x(v) + cp(v, l + y, !0), w = "left", A = "middle";
        break;
      case "insideEndAngle":
        b = c + p * _(v) + up(v, -l + y, !0), S = f + p * x(v) + cp(v, -l + y, !0), w = "right", A = "middle";
        break;
      default:
        return Cv(n, i, a);
    }
    return n = n || {}, n.x = b, n.y = S, n.align = w, n.verticalAlign = A, n;
  };
}
function eK(r, t, e, n) {
  if (fe(n)) {
    r.setTextConfig({
      rotation: n
    });
    return;
  } else if (et(t)) {
    r.setTextConfig({
      rotation: 0
    });
    return;
  }
  var i = r.shape, a = i.clockwise ? i.startAngle : i.endAngle, o = i.clockwise ? i.endAngle : i.startAngle, s = (a + o) / 2, l, u = e(t);
  switch (u) {
    case "startArc":
    case "insideStartArc":
    case "middle":
    case "insideEndArc":
    case "endArc":
      l = s;
      break;
    case "startAngle":
    case "insideStartAngle":
      l = a;
      break;
    case "endAngle":
    case "insideEndAngle":
      l = o;
      break;
    default:
      r.setTextConfig({
        rotation: 0
      });
      return;
  }
  var c = Math.PI * 1.5 - l;
  u === "middle" && c > Math.PI / 2 && c < Math.PI * 1.5 && (c -= Math.PI), r.setTextConfig({
    rotation: c
  });
}
function up(r, t, e) {
  return t * Math.sin(r) * (e ? -1 : 1);
}
function cp(r, t, e) {
  return t * Math.cos(r) * (e ? 1 : -1);
}
function Ki(r, t, e) {
  var n = r.get("borderRadius");
  if (n == null)
    return e ? {
      cornerRadius: 0
    } : null;
  et(n) || (n = [n, n, n, n]);
  var i = Math.abs(t.r || 0 - t.r0 || 0);
  return {
    cornerRadius: rt(n, function(a) {
      return bi(a, i);
    })
  };
}
var D0 = Math.max, L0 = Math.min;
function rK(r, t) {
  var e = r.getArea && r.getArea();
  if (Wo(r, "cartesian2d")) {
    var n = r.getBaseAxis();
    if (n.type !== "category" || !n.onBand) {
      var i = t.getLayout("bandWidth");
      n.isHorizontal() ? (e.x -= i, e.width += i * 2) : (e.y -= i, e.height += i * 2);
    }
  }
  return e;
}
var nK = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r.call(this) || this;
      return e.type = t.type, e._isFirstFrame = !0, e;
    }
    return t.prototype.render = function(e, n, i, a) {
      this._model = e, this._removeOnRenderedListener(i), this._updateDrawMode(e);
      var o = e.get("coordinateSystem");
      o === "cartesian2d" || o === "polar" ? (this._progressiveEls = null, this._isLargeDraw ? this._renderLarge(e, n, i) : this._renderNormal(e, n, i, a)) : process.env.NODE_ENV !== "production" && Xe("Only cartesian2d and polar supported for bar.");
    }, t.prototype.incrementalPrepareRender = function(e) {
      this._clear(), this._updateDrawMode(e), this._updateLargeClip(e);
    }, t.prototype.incrementalRender = function(e, n) {
      this._progressiveEls = [], this._incrementalRenderLarge(e, n);
    }, t.prototype.eachRendered = function(e) {
      Ko(this._progressiveEls || this.group, e);
    }, t.prototype._updateDrawMode = function(e) {
      var n = e.pipelineContext.large;
      (this._isLargeDraw == null || n !== this._isLargeDraw) && (this._isLargeDraw = n, this._clear());
    }, t.prototype._renderNormal = function(e, n, i, a) {
      var o = this.group, s = e.getData(), l = this._data, u = e.coordinateSystem, c = u.getBaseAxis(), f;
      u.type === "cartesian2d" ? f = c.isHorizontal() : u.type === "polar" && (f = c.dim === "angle");
      var h = e.isAnimationEnabled() ? e : null, d = iK(e, u);
      d && this._enableRealtimeSort(d, s, i);
      var p = e.get("clip", !0) || d, g = rK(u, s);
      o.removeClipPath();
      var v = e.get("roundCap", !0), m = e.get("showBackground", !0), y = e.getModel("backgroundStyle"), _ = y.get("borderRadius") || 0, x = [], b = this._backgroundEls, S = a && a.isInitSort, w = a && a.type === "changeAxisOrder";
      function A(E) {
        var R = fp[u.type](s, E);
        if (!R)
          return null;
        var C = fK(u, f, R);
        return C.useStyle(y.getItemStyle()), u.type === "cartesian2d" ? C.setShape("r", _) : C.setShape("cornerRadius", _), x[E] = C, C;
      }
      s.diff(l).add(function(E) {
        var R = s.getItemModel(E), C = fp[u.type](s, E, R);
        if (C && (m && A(E), !(!s.hasValue(E) || !zC[u.type](C)))) {
          var D = !1;
          p && (D = kC[u.type](g, C));
          var I = BC[u.type](e, s, E, C, f, h, c.model, !1, v);
          d && (I.forceLabelAnimation = !0), UC(I, s, E, R, C, e, f, u.type === "polar"), S ? I.attr({
            shape: C
          }) : d ? VC(d, h, I, C, E, f, !1, !1) : ze(I, {
            shape: C
          }, e, E), s.setItemGraphicEl(E, I), o.add(I), I.ignore = D;
        }
      }).update(function(E, R) {
        var C = s.getItemModel(E), D = fp[u.type](s, E, C);
        if (D) {
          if (m) {
            var I = void 0;
            b.length === 0 ? I = A(R) : (I = b[R], I.useStyle(y.getItemStyle()), u.type === "cartesian2d" ? I.setShape("r", _) : I.setShape("cornerRadius", _), x[E] = I);
            var P = fp[u.type](s, E), O = f3(f, P, u);
            ve(I, {
              shape: O
            }, h, E);
          }
          var N = l.getItemGraphicEl(R);
          if (!s.hasValue(E) || !zC[u.type](D)) {
            o.remove(N);
            return;
          }
          var B = !1;
          p && (B = kC[u.type](g, D), B && o.remove(N));
          var F = N && (N.type === "sector" && v || N.type === "sausage" && !v);
          if (F && (N && Pa(N, e, R), N = null), N ? ai(N) : N = BC[u.type](e, s, E, D, f, h, c.model, !0, v), d && (N.forceLabelAnimation = !0), w) {
            var G = N.getTextContent();
            if (G) {
              var X = Tc(G);
              X.prevValue != null && (X.prevValue = X.value);
            }
          } else
            UC(N, s, E, C, D, e, f, u.type === "polar");
          S ? N.attr({
            shape: D
          }) : d ? VC(d, h, N, D, E, f, !0, w) : ve(N, {
            shape: D
          }, e, E, null), s.setItemGraphicEl(E, N), N.ignore = B, o.add(N);
        }
      }).remove(function(E) {
        var R = l.getItemGraphicEl(E);
        R && Pa(R, e, E);
      }).execute();
      var T = this._backgroundGroup || (this._backgroundGroup = new Et());
      T.removeAll();
      for (var M = 0; M < x.length; ++M)
        T.add(x[M]);
      o.add(T), this._backgroundEls = x, this._data = s;
    }, t.prototype._renderLarge = function(e, n, i) {
      this._clear(), HC(e, this.group), this._updateLargeClip(e);
    }, t.prototype._incrementalRenderLarge = function(e, n) {
      this._removeBackground(), HC(n, this.group, this._progressiveEls, !0);
    }, t.prototype._updateLargeClip = function(e) {
      var n = e.get("clip", !0) && Yh(e.coordinateSystem, !1, e), i = this.group;
      n ? i.setClipPath(n) : i.removeClipPath();
    }, t.prototype._enableRealtimeSort = function(e, n, i) {
      var a = this;
      if (n.count()) {
        var o = e.baseAxis;
        if (this._isFirstFrame)
          this._dispatchInitSort(n, e, i), this._isFirstFrame = !1;
        else {
          var s = function(l) {
            var u = n.getItemGraphicEl(l), c = u && u.shape;
            return c && // The result should be consistent with the initial sort by data value.
            // Do not support the case that both positive and negative exist.
            Math.abs(o.isHorizontal() ? c.height : c.width) || 0;
          };
          this._onRendered = function() {
            a._updateSortWithinSameData(n, s, o, i);
          }, i.getZr().on("rendered", this._onRendered);
        }
      }
    }, t.prototype._dataSort = function(e, n, i) {
      var a = [];
      return e.each(e.mapDimension(n.dim), function(o, s) {
        var l = i(s);
        l = l ?? NaN, a.push({
          dataIndex: s,
          mappedValue: l,
          ordinalNumber: o
        });
      }), a.sort(function(o, s) {
        return s.mappedValue - o.mappedValue;
      }), {
        ordinalNumbers: rt(a, function(o) {
          return o.ordinalNumber;
        })
      };
    }, t.prototype._isOrderChangedWithinSameData = function(e, n, i) {
      for (var a = i.scale, o = e.mapDimension(i.dim), s = Number.MAX_VALUE, l = 0, u = a.getOrdinalMeta().categories.length; l < u; ++l) {
        var c = e.rawIndexOf(o, a.getRawOrdinalNumber(l)), f = c < 0 ? Number.MIN_VALUE : n(e.indexOfRawIndex(c));
        if (f > s)
          return !0;
        s = f;
      }
      return !1;
    }, t.prototype._isOrderDifferentInView = function(e, n) {
      for (var i = n.scale, a = i.getExtent(), o = Math.max(0, a[0]), s = Math.min(a[1], i.getOrdinalMeta().categories.length - 1); o <= s; ++o)
        if (e.ordinalNumbers[o] !== i.getRawOrdinalNumber(o))
          return !0;
    }, t.prototype._updateSortWithinSameData = function(e, n, i, a) {
      if (this._isOrderChangedWithinSameData(e, n, i)) {
        var o = this._dataSort(e, i, n);
        this._isOrderDifferentInView(o, i) && (this._removeOnRenderedListener(a), a.dispatchAction({
          type: "changeAxisOrder",
          componentType: i.dim + "Axis",
          axisId: i.index,
          sortInfo: o
        }));
      }
    }, t.prototype._dispatchInitSort = function(e, n, i) {
      var a = n.baseAxis, o = this._dataSort(e, a, function(s) {
        return e.get(e.mapDimension(n.otherAxis.dim), s);
      });
      i.dispatchAction({
        type: "changeAxisOrder",
        componentType: a.dim + "Axis",
        isInitSort: !0,
        axisId: a.index,
        sortInfo: o
      });
    }, t.prototype.remove = function(e, n) {
      this._clear(this._model), this._removeOnRenderedListener(n);
    }, t.prototype.dispose = function(e, n) {
      this._removeOnRenderedListener(n);
    }, t.prototype._removeOnRenderedListener = function(e) {
      this._onRendered && (e.getZr().off("rendered", this._onRendered), this._onRendered = null);
    }, t.prototype._clear = function(e) {
      var n = this.group, i = this._data;
      e && e.isAnimationEnabled() && i && !this._isLargeDraw ? (this._removeBackground(), this._backgroundEls = [], i.eachItemGraphicEl(function(a) {
        Pa(a, e, zt(a).dataIndex);
      })) : n.removeAll(), this._data = null, this._isFirstFrame = !0;
    }, t.prototype._removeBackground = function() {
      this.group.remove(this._backgroundGroup), this._backgroundGroup = null;
    }, t.type = "bar", t;
  }(Re)
), kC = {
  cartesian2d: function(r, t) {
    var e = t.width < 0 ? -1 : 1, n = t.height < 0 ? -1 : 1;
    e < 0 && (t.x += t.width, t.width = -t.width), n < 0 && (t.y += t.height, t.height = -t.height);
    var i = r.x + r.width, a = r.y + r.height, o = D0(t.x, r.x), s = L0(t.x + t.width, i), l = D0(t.y, r.y), u = L0(t.y + t.height, a), c = s < o, f = u < l;
    return t.x = c && o > i ? s : o, t.y = f && l > a ? u : l, t.width = c ? 0 : s - o, t.height = f ? 0 : u - l, e < 0 && (t.x += t.width, t.width = -t.width), n < 0 && (t.y += t.height, t.height = -t.height), c || f;
  },
  polar: function(r, t) {
    var e = t.r0 <= t.r ? 1 : -1;
    if (e < 0) {
      var n = t.r;
      t.r = t.r0, t.r0 = n;
    }
    var i = L0(t.r, r.r), a = D0(t.r0, r.r0);
    t.r = i, t.r0 = a;
    var o = i - a < 0;
    if (e < 0) {
      var n = t.r;
      t.r = t.r0, t.r0 = n;
    }
    return o;
  }
}, BC = {
  cartesian2d: function(r, t, e, n, i, a, o, s, l) {
    var u = new te({
      shape: J({}, n),
      z2: 1
    });
    if (u.__dataIndex = e, u.name = "item", a) {
      var c = u.shape, f = i ? "height" : "width";
      c[f] = 0;
    }
    return u;
  },
  polar: function(r, t, e, n, i, a, o, s, l) {
    var u = !i && l ? ig : Kr, c = new u({
      shape: n,
      z2: 1
    });
    c.name = "item";
    var f = c3(i);
    if (c.calculateTextPosition = tK(f, {
      isRoundCap: u === ig
    }), a) {
      var h = c.shape, d = i ? "r" : "endAngle", p = {};
      h[d] = i ? n.r0 : n.startAngle, p[d] = n[d], (s ? ve : ze)(c, {
        shape: p
        // __value: typeof dataValue === 'string' ? parseInt(dataValue, 10) : dataValue
      }, a);
    }
    return c;
  }
};
function iK(r, t) {
  var e = r.get("realtimeSort", !0), n = t.getBaseAxis();
  if (process.env.NODE_ENV !== "production" && e && (n.type !== "category" && Xe("`realtimeSort` will not work because this bar series is not based on a category axis."), t.type !== "cartesian2d" && Xe("`realtimeSort` will not work because this bar series is not on cartesian2d.")), e && n.type === "category" && t.type === "cartesian2d")
    return {
      baseAxis: n,
      otherAxis: t.getOtherAxis(n)
    };
}
function VC(r, t, e, n, i, a, o, s) {
  var l, u;
  a ? (u = {
    x: n.x,
    width: n.width
  }, l = {
    y: n.y,
    height: n.height
  }) : (u = {
    y: n.y,
    height: n.height
  }, l = {
    x: n.x,
    width: n.width
  }), s || (o ? ve : ze)(e, {
    shape: l
  }, t, i, null);
  var c = t ? r.baseAxis.model : null;
  (o ? ve : ze)(e, {
    shape: u
  }, c, i);
}
function FC(r, t) {
  for (var e = 0; e < t.length; e++)
    if (!isFinite(r[t[e]]))
      return !0;
  return !1;
}
var aK = ["x", "y", "width", "height"], oK = ["cx", "cy", "r", "startAngle", "endAngle"], zC = {
  cartesian2d: function(r) {
    return !FC(r, aK);
  },
  polar: function(r) {
    return !FC(r, oK);
  }
}, fp = {
  // itemModel is only used to get borderWidth, which is not needed
  // when calculating bar background layout.
  cartesian2d: function(r, t, e) {
    var n = r.getItemLayout(t);
    if (!n)
      return null;
    var i = e ? lK(e, n) : 0, a = n.width > 0 ? 1 : -1, o = n.height > 0 ? 1 : -1;
    return {
      x: n.x + a * i / 2,
      y: n.y + o * i / 2,
      width: n.width - a * i,
      height: n.height - o * i
    };
  },
  polar: function(r, t, e) {
    var n = r.getItemLayout(t);
    return {
      cx: n.cx,
      cy: n.cy,
      r0: n.r0,
      r: n.r,
      startAngle: n.startAngle,
      endAngle: n.endAngle,
      clockwise: n.clockwise
    };
  }
};
function sK(r) {
  return r.startAngle != null && r.endAngle != null && r.startAngle === r.endAngle;
}
function c3(r) {
  return /* @__PURE__ */ function(t) {
    var e = t ? "Arc" : "Angle";
    return function(n) {
      switch (n) {
        case "start":
        case "insideStart":
        case "end":
        case "insideEnd":
          return n + e;
        default:
          return n;
      }
    };
  }(r);
}
function UC(r, t, e, n, i, a, o, s) {
  var l = t.getItemVisual(e, "style");
  if (s) {
    if (!a.get("roundCap")) {
      var c = r.shape, f = Ki(n.getModel("itemStyle"), c, !0);
      J(c, f), r.setShape(c);
    }
  } else {
    var u = n.get(["itemStyle", "borderRadius"]) || 0;
    r.setShape("r", u);
  }
  r.useStyle(l);
  var h = n.getShallow("cursor");
  h && r.attr("cursor", h);
  var d = s ? o ? i.r >= i.r0 ? "endArc" : "startArc" : i.endAngle >= i.startAngle ? "endAngle" : "startAngle" : o ? i.height >= 0 ? "bottom" : "top" : i.width >= 0 ? "right" : "left", p = _r(n);
  Er(r, p, {
    labelFetcher: a,
    labelDataIndex: e,
    defaultText: uc(a.getData(), e),
    inheritColor: l.fill,
    defaultOpacity: l.opacity,
    defaultOutsidePosition: d
  });
  var g = r.getTextContent();
  if (s && g) {
    var v = n.get(["label", "position"]);
    r.textConfig.inside = v === "middle" ? !0 : null, eK(r, v === "outside" ? d : v, c3(o), n.get(["label", "rotate"]));
  }
  MN(g, p, a.getRawValue(e), function(y) {
    return e3(t, y);
  });
  var m = n.getModel(["emphasis"]);
  Ge(r, m.get("focus"), m.get("blurScope"), m.get("disabled")), yr(r, n), sK(i) && (r.style.fill = "none", r.style.stroke = "none", L(r.states, function(y) {
    y.style && (y.style.fill = y.style.stroke = "none");
  }));
}
function lK(r, t) {
  var e = r.get(["itemStyle", "borderColor"]);
  if (!e || e === "none")
    return 0;
  var n = r.get(["itemStyle", "borderWidth"]) || 0, i = isNaN(t.width) ? Number.MAX_VALUE : Math.abs(t.width), a = isNaN(t.height) ? Number.MAX_VALUE : Math.abs(t.height);
  return Math.min(n, i, a);
}
var uK = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
    }
    return r;
  }()
), GC = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e) {
      var n = r.call(this, e) || this;
      return n.type = "largeBar", n;
    }
    return t.prototype.getDefaultShape = function() {
      return new uK();
    }, t.prototype.buildPath = function(e, n) {
      for (var i = n.points, a = this.baseDimIdx, o = 1 - this.baseDimIdx, s = [], l = [], u = this.barWidth, c = 0; c < i.length; c += 3)
        l[a] = u, l[o] = i[c + 2], s[a] = i[c + a], s[o] = i[c + o], e.rect(s[0], s[1], l[0], l[1]);
    }, t;
  }(ne)
);
function HC(r, t, e, n) {
  var i = r.getData(), a = i.getLayout("valueAxisHorizontal") ? 1 : 0, o = i.getLayout("largeDataIndices"), s = i.getLayout("size"), l = r.getModel("backgroundStyle"), u = i.getLayout("largeBackgroundPoints");
  if (u) {
    var c = new GC({
      shape: {
        points: u
      },
      incremental: !!n,
      silent: !0,
      z2: 0
    });
    c.baseDimIdx = a, c.largeDataIndices = o, c.barWidth = s, c.useStyle(l.getItemStyle()), t.add(c), e && e.push(c);
  }
  var f = new GC({
    shape: {
      points: i.getLayout("largePoints")
    },
    incremental: !!n,
    ignoreCoarsePointer: !0,
    z2: 1
  });
  f.baseDimIdx = a, f.largeDataIndices = o, f.barWidth = s, t.add(f), f.useStyle(i.getVisual("style")), f.style.stroke = null, zt(f).seriesIndex = r.seriesIndex, r.get("silent") || (f.on("mousedown", WC), f.on("mousemove", WC)), e && e.push(f);
}
var WC = ub(function(r) {
  var t = this, e = cK(t, r.offsetX, r.offsetY);
  zt(t).dataIndex = e >= 0 ? e : null;
}, 30, !1);
function cK(r, t, e) {
  for (var n = r.baseDimIdx, i = 1 - n, a = r.shape.points, o = r.largeDataIndices, s = [], l = [], u = r.barWidth, c = 0, f = a.length / 3; c < f; c++) {
    var h = c * 3;
    if (l[n] = u, l[i] = a[h + 2], s[n] = a[h + n], s[i] = a[h + i], l[i] < 0 && (s[i] += l[i], l[i] = -l[i]), t >= s[0] && t <= s[0] + l[0] && e >= s[1] && e <= s[1] + l[1])
      return o[c];
  }
  return -1;
}
function f3(r, t, e) {
  if (Wo(e, "cartesian2d")) {
    var n = t, i = e.getArea();
    return {
      x: r ? n.x : i.x,
      y: r ? i.y : n.y,
      width: r ? n.width : i.width,
      height: r ? i.height : n.height
    };
  } else {
    var i = e.getArea(), a = t;
    return {
      cx: i.cx,
      cy: i.cy,
      r0: r ? i.r0 : a.r0,
      r: r ? i.r : a.r,
      startAngle: r ? a.startAngle : 0,
      endAngle: r ? a.endAngle : Math.PI * 2
    };
  }
}
function fK(r, t, e) {
  var n = r.type === "polar" ? Kr : te;
  return new n({
    shape: f3(t, e, r),
    silent: !0,
    z2: 0
  });
}
function hK(r) {
  r.registerChartView(nK), r.registerSeriesModel(Jq), r.registerLayout(r.PRIORITY.VISUAL.LAYOUT, Yt(pk, "bar")), r.registerLayout(r.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, vk("bar")), r.registerProcessor(r.PRIORITY.PROCESSOR.STATISTIC, u3("bar")), r.registerAction({
    type: "changeAxisOrder",
    event: "changeAxisOrder",
    update: "update"
  }, function(t, e) {
    var n = t.componentType || "series";
    e.eachComponent({
      mainType: n,
      query: t
    }, function(i) {
      t.sortInfo && i.axis.setCategorySortInfo(t.sortInfo);
    });
  });
}
var XC = Math.PI * 2, hp = Math.PI / 180;
function dK(r, t, e) {
  t.eachSeriesByType(r, function(n) {
    var i = n.getData(), a = i.mapDimension("value"), o = WN(n, e), s = o.cx, l = o.cy, u = o.r, c = o.r0, f = o.viewRect, h = -n.get("startAngle") * hp, d = n.get("endAngle"), p = n.get("padAngle") * hp;
    d = d === "auto" ? h - XC : -d * hp;
    var g = n.get("minAngle") * hp, v = g + p, m = 0;
    i.each(a, function(O) {
      !isNaN(O) && m++;
    });
    var y = i.getSum(a), _ = Math.PI / (y || m) * 2, x = n.get("clockwise"), b = n.get("roseType"), S = n.get("stillShowZeroSum"), w = i.getDataExtent(a);
    w[0] = 0;
    var A = x ? 1 : -1, T = [h, d], M = A * p / 2;
    Jg(T, !x), h = T[0], d = T[1];
    var E = h3(n);
    E.startAngle = h, E.endAngle = d, E.clockwise = x, E.cx = s, E.cy = l, E.r = u, E.r0 = c;
    var R = Math.abs(d - h), C = R, D = 0, I = h;
    if (i.setLayout({
      viewRect: f,
      r: u
    }), i.each(a, function(O, N) {
      var B;
      if (isNaN(O)) {
        i.setItemLayout(N, {
          angle: NaN,
          startAngle: NaN,
          endAngle: NaN,
          clockwise: x,
          cx: s,
          cy: l,
          r0: c,
          r: b ? NaN : u
        });
        return;
      }
      b !== "area" ? B = y === 0 && S ? _ : O * _ : B = R / m, B < v ? (B = v, C -= v) : D += O;
      var F = I + A * B, G = 0, X = 0;
      p > B ? (G = I + A * B / 2, X = G) : (G = I + M, X = F - M), i.setItemLayout(N, {
        angle: B,
        startAngle: G,
        endAngle: X,
        clockwise: x,
        cx: s,
        cy: l,
        r0: c,
        r: b ? Me(O, w, [c, u]) : u
      }), I = F;
    }), C < XC && m)
      if (C <= 1e-3) {
        var P = R / m;
        i.each(a, function(O, N) {
          if (!isNaN(O)) {
            var B = i.getItemLayout(N);
            B.angle = P;
            var F = 0, G = 0;
            P < p ? (F = h + A * (N + 1 / 2) * P, G = F) : (F = h + A * N * P + M, G = h + A * (N + 1) * P - M), B.startAngle = F, B.endAngle = G;
          }
        });
      } else
        _ = C / D, I = h, i.each(a, function(O, N) {
          if (!isNaN(O)) {
            var B = i.getItemLayout(N), F = B.angle === v ? v : O * _, G = 0, X = 0;
            F < p ? (G = I + A * F / 2, X = G) : (G = I + M, X = I + A * F - M), B.startAngle = G, B.endAngle = X, I += A * F;
          }
        });
  });
}
var h3 = ee();
function Ic(r) {
  return {
    seriesType: r,
    reset: function(t, e) {
      var n = e.findComponents({
        mainType: "legend"
      });
      if (!(!n || !n.length)) {
        var i = t.getData();
        i.filterSelf(function(a) {
          for (var o = i.getName(a), s = 0; s < n.length; s++)
            if (!n[s].isSelected(o))
              return !1;
          return !0;
        });
      }
    }
  };
}
var pK = Math.PI / 180;
function YC(r, t, e, n, i, a, o, s, l, u) {
  if (r.length < 2)
    return;
  function c(g) {
    for (var v = g.rB, m = v * v, y = 0; y < g.list.length; y++) {
      var _ = g.list[y], x = Math.abs(_.label.y - e), b = n + _.len, S = b * b, w = Math.sqrt(Math.abs((1 - x * x / m) * S)), A = t + (w + _.len2) * i, T = A - _.label.x, M = _.targetTextWidth - T * i;
      d3(_, M, !0), _.label.x = A;
    }
  }
  function f(g) {
    for (var v = {
      list: [],
      maxY: 0
    }, m = {
      list: [],
      maxY: 0
    }, y = 0; y < g.length; y++)
      if (g[y].labelAlignTo === "none") {
        var _ = g[y], x = _.label.y > e ? m : v, b = Math.abs(_.label.y - e);
        if (b >= x.maxY) {
          var S = _.label.x - t - _.len2 * i, w = n + _.len, A = Math.abs(S) < w ? Math.sqrt(b * b / (1 - S * S / w / w)) : w;
          x.rB = A, x.maxY = b;
        }
        x.list.push(_);
      }
    c(v), c(m);
  }
  for (var h = r.length, d = 0; d < h; d++)
    if (r[d].position === "outer" && r[d].labelAlignTo === "labelLine") {
      var p = r[d].label.x - u;
      r[d].linePoints[1][0] += p, r[d].label.x = u;
    }
  cS(r, 1, l, l + o) && f(r);
}
function vK(r, t, e, n, i, a, o, s) {
  for (var l = [], u = [], c = Number.MAX_VALUE, f = -Number.MAX_VALUE, h = 0; h < r.length; h++) {
    var d = r[h].label;
    R0(r[h]) || (d.x < t ? (c = Math.min(c, d.x), l.push(r[h])) : (f = Math.max(f, d.x), u.push(r[h])));
  }
  for (var h = 0; h < r.length; h++) {
    var p = r[h];
    if (!R0(p) && p.linePoints) {
      if (p.labelStyleWidth != null)
        continue;
      var d = p.label, g = p.linePoints, v = void 0;
      p.labelAlignTo === "edge" ? d.x < t ? v = g[2][0] - p.labelDistance - o - p.edgeDistance : v = o + i - p.edgeDistance - g[2][0] - p.labelDistance : p.labelAlignTo === "labelLine" ? d.x < t ? v = c - o - p.bleedMargin : v = o + i - f - p.bleedMargin : d.x < t ? v = d.x - o - p.bleedMargin : v = o + i - d.x - p.bleedMargin, p.targetTextWidth = v, d3(p, v, !1);
    }
  }
  YC(u, t, e, n, 1, i, a, o, s, f), YC(l, t, e, n, -1, i, a, o, s, c);
  for (var h = 0; h < r.length; h++) {
    var p = r[h];
    if (!R0(p) && p.linePoints) {
      var d = p.label, g = p.linePoints, m = p.labelAlignTo === "edge", y = d.style.padding, _ = y ? y[1] + y[3] : 0, x = d.style.backgroundColor ? 0 : _, b = p.rect.width + x, S = g[1][0] - g[2][0];
      m ? d.x < t ? g[2][0] = o + p.edgeDistance + b + p.labelDistance : g[2][0] = o + i - p.edgeDistance - b - p.labelDistance : (d.x < t ? g[2][0] = d.x + p.labelDistance : g[2][0] = d.x - p.labelDistance, g[1][0] = g[2][0] + S), g[1][1] = g[2][1] = d.y;
    }
  }
}
function d3(r, t, e) {
  if (r.labelStyleWidth == null) {
    var n = r.label, i = n.style, a = r.rect, o = i.backgroundColor, s = i.padding, l = s ? s[1] + s[3] : 0, u = i.overflow, c = a.width + (o ? 0 : l);
    if (t < c || e) {
      if (u && u.match("break")) {
        n.setStyle("backgroundColor", null), n.setStyle("width", t - l);
        var f = n.getBoundingRect();
        n.setStyle("width", Math.ceil(f.width)), n.setStyle("backgroundColor", o);
      } else {
        var h = t - l, d = t < c ? h : (
          // Current available width is enough, but the text may have
          // already been wrapped with a smaller available width.
          e ? h > r.unconstrainedWidth ? null : h : null
        );
        n.setStyle("width", d);
      }
      p3(a, n);
    }
  }
}
function p3(r, t) {
  $C.rect = r, Vk($C, t, gK);
}
var gK = {
  minMarginForce: [null, 0, null, 0],
  marginDefault: [1, 0, 1, 0]
}, $C = {};
function R0(r) {
  return r.position === "center";
}
function mK(r) {
  var t = r.getData(), e = [], n, i, a = !1, o = (r.get("minShowLabelAngle") || 0) * pK, s = t.getLayout("viewRect"), l = t.getLayout("r"), u = s.width, c = s.x, f = s.y, h = s.height;
  function d(S) {
    S.ignore = !0;
  }
  function p(S) {
    if (!S.ignore)
      return !0;
    for (var w in S.states)
      if (S.states[w].ignore === !1)
        return !0;
    return !1;
  }
  t.each(function(S) {
    var w = t.getItemGraphicEl(S), A = w.shape, T = w.getTextContent(), M = w.getTextGuideLine(), E = t.getItemModel(S), R = E.getModel("label"), C = R.get("position") || E.get(["emphasis", "label", "position"]), D = R.get("distanceToLabelLine"), I = R.get("alignTo"), P = dt(R.get("edgeDistance"), u), O = R.get("bleedMargin");
    O == null && (O = Math.min(u, h) > 200 ? 10 : 2);
    var N = E.getModel("labelLine"), B = N.get("length");
    B = dt(B, u);
    var F = N.get("length2");
    if (F = dt(F, u), Math.abs(A.endAngle - A.startAngle) < o) {
      L(T.states, d), T.ignore = !0, M && (L(M.states, d), M.ignore = !0);
      return;
    }
    if (p(T)) {
      var G = (A.startAngle + A.endAngle) / 2, X = Math.cos(G), K = Math.sin(G), U, $, ct, at;
      n = A.cx, i = A.cy;
      var lt = C === "inside" || C === "inner";
      if (C === "center")
        U = A.cx, $ = A.cy, at = "center";
      else {
        var ot = (lt ? (A.r + A.r0) / 2 * X : A.r * X) + n, H = (lt ? (A.r + A.r0) / 2 * K : A.r * K) + i;
        if (U = ot + X * 3, $ = H + K * 3, !lt) {
          var st = ot + X * (B + l - A.r), ut = H + K * (B + l - A.r), Gt = st + (X < 0 ? -1 : 1) * F, gt = ut;
          I === "edge" ? U = X < 0 ? c + P : c + u - P : U = Gt + (X < 0 ? -D : D), $ = gt, ct = [[ot, H], [st, ut], [Gt, gt]];
        }
        at = lt ? "center" : I === "edge" ? X > 0 ? "right" : "left" : X > 0 ? "left" : "right";
      }
      var Lt = Math.PI, Vt = 0, Kt = R.get("rotate");
      if (fe(Kt))
        Vt = Kt * (Lt / 180);
      else if (C === "center")
        Vt = 0;
      else if (Kt === "radial" || Kt === !0) {
        var Ae = X < 0 ? -G + Lt : -G;
        Vt = Ae;
      } else if (Kt === "tangential" && C !== "outside" && C !== "outer") {
        var z = Math.atan2(X, K);
        z < 0 && (z = Lt * 2 + z);
        var k = K > 0;
        k && (z = Lt + z), Vt = z - Lt;
      }
      if (a = !!Vt, T.x = U, T.y = $, T.rotation = Vt, T.setStyle({
        verticalAlign: "middle"
      }), lt) {
        T.setStyle({
          align: at
        });
        var ht = T.states.select;
        ht && (ht.x += T.x, ht.y += T.y);
      } else {
        var nt = new Bt(0, 0, 0, 0);
        p3(nt, T), e.push({
          label: T,
          labelLine: M,
          position: C,
          len: B,
          len2: F,
          minTurnAngle: N.get("minTurnAngle"),
          maxSurfaceAngle: N.get("maxSurfaceAngle"),
          surfaceNormal: new Nt(X, K),
          linePoints: ct,
          textAlign: at,
          labelDistance: D,
          labelAlignTo: I,
          edgeDistance: P,
          bleedMargin: O,
          rect: nt,
          unconstrainedWidth: nt.width,
          labelStyleWidth: T.style.width
        });
      }
      w.setTextConfig({
        inside: lt
      });
    }
  }), !a && r.get("avoidLabelOverlap") && vK(e, n, i, l, u, h, c, f);
  for (var g = 0; g < e.length; g++) {
    var v = e[g], m = v.label, y = v.labelLine, _ = isNaN(m.x) || isNaN(m.y);
    if (m) {
      m.setStyle({
        align: v.textAlign
      }), _ && (L(m.states, d), m.ignore = !0);
      var x = m.states.select;
      x && (x.x += m.x, x.y += m.y);
    }
    if (y) {
      var b = v.linePoints;
      _ || !b ? (L(y.states, d), y.ignore = !0) : (Ok(b, v.minTurnAngle), BZ(b, v.surfaceNormal, v.maxSurfaceAngle), y.setShape({
        points: b
      }), m.__hostTarget.textGuideLineConfig = {
        anchor: new Nt(b[0][0], b[0][1])
      });
    }
  }
}
var yK = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e, n, i) {
      var a = r.call(this) || this;
      a.z2 = 2;
      var o = new pe();
      return a.setTextContent(o), a.updateData(e, n, i, !0), a;
    }
    return t.prototype.updateData = function(e, n, i, a) {
      var o = this, s = e.hostModel, l = e.getItemModel(n), u = l.getModel("emphasis"), c = e.getItemLayout(n), f = J(Ki(l.getModel("itemStyle"), c, !0), c);
      if (isNaN(f.startAngle)) {
        o.setShape(f);
        return;
      }
      if (a) {
        o.setShape(f);
        var h = s.getShallow("animationType");
        s.ecModel.ssr ? (ze(o, {
          scaleX: 0,
          scaleY: 0
        }, s, {
          dataIndex: n,
          isFrom: !0
        }), o.originX = f.cx, o.originY = f.cy) : h === "scale" ? (o.shape.r = c.r0, ze(o, {
          shape: {
            r: c.r
          }
        }, s, n)) : i != null ? (o.setShape({
          startAngle: i,
          endAngle: i
        }), ze(o, {
          shape: {
            startAngle: c.startAngle,
            endAngle: c.endAngle
          }
        }, s, n)) : (o.shape.endAngle = c.startAngle, ve(o, {
          shape: {
            endAngle: c.endAngle
          }
        }, s, n));
      } else
        ai(o), ve(o, {
          shape: f
        }, s, n);
      o.useStyle(e.getItemVisual(n, "style")), yr(o, l);
      var d = (c.startAngle + c.endAngle) / 2, p = s.get("selectedOffset"), g = Math.cos(d) * p, v = Math.sin(d) * p, m = l.getShallow("cursor");
      m && o.attr("cursor", m), this._updateLabel(s, e, n), o.ensureState("emphasis").shape = J({
        r: c.r + (u.get("scale") && u.get("scaleSize") || 0)
      }, Ki(u.getModel("itemStyle"), c)), J(o.ensureState("select"), {
        x: g,
        y: v,
        shape: Ki(l.getModel(["select", "itemStyle"]), c)
      }), J(o.ensureState("blur"), {
        shape: Ki(l.getModel(["blur", "itemStyle"]), c)
      });
      var y = o.getTextGuideLine(), _ = o.getTextContent();
      y && J(y.ensureState("select"), {
        x: g,
        y: v
      }), J(_.ensureState("select"), {
        x: g,
        y: v
      }), Ge(this, u.get("focus"), u.get("blurScope"), u.get("disabled"));
    }, t.prototype._updateLabel = function(e, n, i) {
      var a = this, o = n.getItemModel(i), s = o.getModel("labelLine"), l = n.getItemVisual(i, "style"), u = l && l.fill, c = l && l.opacity;
      Er(a, _r(o), {
        labelFetcher: n.hostModel,
        labelDataIndex: i,
        inheritColor: u,
        defaultOpacity: c,
        defaultText: e.getFormattedLabel(i, "normal") || n.getName(i)
      });
      var f = a.getTextContent();
      a.setTextConfig({
        // reset position, rotation
        position: null,
        rotation: null
      }), f.attr({
        z2: 10
      });
      var h = o.get(["label", "position"]);
      if (h !== "outside" && h !== "outer")
        a.removeTextGuideLine();
      else {
        var d = this.getTextGuideLine();
        d || (d = new Ur(), this.setTextGuideLine(d)), bb(this, wb(o), {
          stroke: u,
          opacity: ln(s.get(["lineStyle", "opacity"]), c, 1)
        });
      }
    }, t;
  }(Kr)
), _K = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.ignoreLabelLineUpdate = !0, e;
    }
    return t.prototype.render = function(e, n, i, a) {
      var o = e.getData(), s = this._data, l = this.group, u;
      if (!s && o.count() > 0) {
        for (var c = o.getItemLayout(0), f = 1; isNaN(c && c.startAngle) && f < o.count(); ++f)
          c = o.getItemLayout(f);
        c && (u = c.startAngle);
      }
      if (this._emptyCircleSector && l.remove(this._emptyCircleSector), o.count() === 0 && e.get("showEmptyCircle")) {
        var h = h3(e), d = new Kr({
          shape: Ct(h)
        });
        d.useStyle(e.getModel("emptyCircleStyle").getItemStyle()), this._emptyCircleSector = d, l.add(d);
      }
      o.diff(s).add(function(p) {
        var g = new yK(o, p, u);
        o.setItemGraphicEl(p, g), l.add(g);
      }).update(function(p, g) {
        var v = s.getItemGraphicEl(g);
        v.updateData(o, p, u), v.off("click"), l.add(v), o.setItemGraphicEl(p, v);
      }).remove(function(p) {
        var g = s.getItemGraphicEl(p);
        Pa(g, e, p);
      }).execute(), mK(e), e.get("animationTypeUpdate") !== "expansion" && (this._data = o);
    }, t.prototype.dispose = function() {
    }, t.prototype.containPoint = function(e, n) {
      var i = n.getData(), a = i.getItemLayout(0);
      if (a) {
        var o = e[0] - a.cx, s = e[1] - a.cy, l = Math.sqrt(o * o + s * s);
        return l <= a.r && l >= a.r0;
      }
    }, t.type = "pie", t;
  }(Re)
);
function Pc(r, t, e) {
  t = et(t) && {
    coordDimensions: t
  } || J({
    encodeDefine: r.getEncode()
  }, t);
  var n = r.getSource(), i = Gh(n, t).dimensions, a = new un(i, r);
  return a.initData(n, e), a;
}
var Nc = (
  /** @class */
  function() {
    function r(t, e) {
      this._getDataWithEncodedVisual = t, this._getRawData = e;
    }
    return r.prototype.getAllNames = function() {
      var t = this._getRawData();
      return t.mapArray(t.getName);
    }, r.prototype.containName = function(t) {
      var e = this._getRawData();
      return e.indexOfName(t) >= 0;
    }, r.prototype.indexOfName = function(t) {
      var e = this._getDataWithEncodedVisual();
      return e.indexOfName(t);
    }, r.prototype.getItemVisual = function(t, e) {
      var n = this._getDataWithEncodedVisual();
      return n.getItemVisual(t, e);
    }, r;
  }()
), xK = ee(), v3 = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t.prototype.init = function(e) {
      r.prototype.init.apply(this, arguments), this.legendVisualProvider = new Nc(mt(this.getData, this), mt(this.getRawData, this)), this._defaultLabelLine(e);
    }, t.prototype.mergeOption = function() {
      r.prototype.mergeOption.apply(this, arguments);
    }, t.prototype.getInitialData = function() {
      return Pc(this, {
        coordDimensions: ["value"],
        encodeDefaulter: Yt(rb, this)
      });
    }, t.prototype.getDataParams = function(e) {
      var n = this.getData(), i = xK(n), a = i.seats;
      if (!a) {
        var o = [];
        n.each(n.mapDimension("value"), function(l) {
          o.push(l);
        }), a = i.seats = F8(o, n.hostModel.get("percentPrecision"));
      }
      var s = r.prototype.getDataParams.call(this, e);
      return s.percent = a[e] || 0, s.$vars.push("percent"), s;
    }, t.prototype._defaultLabelLine = function(e) {
      hl(e, "labelLine", ["show"]);
      var n = e.labelLine, i = e.emphasis.labelLine;
      n.show = n.show && e.label.show, i.show = i.show && e.emphasis.label.show;
    }, t.type = "series.pie", t.defaultOption = {
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      colorBy: "data",
      // 
      center: ["50%", "50%"],
      radius: [0, "50%"],
      // 
      clockwise: !0,
      startAngle: 90,
      endAngle: "auto",
      padAngle: 0,
      // 0
      minAngle: 0,
      // If the angle of a sector less than `minShowLabelAngle`,
      // the label will not be displayed.
      minShowLabelAngle: 0,
      // 
      selectedOffset: 10,
      // singlemultiple
      // selectedMode: false,
      // 'radius' | 'area'
      // roseType: null,
      percentPrecision: 2,
      // If still show when all data zero.
      stillShowZeroSum: !0,
      // cursor: null,
      coordinateSystemUsage: "box",
      left: 0,
      top: 0,
      right: 0,
      bottom: 0,
      width: null,
      height: null,
      label: {
        // color: 'inherit',
        // If rotate around circle
        rotate: 0,
        show: !0,
        overflow: "truncate",
        // 'outer', 'inside', 'center'
        position: "outer",
        // 'none', 'labelLine', 'edge'. Works only when position is 'outer'
        alignTo: "none",
        // Closest distance between label and chart edge.
        // Works only position is 'outer' and alignTo is 'edge'.
        edgeDistance: "25%",
        // Works only position is 'outer' and alignTo is not 'edge'.
        // The default `bleedMargin` is auto determined according to view rect size.
        // bleedMargin: 10,
        // Distance between text and label line.
        distanceToLabelLine: 5
        // formatter:  tooltip.formatter
        //  textStyle
        // distance: positioninnerlabel()
      },
      // Enabled when label.normal.position is 'outer'
      labelLine: {
        show: !0,
        // 
        length: 15,
        // 
        length2: 30,
        smooth: !1,
        minTurnAngle: 90,
        maxSurfaceAngle: 90,
        lineStyle: {
          // color: ,
          width: 1,
          type: "solid"
        }
      },
      itemStyle: {
        borderWidth: 1,
        borderJoin: "round"
      },
      showEmptyCircle: !0,
      emptyCircleStyle: {
        color: "lightgray",
        opacity: 1
      },
      labelLayout: {
        // Hide the overlapped label.
        hideOverlap: !0
      },
      emphasis: {
        scale: !0,
        scaleSize: 5
      },
      // If use strategy to avoid label overlapping
      avoidLabelOverlap: !0,
      // Animation type. Valid values: expansion, scale
      animationType: "expansion",
      animationDuration: 1e3,
      // Animation type when update. Valid values: transition, expansion
      animationTypeUpdate: "transition",
      animationEasingUpdate: "cubicInOut",
      animationDurationUpdate: 500,
      animationEasing: "cubicInOut"
    }, t;
  }(ke)
);
T9({
  fullType: v3.type,
  getCoord2: function(r) {
    return r.getShallow("center");
  }
});
function SK(r) {
  return {
    seriesType: r,
    reset: function(t, e) {
      var n = t.getData();
      n.filterSelf(function(i) {
        var a = n.mapDimension("value"), o = n.get(a, i);
        return !(fe(o) && !isNaN(o) && o < 0);
      });
    }
  };
}
function bK(r) {
  r.registerChartView(_K), r.registerSeriesModel(v3), NO("pie", r.registerAction), r.registerLayout(Yt(dK, "pie")), r.registerProcessor(Ic("pie")), r.registerProcessor(SK("pie"));
}
var wK = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.hasSymbolVisual = !0, e;
    }
    return t.prototype.getInitialData = function(e, n) {
      return ja(null, this, {
        useEncodeDefaulter: !0
      });
    }, t.prototype.getProgressive = function() {
      var e = this.option.progressive;
      return e ?? (this.option.large ? 5e3 : this.get("progressive"));
    }, t.prototype.getProgressiveThreshold = function() {
      var e = this.option.progressiveThreshold;
      return e ?? (this.option.large ? 1e4 : this.get("progressiveThreshold"));
    }, t.prototype.brushSelector = function(e, n, i) {
      return i.point(n.getItemLayout(e));
    }, t.prototype.getZLevelKey = function() {
      return this.getData().count() > this.getProgressiveThreshold() ? this.id : "";
    }, t.type = "series.scatter", t.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar", "matrix"], t.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      symbolSize: 10,
      // symbolRotate: null,  // 
      large: !1,
      // Available when large is true
      largeThreshold: 2e3,
      // cursor: null,
      itemStyle: {
        opacity: 0.8
        // color: 
      },
      emphasis: {
        scale: !0
      },
      // If clip the overflow graphics
      // Works on cartesian / polar series
      clip: !0,
      select: {
        itemStyle: {
          borderColor: Y.color.primary
        }
      },
      universalTransition: {
        divideShape: "clone"
      }
      // progressive: null
    }, t;
  }(ke)
), g3 = 4, MK = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
    }
    return r;
  }()
), TK = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e) {
      var n = r.call(this, e) || this;
      return n._off = 0, n.hoverDataIdx = -1, n;
    }
    return t.prototype.getDefaultShape = function() {
      return new MK();
    }, t.prototype.reset = function() {
      this.notClear = !1, this._off = 0;
    }, t.prototype.buildPath = function(e, n) {
      var i = n.points, a = n.size, o = this.symbolProxy, s = o.shape, l = e.getContext ? e.getContext() : e, u = l && a[0] < g3, c = this.softClipShape, f;
      if (u) {
        this._ctx = l;
        return;
      }
      for (this._ctx = null, f = this._off; f < i.length; ) {
        var h = i[f++], d = i[f++];
        isNaN(h) || isNaN(d) || c && !c.contain(h, d) || (s.x = h - a[0] / 2, s.y = d - a[1] / 2, s.width = a[0], s.height = a[1], o.buildPath(e, s, !0));
      }
      this.incremental && (this._off = f, this.notClear = !0);
    }, t.prototype.afterBrush = function() {
      var e = this.shape, n = e.points, i = e.size, a = this._ctx, o = this.softClipShape, s;
      if (a) {
        for (s = this._off; s < n.length; ) {
          var l = n[s++], u = n[s++];
          isNaN(l) || isNaN(u) || o && !o.contain(l, u) || a.fillRect(l - i[0] / 2, u - i[1] / 2, i[0], i[1]);
        }
        this.incremental && (this._off = s, this.notClear = !0);
      }
    }, t.prototype.findDataIndex = function(e, n) {
      for (var i = this.shape, a = i.points, o = i.size, s = Math.max(o[0], 4), l = Math.max(o[1], 4), u = a.length / 2 - 1; u >= 0; u--) {
        var c = u * 2, f = a[c] - s / 2, h = a[c + 1] - l / 2;
        if (e >= f && n >= h && e <= f + s && n <= h + l)
          return u;
      }
      return -1;
    }, t.prototype.contain = function(e, n) {
      var i = this.transformCoordToLocal(e, n), a = this.getBoundingRect();
      if (e = i[0], n = i[1], a.contain(e, n)) {
        var o = this.hoverDataIdx = this.findDataIndex(e, n);
        return o >= 0;
      }
      return this.hoverDataIdx = -1, !1;
    }, t.prototype.getBoundingRect = function() {
      var e = this._rect;
      if (!e) {
        for (var n = this.shape, i = n.points, a = n.size, o = a[0], s = a[1], l = 1 / 0, u = 1 / 0, c = -1 / 0, f = -1 / 0, h = 0; h < i.length; ) {
          var d = i[h++], p = i[h++];
          l = Math.min(d, l), c = Math.max(d, c), u = Math.min(p, u), f = Math.max(p, f);
        }
        e = this._rect = new Bt(l - o / 2, u - s / 2, c - l + o, f - u + s);
      }
      return e;
    }, t;
  }(ne)
), AK = (
  /** @class */
  function() {
    function r() {
      this.group = new Et();
    }
    return r.prototype.updateData = function(t, e) {
      this._clear();
      var n = this._create();
      n.setShape({
        points: t.getLayout("points")
      }), this._setCommon(n, t, e);
    }, r.prototype.updateLayout = function(t) {
      var e = t.getLayout("points");
      this.group.eachChild(function(n) {
        if (n.startIndex != null) {
          var i = (n.endIndex - n.startIndex) * 2, a = n.startIndex * 4 * 2;
          e = new Float32Array(e.buffer, a, i);
        }
        n.setShape("points", e), n.reset();
      });
    }, r.prototype.incrementalPrepareUpdate = function(t) {
      this._clear();
    }, r.prototype.incrementalUpdate = function(t, e, n) {
      var i = this._newAdded[0], a = e.getLayout("points"), o = i && i.shape.points;
      if (o && o.length < 2e4) {
        var s = o.length, l = new Float32Array(s + a.length);
        l.set(o), l.set(a, s), i.endIndex = t.end, i.setShape({
          points: l
        });
      } else {
        this._newAdded = [];
        var u = this._create();
        u.startIndex = t.start, u.endIndex = t.end, u.incremental = !0, u.setShape({
          points: a
        }), this._setCommon(u, e, n);
      }
    }, r.prototype.eachRendered = function(t) {
      this._newAdded[0] && t(this._newAdded[0]);
    }, r.prototype._create = function() {
      var t = new TK({
        cursor: "default"
      });
      return t.ignoreCoarsePointer = !0, this.group.add(t), this._newAdded.push(t), t;
    }, r.prototype._setCommon = function(t, e, n) {
      var i = e.hostModel;
      n = n || {};
      var a = e.getVisual("symbolSize");
      t.setShape("size", a instanceof Array ? a : [a, a]), t.softClipShape = n.clipShape || null, t.symbolProxy = fr(e.getVisual("symbol"), 0, 0, 0, 0), t.setColor = t.symbolProxy.setColor;
      var o = t.shape.size[0] < g3;
      t.useStyle(
        // Draw shadow when doing fillRect is extremely slow.
        i.getModel("itemStyle").getItemStyle(o ? ["color", "shadowBlur", "shadowColor"] : ["color"])
      );
      var s = e.getVisual("style"), l = s && s.fill;
      l && t.setColor(l);
      var u = zt(t);
      u.seriesIndex = i.seriesIndex, t.on("mousemove", function(c) {
        u.dataIndex = null;
        var f = t.hoverDataIdx;
        f >= 0 && (u.dataIndex = f + (t.startIndex || 0));
      });
    }, r.prototype.remove = function() {
      this._clear();
    }, r.prototype._clear = function() {
      this._newAdded = [], this.group.removeAll();
    }, r;
  }()
), EK = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n, i) {
      var a = e.getData(), o = this._updateSymbolDraw(a, e);
      o.updateData(a, {
        // TODO
        // If this parameter should be a shape or a bounding volume
        // shape will be more general.
        // But bounding volume like bounding rect will be much faster in the contain calculation
        clipShape: this._getClipShape(e)
      }), this._finished = !0;
    }, t.prototype.incrementalPrepareRender = function(e, n, i) {
      var a = e.getData(), o = this._updateSymbolDraw(a, e);
      o.incrementalPrepareUpdate(a), this._finished = !1;
    }, t.prototype.incrementalRender = function(e, n, i) {
      this._symbolDraw.incrementalUpdate(e, n.getData(), {
        clipShape: this._getClipShape(n)
      }), this._finished = e.end === n.getData().count();
    }, t.prototype.updateTransform = function(e, n, i) {
      var a = e.getData();
      if (this.group.dirty(), !this._finished || a.count() > 1e4)
        return {
          update: !0
        };
      var o = $h("").reset(e, n, i);
      o.progress && o.progress({
        start: 0,
        end: a.count(),
        count: a.count()
      }, a), this._symbolDraw.updateLayout(a);
    }, t.prototype.eachRendered = function(e) {
      this._symbolDraw && this._symbolDraw.eachRendered(e);
    }, t.prototype._getClipShape = function(e) {
      if (e.get("clip", !0)) {
        var n = e.coordinateSystem;
        return n && n.getArea && n.getArea(0.1);
      }
    }, t.prototype._updateSymbolDraw = function(e, n) {
      var i = this._symbolDraw, a = n.pipelineContext, o = a.large;
      return (!i || o !== this._isLargeDraw) && (i && i.remove(), i = this._symbolDraw = o ? new AK() : new Xh(), this._isLargeDraw = o, this.group.removeAll()), this.group.add(i.group), i;
    }, t.prototype.remove = function(e, n) {
      this._symbolDraw && this._symbolDraw.remove(!0), this._symbolDraw = null;
    }, t.prototype.dispose = function() {
    }, t.type = "scatter", t;
  }(Re)
), m3 = {
  left: 0,
  right: 0,
  top: 0,
  bottom: 0
}, ag = ["25%", "25%"], CK = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t.prototype.mergeDefaultAndTheme = function(e, n) {
      var i = El(e.outerBounds);
      r.prototype.mergeDefaultAndTheme.apply(this, arguments), i && e.outerBounds && oa(e.outerBounds, i);
    }, t.prototype.mergeOption = function(e, n) {
      r.prototype.mergeOption.apply(this, arguments), this.option.outerBounds && e.outerBounds && oa(this.option.outerBounds, e.outerBounds);
    }, t.type = "grid", t.dependencies = ["xAxis", "yAxis"], t.layoutMode = "box", t.defaultOption = {
      show: !1,
      // zlevel: 0,
      z: 0,
      left: "15%",
      top: 65,
      right: "10%",
      bottom: 80,
      // If grid size contain label
      containLabel: !1,
      outerBoundsMode: "auto",
      outerBounds: m3,
      outerBoundsContain: "all",
      outerBoundsClampWidth: ag[0],
      outerBoundsClampHeight: ag[1],
      // width: {totalWidth} - left - right,
      // height: {totalHeight} - top - bottom,
      backgroundColor: Y.color.transparent,
      borderWidth: 1,
      borderColor: Y.color.neutral30
    }, t;
  }(re)
), vS = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t.prototype.getCoordSysModel = function() {
      return this.getReferringComponents("grid", Ke).models[0];
    }, t.type = "cartesian2dAxis", t;
  }(re)
);
hr(vS, Hh);
var y3 = {
  show: !0,
  // zlevel: 0,
  z: 0,
  // Inverse the axis.
  inverse: !1,
  // Axis name displayed.
  name: "",
  // 'start' | 'middle' | 'end'
  nameLocation: "end",
  // By degree. By default auto rotate by nameLocation.
  nameRotate: null,
  nameTruncate: {
    maxWidth: null,
    ellipsis: "...",
    placeholder: "."
  },
  // Use global text style by default.
  nameTextStyle: {
    // textMargin: never, // The default value will be specified based on `nameLocation`.
  },
  // The gap between axisName and axisLine.
  nameGap: 15,
  // Default `false` to support tooltip.
  silent: !1,
  // Default `false` to avoid legacy user event listener fail.
  triggerEvent: !1,
  tooltip: {
    show: !1
  },
  axisPointer: {},
  axisLine: {
    show: !0,
    onZero: !0,
    onZeroAxisIndex: null,
    lineStyle: {
      color: Y.color.axisLine,
      width: 1,
      type: "solid"
    },
    // The arrow at both ends the the axis.
    symbol: ["none", "none"],
    symbolSize: [10, 15],
    breakLine: !0
  },
  axisTick: {
    show: !0,
    // Whether axisTick is inside the grid or outside the grid.
    inside: !1,
    // The length of axisTick.
    length: 5,
    lineStyle: {
      width: 1
    }
  },
  axisLabel: {
    show: !0,
    // Whether axisLabel is inside the grid or outside the grid.
    inside: !1,
    rotate: 0,
    // true | false | null/undefined (auto)
    showMinLabel: null,
    // true | false | null/undefined (auto)
    showMaxLabel: null,
    margin: 8,
    // formatter: null,
    fontSize: 12,
    color: Y.color.axisLabel,
    // In scenarios like axis labels, when labels text's progression direction matches the label
    // layout direction (e.g., when all letters are in a single line), extra start/end margin is
    // needed to prevent the text from appearing visually joined. In the other case, when lables
    // are stacked (e.g., having rotation or horizontal labels on yAxis), the layout needs to be
    // compact, so NO extra top/bottom margin should be applied.
    textMargin: [0, 3]
  },
  splitLine: {
    show: !0,
    showMinLine: !0,
    showMaxLine: !0,
    lineStyle: {
      color: Y.color.axisSplitLine,
      width: 1,
      type: "solid"
    }
  },
  splitArea: {
    show: !1,
    areaStyle: {
      color: [Y.color.backgroundTint, Y.color.backgroundTransparent]
    }
  },
  breakArea: {
    show: !0,
    itemStyle: {
      color: Y.color.neutral00,
      // Break border color should be darker than the splitLine
      // because it has opacity and should be more prominent
      borderColor: Y.color.border,
      borderWidth: 1,
      borderType: [3, 3],
      opacity: 0.6
    },
    zigzagAmplitude: 4,
    zigzagMinSpan: 4,
    zigzagMaxSpan: 20,
    zigzagZ: 100,
    expandOnClick: !0
  },
  breakLabelLayout: {
    moveOverlap: "auto"
  }
}, DK = qt({
  // The gap at both ends of the axis. For categoryAxis, boolean.
  boundaryGap: !0,
  // Set false to faster category collection.
  deduplication: null,
  jitter: 0,
  jitterOverlap: !0,
  jitterMargin: 2,
  // splitArea: {
  // show: false
  // },
  splitLine: {
    show: !1
  },
  axisTick: {
    // If tick is align with label when boundaryGap is true
    alignWithLabel: !1,
    interval: "auto",
    show: "auto"
  },
  axisLabel: {
    interval: "auto"
  }
}, y3), Lb = qt({
  boundaryGap: [0, 0],
  axisLine: {
    // Not shown when other axis is categoryAxis in cartesian
    show: "auto"
  },
  axisTick: {
    // Not shown when other axis is categoryAxis in cartesian
    show: "auto"
  },
  // TODO
  // min/max: [30, datamin, 60] or [20, datamin] or [datamin, 60]
  splitNumber: 5,
  minorTick: {
    // Minor tick, not available for cateogry axis.
    show: !1,
    // Split number of minor ticks. The value should be in range of (0, 100)
    splitNumber: 5,
    // Length of minor tick
    length: 3,
    // Line style
    lineStyle: {
      // Default to be same with axisTick
    }
  },
  minorSplitLine: {
    show: !1,
    lineStyle: {
      color: Y.color.axisMinorSplitLine,
      width: 1
    }
  }
}, y3), LK = qt({
  splitNumber: 6,
  axisLabel: {
    // To eliminate labels that are not nice
    showMinLabel: !1,
    showMaxLabel: !1,
    rich: {
      primary: {
        fontWeight: "bold"
      }
    }
  },
  splitLine: {
    show: !1
  }
}, Lb), RK = kt({
  logBase: 10
}, Lb);
const _3 = {
  category: DK,
  value: Lb,
  time: LK,
  log: RK
};
var IK = {
  value: 1,
  category: 1,
  time: 1,
  log: 1
}, gS = null;
function PK(r) {
  gS || (gS = r);
}
function Zh() {
  return gS;
}
function cc(r, t, e, n) {
  L(IK, function(i, a) {
    var o = qt(qt({}, _3[a], !0), n, !0), s = (
      /** @class */
      function(l) {
        W(u, l);
        function u() {
          var c = l !== null && l.apply(this, arguments) || this;
          return c.type = t + "Axis." + a, c;
        }
        return u.prototype.mergeDefaultAndTheme = function(c, f) {
          var h = lh(this), d = h ? El(c) : {}, p = f.getTheme();
          qt(c, p.get(a + "Axis")), qt(c, this.getDefaultOption()), c.type = ZC(c), h && oa(c, d, h);
        }, u.prototype.optionUpdated = function() {
          var c = this.option;
          c.type === "category" && (this.__ordinalMeta = ph.createByAxisModel(this));
        }, u.prototype.getCategories = function(c) {
          var f = this.option;
          if (f.type === "category")
            return c ? f.data : this.__ordinalMeta.categories;
        }, u.prototype.getOrdinalMeta = function() {
          return this.__ordinalMeta;
        }, u.prototype.updateAxisBreaks = function(c) {
          var f = Zh();
          return f ? f.updateModelAxisBreak(this, c) : {
            breaks: []
          };
        }, u.type = t + "Axis." + a, u.defaultOption = o, u;
      }(e)
    );
    r.registerComponentModel(s);
  }), r.registerSubTypeDefaulter(t + "Axis", ZC);
}
function ZC(r) {
  return r.type || (r.data ? "category" : "value");
}
var NK = (
  /** @class */
  function() {
    function r(t) {
      this.type = "cartesian", this._dimList = [], this._axes = {}, this.name = t || "";
    }
    return r.prototype.getAxis = function(t) {
      return this._axes[t];
    }, r.prototype.getAxes = function() {
      return rt(this._dimList, function(t) {
        return this._axes[t];
      }, this);
    }, r.prototype.getAxesByScale = function(t) {
      return t = t.toLowerCase(), Te(this.getAxes(), function(e) {
        return e.scale.type === t;
      });
    }, r.prototype.addAxis = function(t) {
      var e = t.dim;
      this._axes[e] = t, this._dimList.push(e);
    }, r;
  }()
), mS = ["x", "y"];
function qC(r) {
  return (r.type === "interval" || r.type === "time") && !r.hasBreaks();
}
var OK = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = "cartesian2d", e.dimensions = mS, e;
    }
    return t.prototype.calcAffineTransform = function() {
      this._transform = this._invTransform = null;
      var e = this.getAxis("x").scale, n = this.getAxis("y").scale;
      if (!(!qC(e) || !qC(n))) {
        var i = e.getExtent(), a = n.getExtent(), o = this.dataToPoint([i[0], a[0]]), s = this.dataToPoint([i[1], a[1]]), l = i[1] - i[0], u = a[1] - a[0];
        if (!(!l || !u)) {
          var c = (s[0] - o[0]) / l, f = (s[1] - o[1]) / u, h = o[0] - i[0] * c, d = o[1] - a[0] * f, p = this._transform = [c, 0, 0, f, h, d];
          this._invTransform = Si([], p);
        }
      }
    }, t.prototype.getBaseAxis = function() {
      return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x");
    }, t.prototype.containPoint = function(e) {
      var n = this.getAxis("x"), i = this.getAxis("y");
      return n.contain(n.toLocalCoord(e[0])) && i.contain(i.toLocalCoord(e[1]));
    }, t.prototype.containData = function(e) {
      return this.getAxis("x").containData(e[0]) && this.getAxis("y").containData(e[1]);
    }, t.prototype.containZone = function(e, n) {
      var i = this.dataToPoint(e), a = this.dataToPoint(n), o = this.getArea(), s = new Bt(i[0], i[1], a[0] - i[0], a[1] - i[1]);
      return o.intersect(s);
    }, t.prototype.dataToPoint = function(e, n, i) {
      i = i || [];
      var a = e[0], o = e[1];
      if (this._transform && a != null && isFinite(a) && o != null && isFinite(o))
        return rr(i, e, this._transform);
      var s = this.getAxis("x"), l = this.getAxis("y");
      return i[0] = s.toGlobalCoord(s.dataToCoord(a, n)), i[1] = l.toGlobalCoord(l.dataToCoord(o, n)), i;
    }, t.prototype.clampData = function(e, n) {
      var i = this.getAxis("x").scale, a = this.getAxis("y").scale, o = i.getExtent(), s = a.getExtent(), l = i.parse(e[0]), u = a.parse(e[1]);
      return n = n || [], n[0] = Math.min(Math.max(Math.min(o[0], o[1]), l), Math.max(o[0], o[1])), n[1] = Math.min(Math.max(Math.min(s[0], s[1]), u), Math.max(s[0], s[1])), n;
    }, t.prototype.pointToData = function(e, n, i) {
      if (i = i || [], this._invTransform)
        return rr(i, e, this._invTransform);
      var a = this.getAxis("x"), o = this.getAxis("y");
      return i[0] = a.coordToData(a.toLocalCoord(e[0]), n), i[1] = o.coordToData(o.toLocalCoord(e[1]), n), i;
    }, t.prototype.getOtherAxis = function(e) {
      return this.getAxis(e.dim === "x" ? "y" : "x");
    }, t.prototype.getArea = function(e) {
      e = e || 0;
      var n = this.getAxis("x").getGlobalExtent(), i = this.getAxis("y").getGlobalExtent(), a = Math.min(n[0], n[1]) - e, o = Math.min(i[0], i[1]) - e, s = Math.max(n[0], n[1]) - a + e, l = Math.max(i[0], i[1]) - o + e;
      return new Bt(a, o, s, l);
    }, t;
  }(NK)
), x3 = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e, n, i, a, o) {
      var s = r.call(this, e, n, i) || this;
      return s.index = 0, s.type = a || "value", s.position = o || "bottom", s;
    }
    return t.prototype.isHorizontal = function() {
      var e = this.position;
      return e === "top" || e === "bottom";
    }, t.prototype.getGlobalExtent = function(e) {
      var n = this.getExtent();
      return n[0] = this.toGlobalCoord(n[0]), n[1] = this.toGlobalCoord(n[1]), e && n[0] > n[1] && n.reverse(), n;
    }, t.prototype.pointToData = function(e, n) {
      return this.coordToData(this.toLocalCoord(e[this.dim === "x" ? 0 : 1]), n);
    }, t.prototype.setCategorySortInfo = function(e) {
      if (this.type !== "category")
        return !1;
      this.model.option.categorySortInfo = e, this.scale.setSortInfo(e);
    }, t;
  }(Ai)
), mm = "expandAxisBreak", S3 = "collapseAxisBreak", b3 = "toggleAxisBreak", Rb = "axisbreakchanged", kK = {
  type: mm,
  event: Rb,
  update: "update",
  refineEvent: Ib
}, BK = {
  type: S3,
  event: Rb,
  update: "update",
  refineEvent: Ib
}, VK = {
  type: b3,
  event: Rb,
  update: "update",
  refineEvent: Ib
};
function Ib(r, t, e, n) {
  var i = [];
  return L(r, function(a) {
    i = i.concat(a.eventBreaks);
  }), {
    eventContent: {
      breaks: i
    }
  };
}
function FK(r) {
  r.registerAction(kK, t), r.registerAction(BK, t), r.registerAction(VK, t);
  function t(e, n) {
    var i = [], a = Wu(n, e);
    function o(s, l) {
      L(a[s], function(u) {
        var c = u.updateAxisBreaks(e);
        L(c.breaks, function(f) {
          var h;
          i.push(kt((h = {}, h[l] = u.componentIndex, h), f));
        });
      });
    }
    return o("xAxisModels", "xAxisIndex"), o("yAxisModels", "yAxisIndex"), o("singleAxisModels", "singleAxisIndex"), {
      eventBreaks: i
    };
  }
}
var Ao = Math.PI, zK = [[1, 2, 1, 2], [5, 3, 5, 3], [8, 3, 8, 3]], UK = [[0, 1, 0, 1], [0, 3, 0, 3], [0, 3, 0, 3]], fc = ee(), w3 = ee(), M3 = (
  /** @class */
  function() {
    function r(t) {
      this.recordMap = {}, this.resolveAxisNameOverlap = t;
    }
    return r.prototype.ensureRecord = function(t) {
      var e = t.axis.dim, n = t.componentIndex, i = this.recordMap, a = i[e] || (i[e] = []);
      return a[n] || (a[n] = {
        ready: {}
      });
    }, r;
  }()
);
function GK(r, t, e, n) {
  var i = e.axis, a = t.ensureRecord(e), o = [], s, l = Pb(r.axisName) && lc(r.nameLocation);
  L(n, function(p) {
    var g = sa(p);
    if (!(!g || g.label.ignore)) {
      o.push(g);
      var v = a.transGroup;
      l && (v.transform ? Si(lf, v.transform) : Ug(lf), g.transform && ji(lf, lf, g.transform), Bt.copy(dp, g.localRect), dp.applyTransform(lf), s ? s.union(dp) : Bt.copy(s = new Bt(0, 0, 0, 0), dp));
    }
  });
  var u = Math.abs(a.dirVec.x) > 0.1 ? "x" : "y", c = a.transGroup[u];
  if (o.sort(function(p, g) {
    return Math.abs(p.label[u] - c) - Math.abs(g.label[u] - c);
  }), l && s) {
    var f = i.getExtent(), h = Math.min(f[0], f[1]), d = Math.max(f[0], f[1]) - h;
    s.union(new Bt(h, 0, d, 1));
  }
  a.stOccupiedRect = s, a.labelInfoList = o;
}
var lf = kr(), dp = new Bt(0, 0, 0, 0), T3 = function(r, t, e, n, i, a) {
  if (lc(r.nameLocation)) {
    var o = a.stOccupiedRect;
    o && A3(zZ({}, o, a.transGroup.transform), n, i);
  } else
    E3(a.labelInfoList, a.dirVec, n, i);
};
function A3(r, t, e) {
  var n = new Nt();
  vm(r, t, n, {
    direction: Math.atan2(e.y, e.x),
    bidirectional: !1,
    touchThreshold: 0.05
  }) && lS(t, n);
}
function E3(r, t, e, n) {
  for (var i = Nt.dot(n, t) >= 0, a = 0, o = r.length; a < o; a++) {
    var s = r[i ? a : o - 1 - a];
    s.label.ignore || A3(s, e, n);
  }
}
var cn = (
  /** @class */
  function() {
    function r(t, e, n, i) {
      this.group = new Et(), this._axisModel = t, this._api = e, this._local = {}, this._shared = i || new M3(T3), this._resetCfgDetermined(n);
    }
    return r.prototype.updateCfg = function(t) {
      if (process.env.NODE_ENV !== "production") {
        var e = this._shared.ensureRecord(this._axisModel).ready;
        St(!e.axisLine && !e.axisTickLabelDetermine), e.axisName = e.axisTickLabelEstimate = !1;
      }
      var n = this._cfg.raw;
      n.position = t.position, n.labelOffset = t.labelOffset, this._resetCfgDetermined(n);
    }, r.prototype.__getRawCfg = function() {
      return this._cfg.raw;
    }, r.prototype._resetCfgDetermined = function(t) {
      var e = this._axisModel, n = e.getDefaultOption ? e.getDefaultOption() : {}, i = bt(t.axisName, e.get("name")), a = e.get("nameMoveOverlap");
      (a == null || a === "auto") && (a = bt(t.defaultNameMoveOverlap, !0));
      var o = {
        raw: t,
        position: t.position,
        rotation: t.rotation,
        nameDirection: bt(t.nameDirection, 1),
        tickDirection: bt(t.tickDirection, 1),
        labelDirection: bt(t.labelDirection, 1),
        labelOffset: bt(t.labelOffset, 0),
        silent: bt(t.silent, !0),
        axisName: i,
        nameLocation: ln(e.get("nameLocation"), n.nameLocation, "end"),
        shouldNameMoveOverlap: Pb(i) && a,
        optionHideOverlap: e.get(["axisLabel", "hideOverlap"]),
        showMinorTicks: e.get(["minorTick", "show"])
      };
      process.env.NODE_ENV !== "production" && (St(o.position != null), St(o.rotation != null)), this._cfg = o;
      var s = new Et({
        x: o.position[0],
        y: o.position[1],
        rotation: o.rotation
      });
      s.updateTransform(), this._transformGroup = s;
      var l = this._shared.ensureRecord(e);
      l.transGroup = this._transformGroup, l.dirVec = new Nt(Math.cos(-o.rotation), Math.sin(-o.rotation));
    }, r.prototype.build = function(t, e) {
      var n = this;
      return t || (t = {
        axisLine: !0,
        axisTickLabelEstimate: !1,
        axisTickLabelDetermine: !0,
        axisName: !0
      }), L(HK, function(i) {
        t[i] && WK[i](n._cfg, n._local, n._shared, n._axisModel, n.group, n._transformGroup, n._api, e || {});
      }), this;
    }, r.innerTextLayout = function(t, e, n) {
      var i = CP(e - t), a, o;
      return ih(i) ? (o = n > 0 ? "top" : "bottom", a = "center") : ih(i - Ao) ? (o = n > 0 ? "bottom" : "top", a = "center") : (o = "middle", i > 0 && i < Ao ? a = n > 0 ? "right" : "left" : a = n > 0 ? "left" : "right"), {
        rotation: i,
        textAlign: a,
        textVerticalAlign: o
      };
    }, r.makeAxisEventDataBase = function(t) {
      var e = {
        componentType: t.mainType,
        componentIndex: t.componentIndex
      };
      return e[t.mainType + "Index"] = t.componentIndex, e;
    }, r.isLabelSilent = function(t) {
      var e = t.get("tooltip");
      return t.get("silent") || !(t.get("triggerEvent") || e && e.show);
    }, r;
  }()
), HK = ["axisLine", "axisTickLabelEstimate", "axisTickLabelDetermine", "axisName"], WK = {
  axisLine: function(r, t, e, n, i, a, o) {
    if (process.env.NODE_ENV !== "production") {
      var s = e.ensureRecord(n).ready;
      St(!s.axisLine), s.axisLine = !0;
    }
    var l = n.get(["axisLine", "show"]);
    if (l === "auto" && (l = !0, r.raw.axisLineAutoShow != null && (l = !!r.raw.axisLineAutoShow)), !!l) {
      var u = n.axis.getExtent(), c = a.transform, f = [u[0], 0], h = [u[1], 0], d = f[0] > h[0];
      c && (rr(f, f, c), rr(h, h, c));
      var p = J({
        lineCap: "round"
      }, n.getModel(["axisLine", "lineStyle"]).getLineStyle()), g = {
        strokeContainThreshold: r.raw.strokeContainThreshold || 5,
        silent: !0,
        z2: 1,
        style: p
      };
      if (n.get(["axisLine", "breakLine"]) && n.axis.scale.hasBreaks())
        Zh().buildAxisBreakLine(n, i, a, g);
      else {
        var v = new sr(J({
          shape: {
            x1: f[0],
            y1: f[1],
            x2: h[0],
            y2: h[1]
          }
        }, g));
        nc(v.shape, v.style.lineWidth), v.anid = "line", i.add(v);
      }
      var m = n.get(["axisLine", "symbol"]);
      if (m != null) {
        var y = n.get(["axisLine", "symbolSize"]);
        pt(m) && (m = [m, m]), (pt(y) || fe(y)) && (y = [y, y]);
        var _ = Dl(n.get(["axisLine", "symbolOffset"]) || 0, y), x = y[0], b = y[1];
        L([{
          rotate: r.rotation + Math.PI / 2,
          offset: _[0],
          r: 0
        }, {
          rotate: r.rotation - Math.PI / 2,
          offset: _[1],
          r: Math.sqrt((f[0] - h[0]) * (f[0] - h[0]) + (f[1] - h[1]) * (f[1] - h[1]))
        }], function(S, w) {
          if (m[w] !== "none" && m[w] != null) {
            var A = fr(m[w], -x / 2, -b / 2, x, b, p.stroke, !0), T = S.r + S.offset, M = d ? h : f;
            A.attr({
              rotation: S.rotate,
              x: M[0] + T * Math.cos(r.rotation),
              y: M[1] - T * Math.sin(r.rotation),
              silent: !0,
              z2: 11
            }), i.add(A);
          }
        });
      }
    }
  },
  /**
   * [CAUTION] This method can be called multiple times, following the change due to `resetCfg` called
   *  in size measurement. Thus this method should be idempotent, and should be performant.
   */
  axisTickLabelEstimate: function(r, t, e, n, i, a, o, s) {
    if (process.env.NODE_ENV !== "production") {
      var l = e.ensureRecord(n).ready;
      St(!l.axisTickLabelDetermine), l.axisTickLabelEstimate = !0;
    }
    var u = jC(t, i, s);
    u && KC(r, t, e, n, i, a, o, wi.estimate);
  },
  /**
   * Finish axis tick label build.
   * Can be only called once.
   */
  axisTickLabelDetermine: function(r, t, e, n, i, a, o, s) {
    if (process.env.NODE_ENV !== "production") {
      var l = e.ensureRecord(n).ready;
      l.axisTickLabelDetermine = !0;
    }
    var u = jC(t, i, s);
    u && KC(r, t, e, n, i, a, o, wi.determine);
    var c = ZK(r, i, a, n);
    $K(r, t.labelLayoutList, c), qK(r, i, a, n, r.tickDirection);
  },
  /**
   * [CAUTION] This method can be called multiple times, following the change due to `resetCfg` called
   *  in size measurement. Thus this method should be idempotent, and should be performant.
   */
  axisName: function(r, t, e, n, i, a, o, s) {
    var l = e.ensureRecord(n);
    if (process.env.NODE_ENV !== "production") {
      var u = l.ready;
      St(u.axisTickLabelEstimate || u.axisTickLabelDetermine), u.axisName = !0;
    }
    t.nameEl && (i.remove(t.nameEl), t.nameEl = l.nameLayout = l.nameLocation = null);
    var c = r.axisName;
    if (Pb(c)) {
      var f = r.nameLocation, h = r.nameDirection, d = n.getModel("nameTextStyle"), p = n.get("nameGap") || 0, g = n.axis.getExtent(), v = n.axis.inverse ? -1 : 1, m = new Nt(0, 0), y = new Nt(0, 0);
      f === "start" ? (m.x = g[0] - v * p, y.x = -v) : f === "end" ? (m.x = g[1] + v * p, y.x = v) : (m.x = (g[0] + g[1]) / 2, m.y = r.labelOffset + h * p, y.y = h);
      var _ = kr();
      y.transform(qo(_, _, r.rotation));
      var x = n.get("nameRotate");
      x != null && (x = x * Ao / 180);
      var b, S;
      lc(f) ? b = cn.innerTextLayout(
        r.rotation,
        x ?? r.rotation,
        // Adapt to axis.
        h
      ) : (b = XK(r.rotation, f, x || 0, g), S = r.raw.axisNameAvailableWidth, S != null && (S = Math.abs(S / Math.sin(b.rotation)), !isFinite(S) && (S = null)));
      var w = d.getFont(), A = n.get("nameTruncate", !0) || {}, T = A.ellipsis, M = gr(r.raw.nameTruncateMaxWidth, A.maxWidth, S), E = s.nameMarginLevel || 0, R = new pe({
        x: m.x,
        y: m.y,
        rotation: b.rotation,
        silent: cn.isLabelSilent(n),
        style: Oe(d, {
          text: c,
          font: w,
          overflow: "truncate",
          width: M,
          ellipsis: T,
          fill: d.getTextColor() || n.get(["axisLine", "lineStyle", "color"]),
          align: d.get("align") || b.textAlign,
          verticalAlign: d.get("verticalAlign") || b.textVerticalAlign
        }),
        z2: 1
      });
      if (Ka({
        el: R,
        componentModel: n,
        itemName: c
      }), R.__fullText = c, R.anid = "name", n.get("triggerEvent")) {
        var C = cn.makeAxisEventDataBase(n);
        C.targetType = "axisName", C.name = c, zt(R).eventData = C;
      }
      a.add(R), R.updateTransform(), t.nameEl = R;
      var D = l.nameLayout = sa({
        label: R,
        priority: R.z2,
        defaultAttr: {
          ignore: R.ignore
        },
        marginDefault: lc(f) ? zK[E] : UK[E]
      });
      if (l.nameLocation = f, i.add(R), R.decomposeTransform(), r.shouldNameMoveOverlap && D) {
        var I = e.ensureRecord(n);
        process.env.NODE_ENV !== "production" && St(I.labelInfoList), e.resolveAxisNameOverlap(r, e, n, D, y, I);
      }
    }
  }
};
function KC(r, t, e, n, i, a, o, s) {
  D3(t) || KK(r, t, i, s, n, o);
  var l = t.labelLayoutList;
  jK(r, n, l, a), tj(n, r.rotation, l);
  var u = r.optionHideOverlap;
  YK(n, l, u), u && Fk(
    // Filter the already ignored labels by the previous overlap resolving methods.
    Te(l, function(c) {
      return c && !c.label.ignore;
    })
  ), GK(r, e, n, l);
}
function XK(r, t, e, n) {
  var i = CP(e - r), a, o, s = n[0] > n[1], l = t === "start" && !s || t !== "start" && s;
  return ih(i - Ao / 2) ? (o = l ? "bottom" : "top", a = "center") : ih(i - Ao * 1.5) ? (o = l ? "top" : "bottom", a = "center") : (o = "middle", i < Ao * 1.5 && i > Ao / 2 ? a = l ? "left" : "right" : a = l ? "right" : "left"), {
    rotation: i,
    textAlign: a,
    textVerticalAlign: o
  };
}
function YK(r, t, e) {
  if (bk(r.axis))
    return;
  function n(s, l, u) {
    var c = sa(t[l]), f = sa(t[u]);
    if (!(!c || !f)) {
      if (s === !1 || c.suggestIgnore) {
        Nf(c.label);
        return;
      }
      if (f.suggestIgnore) {
        Nf(f.label);
        return;
      }
      var h = 0.1;
      if (!e) {
        var d = [0, 0, 0, 0];
        c = uS({
          marginForce: d
        }, c), f = uS({
          marginForce: d
        }, f);
      }
      vm(c, f, null, {
        touchThreshold: h
      }) && Nf(s ? f.label : c.label);
    }
  }
  var i = r.get(["axisLabel", "showMinLabel"]), a = r.get(["axisLabel", "showMaxLabel"]), o = t.length;
  n(i, 0, 1), n(a, o - 1, o - 2);
}
function $K(r, t, e) {
  r.showMinorTicks || L(t, function(n) {
    if (n && n.label.ignore)
      for (var i = 0; i < e.length; i++) {
        var a = e[i], o = w3(a), s = fc(n.label);
        if (o.tickValue != null && !o.onBand && o.tickValue === s.tickValue) {
          Nf(a);
          return;
        }
      }
  });
}
function Nf(r) {
  r && (r.ignore = !0);
}
function C3(r, t, e, n, i) {
  for (var a = [], o = [], s = [], l = 0; l < r.length; l++) {
    var u = r[l].coord;
    o[0] = u, o[1] = 0, s[0] = u, s[1] = e, t && (rr(o, o, t), rr(s, s, t));
    var c = new sr({
      shape: {
        x1: o[0],
        y1: o[1],
        x2: s[0],
        y2: s[1]
      },
      style: n,
      z2: 2,
      autoBatch: !0,
      silent: !0
    });
    nc(c.shape, c.style.lineWidth), c.anid = i + "_" + r[l].tickValue, a.push(c);
    var f = w3(c);
    f.onBand = !!r[l].onBand, f.tickValue = r[l].tickValue;
  }
  return a;
}
function ZK(r, t, e, n) {
  var i = n.axis, a = n.getModel("axisTick"), o = a.get("show");
  if (o === "auto" && (o = !0, r.raw.axisTickAutoShow != null && (o = !!r.raw.axisTickAutoShow)), !o || i.scale.isBlank())
    return [];
  for (var s = a.getModel("lineStyle"), l = r.tickDirection * a.get("length"), u = i.getTicksCoords(), c = C3(u, e.transform, l, kt(s.getLineStyle(), {
    stroke: n.get(["axisLine", "lineStyle", "color"])
  }), "ticks"), f = 0; f < c.length; f++)
    t.add(c[f]);
  return c;
}
function qK(r, t, e, n, i) {
  var a = n.axis, o = n.getModel("minorTick");
  if (!(!r.showMinorTicks || a.scale.isBlank())) {
    var s = a.getMinorTicksCoords();
    if (s.length)
      for (var l = o.getModel("lineStyle"), u = i * o.get("length"), c = kt(l.getLineStyle(), kt(n.getModel("axisTick").getLineStyle(), {
        stroke: n.get(["axisLine", "lineStyle", "color"])
      })), f = 0; f < s.length; f++)
        for (var h = C3(s[f], e.transform, u, c, "minorticks_" + f), d = 0; d < h.length; d++)
          t.add(h[d]);
  }
}
function jC(r, t, e) {
  if (D3(r)) {
    var n = r.axisLabelsCreationContext;
    process.env.NODE_ENV !== "production" && St(r.labelGroup && n);
    var i = n.out.noPxChangeTryDetermine;
    if (e.noPxChange) {
      for (var a = !0, o = 0; o < i.length; o++)
        a = a && i[o]();
      if (a)
        return !1;
    }
    i.length && (t.remove(r.labelGroup), yS(r, null, null, null));
  }
  return !0;
}
function KK(r, t, e, n, i, a) {
  var o = i.axis, s = gr(r.raw.axisLabelShow, i.get(["axisLabel", "show"])), l = new Et();
  e.add(l);
  var u = Jv(n);
  if (!s || o.scale.isBlank()) {
    yS(t, [], l, u);
    return;
  }
  var c = i.getModel("axisLabel"), f = o.getViewLabels(u), h = (gr(r.raw.labelRotate, c.get("rotate")) || 0) * Ao / 180, d = cn.innerTextLayout(r.rotation, h, r.labelDirection), p = i.getCategories && i.getCategories(!0), g = [], v = i.get("triggerEvent"), m = 1 / 0, y = -1 / 0;
  L(f, function(x, b) {
    var S, w = o.scale.type === "ordinal" ? o.scale.getRawOrdinalNumber(x.tickValue) : x.tickValue, A = x.formattedLabel, T = x.rawLabel, M = c;
    if (p && p[w]) {
      var E = p[w];
      Dt(E) && E.textStyle && (M = new ue(E.textStyle, c, i.ecModel));
    }
    var R = M.getTextColor() || i.get(["axisLine", "lineStyle", "color"]), C = M.getShallow("align", !0) || d.textAlign, D = bt(M.getShallow("alignMinLabel", !0), C), I = bt(M.getShallow("alignMaxLabel", !0), C), P = M.getShallow("verticalAlign", !0) || M.getShallow("baseline", !0) || d.textVerticalAlign, O = bt(M.getShallow("verticalAlignMinLabel", !0), P), N = bt(M.getShallow("verticalAlignMaxLabel", !0), P), B = 10 + (((S = x.time) === null || S === void 0 ? void 0 : S.level) || 0);
    m = Math.min(m, B), y = Math.max(y, B);
    var F = new pe({
      // --- transform props start ---
      // All of the transform props MUST not be set here, but should be set in
      // `updateAxisLabelChangableProps`, because they may change in estimation,
      // and need to calculate based on global coord sys by `decomposeTransform`.
      x: 0,
      y: 0,
      rotation: 0,
      // --- transform props end ---
      silent: cn.isLabelSilent(i),
      z2: B,
      style: Oe(M, {
        text: A,
        align: b === 0 ? D : b === f.length - 1 ? I : C,
        verticalAlign: b === 0 ? O : b === f.length - 1 ? N : P,
        fill: Tt(R) ? R(
          // (1) In category axis with data zoom, tick is not the original
          // index of axis.data. So tick should not be exposed to user
          // in category axis.
          // (2) Compatible with previous version, which always use formatted label as
          // input. But in interval scale the formatted label is like '223,445', which
          // maked user replace ','. So we modify it to return original val but remain
          // it as 'string' to avoid error in replacing.
          o.type === "category" ? T : o.type === "value" ? w + "" : w,
          b
        ) : R
      })
    });
    F.anid = "label_" + w;
    var G = fc(F);
    if (G.break = x.break, G.tickValue = w, G.layoutRotation = d.rotation, Ka({
      el: F,
      componentModel: i,
      itemName: A,
      formatterParamsExtra: {
        isTruncated: function() {
          return F.isTruncated;
        },
        value: T,
        tickIndex: b
      }
    }), v) {
      var X = cn.makeAxisEventDataBase(i);
      X.targetType = "axisLabel", X.value = T, X.tickIndex = b, x.break && (X.break = {
        // type: labelItem.break.type,
        start: x.break.parsedBreak.vmin,
        end: x.break.parsedBreak.vmax
      }), o.type === "category" && (X.dataIndex = w), zt(F).eventData = X, x.break && QK(i, a, F, x.break);
    }
    g.push(F), l.add(F);
  });
  var _ = rt(g, function(x) {
    return {
      label: x,
      priority: fc(x).break ? x.z2 + (y - m + 1) : x.z2,
      defaultAttr: {
        ignore: x.ignore
      }
    };
  });
  yS(t, _, l, u);
}
function D3(r) {
  return !!r.labelLayoutList;
}
function yS(r, t, e, n) {
  r.labelLayoutList = t, r.labelGroup = e, r.axisLabelsCreationContext = n;
}
function jK(r, t, e, n) {
  var i = t.get(["axisLabel", "margin"]);
  L(e, function(a, o) {
    var s = sa(a);
    if (s) {
      var l = s.label, u = fc(l);
      s.suggestIgnore = l.ignore, l.ignore = !1, Ev(xa, JK), xa.x = t.axis.dataToCoord(u.tickValue), xa.y = r.labelOffset + r.labelDirection * i, xa.rotation = u.layoutRotation, n.add(xa), xa.updateTransform(), n.remove(xa), xa.decomposeTransform(), Ev(l, xa), l.markRedraw(), rg(s, !0), sa(s);
    }
  });
}
var xa = new te(), JK = new te();
function Pb(r) {
  return !!r;
}
function QK(r, t, e, n) {
  e.on("click", function(i) {
    var a = {
      type: mm,
      breaks: [{
        start: n.parsedBreak.breakOption.start,
        end: n.parsedBreak.breakOption.end
      }]
    };
    a[r.axis.dim + "AxisIndex"] = r.componentIndex, t.dispatchAction(a);
  });
}
function tj(r, t, e) {
  var n = lr();
  if (n) {
    var i = n.retrieveAxisBreakPairs(e, function(o) {
      return o && fc(o.label).break;
    }, !0), a = r.get(["breakLabelLayout", "moveOverlap"], !0);
    (a === !0 || a === "auto") && L(i, function(o) {
      Zh().adjustBreakLabelPair(r.axis.inverse, t, [sa(e[o[0]]), sa(e[o[1]])]);
    });
  }
}
function og(r, t, e) {
  e = e || {};
  var n = t.axis, i = {}, a = n.getAxesOnZeroOf()[0], o = n.position, s = a ? "onZero" : o, l = n.dim, u = [r.x, r.x + r.width, r.y, r.y + r.height], c = {
    left: 0,
    right: 1,
    top: 0,
    bottom: 1,
    onZero: 2
  }, f = t.get("offset") || 0, h = l === "x" ? [u[2] - f, u[3] + f] : [u[0] - f, u[1] + f];
  if (a) {
    var d = a.toGlobalCoord(a.dataToCoord(0));
    h[c.onZero] = Math.max(Math.min(d, h[1]), h[0]);
  }
  i.position = [l === "y" ? h[c[s]] : u[0], l === "x" ? h[c[s]] : u[3]], i.rotation = Math.PI / 2 * (l === "x" ? 0 : 1);
  var p = {
    top: -1,
    bottom: 1,
    left: -1,
    right: 1
  };
  i.labelDirection = i.tickDirection = i.nameDirection = p[o], i.labelOffset = a ? h[c[o]] - h[c.onZero] : 0, t.get(["axisTick", "inside"]) && (i.tickDirection = -i.tickDirection), gr(e.labelInside, t.get(["axisLabel", "inside"])) && (i.labelDirection = -i.labelDirection);
  var g = t.get(["axisLabel", "rotate"]);
  return i.labelRotate = s === "top" ? -g : g, i.z2 = 1, i;
}
function ej(r) {
  return r.coordinateSystem && r.coordinateSystem.type === "cartesian2d";
}
function JC(r) {
  var t = {
    xAxisModel: null,
    yAxisModel: null
  };
  return L(t, function(e, n) {
    var i = n.replace(/Model$/, ""), a = r.getReferringComponents(i, Ke).models[0];
    if (process.env.NODE_ENV !== "production" && !a)
      throw new Error(i + ' "' + ln(r.get(i + "Index"), r.get(i + "Id"), 0) + '" not found');
    t[n] = a;
  }), t;
}
function rj(r, t, e, n, i, a) {
  for (var o = og(r, e), s = !1, l = !1, u = 0; u < t.length; u++)
    nS(t[u].getOtherAxis(e.axis).scale) && (s = l = !0, e.axis.type === "category" && e.axis.onBand && (l = !1));
  return o.axisLineAutoShow = s, o.axisTickAutoShow = l, o.defaultNameMoveOverlap = a, new cn(e, n, o, i);
}
function nj(r, t, e) {
  var n = og(t, e);
  if (process.env.NODE_ENV !== "production") {
    var i = r.__getRawCfg();
    L(se(n), function(a) {
      a !== "position" && a !== "labelOffset" && St(n[a] === i[a]);
    });
  }
  r.updateCfg(n);
}
function L3(r, t, e) {
  var n, i = Ya.prototype, a = i.getTicks.call(e), o = i.getTicks.call(e, {
    expandToNicedExtent: !0
  }), s = a.length - 1, l = i.getInterval.call(e), u = Sk(r, t), c = u.extent, f = u.fixMin, h = u.fixMax;
  r.type === "log" && (c = iS(r.base, c, !0)), r.setBreaksFromOption(wk(t)), r.setExtent(c[0], c[1]), r.calcNiceExtent({
    splitNumber: s,
    fixMin: f,
    fixMax: h
  });
  var d = i.getExtent.call(r);
  f && (c[0] = d[0]), h && (c[1] = d[1]);
  var p = i.getInterval.call(r), g = c[0], v = c[1];
  if (f && h)
    p = (v - g) / s;
  else if (f)
    for (v = c[0] + p * s; v < c[1] && isFinite(v) && isFinite(c[1]); )
      p = g0(p), v = c[0] + p * s;
  else if (h)
    for (g = c[1] - p * s; g > c[0] && isFinite(g) && isFinite(c[0]); )
      p = g0(p), g = c[1] - p * s;
  else {
    var m = r.getTicks().length - 1;
    m > s && (p = g0(p));
    var y = p * s;
    v = Math.ceil(c[1] / p) * p, g = or(v - y), g < 0 && c[0] >= 0 ? (g = 0, v = or(y)) : v > 0 && c[1] <= 0 && (v = 0, g = -or(y));
  }
  var _ = (a[0].value - o[0].value) / l, x = (a[s].value - o[s].value) / l;
  if (i.setExtent.call(r, g + p * _, v + p * x), i.setInterval.call(r, p), (_ || x) && i.setNiceExtent.call(r, g + p, v - p), process.env.NODE_ENV !== "production") {
    var b = i.getTicks.call(r);
    b[1] && (!F$(p) || _x(b[1].value) > _x(p)) && Xe("The ticks may be not readable when set min: " + t.get("min") + ", max: " + t.get("max") + (" and alignTicks: true. (" + ((n = t.axis) === null || n === void 0 ? void 0 : n.dim) + "AxisIndex: " + t.componentIndex + ")"), !0);
  }
}
var QC = [
  [3, 1],
  [0, 2]
  // xyIdx 1 => 'y'
], ij = (
  /** @class */
  function() {
    function r(t, e, n) {
      this.type = "grid", this._coordsMap = {}, this._coordsList = [], this._axesMap = {}, this._axesList = [], this.axisPointerEnabled = !0, this.dimensions = mS, this._initCartesian(t, e, n), this.model = t;
    }
    return r.prototype.getRect = function() {
      return this._rect;
    }, r.prototype.update = function(t, e) {
      var n = this._axesMap;
      this._updateScale(t, this.model);
      function i(o) {
        var s, l = se(o), u = l.length;
        if (u) {
          for (var c = [], f = u - 1; f >= 0; f--) {
            var h = +l[f], d = o[h], p = d.model, g = d.scale;
            // Only value and log axis without interval support alignTicks.
            nS(g) && p.get("alignTicks") && p.get("interval") == null ? c.push(d) : (sc(g, p), nS(g) && (s = d));
          }
          c.length && (s || (s = c.pop(), sc(s.scale, s.model)), L(c, function(v) {
            L3(v.scale, v.model, s.scale);
          }));
        }
      }
      i(n.x), i(n.y);
      var a = {};
      L(n.x, function(o) {
        tD(n, "y", o, a);
      }), L(n.y, function(o) {
        tD(n, "x", o, a);
      }), this.resize(this.model, e);
    }, r.prototype.resize = function(t, e, n) {
      var i = xr(t, e), a = this._rect = He(t.getBoxLayoutParams(), i.refContainer), o = this._axesMap, s = this._coordsList, l = t.get("containLabel");
      if (_S(o, a), !n) {
        var u = sj(a, s, o, l, e), c = void 0;
        if (l)
          xS ? (xS(this._axesList, a), _S(o, a)) : (process.env.NODE_ENV !== "production" && IP("Specified `grid.containLabel` but no `use(LegacyGridContainLabel)`;use `grid.outerBounds` instead.", !0), c = nD(a.clone(), "axisLabel", null, a, o, u, i));
        else {
          var f = lj(t, a, i), h = f.outerBoundsRect, d = f.parsedOuterBoundsContain, p = f.outerBoundsClamp;
          h && (c = nD(h, d, p, a, o, u, i));
        }
        R3(a, o, wi.determine, null, c, i);
      }
      L(this._coordsList, function(g) {
        g.calcAffineTransform();
      });
    }, r.prototype.getAxis = function(t, e) {
      var n = this._axesMap[t];
      if (n != null)
        return n[e || 0];
    }, r.prototype.getAxes = function() {
      return this._axesList.slice();
    }, r.prototype.getCartesian = function(t, e) {
      if (t != null && e != null) {
        var n = "x" + t + "y" + e;
        return this._coordsMap[n];
      }
      Dt(t) && (e = t.yAxisIndex, t = t.xAxisIndex);
      for (var i = 0, a = this._coordsList; i < a.length; i++)
        if (a[i].getAxis("x").index === t || a[i].getAxis("y").index === e)
          return a[i];
    }, r.prototype.getCartesians = function() {
      return this._coordsList.slice();
    }, r.prototype.convertToPixel = function(t, e, n) {
      var i = this._findConvertTarget(e);
      return i.cartesian ? i.cartesian.dataToPoint(n) : i.axis ? i.axis.toGlobalCoord(i.axis.dataToCoord(n)) : null;
    }, r.prototype.convertFromPixel = function(t, e, n) {
      var i = this._findConvertTarget(e);
      return i.cartesian ? i.cartesian.pointToData(n) : i.axis ? i.axis.coordToData(i.axis.toLocalCoord(n)) : null;
    }, r.prototype._findConvertTarget = function(t) {
      var e = t.seriesModel, n = t.xAxisModel || e && e.getReferringComponents("xAxis", Ke).models[0], i = t.yAxisModel || e && e.getReferringComponents("yAxis", Ke).models[0], a = t.gridModel, o = this._coordsList, s, l;
      if (e)
        s = e.coordinateSystem, Zt(o, s) < 0 && (s = null);
      else if (n && i)
        s = this.getCartesian(n.componentIndex, i.componentIndex);
      else if (n)
        l = this.getAxis("x", n.componentIndex);
      else if (i)
        l = this.getAxis("y", i.componentIndex);
      else if (a) {
        var u = a.coordinateSystem;
        u === this && (s = this._coordsList[0]);
      }
      return {
        cartesian: s,
        axis: l
      };
    }, r.prototype.containPoint = function(t) {
      var e = this._coordsList[0];
      if (e)
        return e.containPoint(t);
    }, r.prototype._initCartesian = function(t, e, n) {
      var i = this, a = this, o = {
        left: !1,
        right: !1,
        top: !1,
        bottom: !1
      }, s = {
        x: {},
        y: {}
      }, l = {
        x: 0,
        y: 0
      };
      if (e.eachComponent("xAxis", u("x"), this), e.eachComponent("yAxis", u("y"), this), !l.x || !l.y) {
        this._axesMap = {}, this._axesList = [];
        return;
      }
      this._axesMap = s, L(s.x, function(c, f) {
        L(s.y, function(h, d) {
          var p = "x" + f + "y" + d, g = new OK(p);
          g.master = i, g.model = t, i._coordsMap[p] = g, i._coordsList.push(g), g.addAxis(c), g.addAxis(h);
        });
      });
      function u(c) {
        return function(f, h) {
          if (I0(f, t)) {
            var d = f.get("position");
            c === "x" ? d !== "top" && d !== "bottom" && (d = o.bottom ? "top" : "bottom") : d !== "left" && d !== "right" && (d = o.left ? "right" : "left"), o[d] = !0;
            var p = new x3(c, pm(f), [0, 0], f.get("type"), d), g = p.type === "category";
            p.onBand = g && f.get("boundaryGap"), p.inverse = f.get("inverse"), f.axis = p, p.model = f, p.grid = a, p.index = h, a._axesList.push(p), s[c][h] = p, l[c]++;
          }
        };
      }
    }, r.prototype._updateScale = function(t, e) {
      L(this._axesList, function(i) {
        if (i.scale.setExtent(1 / 0, -1 / 0), i.type === "category") {
          var a = i.model.get("categorySortInfo");
          i.scale.setSortInfo(a);
        }
      }), t.eachSeries(function(i) {
        if (ej(i)) {
          var a = JC(i), o = a.xAxisModel, s = a.yAxisModel;
          if (!I0(o, e) || !I0(s, e))
            return;
          var l = this.getCartesian(o.componentIndex, s.componentIndex), u = i.getData(), c = l.getAxis("x"), f = l.getAxis("y");
          n(u, c), n(u, f);
        }
      }, this);
      function n(i, a) {
        L(jv(i, a.dim), function(o) {
          a.scale.unionExtentFromData(i, o);
        });
      }
    }, r.prototype.getTooltipAxes = function(t) {
      var e = [], n = [];
      return L(this.getCartesians(), function(i) {
        var a = t != null && t !== "auto" ? i.getAxis(t) : i.getBaseAxis(), o = i.getOtherAxis(a);
        Zt(e, a) < 0 && e.push(a), Zt(n, o) < 0 && n.push(o);
      }), {
        baseAxes: e,
        otherAxes: n
      };
    }, r.create = function(t, e) {
      var n = [];
      return t.eachComponent("grid", function(i, a) {
        var o = new r(i, t, e);
        o.name = "grid_" + a, o.resize(i, e, !0), i.coordinateSystem = o, n.push(o);
      }), t.eachSeries(function(i) {
        zh({
          targetModel: i,
          coordSysType: "cartesian2d",
          coordSysProvider: a
        });
        function a() {
          var o = JC(i), s = o.xAxisModel, l = o.yAxisModel, u = s.getCoordSysModel();
          if (process.env.NODE_ENV !== "production") {
            if (!u)
              throw new Error('Grid "' + ln(s.get("gridIndex"), s.get("gridId"), 0) + '" not found');
            if (s.getCoordSysModel() !== l.getCoordSysModel())
              throw new Error("xAxis and yAxis must use the same grid");
          }
          var c = u.coordinateSystem;
          return c.getCartesian(s.componentIndex, l.componentIndex);
        }
      }), n;
    }, r.dimensions = mS, r;
  }()
);
function I0(r, t) {
  return r.getCoordSysModel() === t;
}
function tD(r, t, e, n) {
  e.getAxesOnZeroOf = function() {
    return a ? [a] : [];
  };
  var i = r[t], a, o = e.model, s = o.get(["axisLine", "onZero"]), l = o.get(["axisLine", "onZeroAxisIndex"]);
  if (!s)
    return;
  if (l != null)
    eD(i[l]) && (a = i[l]);
  else
    for (var u in i)
      if (i.hasOwnProperty(u) && eD(i[u]) && !n[c(i[u])]) {
        a = i[u];
        break;
      }
  a && (n[c(a)] = !0);
  function c(f) {
    return f.dim + "_" + f.index;
  }
}
function eD(r) {
  return r && r.type !== "category" && r.type !== "time" && cZ(r);
}
function aj(r, t) {
  var e = r.getExtent(), n = e[0] + e[1];
  r.toGlobalCoord = r.dim === "x" ? function(i) {
    return i + t;
  } : function(i) {
    return n - i + t;
  }, r.toLocalCoord = r.dim === "x" ? function(i) {
    return i - t;
  } : function(i) {
    return n - i + t;
  };
}
function _S(r, t) {
  L(r.x, function(e) {
    return rD(e, t.x, t.width);
  }), L(r.y, function(e) {
    return rD(e, t.y, t.height);
  });
}
function rD(r, t, e) {
  var n = [0, e], i = r.inverse ? 1 : 0;
  r.setExtent(n[i], n[1 - i]), aj(r, t);
}
var xS;
function oj(r) {
  xS = r;
}
function nD(r, t, e, n, i, a, o) {
  process.env.NODE_ENV !== "production" && St(t === "all" || t === "axisLabel"), R3(n, i, wi.estimate, t, !1, o);
  var s = [0, 0, 0, 0];
  u(0), u(1), c(n, 0, NaN), c(n, 1, NaN);
  var l = wl(s, function(h) {
    return h > 0;
  }) == null;
  return gl(n, s, !0, !0, e), _S(i, n), l;
  function u(h) {
    L(i[Wt[h]], function(d) {
      if (vh(d.model)) {
        var p = a.ensureRecord(d.model), g = p.labelInfoList;
        if (g)
          for (var v = 0; v < g.length; v++) {
            var m = g[v], y = d.scale.normalize(fc(m.label).tickValue);
            y = h === 1 ? 1 - y : y, c(m.rect, h, y), c(m.rect, 1 - h, NaN);
          }
        var _ = p.nameLayout;
        if (_) {
          var y = lc(p.nameLocation) ? 0.5 : NaN;
          c(_.rect, h, y), c(_.rect, 1 - h, NaN);
        }
      }
    });
  }
  function c(h, d, p) {
    var g = r[Wt[d]] - h[Wt[d]], v = h[ur[d]] + h[Wt[d]] - (r[ur[d]] + r[Wt[d]]);
    g = f(g, 1 - p), v = f(v, p);
    var m = QC[d][0], y = QC[d][1];
    s[m] = tr(s[m], g), s[y] = tr(s[y], v);
  }
  function f(h, d) {
    return h > 0 && !Or(d) && d > 1e-4 && (h /= d), h;
  }
}
function sj(r, t, e, n, i) {
  var a = new M3(uj);
  return L(e, function(o) {
    return L(o, function(s) {
      if (vh(s.model)) {
        var l = !n;
        s.axisBuilder = rj(r, t, s.model, i, a, l);
      }
    });
  }), a;
}
function R3(r, t, e, n, i, a) {
  var o = e === wi.determine;
  L(t, function(u) {
    return L(u, function(c) {
      vh(c.model) && (nj(c.axisBuilder, r, c.model), c.axisBuilder.build(o ? {
        axisTickLabelDetermine: !0
      } : {
        axisTickLabelEstimate: !0
      }, {
        noPxChange: i
      }));
    });
  });
  var s = {
    x: 0,
    y: 0
  };
  l(0), l(1);
  function l(u) {
    s[Wt[1 - u]] = r[ur[u]] <= a.refContainer[ur[u]] * 0.5 ? 0 : 1 - u === 1 ? 2 : 1;
  }
  L(t, function(u, c) {
    return L(u, function(f) {
      vh(f.model) && ((n === "all" || o) && f.axisBuilder.build({
        axisName: !0
      }, {
        nameMarginLevel: s[c]
      }), o && f.axisBuilder.build({
        axisLine: !0
      }));
    });
  });
}
function lj(r, t, e) {
  var n, i = r.get("outerBoundsMode", !0);
  i === "same" ? n = t.clone() : i == null || i === "auto" ? n = He(r.get("outerBounds", !0) || m3, e.refContainer) : i !== "none" && process.env.NODE_ENV !== "production" && ce("Invalid grid[" + r.componentIndex + "].outerBoundsMode.");
  var a = r.get("outerBoundsContain", !0), o;
  a == null || a === "auto" ? o = "all" : Zt(["all", "axisLabel"], a) < 0 ? (process.env.NODE_ENV !== "production" && ce("Invalid grid[" + r.componentIndex + "].outerBoundsContain."), o = "all") : o = a;
  var s = [Dv(bt(r.get("outerBoundsClampWidth", !0), ag[0]), t.width), Dv(bt(r.get("outerBoundsClampHeight", !0), ag[1]), t.height)];
  return {
    outerBoundsRect: n,
    parsedOuterBoundsContain: o,
    outerBoundsClamp: s
  };
}
var uj = function(r, t, e, n, i, a) {
  var o = e.axis.dim === "x" ? "y" : "x";
  T3(r, t, e, n, i, a), lc(r.nameLocation) || L(t.recordMap[o], function(s) {
    s && s.labelInfoList && s.dirVec && E3(s.labelInfoList, s.dirVec, n, i);
  });
};
function cj(r, t) {
  var e = {
    /**
     * key: makeKey(axis.model)
     * value: {
     *      axis,
     *      coordSys,
     *      axisPointerModel,
     *      triggerTooltip,
     *      triggerEmphasis,
     *      involveSeries,
     *      snap,
     *      seriesModels,
     *      seriesDataCount
     * }
     */
    axesInfo: {},
    seriesInvolved: !1,
    /**
     * key: makeKey(coordSys.model)
     * value: Object: key makeKey(axis.model), value: axisInfo
     */
    coordSysAxesInfo: {},
    coordSysMap: {}
  };
  return fj(e, r, t), e.seriesInvolved && dj(e, r), e;
}
function fj(r, t, e) {
  var n = t.getComponent("tooltip"), i = t.getComponent("axisPointer"), a = i.get("link", !0) || [], o = [];
  L(e.getCoordinateSystems(), function(s) {
    if (!s.axisPointerEnabled)
      return;
    var l = _h(s.model), u = r.coordSysAxesInfo[l] = {};
    r.coordSysMap[l] = s;
    var c = s.model, f = c.getModel("tooltip", n);
    if (L(s.getAxes(), Yt(g, !1, null)), s.getTooltipAxes && n && f.get("show")) {
      var h = f.get("trigger") === "axis", d = f.get(["axisPointer", "type"]) === "cross", p = s.getTooltipAxes(f.get(["axisPointer", "axis"]));
      (h || d) && L(p.baseAxes, Yt(g, d ? "cross" : !0, h)), d && L(p.otherAxes, Yt(g, "cross", !1));
    }
    function g(v, m, y) {
      var _ = y.model.getModel("axisPointer", i), x = _.get("show");
      if (!(!x || x === "auto" && !v && !SS(_))) {
        m == null && (m = _.get("triggerTooltip")), _ = v ? hj(y, f, i, t, v, m) : _;
        var b = _.get("snap"), S = _.get("triggerEmphasis"), w = _h(y.model), A = m || b || y.type === "category", T = r.axesInfo[w] = {
          key: w,
          axis: y,
          coordSys: s,
          axisPointerModel: _,
          triggerTooltip: m,
          triggerEmphasis: S,
          involveSeries: A,
          snap: b,
          useHandle: SS(_),
          seriesModels: [],
          linkGroup: null
        };
        u[w] = T, r.seriesInvolved = r.seriesInvolved || A;
        var M = pj(a, y);
        if (M != null) {
          var E = o[M] || (o[M] = {
            axesInfo: {}
          });
          E.axesInfo[w] = T, E.mapper = a[M].mapper, T.linkGroup = E;
        }
      }
    }
  });
}
function hj(r, t, e, n, i, a) {
  var o = t.getModel("axisPointer"), s = ["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"], l = {};
  L(s, function(h) {
    l[h] = Ct(o.get(h));
  }), l.snap = r.type !== "category" && !!a, o.get("type") === "cross" && (l.type = "line");
  var u = l.label || (l.label = {});
  if (u.show == null && (u.show = !1), i === "cross") {
    var c = o.get(["label", "show"]);
    if (u.show = c ?? !0, !a) {
      var f = l.lineStyle = o.get("crossStyle");
      f && kt(u, f.textStyle);
    }
  }
  return r.model.getModel("axisPointer", new ue(l, e, n));
}
function dj(r, t) {
  t.eachSeries(function(e) {
    var n = e.coordinateSystem, i = e.get(["tooltip", "trigger"], !0), a = e.get(["tooltip", "show"], !0);
    !n || !n.model || i === "none" || i === !1 || i === "item" || a === !1 || e.get(["axisPointer", "show"], !0) === !1 || L(r.coordSysAxesInfo[_h(n.model)], function(o) {
      var s = o.axis;
      n.getAxis(s.dim) === s && (o.seriesModels.push(e), o.seriesDataCount == null && (o.seriesDataCount = 0), o.seriesDataCount += e.getData().count());
    });
  });
}
function pj(r, t) {
  for (var e = t.model, n = t.dim, i = 0; i < r.length; i++) {
    var a = r[i] || {};
    if (P0(a[n + "AxisId"], e.id) || P0(a[n + "AxisIndex"], e.componentIndex) || P0(a[n + "AxisName"], e.name))
      return i;
  }
}
function P0(r, t) {
  return r === "all" || et(r) && Zt(r, t) >= 0 || r === t;
}
function vj(r) {
  var t = Nb(r);
  if (t) {
    var e = t.axisPointerModel, n = t.axis.scale, i = e.option, a = e.get("status"), o = e.get("value");
    o != null && (o = n.parse(o));
    var s = SS(e);
    a == null && (i.status = s ? "show" : "hide");
    var l = n.getExtent().slice();
    l[0] > l[1] && l.reverse(), // Pick a value on axis when initializing.
    (o == null || o > l[1]) && (o = l[1]), o < l[0] && (o = l[0]), i.value = o, s && (i.status = t.axis.scale.isBlank() ? "hide" : "show");
  }
}
function Nb(r) {
  var t = (r.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
  return t && t.axesInfo[_h(r)];
}
function gj(r) {
  var t = Nb(r);
  return t && t.axisPointerModel;
}
function SS(r) {
  return !!r.get(["handle", "show"]);
}
function _h(r) {
  return r.type + "||" + r.id;
}
var N0 = {}, Rl = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n, i, a) {
      this.axisPointerClass && vj(e), r.prototype.render.apply(this, arguments), this._doUpdateAxisPointerClass(e, i, !0);
    }, t.prototype.updateAxisPointer = function(e, n, i, a) {
      this._doUpdateAxisPointerClass(e, i, !1);
    }, t.prototype.remove = function(e, n) {
      var i = this._axisPointer;
      i && i.remove(n);
    }, t.prototype.dispose = function(e, n) {
      this._disposeAxisPointer(n), r.prototype.dispose.apply(this, arguments);
    }, t.prototype._doUpdateAxisPointerClass = function(e, n, i) {
      var a = t.getAxisPointerClass(this.axisPointerClass);
      if (a) {
        var o = gj(e);
        o ? (this._axisPointer || (this._axisPointer = new a())).render(e, o, n, i) : this._disposeAxisPointer(n);
      }
    }, t.prototype._disposeAxisPointer = function(e) {
      this._axisPointer && this._axisPointer.dispose(e), this._axisPointer = null;
    }, t.registerAxisPointerClass = function(e, n) {
      if (process.env.NODE_ENV !== "production" && N0[e])
        throw new Error("axisPointer " + e + " exists");
      N0[e] = n;
    }, t.getAxisPointerClass = function(e) {
      return e && N0[e];
    }, t.type = "axis", t;
  }(Ue)
), bS = ee();
function I3(r, t, e, n) {
  var i = e.axis;
  if (!i.scale.isBlank()) {
    var a = e.getModel("splitArea"), o = a.getModel("areaStyle"), s = o.get("color"), l = n.coordinateSystem.getRect(), u = i.getTicksCoords({
      tickModel: a,
      clamp: !0,
      breakTicks: "none",
      pruneByBreak: "preserve_extent_bound"
    });
    if (u.length) {
      var c = s.length, f = bS(r).splitAreaColors, h = wt(), d = 0;
      if (f)
        for (var p = 0; p < u.length; p++) {
          var g = f.get(u[p].tickValue);
          if (g != null) {
            d = (g + (c - 1) * p) % c;
            break;
          }
        }
      var v = i.toGlobalCoord(u[0].coord), m = o.getAreaStyle();
      s = et(s) ? s : [s];
      for (var p = 1; p < u.length; p++) {
        var y = i.toGlobalCoord(u[p].coord), _ = void 0, x = void 0, b = void 0, S = void 0;
        i.isHorizontal() ? (_ = v, x = l.y, b = y - _, S = l.height, v = _ + b) : (_ = l.x, x = v, b = l.width, S = y - x, v = x + S);
        var w = u[p - 1].tickValue;
        w != null && h.set(w, d), t.add(new te({
          anid: w != null ? "area_" + w : null,
          shape: {
            x: _,
            y: x,
            width: b,
            height: S
          },
          style: kt({
            fill: s[d]
          }, m),
          autoBatch: !0,
          silent: !0
        })), d = (d + 1) % c;
      }
      bS(r).splitAreaColors = h;
    }
  }
}
function P3(r) {
  bS(r).splitAreaColors = null;
}
var mj = ["splitArea", "splitLine", "minorSplitLine", "breakArea"], N3 = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.axisPointerClass = "CartesianAxisPointer", e;
    }
    return t.prototype.render = function(e, n, i, a) {
      this.group.removeAll();
      var o = this._axisGroup;
      if (this._axisGroup = new Et(), this.group.add(this._axisGroup), !!vh(e)) {
        this._axisGroup.add(e.axis.axisBuilder.group), L(mj, function(l) {
          e.get([l, "show"]) && yj[l](this, this._axisGroup, e, e.getCoordSysModel(), i);
        }, this);
        var s = a && a.type === "changeAxisOrder" && a.isInitSort;
        s || Bh(o, this._axisGroup, e), r.prototype.render.call(this, e, n, i, a);
      }
    }, t.prototype.remove = function() {
      P3(this);
    }, t.type = "cartesianAxis", t;
  }(Rl)
), yj = {
  splitLine: function(r, t, e, n, i) {
    var a = e.axis;
    if (!a.scale.isBlank()) {
      var o = e.getModel("splitLine"), s = o.getModel("lineStyle"), l = s.get("color"), u = o.get("showMinLine") !== !1, c = o.get("showMaxLine") !== !1;
      l = et(l) ? l : [l];
      for (var f = n.coordinateSystem.getRect(), h = a.isHorizontal(), d = 0, p = a.getTicksCoords({
        tickModel: o,
        breakTicks: "none",
        pruneByBreak: "preserve_extent_bound"
      }), g = [], v = [], m = s.getLineStyle(), y = 0; y < p.length; y++) {
        var _ = a.toGlobalCoord(p[y].coord);
        if (!(y === 0 && !u || y === p.length - 1 && !c)) {
          var x = p[y].tickValue;
          h ? (g[0] = _, g[1] = f.y, v[0] = _, v[1] = f.y + f.height) : (g[0] = f.x, g[1] = _, v[0] = f.x + f.width, v[1] = _);
          var b = d++ % l.length, S = new sr({
            anid: x != null ? "line_" + x : null,
            autoBatch: !0,
            shape: {
              x1: g[0],
              y1: g[1],
              x2: v[0],
              y2: v[1]
            },
            style: kt({
              stroke: l[b]
            }, m),
            silent: !0
          });
          nc(S.shape, m.lineWidth), t.add(S);
        }
      }
    }
  },
  minorSplitLine: function(r, t, e, n, i) {
    var a = e.axis, o = e.getModel("minorSplitLine"), s = o.getModel("lineStyle"), l = n.coordinateSystem.getRect(), u = a.isHorizontal(), c = a.getMinorTicksCoords();
    if (c.length)
      for (var f = [], h = [], d = s.getLineStyle(), p = 0; p < c.length; p++)
        for (var g = 0; g < c[p].length; g++) {
          var v = a.toGlobalCoord(c[p][g].coord);
          u ? (f[0] = v, f[1] = l.y, h[0] = v, h[1] = l.y + l.height) : (f[0] = l.x, f[1] = v, h[0] = l.x + l.width, h[1] = v);
          var m = new sr({
            anid: "minor_line_" + c[p][g].tickValue,
            autoBatch: !0,
            shape: {
              x1: f[0],
              y1: f[1],
              x2: h[0],
              y2: h[1]
            },
            style: d,
            silent: !0
          });
          nc(m.shape, d.lineWidth), t.add(m);
        }
  },
  splitArea: function(r, t, e, n, i) {
    I3(r, t, e, n);
  },
  breakArea: function(r, t, e, n, i) {
    var a = Zh(), o = e.axis.scale;
    a && o.type !== "ordinal" && a.rectCoordBuildBreakAxis(t, r, e, n.coordinateSystem.getRect(), i);
  }
}, O3 = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.type = "xAxis", t;
  }(N3)
), _j = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = O3.type, e;
    }
    return t.type = "yAxis", t;
  }(N3)
), xj = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = "grid", e;
    }
    return t.prototype.render = function(e, n) {
      this.group.removeAll(), e.get("show") && this.group.add(new te({
        shape: e.coordinateSystem.getRect(),
        style: kt({
          fill: e.get("backgroundColor")
        }, e.getItemStyle()),
        silent: !0,
        z2: -1
      }));
    }, t.type = "grid", t;
  }(Ue)
), iD = {
  // gridIndex: 0,
  // gridId: '',
  offset: 0
};
function k3(r) {
  r.registerComponentView(xj), r.registerComponentModel(CK), r.registerCoordinateSystem("cartesian2d", ij), cc(r, "x", vS, iD), cc(r, "y", vS, iD), r.registerComponentView(O3), r.registerComponentView(_j), r.registerPreprocessor(function(t) {
    t.xAxis && t.yAxis && !t.grid && (t.grid = {});
  });
}
function Sj(r, t) {
  var e = r.coordinateSystem, n = e && e.type, i = e && e.getBaseAxis && e.getBaseAxis(), a = i && i.scale && i.scale.type, o = n === "cartesian2d" && a === "ordinal" || n === "single", s = t.model.get("jitter") > 0;
  return o && s;
}
var bj = ee();
function aD(r, t, e, n) {
  if (r instanceof x3) {
    var i = r.scale.type;
    if (i !== "category" && i !== "ordinal")
      return e;
  }
  var a = r.model, o = a.get("jitter"), s = a.get("jitterOverlap"), l = a.get("jitterMargin") || 0, u = r.scale.type === "ordinal" ? r.getBandWidth() : null;
  return o > 0 ? s ? B3(e, o, u, n) : wj(r, t, e, n, o, l) : e;
}
function B3(r, t, e, n) {
  if (e === null)
    return r + (Math.random() - 0.5) * t;
  var i = e - n * 2, a = Math.min(Math.max(0, t), i);
  return r + (Math.random() - 0.5) * a;
}
function wj(r, t, e, n, i, a) {
  var o = bj(r);
  o.items || (o.items = []);
  var s = o.items, l = oD(s, t, e, n, i, a, 1), u = oD(s, t, e, n, i, a, -1), c = Math.abs(l - e) < Math.abs(u - e) ? l : u, f = r.scale.type === "ordinal" ? r.getBandWidth() : null, h = Math.abs(c - e);
  return h > i / 2 || f && h > f / 2 - n ? B3(e, i, f, n) : (s.push({
    fixedCoord: t,
    floatCoord: c,
    r: n
  }), c);
}
function oD(r, t, e, n, i, a, o) {
  for (var s = e, l = 0; l < r.length; l++) {
    var u = r[l], c = t - u.fixedCoord, f = s - u.floatCoord, h = c * c + f * f, d = n + u.r + a;
    if (h < d * d) {
      var p = u.floatCoord + Math.sqrt(d * d - c * c) * o;
      if (Math.abs(p - e) > i / 2)
        return Number.MAX_VALUE;
      if (o === 1 && p > s || o === -1 && p < s) {
        s = p, l = -1;
        continue;
      }
    }
  }
  return s;
}
function Mj(r) {
  r.eachSeriesByType("scatter", function(t) {
    var e = t.coordinateSystem;
    if (e && (e.type === "cartesian2d" || e.type === "single")) {
      var n = e.getBaseAxis ? e.getBaseAxis() : null, i = n && Sj(t, n);
      if (i) {
        var a = t.getData();
        a.each(function(o) {
          var s = n.dim, l = n.orient, u = l === "horizontal" && n.type !== "category" || l === "vertical" && n.type === "category", c = a.getItemLayout(o), f = a.getItemVisual(o, "symbolSize"), h = f instanceof Array ? (f[1] + f[0]) / 2 : f;
          if (s === "y" || s === "single" && u) {
            var d = aD(n, c[0], c[1], h / 2);
            a.setItemLayout(o, [c[0], d]);
          } else if (s === "x" || s === "single" && !u) {
            var d = aD(n, c[1], c[0], h / 2);
            a.setItemLayout(o, [d, c[1]]);
          }
        });
      }
    }
  });
}
function Tj(r) {
  jt(k3), r.registerSeriesModel(wK), r.registerChartView(EK), r.registerLayout($h("scatter"));
}
function Aj(r) {
  r.registerLayout(r.PRIORITY.VISUAL.POST_CHART_LAYOUT, Mj);
}
function Ej(r) {
  r.eachSeriesByType("radar", function(t) {
    var e = t.getData(), n = [], i = t.coordinateSystem;
    if (i) {
      var a = i.getIndicatorAxes();
      L(a, function(o, s) {
        e.each(e.mapDimension(a[s].dim), function(l, u) {
          n[u] = n[u] || [];
          var c = i.dataToPoint(l, s);
          n[u][s] = sD(c) ? c : lD(i);
        });
      }), e.each(function(o) {
        var s = wl(n[o], function(l) {
          return sD(l);
        }) || lD(i);
        n[o].push(s.slice()), e.setItemLayout(o, n[o]);
      });
    }
  });
}
function sD(r) {
  return !isNaN(r[0]) && !isNaN(r[1]);
}
function lD(r) {
  return [r.cx, r.cy];
}
function Cj(r) {
  var t = r.polar;
  if (t) {
    et(t) || (t = [t]);
    var e = [];
    L(t, function(n, i) {
      n.indicator ? (n.type && !n.shape && (n.shape = n.type), r.radar = r.radar || [], et(r.radar) || (r.radar = [r.radar]), r.radar.push(n)) : e.push(n);
    }), r.polar = e;
  }
  L(r.series, function(n) {
    n && n.type === "radar" && n.polarIndex && (n.radarIndex = n.polarIndex);
  });
}
var Dj = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n, i) {
      var a = e.coordinateSystem, o = this.group, s = e.getData(), l = this._data;
      function u(h, d) {
        var p = h.getItemVisual(d, "symbol") || "circle";
        if (p !== "none") {
          var g = Lc(h.getItemVisual(d, "symbolSize")), v = fr(p, -1, -1, 2, 2), m = h.getItemVisual(d, "symbolRotate") || 0;
          return v.attr({
            style: {
              strokeNoScale: !0
            },
            z2: 100,
            scaleX: g[0] / 2,
            scaleY: g[1] / 2,
            rotation: m * Math.PI / 180 || 0
          }), v;
        }
      }
      function c(h, d, p, g, v, m) {
        p.removeAll();
        for (var y = 0; y < d.length - 1; y++) {
          var _ = u(g, v);
          _ && (_.__dimIdx = y, h[y] ? (_.setPosition(h[y]), Al[m ? "initProps" : "updateProps"](_, {
            x: d[y][0],
            y: d[y][1]
          }, e, v)) : _.setPosition(d[y]), p.add(_));
        }
      }
      function f(h) {
        return rt(h, function(d) {
          return [a.cx, a.cy];
        });
      }
      s.diff(l).add(function(h) {
        var d = s.getItemLayout(h);
        if (d) {
          var p = new jr(), g = new Ur(), v = {
            shape: {
              points: d
            }
          };
          p.shape.points = f(d), g.shape.points = f(d), ze(p, v, e, h), ze(g, v, e, h);
          var m = new Et(), y = new Et();
          m.add(g), m.add(p), m.add(y), c(g.shape.points, d, y, s, h, !0), s.setItemGraphicEl(h, m);
        }
      }).update(function(h, d) {
        var p = l.getItemGraphicEl(d), g = p.childAt(0), v = p.childAt(1), m = p.childAt(2), y = {
          shape: {
            points: s.getItemLayout(h)
          }
        };
        y.shape.points && (c(g.shape.points, y.shape.points, m, s, h, !1), ai(v), ai(g), ve(g, y, e), ve(v, y, e), s.setItemGraphicEl(h, p));
      }).remove(function(h) {
        o.remove(l.getItemGraphicEl(h));
      }).execute(), s.eachItemGraphicEl(function(h, d) {
        var p = s.getItemModel(d), g = h.childAt(0), v = h.childAt(1), m = h.childAt(2), y = s.getItemVisual(d, "style"), _ = y.fill;
        o.add(h), g.useStyle(kt(p.getModel("lineStyle").getLineStyle(), {
          fill: "none",
          stroke: _
        })), yr(g, p, "lineStyle"), yr(v, p, "areaStyle");
        var x = p.getModel("areaStyle"), b = x.isEmpty() && x.parentModel.isEmpty();
        v.ignore = b, L(["emphasis", "select", "blur"], function(w) {
          var A = p.getModel([w, "areaStyle"]), T = A.isEmpty() && A.parentModel.isEmpty();
          v.ensureState(w).ignore = T && b;
          var M = p.getModel([w, "lineStyle"]).getLineStyle();
          g.ensureState(w).style = M;
          var E = A.getAreaStyle();
          v.ensureState(w).style = E;
          var R = p.getModel([w, "itemStyle"]).getItemStyle();
          m.eachChild(function(C) {
            C.ensureState(w).style = Ct(R);
          });
        }), v.useStyle(kt(p.getModel("areaStyle").getAreaStyle(), {
          fill: _,
          opacity: 0.7,
          decal: y.decal
        }));
        var S = p.getModel("emphasis");
        m.eachChild(function(w) {
          if (w instanceof Vr) {
            var A = w.style;
            w.useStyle(J({
              // TODO other properties like x, y ?
              image: A.image,
              x: A.x,
              y: A.y,
              width: A.width,
              height: A.height
            }, y));
          } else
            w.useStyle(y), w.setColor(_), w.style.strokeNoScale = !0;
          var T = s.getStore().get(s.getDimensionIndex(w.__dimIdx), d);
          (T == null || isNaN(T)) && (T = ""), Er(w, _r(p), {
            labelFetcher: s.hostModel,
            labelDataIndex: d,
            labelDimIndex: w.__dimIdx,
            defaultText: T,
            inheritColor: _,
            defaultOpacity: y.opacity
          });
        }), Ge(h, S.get("focus"), S.get("blurScope"), S.get("disabled"));
      }), this._data = s;
    }, t.prototype.remove = function() {
      this.group.removeAll(), this._data = null;
    }, t.type = "radar", t;
  }(Re)
), Lj = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.hasSymbolVisual = !0, e;
    }
    return t.prototype.init = function(e) {
      r.prototype.init.apply(this, arguments), this.legendVisualProvider = new Nc(mt(this.getData, this), mt(this.getRawData, this));
    }, t.prototype.getInitialData = function(e, n) {
      return Pc(this, {
        generateCoord: "indicator_",
        generateCoordCount: 1 / 0
      });
    }, t.prototype.formatTooltip = function(e, n, i) {
      var a = this.getData(), o = this.coordinateSystem, s = o.getIndicatorAxes(), l = this.getData().getName(e), u = l === "" ? this.name : l, c = bO(this, e);
      return cr("section", {
        header: u,
        sortBlocks: !0,
        blocks: rt(s, function(f) {
          var h = a.get(a.mapDimension(f.dim), e);
          return cr("nameValue", {
            markerType: "subItem",
            markerColor: c,
            name: f.name,
            value: h,
            sortParam: h
          });
        })
      });
    }, t.prototype.getTooltipPosition = function(e) {
      if (e != null) {
        for (var n = this.getData(), i = this.coordinateSystem, a = n.getValues(rt(i.dimensions, function(u) {
          return n.mapDimension(u);
        }), e), o = 0, s = a.length; o < s; o++)
          if (!isNaN(a[o])) {
            var l = i.getIndicatorAxes();
            return i.coordToPoint(l[o].dataToCoord(a[o]), o);
          }
      }
    }, t.type = "series.radar", t.dependencies = ["radar"], t.defaultOption = {
      // zlevel: 0,
      z: 2,
      colorBy: "data",
      coordinateSystem: "radar",
      legendHoverLink: !0,
      radarIndex: 0,
      lineStyle: {
        width: 2,
        type: "solid",
        join: "round"
      },
      label: {
        position: "top"
      },
      // areaStyle: {
      // },
      // itemStyle: {}
      symbolSize: 8
      // symbolRotate: null
    }, t;
  }(ke)
), uf = _3.value;
function pp(r, t) {
  return kt({
    show: t
  }, r);
}
var Rj = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.optionUpdated = function() {
      var e = this.get("boundaryGap"), n = this.get("splitNumber"), i = this.get("scale"), a = this.get("axisLine"), o = this.get("axisTick"), s = this.get("axisLabel"), l = this.get("axisName"), u = this.get(["axisName", "show"]), c = this.get(["axisName", "formatter"]), f = this.get("axisNameGap"), h = this.get("triggerEvent"), d = rt(this.get("indicator") || [], function(p) {
        p.max != null && p.max > 0 && !p.min ? p.min = 0 : p.min != null && p.min < 0 && !p.max && (p.max = 0);
        var g = l;
        p.color != null && (g = kt({
          color: p.color
        }, l));
        var v = qt(Ct(p), {
          boundaryGap: e,
          splitNumber: n,
          scale: i,
          axisLine: a,
          axisTick: o,
          // axisType: axisType,
          axisLabel: s,
          // Compatible with 2 and use text
          name: p.text,
          showName: u,
          nameLocation: "end",
          nameGap: f,
          // min: 0,
          nameTextStyle: g,
          triggerEvent: h
        }, !1);
        if (pt(c)) {
          var m = v.name;
          v.name = c.replace("{value}", m ?? "");
        } else
          Tt(c) && (v.name = c(v.name, v));
        var y = new ue(v, null, this.ecModel);
        return hr(y, Hh.prototype), y.mainType = "radar", y.componentIndex = this.componentIndex, y;
      }, this);
      this._indicatorModels = d;
    }, t.prototype.getIndicatorModels = function() {
      return this._indicatorModels;
    }, t.type = "radar", t.defaultOption = {
      // zlevel: 0,
      z: 0,
      center: ["50%", "50%"],
      radius: "50%",
      startAngle: 90,
      axisName: {
        show: !0,
        color: Y.color.axisLabel
        // formatter: null
        // textStyle: {}
      },
      boundaryGap: [0, 0],
      splitNumber: 5,
      axisNameGap: 15,
      scale: !1,
      // Polygon or circle
      shape: "polygon",
      axisLine: qt({
        lineStyle: {
          color: Y.color.neutral20
        }
      }, uf.axisLine),
      axisLabel: pp(uf.axisLabel, !1),
      axisTick: pp(uf.axisTick, !1),
      // axisType: 'value',
      splitLine: pp(uf.splitLine, !0),
      splitArea: pp(uf.splitArea, !0),
      // {text, min, max}
      indicator: []
    }, t;
  }(re)
), Ij = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n, i) {
      var a = this.group;
      a.removeAll(), this._buildAxes(e, i), this._buildSplitLineAndArea(e);
    }, t.prototype._buildAxes = function(e, n) {
      var i = e.coordinateSystem, a = i.getIndicatorAxes(), o = rt(a, function(s) {
        var l = s.model.get("showName") ? s.name : "", u = new cn(s.model, n, {
          axisName: l,
          position: [i.cx, i.cy],
          rotation: s.angle,
          labelDirection: -1,
          tickDirection: -1,
          nameDirection: 1
        });
        return u;
      });
      L(o, function(s) {
        s.build(), this.group.add(s.group);
      }, this);
    }, t.prototype._buildSplitLineAndArea = function(e) {
      var n = e.coordinateSystem, i = n.getIndicatorAxes();
      if (!i.length)
        return;
      var a = e.get("shape"), o = e.getModel("splitLine"), s = e.getModel("splitArea"), l = o.getModel("lineStyle"), u = s.getModel("areaStyle"), c = o.get("show"), f = s.get("show"), h = l.get("color"), d = u.get("color"), p = et(h) ? h : [h], g = et(d) ? d : [d], v = [], m = [];
      function y(I, P, O) {
        var N = O % P.length;
        return I[N] = I[N] || [], N;
      }
      if (a === "circle")
        for (var _ = i[0].getTicksCoords(), x = n.cx, b = n.cy, S = 0; S < _.length; S++) {
          if (c) {
            var w = y(v, p, S);
            v[w].push(new qa({
              shape: {
                cx: x,
                cy: b,
                r: _[S].coord
              }
            }));
          }
          if (f && S < _.length - 1) {
            var w = y(m, g, S);
            m[w].push(new Oh({
              shape: {
                cx: x,
                cy: b,
                r0: _[S].coord,
                r: _[S + 1].coord
              }
            }));
          }
        }
      else
        for (var A, T = rt(i, function(I, P) {
          var O = I.getTicksCoords();
          return A = A == null ? O.length - 1 : Math.min(O.length - 1, A), rt(O, function(N) {
            return n.coordToPoint(N.coord, P);
          });
        }), M = [], S = 0; S <= A; S++) {
          for (var E = [], R = 0; R < i.length; R++)
            E.push(T[R][S]);
          if (E[0] ? E.push(E[0].slice()) : process.env.NODE_ENV !== "production" && console.error("Can't draw value axis " + S), c) {
            var w = y(v, p, S);
            v[w].push(new Ur({
              shape: {
                points: E
              }
            }));
          }
          if (f && M) {
            var w = y(m, g, S - 1);
            m[w].push(new jr({
              shape: {
                points: E.concat(M)
              }
            }));
          }
          M = E.slice().reverse();
        }
      var C = l.getLineStyle(), D = u.getAreaStyle();
      L(m, function(I, P) {
        this.group.add(Jn(I, {
          style: kt({
            stroke: "none",
            fill: g[P % g.length]
          }, D),
          silent: !0
        }));
      }, this), L(v, function(I, P) {
        this.group.add(Jn(I, {
          style: kt({
            fill: "none",
            stroke: p[P % p.length]
          }, C),
          silent: !0
        }));
      }, this);
    }, t.type = "radar", t;
  }(Ue)
), Pj = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e, n, i) {
      var a = r.call(this, e, n, i) || this;
      return a.type = "value", a.angle = 0, a.name = "", a;
    }
    return t;
  }(Ai)
), Nj = (
  /** @class */
  function() {
    function r(t, e, n) {
      this.dimensions = [], this._model = t, this._indicatorAxes = rt(t.getIndicatorModels(), function(i, a) {
        var o = "indicator_" + a, s = new Pj(
          o,
          new Ya()
          // (indicatorModel.get('axisType') === 'log') ? new LogScale() : new IntervalScale()
        );
        return s.name = i.get("name"), s.model = i, i.axis = s, this.dimensions.push(o), s;
      }, this), this.resize(t, n);
    }
    return r.prototype.getIndicatorAxes = function() {
      return this._indicatorAxes;
    }, r.prototype.dataToPoint = function(t, e) {
      var n = this._indicatorAxes[e];
      return this.coordToPoint(n.dataToCoord(t), e);
    }, r.prototype.coordToPoint = function(t, e) {
      var n = this._indicatorAxes[e], i = n.angle, a = this.cx + t * Math.cos(i), o = this.cy - t * Math.sin(i);
      return [a, o];
    }, r.prototype.pointToData = function(t) {
      var e = t[0] - this.cx, n = t[1] - this.cy, i = Math.sqrt(e * e + n * n);
      e /= i, n /= i;
      for (var a = Math.atan2(-n, e), o = 1 / 0, s, l = -1, u = 0; u < this._indicatorAxes.length; u++) {
        var c = this._indicatorAxes[u], f = Math.abs(a - c.angle);
        f < o && (s = c, l = u, o = f);
      }
      return [l, +(s && s.coordToData(i))];
    }, r.prototype.resize = function(t, e) {
      var n = xr(t, e).refContainer, i = t.get("center"), a = Math.min(n.width, n.height) / 2;
      this.cx = dt(i[0], n.width) + n.x, this.cy = dt(i[1], n.height) + n.y, this.startAngle = t.get("startAngle") * Math.PI / 180;
      var o = t.get("radius");
      (pt(o) || fe(o)) && (o = [0, o]), this.r0 = dt(o[0], a), this.r = dt(o[1], a), L(this._indicatorAxes, function(s, l) {
        s.setExtent(this.r0, this.r);
        var u = this.startAngle + l * Math.PI * 2 / this._indicatorAxes.length;
        u = Math.atan2(Math.sin(u), Math.cos(u)), s.angle = u;
      }, this);
    }, r.prototype.update = function(t, e) {
      var n = this._indicatorAxes, i = this._model;
      L(n, function(s) {
        s.scale.setExtent(1 / 0, -1 / 0);
      }), t.eachSeriesByType("radar", function(s, l) {
        if (!(s.get("coordinateSystem") !== "radar" || t.getComponent("radar", s.get("radarIndex")) !== i)) {
          var u = s.getData();
          L(n, function(c) {
            c.scale.unionExtentFromData(u, u.mapDimension(c.dim));
          });
        }
      }, this);
      var a = i.get("splitNumber"), o = new Ya();
      o.setExtent(0, a), o.setInterval(1), L(n, function(s, l) {
        L3(s.scale, s.model, o);
      });
    }, r.prototype.convertToPixel = function(t, e, n) {
      return console.warn("Not implemented."), null;
    }, r.prototype.convertFromPixel = function(t, e, n) {
      return console.warn("Not implemented."), null;
    }, r.prototype.containPoint = function(t) {
      return console.warn("Not implemented."), !1;
    }, r.create = function(t, e) {
      var n = [];
      return t.eachComponent("radar", function(i) {
        var a = new r(i, t, e);
        n.push(a), i.coordinateSystem = a;
      }), t.eachSeriesByType("radar", function(i) {
        i.get("coordinateSystem") === "radar" && (i.coordinateSystem = n[i.get("radarIndex") || 0]);
      }), n;
    }, r.dimensions = [], r;
  }()
);
function Oj(r) {
  r.registerCoordinateSystem("radar", Nj), r.registerComponentModel(Rj), r.registerComponentView(Ij), r.registerVisual({
    seriesType: "radar",
    reset: function(t) {
      var e = t.getData();
      e.each(function(n) {
        e.setItemVisual(n, "legendIcon", "roundRect");
      }), e.setVisual("legendIcon", "roundRect");
    }
  });
}
function kj(r) {
  jt(Oj), r.registerChartView(Dj), r.registerSeriesModel(Lj), r.registerLayout(Ej), r.registerProcessor(Ic("radar")), r.registerPreprocessor(Cj);
}
var Ob = ee();
function Bj(r, t, e) {
  Ob(r)[t] = e;
}
function Vj(r, t, e) {
  var n = Ob(r), i = n[t];
  i === e && (n[t] = null);
}
function uD(r, t) {
  return !!Ob(r)[t];
}
ca({
  type: "takeGlobalCursor",
  event: "globalCursorTaken",
  update: "update"
}, er);
var Fj = {
  axisPointer: 1,
  tooltip: 1,
  brush: 1
};
function V3(r, t, e) {
  var n = t.getComponentByElement(r.topTarget);
  if (!n || n === e || Fj.hasOwnProperty(n.mainType))
    return !1;
  var i = n.coordinateSystem;
  if (!i || i.model === e)
    return !1;
  var a = ml(n), o = ml(e);
  return !((a.zlevel - o.zlevel || a.z - o.z) <= 0);
}
var Il = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e) {
      var n = r.call(this) || this;
      n._zr = e;
      var i = mt(n._mousedownHandler, n), a = mt(n._mousemoveHandler, n), o = mt(n._mouseupHandler, n), s = mt(n._mousewheelHandler, n), l = mt(n._pinchHandler, n);
      return n.enable = function(u, c) {
        var f = c.zInfo, h = ml(f.component), d = h.z, p = h.zlevel, g = {
          component: f.component,
          z: d,
          zlevel: p,
          // By default roam controller is the lowest z2 comparing to other elememts in a component.
          z2: bt(f.z2, -1 / 0)
        }, v = J({}, c.triggerInfo);
        this._opt = kt(J({}, c), {
          zoomOnMouseWheel: !0,
          moveOnMouseMove: !0,
          // By default, wheel do not trigger move.
          moveOnMouseWheel: !1,
          preventDefaultMouseMove: !0,
          zInfoParsed: g,
          triggerInfo: v
        }), u == null && (u = !0), (!this._enabled || this._controlType !== u) && (this._enabled = !0, this.disable(), (u === !0 || u === "move" || u === "pan") && (ff(e, "mousedown", i, g), ff(e, "mousemove", a, g), ff(e, "mouseup", o, g)), (u === !0 || u === "scale" || u === "zoom") && (ff(e, "mousewheel", s, g), ff(e, "pinch", l, g)));
      }, n.disable = function() {
        this._enabled = !1, hf(e, "mousedown", i), hf(e, "mousemove", a), hf(e, "mouseup", o), hf(e, "mousewheel", s), hf(e, "pinch", l);
      }, n;
    }
    return t.prototype.isDragging = function() {
      return this._dragging;
    }, t.prototype.isPinching = function() {
      return this._pinching;
    }, t.prototype._checkPointer = function(e, n, i) {
      var a = this._opt, o = a.zInfoParsed;
      if (V3(e, a.api, o.component))
        return !1;
      var s = a.triggerInfo, l = s.roamTrigger, u = !1;
      return l === "global" && (u = !0), u || (u = s.isInSelf(e, n, i)), u && s.isInClip && !s.isInClip(e, n, i) && (u = !1), u;
    }, t.prototype._decideCursorStyle = function(e, n, i, a) {
      var o = e.target;
      if (!o && this._checkPointer(e, n, i))
        return "grab";
      if (a)
        return o && o.cursor || "default";
    }, t.prototype.dispose = function() {
      this.disable();
    }, t.prototype._mousedownHandler = function(e) {
      if (!(MT(e) || cf(e))) {
        for (var n = e.target; n; ) {
          if (n.draggable)
            return;
          n = n.__hostTarget || n.parent;
        }
        var i = e.offsetX, a = e.offsetY;
        this._checkPointer(e, i, a) && (this._x = i, this._y = a, this._dragging = !0);
      }
    }, t.prototype._mousemoveHandler = function(e) {
      var n = this._zr;
      if (!(e.gestureEvent === "pinch" || uD(n, "globalPan") || cf(e))) {
        var i = e.offsetX, a = e.offsetY;
        if (!this._dragging || !rv("moveOnMouseMove", e, this._opt)) {
          var o = this._decideCursorStyle(e, i, a, !1);
          o && n.setCursorStyle(o);
          return;
        }
        n.setCursorStyle("grabbing");
        var s = this._x, l = this._y, u = i - s, c = a - l;
        this._x = i, this._y = a, this._opt.preventDefaultMouseMove && Ua(e.event), e.__ecRoamConsumed = !0, cD(this, "pan", "moveOnMouseMove", e, {
          dx: u,
          dy: c,
          oldX: s,
          oldY: l,
          newX: i,
          newY: a,
          isAvailableBehavior: null
        });
      }
    }, t.prototype._mouseupHandler = function(e) {
      if (!cf(e)) {
        var n = this._zr;
        if (!MT(e)) {
          this._dragging = !1;
          var i = this._decideCursorStyle(e, e.offsetX, e.offsetY, !0);
          i && n.setCursorStyle(i);
        }
      }
    }, t.prototype._mousewheelHandler = function(e) {
      if (!cf(e)) {
        var n = rv("zoomOnMouseWheel", e, this._opt), i = rv("moveOnMouseWheel", e, this._opt), a = e.wheelDelta, o = Math.abs(a), s = e.offsetX, l = e.offsetY;
        if (!(a === 0 || !n && !i)) {
          if (n) {
            var u = o > 3 ? 1.4 : o > 1 ? 1.2 : 1.1, c = a > 0 ? u : 1 / u;
            this._checkTriggerMoveZoom(this, "zoom", "zoomOnMouseWheel", e, {
              scale: c,
              originX: s,
              originY: l,
              isAvailableBehavior: null
            });
          }
          if (i) {
            var f = Math.abs(a), h = (a > 0 ? 1 : -1) * (f > 3 ? 0.4 : f > 1 ? 0.15 : 0.05);
            this._checkTriggerMoveZoom(this, "scrollMove", "moveOnMouseWheel", e, {
              scrollDelta: h,
              originX: s,
              originY: l,
              isAvailableBehavior: null
            });
          }
        }
      }
    }, t.prototype._pinchHandler = function(e) {
      if (!(uD(this._zr, "globalPan") || cf(e))) {
        var n = e.pinchScale > 1 ? 1.1 : 1 / 1.1;
        this._checkTriggerMoveZoom(this, "zoom", null, e, {
          scale: n,
          originX: e.pinchX,
          originY: e.pinchY,
          isAvailableBehavior: null
        });
      }
    }, t.prototype._checkTriggerMoveZoom = function(e, n, i, a, o) {
      e._checkPointer(a, o.originX, o.originY) && (Ua(a.event), a.__ecRoamConsumed = !0, cD(e, n, i, a, o));
    }, t;
  }(oi)
);
function cf(r) {
  return r.__ecRoamConsumed;
}
var zj = ee();
function ym(r) {
  var t = zj(r);
  return t.roam = t.roam || {}, t.uniform = t.uniform || {}, t;
}
function ff(r, t, e, n) {
  for (var i = ym(r), a = i.roam, o = a[t] = a[t] || [], s = 0; s < o.length; s++) {
    var l = o[s].zInfoParsed;
    if ((l.zlevel - n.zlevel || l.z - n.z || l.z2 - n.z2) <= 0)
      break;
  }
  o.splice(s, 0, {
    listener: e,
    zInfoParsed: n
  }), Uj(r, t);
}
function hf(r, t, e) {
  for (var n = ym(r), i = n.roam[t] || [], a = 0; a < i.length; a++)
    if (i[a].listener === e) {
      i.splice(a, 1), i.length || Gj(r, t);
      return;
    }
}
function Uj(r, t) {
  var e = ym(r);
  e.uniform[t] || r.on(t, e.uniform[t] = function(n) {
    var i = e.roam[t];
    if (i)
      for (var a = 0; a < i.length; a++)
        i[a].listener(n);
  });
}
function Gj(r, t) {
  var e = ym(r), n = e.uniform;
  n[t] && (r.off(t, n[t]), n[t] = null);
}
function cD(r, t, e, n, i) {
  i.isAvailableBehavior = mt(rv, null, e, n), r.trigger(t, i);
}
function rv(r, t, e) {
  var n = e[r];
  return !r || n && (!pt(n) || t.event[n + "Key"]);
}
function kb(r, t, e) {
  var n = r.target;
  n.x += t, n.y += e, n.dirty();
}
function Bb(r, t, e, n) {
  var i = r.target, a = r.zoomLimit, o = r.zoom = r.zoom || 1;
  o *= t, o = Vb(o, a);
  var s = o / r.zoom;
  r.zoom = o, z3(i, e, n, s), i.dirty();
}
function F3(r, t, e, n, i, a) {
  var o = new Bt(0, 0, 0, 0);
  n.enable(r.get("roam"), {
    api: t,
    zInfo: {
      component: r
    },
    triggerInfo: {
      roamTrigger: r.get("roamTrigger"),
      isInSelf: function(u, c, f) {
        return o.copy(e.getBoundingRect()), o.applyTransform(e.getComputedTransform()), o.contain(c, f);
      },
      isInClip: function(u, c, f) {
        return !a || a.contain(c, f);
      }
    }
  }), i.zoomLimit = r.get("scaleLimit");
  var s = r.coordinateSystem;
  i.zoom = s ? s.getZoom() : 1;
  var l = r.subType + "Roam";
  n.off("pan").off("zoom").on("pan", function(u) {
    kb(i, u.dx, u.dy), t.dispatchAction({
      seriesId: r.id,
      type: l,
      dx: u.dx,
      dy: u.dy
    });
  }).on("zoom", function(u) {
    Bb(i, u.scale, u.originX, u.originY), t.dispatchAction({
      seriesId: r.id,
      type: l,
      zoom: u.scale,
      originX: u.originX,
      originY: u.originY
    }), t.updateLabelLayout();
  });
}
function fD(r, t) {
  return r.pointToProjected ? r.pointToProjected(t) : r.pointToData(t);
}
function _m(r, t, e) {
  var n = r.getZoom(), i = r.getCenter(), a = t.zoom, o = r.projectedToPoint ? r.projectedToPoint(i) : r.dataToPoint(i);
  return t.dx != null && t.dy != null && (o[0] -= t.dx, o[1] -= t.dy, r.setCenter(fD(r, o))), a != null && (a = Vb(n * a, e) / n, z3(r, t.originX, t.originY, a), r.updateTransform(), r.setCenter(fD(r, o)), r.setZoom(a * n)), {
    center: r.getCenter(),
    zoom: r.getZoom()
  };
}
function z3(r, t, e, n) {
  r.x -= (t - r.x) * (n - 1), r.y -= (e - r.y) * (n - 1), r.scaleX *= n, r.scaleY *= n;
}
function Vb(r, t) {
  if (t) {
    var e = t.min || 0, n = t.max || 1 / 0;
    r = Math.max(Math.min(n, r), e);
  }
  return r;
}
function U3(r) {
  if (pt(r)) {
    var t = new DOMParser();
    r = t.parseFromString(r, "text/xml");
  }
  var e = r;
  for (e.nodeType === 9 && (e = e.firstChild); e.nodeName.toLowerCase() !== "svg" || e.nodeType !== 1; )
    e = e.nextSibling;
  return e;
}
var O0, sg = {
  fill: "fill",
  stroke: "stroke",
  "stroke-width": "lineWidth",
  opacity: "opacity",
  "fill-opacity": "fillOpacity",
  "stroke-opacity": "strokeOpacity",
  "stroke-dasharray": "lineDash",
  "stroke-dashoffset": "lineDashOffset",
  "stroke-linecap": "lineCap",
  "stroke-linejoin": "lineJoin",
  "stroke-miterlimit": "miterLimit",
  "font-family": "fontFamily",
  "font-size": "fontSize",
  "font-style": "fontStyle",
  "font-weight": "fontWeight",
  "text-anchor": "textAlign",
  visibility: "visibility",
  display: "display"
}, hD = se(sg), lg = {
  "alignment-baseline": "textBaseline",
  "stop-color": "stopColor"
}, dD = se(lg), Hj = function() {
  function r() {
    this._defs = {}, this._root = null;
  }
  return r.prototype.parse = function(t, e) {
    e = e || {};
    var n = U3(t);
    if (process.env.NODE_ENV !== "production" && !n)
      throw new Error("Illegal svg");
    this._defsUsePending = [];
    var i = new Et();
    this._root = i;
    var a = [], o = n.getAttribute("viewBox") || "", s = parseFloat(n.getAttribute("width") || e.width), l = parseFloat(n.getAttribute("height") || e.height);
    isNaN(s) && (s = null), isNaN(l) && (l = null), En(n, i, null, !0, !1);
    for (var u = n.firstChild; u; )
      this._parseNode(u, i, a, null, !1, !1), u = u.nextSibling;
    Yj(this._defs, this._defsUsePending), this._defsUsePending = [];
    var c, f;
    if (o) {
      var h = xm(o);
      h.length >= 4 && (c = {
        x: parseFloat(h[0] || 0),
        y: parseFloat(h[1] || 0),
        width: parseFloat(h[2]),
        height: parseFloat(h[3])
      });
    }
    if (c && s != null && l != null && (f = H3(c, { x: 0, y: 0, width: s, height: l }), !e.ignoreViewBox)) {
      var d = i;
      i = new Et(), i.add(d), d.scaleX = d.scaleY = f.scale, d.x = f.x, d.y = f.y;
    }
    return !e.ignoreRootClip && s != null && l != null && i.setClipPath(new te({
      shape: { x: 0, y: 0, width: s, height: l }
    })), {
      root: i,
      width: s,
      height: l,
      viewBoxRect: c,
      viewBoxTransform: f,
      named: a
    };
  }, r.prototype._parseNode = function(t, e, n, i, a, o) {
    var s = t.nodeName.toLowerCase(), l, u = i;
    if (s === "defs" && (a = !0), s === "text" && (o = !0), s === "defs" || s === "switch")
      l = e;
    else {
      if (!a) {
        var c = O0[s];
        if (c && _t(O0, s)) {
          l = c.call(this, t, e);
          var f = t.getAttribute("name");
          if (f) {
            var h = {
              name: f,
              namedFrom: null,
              svgNodeTagLower: s,
              el: l
            };
            n.push(h), s === "g" && (u = h);
          } else
            i && n.push({
              name: i.name,
              namedFrom: i,
              svgNodeTagLower: s,
              el: l
            });
          e.add(l);
        }
      }
      var d = pD[s];
      if (d && _t(pD, s)) {
        var p = d.call(this, t), g = t.getAttribute("id");
        g && (this._defs[g] = p);
      }
    }
    if (l && l.isGroup)
      for (var v = t.firstChild; v; )
        v.nodeType === 1 ? this._parseNode(v, l, n, u, a, o) : v.nodeType === 3 && o && this._parseText(v, l), v = v.nextSibling;
  }, r.prototype._parseText = function(t, e) {
    var n = new rc({
      style: {
        text: t.textContent
      },
      silent: !0,
      x: this._textX || 0,
      y: this._textY || 0
    });
    Hn(e, n), En(t, n, this._defsUsePending, !1, !1), Wj(n, e);
    var i = n.style, a = i.fontSize;
    a && a < 9 && (i.fontSize = 9, n.scaleX *= a / 9, n.scaleY *= a / 9);
    var o = (i.fontSize || i.fontFamily) && [
      i.fontStyle,
      i.fontWeight,
      (i.fontSize || 12) + "px",
      i.fontFamily || "sans-serif"
    ].join(" ");
    i.font = o;
    var s = n.getBoundingRect();
    return this._textX += s.width, e.add(n), n;
  }, r.internalField = function() {
    O0 = {
      g: function(t, e) {
        var n = new Et();
        return Hn(e, n), En(t, n, this._defsUsePending, !1, !1), n;
      },
      rect: function(t, e) {
        var n = new te();
        return Hn(e, n), En(t, n, this._defsUsePending, !1, !1), n.setShape({
          x: parseFloat(t.getAttribute("x") || "0"),
          y: parseFloat(t.getAttribute("y") || "0"),
          width: parseFloat(t.getAttribute("width") || "0"),
          height: parseFloat(t.getAttribute("height") || "0")
        }), n.silent = !0, n;
      },
      circle: function(t, e) {
        var n = new qa();
        return Hn(e, n), En(t, n, this._defsUsePending, !1, !1), n.setShape({
          cx: parseFloat(t.getAttribute("cx") || "0"),
          cy: parseFloat(t.getAttribute("cy") || "0"),
          r: parseFloat(t.getAttribute("r") || "0")
        }), n.silent = !0, n;
      },
      line: function(t, e) {
        var n = new sr();
        return Hn(e, n), En(t, n, this._defsUsePending, !1, !1), n.setShape({
          x1: parseFloat(t.getAttribute("x1") || "0"),
          y1: parseFloat(t.getAttribute("y1") || "0"),
          x2: parseFloat(t.getAttribute("x2") || "0"),
          y2: parseFloat(t.getAttribute("y2") || "0")
        }), n.silent = !0, n;
      },
      ellipse: function(t, e) {
        var n = new rm();
        return Hn(e, n), En(t, n, this._defsUsePending, !1, !1), n.setShape({
          cx: parseFloat(t.getAttribute("cx") || "0"),
          cy: parseFloat(t.getAttribute("cy") || "0"),
          rx: parseFloat(t.getAttribute("rx") || "0"),
          ry: parseFloat(t.getAttribute("ry") || "0")
        }), n.silent = !0, n;
      },
      polygon: function(t, e) {
        var n = t.getAttribute("points"), i;
        n && (i = mD(n));
        var a = new jr({
          shape: {
            points: i || []
          },
          silent: !0
        });
        return Hn(e, a), En(t, a, this._defsUsePending, !1, !1), a;
      },
      polyline: function(t, e) {
        var n = t.getAttribute("points"), i;
        n && (i = mD(n));
        var a = new Ur({
          shape: {
            points: i || []
          },
          silent: !0
        });
        return Hn(e, a), En(t, a, this._defsUsePending, !1, !1), a;
      },
      image: function(t, e) {
        var n = new Vr();
        return Hn(e, n), En(t, n, this._defsUsePending, !1, !1), n.setStyle({
          image: t.getAttribute("xlink:href") || t.getAttribute("href"),
          x: +t.getAttribute("x"),
          y: +t.getAttribute("y"),
          width: +t.getAttribute("width"),
          height: +t.getAttribute("height")
        }), n.silent = !0, n;
      },
      text: function(t, e) {
        var n = t.getAttribute("x") || "0", i = t.getAttribute("y") || "0", a = t.getAttribute("dx") || "0", o = t.getAttribute("dy") || "0";
        this._textX = parseFloat(n) + parseFloat(a), this._textY = parseFloat(i) + parseFloat(o);
        var s = new Et();
        return Hn(e, s), En(t, s, this._defsUsePending, !1, !0), s;
      },
      tspan: function(t, e) {
        var n = t.getAttribute("x"), i = t.getAttribute("y");
        n != null && (this._textX = parseFloat(n)), i != null && (this._textY = parseFloat(i));
        var a = t.getAttribute("dx") || "0", o = t.getAttribute("dy") || "0", s = new Et();
        return Hn(e, s), En(t, s, this._defsUsePending, !1, !0), this._textX += parseFloat(a), this._textY += parseFloat(o), s;
      },
      path: function(t, e) {
        var n = t.getAttribute("d") || "", i = uN(n);
        return Hn(e, i), En(t, i, this._defsUsePending, !1, !1), i.silent = !0, i;
      }
    };
  }(), r;
}(), pD = {
  lineargradient: function(r) {
    var t = parseInt(r.getAttribute("x1") || "0", 10), e = parseInt(r.getAttribute("y1") || "0", 10), n = parseInt(r.getAttribute("x2") || "10", 10), i = parseInt(r.getAttribute("y2") || "0", 10), a = new wc(t, e, n, i);
    return vD(r, a), gD(r, a), a;
  },
  radialgradient: function(r) {
    var t = parseInt(r.getAttribute("cx") || "0", 10), e = parseInt(r.getAttribute("cy") || "0", 10), n = parseInt(r.getAttribute("r") || "0", 10), i = new dN(t, e, n);
    return vD(r, i), gD(r, i), i;
  }
};
function vD(r, t) {
  var e = r.getAttribute("gradientUnits");
  e === "userSpaceOnUse" && (t.global = !0);
}
function gD(r, t) {
  for (var e = r.firstChild; e; ) {
    if (e.nodeType === 1 && e.nodeName.toLocaleLowerCase() === "stop") {
      var n = e.getAttribute("offset"), i = void 0;
      n && n.indexOf("%") > 0 ? i = parseInt(n, 10) / 100 : n ? i = parseFloat(n) : i = 0;
      var a = {};
      G3(e, a, a);
      var o = a.stopColor || e.getAttribute("stop-color") || "#000000", s = a.stopOpacity || e.getAttribute("stop-opacity");
      if (s) {
        var l = bn(o), u = l && l[3];
        u && (l[3] *= Po(s), o = Ji(l, "rgba"));
      }
      t.colorStops.push({
        offset: i,
        color: o
      });
    }
    e = e.nextSibling;
  }
}
function Hn(r, t) {
  r && r.__inheritedStyle && (t.__inheritedStyle || (t.__inheritedStyle = {}), kt(t.__inheritedStyle, r.__inheritedStyle));
}
function mD(r) {
  for (var t = xm(r), e = [], n = 0; n < t.length; n += 2) {
    var i = parseFloat(t[n]), a = parseFloat(t[n + 1]);
    e.push([i, a]);
  }
  return e;
}
function En(r, t, e, n, i) {
  var a = t, o = a.__inheritedStyle = a.__inheritedStyle || {}, s = {};
  r.nodeType === 1 && (qj(r, t), G3(r, o, s), n || Kj(r, o, s)), a.style = a.style || {}, o.fill != null && (a.style.fill = yD(a, "fill", o.fill, e)), o.stroke != null && (a.style.stroke = yD(a, "stroke", o.stroke, e)), L([
    "lineWidth",
    "opacity",
    "fillOpacity",
    "strokeOpacity",
    "miterLimit",
    "fontSize"
  ], function(l) {
    o[l] != null && (a.style[l] = parseFloat(o[l]));
  }), L([
    "lineDashOffset",
    "lineCap",
    "lineJoin",
    "fontWeight",
    "fontFamily",
    "fontStyle",
    "textAlign"
  ], function(l) {
    o[l] != null && (a.style[l] = o[l]);
  }), i && (a.__selfStyle = s), o.lineDash && (a.style.lineDash = rt(xm(o.lineDash), function(l) {
    return parseFloat(l);
  })), (o.visibility === "hidden" || o.visibility === "collapse") && (a.invisible = !0), o.display === "none" && (a.ignore = !0);
}
function Wj(r, t) {
  var e = t.__selfStyle;
  if (e) {
    var n = e.textBaseline, i = n;
    !n || n === "auto" || n === "baseline" ? i = "alphabetic" : n === "before-edge" || n === "text-before-edge" ? i = "top" : n === "after-edge" || n === "text-after-edge" ? i = "bottom" : (n === "central" || n === "mathematical") && (i = "middle"), r.style.textBaseline = i;
  }
  var a = t.__inheritedStyle;
  if (a) {
    var o = a.textAlign, s = o;
    o && (o === "middle" && (s = "center"), r.style.textAlign = s);
  }
}
var Xj = /^url\(\s*#(.*?)\)/;
function yD(r, t, e, n) {
  var i = e && e.match(Xj);
  if (i) {
    var a = ti(i[1]);
    n.push([r, t, a]);
    return;
  }
  return e === "none" && (e = null), e;
}
function Yj(r, t) {
  for (var e = 0; e < t.length; e++) {
    var n = t[e];
    n[0].style[n[1]] = r[n[2]];
  }
}
var $j = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function xm(r) {
  return r.match($j) || [];
}
var Zj = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.eE,]*)\)/g, k0 = Math.PI / 180;
function qj(r, t) {
  var e = r.getAttribute("transform");
  if (e) {
    e = e.replace(/,/g, " ");
    var n = [], i = null;
    e.replace(Zj, function(f, h, d) {
      return n.push(h, d), "";
    });
    for (var a = n.length - 1; a > 0; a -= 2) {
      var o = n[a], s = n[a - 1], l = xm(o);
      switch (i = i || kr(), s) {
        case "translate":
          ra(i, i, [parseFloat(l[0]), parseFloat(l[1] || "0")]);
          break;
        case "scale":
          M1(i, i, [parseFloat(l[0]), parseFloat(l[1] || l[0])]);
          break;
        case "rotate":
          qo(i, i, -parseFloat(l[0]) * k0, [
            parseFloat(l[1] || "0"),
            parseFloat(l[2] || "0")
          ]);
          break;
        case "skewX":
          var u = Math.tan(parseFloat(l[0]) * k0);
          ji(i, [1, 0, u, 1, 0, 0], i);
          break;
        case "skewY":
          var c = Math.tan(parseFloat(l[0]) * k0);
          ji(i, [1, c, 0, 1, 0, 0], i);
          break;
        case "matrix":
          i[0] = parseFloat(l[0]), i[1] = parseFloat(l[1]), i[2] = parseFloat(l[2]), i[3] = parseFloat(l[3]), i[4] = parseFloat(l[4]), i[5] = parseFloat(l[5]);
          break;
      }
    }
    t.setLocalTransform(i);
  }
}
var _D = /([^\s:;]+)\s*:\s*([^:;]+)/g;
function G3(r, t, e) {
  var n = r.getAttribute("style");
  if (n) {
    _D.lastIndex = 0;
    for (var i; (i = _D.exec(n)) != null; ) {
      var a = i[1], o = _t(sg, a) ? sg[a] : null;
      o && (t[o] = i[2]);
      var s = _t(lg, a) ? lg[a] : null;
      s && (e[s] = i[2]);
    }
  }
}
function Kj(r, t, e) {
  for (var n = 0; n < hD.length; n++) {
    var i = hD[n], a = r.getAttribute(i);
    a != null && (t[sg[i]] = a);
  }
  for (var n = 0; n < dD.length; n++) {
    var i = dD[n], a = r.getAttribute(i);
    a != null && (e[lg[i]] = a);
  }
}
function H3(r, t) {
  var e = t.width / r.width, n = t.height / r.height, i = Math.min(e, n);
  return {
    scale: i,
    x: -(r.x + r.width / 2) * i + (t.x + t.width / 2),
    y: -(r.y + r.height / 2) * i + (t.y + t.height / 2)
  };
}
function jj(r, t) {
  var e = new Hj();
  return e.parse(r, t);
}
var Jj = wt([
  "rect",
  "circle",
  "line",
  "ellipse",
  "polygon",
  "polyline",
  "path",
  // <text> <tspan> are also enabled because some SVG might paint text itself,
  // but still need to trigger events or tooltip.
  "text",
  "tspan",
  // <g> is also enabled because this case: if multiple tags share one name
  // and need label displayed, every tags will display the name, which is not
  // expected. So we can put them into a <g name="xxx">. Thereby only one label
  // displayed and located based on the bounding rect of the <g>.
  "g"
]), Qj = (
  /** @class */
  function() {
    function r(t, e) {
      this.type = "geoSVG", this._usedGraphicMap = wt(), this._freedGraphics = [], this._mapName = t, this._parsedXML = U3(e);
    }
    return r.prototype.load = function() {
      var t = this._firstGraphic;
      if (!t) {
        t = this._firstGraphic = this._buildGraphic(this._parsedXML), this._freedGraphics.push(t), this._boundingRect = this._firstGraphic.boundingRect.clone();
        var e = eJ(t.named), n = e.regions, i = e.regionsMap;
        this._regions = n, this._regionsMap = i;
      }
      return {
        boundingRect: this._boundingRect,
        regions: this._regions,
        regionsMap: this._regionsMap
      };
    }, r.prototype._buildGraphic = function(t) {
      var e, n;
      try {
        e = t && jj(t, {
          ignoreViewBox: !0,
          ignoreRootClip: !0
        }) || {}, n = e.root, St(n != null);
      } catch (v) {
        throw new Error(`Invalid svg format
` + v.message);
      }
      var i = new Et();
      i.add(n), i.isGeoSVGGraphicRoot = !0;
      var a = e.width, o = e.height, s = e.viewBoxRect, l = this._boundingRect;
      if (!l) {
        var u = void 0, c = void 0, f = void 0, h = void 0;
        if (a != null ? (u = 0, f = a) : s && (u = s.x, f = s.width), o != null ? (c = 0, h = o) : s && (c = s.y, h = s.height), u == null || c == null) {
          var d = n.getBoundingRect();
          u == null && (u = d.x, f = d.width), c == null && (c = d.y, h = d.height);
        }
        l = this._boundingRect = new Bt(u, c, f, h);
      }
      if (s) {
        var p = H3(s, l);
        n.scaleX = n.scaleY = p.scale, n.x = p.x, n.y = p.y;
      }
      i.setClipPath(new te({
        shape: l.plain()
      }));
      var g = [];
      return L(e.named, function(v) {
        Jj.get(v.svgNodeTagLower) != null && (g.push(v), tJ(v.el));
      }), {
        root: i,
        boundingRect: l,
        named: g
      };
    }, r.prototype.useGraphic = function(t) {
      var e = this._usedGraphicMap, n = e.get(t);
      return n || (n = this._freedGraphics.pop() || this._buildGraphic(this._parsedXML), e.set(t, n), n);
    }, r.prototype.freeGraphic = function(t) {
      var e = this._usedGraphicMap, n = e.get(t);
      n && (e.removeKey(t), this._freedGraphics.push(n));
    }, r;
  }()
);
function tJ(r) {
  r.silent = !1, r.isGroup && r.traverse(function(t) {
    t.silent = !1;
  });
}
function eJ(r) {
  var t = [], e = wt();
  return L(r, function(n) {
    if (n.namedFrom == null) {
      var i = new gZ(n.name, n.el);
      t.push(i), e.set(n.name, i);
    }
  }), {
    regions: t,
    regionsMap: e
  };
}
var wS = [126, 25], xD = "", Os = [[[0, 3.5], [7, 11.2], [15, 11.9], [30, 7], [42, 0.7], [52, 0.7], [56, 7.7], [59, 0.7], [64, 0.7], [64, 0], [5, 0], [0, 3.5]], [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]], [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]], [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]], [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]], [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]], [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]], [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]], [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]], [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]], [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]], [[0, 3.5], [0, 93.1], [64, 93.1], [64, 0], [63, 0], [63, 92.4], [1, 92.4], [1, 3.5], [0, 3.5]]];
for (var Rs = 0; Rs < Os.length; Rs++)
  for (var pu = 0; pu < Os[Rs].length; pu++)
    Os[Rs][pu][0] /= 10.5, Os[Rs][pu][1] /= -10.5 / 0.75, Os[Rs][pu][0] += wS[0], Os[Rs][pu][1] += wS[1];
function rJ(r, t) {
  if (r === "china") {
    for (var e = 0; e < t.length; e++)
      if (t[e].name === xD)
        return;
    t.push(new Tk(xD, rt(Os, function(n) {
      return {
        type: "polygon",
        exterior: n
      };
    }), wS));
  }
}
var nJ = {
  : [32, 80],
  // 
  : [0, -10],
  : [10, 5],
  : [-10, 10],
  // '': [-10, 0],
  : [5, 5]
};
function iJ(r, t) {
  if (r === "china") {
    var e = nJ[t.name];
    if (e) {
      var n = t.getCenter();
      n[0] += e[0] / 10.5, n[1] += -e[1] / (10.5 / 0.75), t.setCenter(n);
    }
  }
}
var aJ = [[[123.45165252685547, 25.73527164402261], [123.49731445312499, 25.73527164402261], [123.49731445312499, 25.750734064600884], [123.45165252685547, 25.750734064600884], [123.45165252685547, 25.73527164402261]]];
function oJ(r, t) {
  r === "china" && t.name === "" && t.geometries.push({
    type: "polygon",
    exterior: aJ[0]
  });
}
var sJ = "name", lJ = (
  /** @class */
  function() {
    function r(t, e, n) {
      this.type = "geoJSON", this._parsedMap = wt(), this._mapName = t, this._specialAreas = n, this._geoJSON = cJ(e);
    }
    return r.prototype.load = function(t, e) {
      e = e || sJ;
      var n = this._parsedMap.get(e);
      if (!n) {
        var i = this._parseToRegions(e);
        n = this._parsedMap.set(e, {
          regions: i,
          boundingRect: uJ(i)
        });
      }
      var a = wt(), o = [];
      return L(n.regions, function(s) {
        var l = s.name;
        t && _t(t, l) && (s = s.cloneShallow(l = t[l])), o.push(s), a.set(l, s);
      }), {
        regions: o,
        boundingRect: n.boundingRect || new Bt(0, 0, 0, 0),
        regionsMap: a
      };
    }, r.prototype._parseToRegions = function(t) {
      var e = this._mapName, n = this._geoJSON, i;
      try {
        i = n ? yZ(n, t) : [];
      } catch (a) {
        throw new Error(`Invalid geoJson format
` + a.message);
      }
      return rJ(e, i), L(i, function(a) {
        var o = a.name;
        iJ(e, a), oJ(e, a);
        var s = this._specialAreas && this._specialAreas[o];
        s && a.transformTo(s.left, s.top, s.width, s.height);
      }, this), i;
    }, r.prototype.getMapForUser = function() {
      return {
        // For backward compatibility, use geoJson
        // PENDING: it has been returning them without clone.
        // do we need to avoid outsite modification?
        geoJson: this._geoJSON,
        geoJSON: this._geoJSON,
        specialAreas: this._specialAreas
      };
    }, r;
  }()
);
function uJ(r) {
  for (var t, e = 0; e < r.length; e++) {
    var n = r[e].getBoundingRect();
    t = t || n.clone(), t.union(n);
  }
  return t;
}
function cJ(r) {
  return pt(r) ? typeof JSON < "u" && JSON.parse ? JSON.parse(r) : new Function("return (" + r + ");")() : r;
}
var df = wt();
const $a = {
  /**
   * Compatible with previous `echarts.registerMap`.
   *
   * @usage
   * ```js
   *
   * echarts.registerMap('USA', geoJson, specialAreas);
   *
   * echarts.registerMap('USA', {
   *     geoJson: geoJson,
   *     specialAreas: {...}
   * });
   * echarts.registerMap('USA', {
   *     geoJSON: geoJson,
   *     specialAreas: {...}
   * });
   *
   * echarts.registerMap('airport', {
   *     svg: svg
   * }
   * ```
   *
   * Note:
   * Do not support that register multiple geoJSON or SVG
   * one map name. Because different geoJSON and SVG have
   * different unit. It's not easy to make sure how those
   * units are mapping/normalize.
   * If intending to use multiple geoJSON or SVG, we can
   * use multiple geo coordinate system.
   */
  registerMap: function(r, t, e) {
    if (t.svg) {
      var n = new Qj(r, t.svg);
      df.set(r, n);
    } else {
      var i = t.geoJson || t.geoJSON;
      i && !t.features ? e = t.specialAreas : i = t;
      var n = new lJ(r, i, e);
      df.set(r, n);
    }
  },
  getGeoResource: function(r) {
    return df.get(r);
  },
  /**
   * Only for exporting to users.
   * **MUST NOT** used internally.
   */
  getMapForUser: function(r) {
    var t = df.get(r);
    return t && t.type === "geoJSON" && t.getMapForUser();
  },
  load: function(r, t, e) {
    var n = df.get(r);
    if (!n) {
      process.env.NODE_ENV !== "production" && console.error("Map " + r + " not exists. The GeoJSON of the map must be provided.");
      return;
    }
    return n.load(t, e);
  }
};
var Fb = ["rect", "circle", "line", "ellipse", "polygon", "polyline", "path"], fJ = wt(Fb), hJ = wt(Fb.concat(["g"])), dJ = wt(Fb.concat(["g"])), W3 = ee();
function vp(r) {
  var t = r.getItemStyle(), e = r.get("areaColor");
  return e != null && (t.fill = e), t;
}
function SD(r) {
  var t = r.style;
  t && (t.stroke = t.stroke || t.fill, t.fill = null);
}
var X3 = (
  /** @class */
  function() {
    function r(t) {
      var e = this.group = new Et(), n = this._transformGroup = new Et();
      e.add(n), this.uid = Ac("ec_map_draw"), this._controller = new Il(t.getZr()), this._controllerHost = {
        target: n
      }, n.add(this._regionsGroup = new Et()), n.add(this._svgGroup = new Et());
    }
    return r.prototype.draw = function(t, e, n, i, a) {
      var o = t.mainType === "geo", s = t.getData && t.getData();
      o && e.eachComponent({
        mainType: "series",
        subType: "map"
      }, function(_) {
        !s && _.getHostGeoModel() === t && (s = _.getData());
      });
      var l = t.coordinateSystem, u = this._regionsGroup, c = this._transformGroup, f = l.getTransformInfo(), h = f.raw, d = f.roam, p = !u.childAt(0) || a, g = t.getShallow("clip", !0), v;
      g ? (v = l.getViewRect().clone(), this.group.setClipPath(new te({
        shape: v.clone()
      }))) : this.group.removeClipPath(), p ? (c.x = d.x, c.y = d.y, c.scaleX = d.scaleX, c.scaleY = d.scaleY, c.dirty()) : ve(c, d, t);
      var m = s && s.getVisual("visualMeta") && s.getVisual("visualMeta").length > 0, y = {
        api: n,
        geo: l,
        mapOrGeoModel: t,
        data: s,
        isVisualEncodedByVisualMap: m,
        isGeo: o,
        transformInfoRaw: h
      };
      l.resourceType === "geoJSON" ? this._buildGeoJSON(y) : l.resourceType === "geoSVG" && this._buildSVG(y), this._updateController(t, v, e, n), this._updateMapSelectHandler(t, u, n, i);
    }, r.prototype._buildGeoJSON = function(t) {
      var e = this._regionsGroupByName = wt(), n = wt(), i = this._regionsGroup, a = t.transformInfoRaw, o = t.mapOrGeoModel, s = t.data, l = t.geo.projection, u = l && l.stream;
      function c(d, p) {
        return p && (d = p(d)), d && [d[0] * a.scaleX + a.x, d[1] * a.scaleY + a.y];
      }
      function f(d) {
        for (var p = [], g = !u && l && l.project, v = 0; v < d.length; ++v) {
          var m = c(d[v], g);
          m && p.push(m);
        }
        return p;
      }
      function h(d) {
        return {
          shape: {
            points: f(d)
          }
        };
      }
      i.removeAll(), L(t.geo.regions, function(d) {
        var p = d.name, g = e.get(p), v = n.get(p) || {}, m = v.dataIdx, y = v.regionModel;
        if (!g) {
          g = e.set(p, new Et()), i.add(g), m = s ? s.indexOfName(p) : null, y = t.isGeo ? o.getRegionModel(p) : s ? s.getItemModel(m) : null;
          var _ = y.get("silent", !0);
          _ != null && (g.silent = _), n.set(p, {
            dataIdx: m,
            regionModel: y
          });
        }
        var x = [], b = [];
        L(d.geometries, function(A) {
          if (A.type === "polygon") {
            var T = [A.exterior].concat(A.interiors || []);
            u && (T = ED(T, u)), L(T, function(E) {
              x.push(new jr(h(E)));
            });
          } else {
            var M = A.points;
            u && (M = ED(M, u, !0)), L(M, function(E) {
              b.push(new Ur(h(E)));
            });
          }
        });
        var S = c(d.getCenter(), l && l.project);
        function w(A, T) {
          if (A.length) {
            var M = new im({
              culling: !0,
              segmentIgnoreThreshold: 1,
              shape: {
                paths: A
              }
            });
            g.add(M), bD(t, M, m, y), wD(t, M, p, y, o, m, S), T && (SD(M), L(M.states, SD));
          }
        }
        w(x), w(b, !0);
      }), e.each(function(d, p) {
        var g = n.get(p), v = g.dataIdx, m = g.regionModel;
        MD(t, d, p, m, o, v), TD(t, d, p, m, o), AD(t, d, p, m, o);
      }, this);
    }, r.prototype._buildSVG = function(t) {
      var e = t.geo.map, n = t.transformInfoRaw;
      this._svgGroup.x = n.x, this._svgGroup.y = n.y, this._svgGroup.scaleX = n.scaleX, this._svgGroup.scaleY = n.scaleY, this._svgResourceChanged(e) && (this._freeSVG(), this._useSVG(e));
      var i = this._svgDispatcherMap = wt(), a = !1;
      L(this._svgGraphicRecord.named, function(o) {
        var s = o.name, l = t.mapOrGeoModel, u = t.data, c = o.svgNodeTagLower, f = o.el, h = u ? u.indexOfName(s) : null, d = l.getRegionModel(s);
        fJ.get(c) != null && f instanceof ii && bD(t, f, h, d), f instanceof ii && (f.culling = !0);
        var p = d.get("silent", !0);
        if (p != null && (f.silent = p), f.z2EmphasisLift = 0, !o.namedFrom && (dJ.get(c) != null && wD(t, f, s, d, l, h, null), MD(t, f, s, d, l, h), TD(t, f, s, d, l), hJ.get(c) != null)) {
          var g = AD(t, f, s, d, l);
          g === "self" && (a = !0);
          var v = i.get(s) || i.set(s, []);
          v.push(f);
        }
      }, this), this._enableBlurEntireSVG(a, t);
    }, r.prototype._enableBlurEntireSVG = function(t, e) {
      if (t && e.isGeo) {
        var n = e.mapOrGeoModel.getModel(["blur", "itemStyle"]).getItemStyle(), i = n.opacity;
        this._svgGraphicRecord.root.traverse(function(a) {
          if (!a.isGroup) {
            vl(a);
            var o = a.ensureState("blur").style || {};
            o.opacity == null && i != null && (o.opacity = i), a.ensureState("emphasis");
          }
        });
      }
    }, r.prototype.remove = function() {
      this._regionsGroup.removeAll(), this._regionsGroupByName = null, this._svgGroup.removeAll(), this._freeSVG(), this._controller.dispose(), this._controllerHost = null;
    }, r.prototype.findHighDownDispatchers = function(t, e) {
      if (t == null)
        return [];
      var n = e.coordinateSystem;
      if (n.resourceType === "geoJSON") {
        var i = this._regionsGroupByName;
        if (i) {
          var a = i.get(t);
          return a ? [a] : [];
        }
      } else if (n.resourceType === "geoSVG")
        return this._svgDispatcherMap && this._svgDispatcherMap.get(t) || [];
    }, r.prototype._svgResourceChanged = function(t) {
      return this._svgMapName !== t;
    }, r.prototype._useSVG = function(t) {
      var e = $a.getGeoResource(t);
      if (e && e.type === "geoSVG") {
        var n = e.useGraphic(this.uid);
        this._svgGroup.add(n.root), this._svgGraphicRecord = n, this._svgMapName = t;
      }
    }, r.prototype._freeSVG = function() {
      var t = this._svgMapName;
      if (t != null) {
        var e = $a.getGeoResource(t);
        e && e.type === "geoSVG" && e.freeGraphic(this.uid), this._svgGraphicRecord = null, this._svgDispatcherMap = null, this._svgGroup.removeAll(), this._svgMapName = null;
      }
    }, r.prototype._updateController = function(t, e, n, i) {
      var a = t.coordinateSystem, o = this._controller, s = this._controllerHost;
      s.zoomLimit = t.get("scaleLimit"), s.zoom = a.getZoom(), o.enable(t.get("roam") || !1, {
        api: i,
        zInfo: {
          component: t
        },
        triggerInfo: {
          roamTrigger: t.get("roamTrigger"),
          isInSelf: function(c, f, h) {
            return a.containPoint([f, h]);
          },
          isInClip: function(c, f, h) {
            return !e || e.contain(f, h);
          }
        }
      });
      var l = t.mainType;
      function u() {
        var c = {
          type: "geoRoam",
          componentType: l
        };
        return c[l + "Id"] = t.id, c;
      }
      o.off("pan").on("pan", function(c) {
        this._mouseDownFlag = !1, kb(s, c.dx, c.dy), i.dispatchAction(J(u(), {
          dx: c.dx,
          dy: c.dy,
          animation: {
            duration: 0
          }
        }));
      }, this), o.off("zoom").on("zoom", function(c) {
        this._mouseDownFlag = !1, Bb(s, c.scale, c.originX, c.originY), i.dispatchAction(J(u(), {
          totalZoom: s.zoom,
          zoom: c.scale,
          originX: c.originX,
          originY: c.originY,
          animation: {
            duration: 0
          }
        }));
      }, this);
    }, r.prototype.resetForLabelLayout = function() {
      this.group.traverse(function(t) {
        var e = t.getTextContent();
        e && (e.ignore = W3(e).ignore);
      });
    }, r.prototype._updateMapSelectHandler = function(t, e, n, i) {
      var a = this;
      e.off("mousedown"), e.off("click"), t.get("selectedMode") && (e.on("mousedown", function() {
        a._mouseDownFlag = !0;
      }), e.on("click", function(o) {
        a._mouseDownFlag && (a._mouseDownFlag = !1);
      }));
    }, r;
  }()
);
function bD(r, t, e, n) {
  var i = n.getModel("itemStyle"), a = n.getModel(["emphasis", "itemStyle"]), o = n.getModel(["blur", "itemStyle"]), s = n.getModel(["select", "itemStyle"]), l = vp(i), u = vp(a), c = vp(s), f = vp(o), h = r.data;
  if (h) {
    var d = h.getItemVisual(e, "style"), p = h.getItemVisual(e, "decal");
    r.isVisualEncodedByVisualMap && d.fill && (l.fill = d.fill), p && (l.decal = ac(p, r.api));
  }
  t.setStyle(l), t.style.strokeNoScale = !0, t.ensureState("emphasis").style = u, t.ensureState("select").style = c, t.ensureState("blur").style = f, vl(t);
}
function wD(r, t, e, n, i, a, o) {
  var s = r.data, l = r.isGeo, u = s && isNaN(s.get(s.mapDimension("value"), a)), c = s && s.getItemLayout(a);
  if (l || u || c && c.showLabel) {
    var f = l ? e : a, h = void 0;
    (!s || a >= 0) && (h = i);
    var d = o ? {
      normal: {
        align: "center",
        verticalAlign: "middle"
      }
    } : null;
    Er(t, _r(n), {
      labelFetcher: h,
      labelDataIndex: f,
      defaultText: e
    }, d);
    var p = t.getTextContent();
    if (p && (W3(p).ignore = p.ignore, t.textConfig && o)) {
      var g = t.getBoundingRect().clone();
      t.textConfig.layoutRect = g, t.textConfig.position = [(o[0] - g.x) / g.width * 100 + "%", (o[1] - g.y) / g.height * 100 + "%"];
    }
    t.disableLabelAnimation = !0;
  } else
    t.removeTextContent(), t.removeTextConfig(), t.disableLabelAnimation = null;
}
function MD(r, t, e, n, i, a) {
  r.data ? r.data.setItemGraphicEl(a, t) : zt(t).eventData = {
    componentType: "geo",
    componentIndex: i.componentIndex,
    geoIndex: i.componentIndex,
    name: e,
    region: n && n.option || {}
  };
}
function TD(r, t, e, n, i) {
  r.data || Ka({
    el: t,
    componentModel: i,
    itemName: e,
    // @ts-ignore FIXME:TS fix the "compatible with each other"?
    itemTooltipOption: n.get("tooltip")
  });
}
function AD(r, t, e, n, i) {
  t.highDownSilentOnTouch = !!i.get("selectedMode");
  var a = n.getModel("emphasis"), o = a.get("focus");
  return Ge(t, o, a.get("blurScope"), a.get("disabled")), r.isGeo && v7(t, i, e), o;
}
function ED(r, t, e) {
  var n = [], i;
  function a() {
    i = [];
  }
  function o() {
    i.length && (n.push(i), i = []);
  }
  var s = t({
    polygonStart: a,
    polygonEnd: o,
    lineStart: a,
    lineEnd: o,
    point: function(l, u) {
      isFinite(l) && isFinite(u) && i.push([l, u]);
    },
    sphere: function() {
    }
  });
  return !e && s.polygonStart(), L(r, function(l) {
    s.lineStart();
    for (var u = 0; u < l.length; u++)
      s.point(l[u][0], l[u][1]);
    s.lineEnd();
  }), !e && s.polygonEnd(), n;
}
var pJ = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n, i, a) {
      if (!(a && a.type === "mapToggleSelect" && a.from === this.uid)) {
        var o = this.group;
        if (o.removeAll(), !e.getHostGeoModel()) {
          if (this._mapDraw && a && a.type === "geoRoam" && this._mapDraw.resetForLabelLayout(), a && a.type === "geoRoam" && a.componentType === "series" && a.seriesId === e.id) {
            var s = this._mapDraw;
            s && o.add(s.group);
          } else if (e.needsDrawMap) {
            var s = this._mapDraw || new X3(i);
            o.add(s.group), s.draw(e, n, i, this, a), this._mapDraw = s;
          } else
            this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
          e.get("showLegendSymbol") && n.getComponent("legend") && this._renderSymbols(e, n, i);
        }
      }
    }, t.prototype.remove = function() {
      this._mapDraw && this._mapDraw.remove(), this._mapDraw = null, this.group.removeAll();
    }, t.prototype.dispose = function() {
      this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
    }, t.prototype._renderSymbols = function(e, n, i) {
      var a = e.originalData, o = this.group;
      a.each(a.mapDimension("value"), function(s, l) {
        if (!isNaN(s)) {
          var u = a.getItemLayout(l);
          if (!(!u || !u.point)) {
            var c = u.point, f = u.offset, h = new qa({
              style: {
                // Because the special of map draw.
                // Which needs statistic of multiple series and draw on one map.
                // And each series also need a symbol with legend color
                //
                // Layout and visual are put one the different data
                // TODO
                fill: e.getData().getVisual("style").fill
              },
              shape: {
                cx: c[0] + f * 9,
                cy: c[1],
                r: 3
              },
              silent: !0,
              // Do not overlap the first series, on which labels are displayed.
              z2: 8 + (f ? 0 : bc + 1)
            });
            if (!f) {
              var d = e.mainSeries.getData(), p = a.getName(l), g = d.indexOfName(p), v = a.getItemModel(l), m = v.getModel("label"), y = d.getItemGraphicEl(g);
              Er(h, _r(v), {
                labelFetcher: {
                  getFormattedLabel: function(_, x) {
                    return e.getFormattedLabel(g, x);
                  }
                },
                defaultText: p
              }), h.disableLabelAnimation = !0, m.get("position") || h.setTextConfig({
                position: "bottom"
              }), y.onHoverStateChange = function(_) {
                Pv(h, _);
              };
            }
            o.add(h);
          }
        }
      });
    }, t.type = "map", t;
  }(Re)
), vJ = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.needsDrawMap = !1, e.seriesGroup = [], e.getTooltipPosition = function(n) {
        if (n != null) {
          var i = this.getData().getName(n), a = this.coordinateSystem, o = a.getRegion(i);
          return o && a.dataToPoint(o.getCenter());
        }
      }, e;
    }
    return t.prototype.getInitialData = function(e) {
      for (var n = Pc(this, {
        coordDimensions: ["value"],
        encodeDefaulter: Yt(rb, this)
      }), i = wt(), a = [], o = 0, s = n.count(); o < s; o++) {
        var l = n.getName(o);
        i.set(l, o);
      }
      var u = $a.load(this.getMapType(), this.option.nameMap, this.option.nameProperty);
      return L(u.regions, function(c) {
        var f = c.name, h = i.get(f), d = c.properties && c.properties.echartsStyle, p;
        h == null ? (p = {
          name: f
        }, a.push(p)) : p = n.getRawDataItem(h), d && qt(p, d);
      }), n.appendData(a), n;
    }, t.prototype.getHostGeoModel = function() {
      if (zN(this).kind !== Ui.boxCoordSys)
        return this.getReferringComponents("geo", {
          useDefault: !1,
          enableAll: !1,
          enableNone: !1
        }).models[0];
    }, t.prototype.getMapType = function() {
      return (this.getHostGeoModel() || this).option.map;
    }, t.prototype.getRawValue = function(e) {
      var n = this.getData();
      return n.get(n.mapDimension("value"), e);
    }, t.prototype.getRegionModel = function(e) {
      var n = this.getData();
      return n.getItemModel(n.indexOfName(e));
    }, t.prototype.formatTooltip = function(e, n, i) {
      for (var a = this.getData(), o = this.getRawValue(e), s = a.getName(e), l = this.seriesGroup, u = [], c = 0; c < l.length; c++) {
        var f = l[c].originalData.indexOfName(s), h = a.mapDimension("value");
        isNaN(l[c].originalData.get(h, f)) || u.push(l[c].name);
      }
      return cr("section", {
        header: u.join(", "),
        noHeader: !u.length,
        blocks: [cr("nameValue", {
          name: s,
          value: o
        })]
      });
    }, t.prototype.setZoom = function(e) {
      this.option.zoom = e;
    }, t.prototype.setCenter = function(e) {
      this.option.center = e;
    }, t.prototype.getLegendIcon = function(e) {
      var n = e.icon || "roundRect", i = fr(n, 0, 0, e.itemWidth, e.itemHeight, e.itemStyle.fill);
      return i.setStyle(e.itemStyle), i.style.stroke = "none", n.indexOf("empty") > -1 && (i.style.stroke = i.style.fill, i.style.fill = Y.color.neutral00, i.style.lineWidth = 2), i;
    }, t.type = "series.map", t.dependencies = ["geo"], t.layoutMode = "box", t.defaultOption = {
      // 
      // zlevel: 0,
      // 
      z: 2,
      coordinateSystem: "geo",
      // map should be explicitly specified since ec3.
      map: "",
      // If `geoIndex` is not specified, a exclusive geo will be
      // created. Otherwise use the specified geo component, and
      // `map` and `mapType` are ignored.
      // geoIndex: 0,
      // 'center' | 'left' | 'right' | 'x%' | {number}
      left: "center",
      // 'center' | 'top' | 'bottom' | 'x%' | {number}
      top: "center",
      // right
      // bottom
      // width:
      // height
      // Aspect is width / height. Inited to be geoJson bbox aspect
      // This parameter is used for scale this aspect
      // Default value:
      // for geoSVG source: 1,
      // for geoJSON source: 0.75.
      aspectScale: null,
      // Layout with center and size
      // If you want to put map in a fixed size box with right aspect ratio
      // This two properties may be more convenient.
      // layoutCenter: [50%, 50%]
      // layoutSize: 100
      showLegendSymbol: !0,
      // Define left-top, right-bottom coords to control view
      // For example, [ [180, 90], [-180, -90] ],
      // higher priority than center and zoom
      boundingCoords: null,
      // Default on center of map
      center: null,
      zoom: 1,
      scaleLimit: null,
      selectedMode: !0,
      label: {
        show: !1,
        color: Y.color.tertiary
      },
      // scaleLimit: null,
      itemStyle: {
        borderWidth: 0.5,
        borderColor: Y.color.border,
        areaColor: Y.color.background
      },
      emphasis: {
        label: {
          show: !0,
          color: Y.color.primary
        },
        itemStyle: {
          areaColor: Y.color.highlight
        }
      },
      select: {
        label: {
          show: !0,
          color: Y.color.primary
        },
        itemStyle: {
          color: Y.color.highlight
        }
      },
      nameProperty: "name"
    }, t;
  }(ke)
);
function gJ(r, t) {
  var e = {};
  return L(r, function(n) {
    n.each(n.mapDimension("value"), function(i, a) {
      var o = "ec-" + n.getName(a);
      e[o] = e[o] || [], isNaN(i) || e[o].push(i);
    });
  }), r[0].map(r[0].mapDimension("value"), function(n, i) {
    for (var a = "ec-" + r[0].getName(i), o = 0, s = 1 / 0, l = -1 / 0, u = e[a].length, c = 0; c < u; c++)
      s = Math.min(s, e[a][c]), l = Math.max(l, e[a][c]), o += e[a][c];
    var f;
    return t === "min" ? f = s : t === "max" ? f = l : t === "average" ? f = o / u : f = o, u === 0 ? NaN : f;
  });
}
function mJ(r) {
  var t = {};
  r.eachSeriesByType("map", function(e) {
    var n = e.getHostGeoModel(), i = n ? "o" + n.id : "i" + e.getMapType();
    (t[i] = t[i] || []).push(e);
  }), L(t, function(e, n) {
    for (var i = gJ(rt(e, function(o) {
      return o.getData();
    }), e[0].get("mapValueCalculation")), a = 0; a < e.length; a++)
      e[a].originalData = e[a].getData();
    for (var a = 0; a < e.length; a++)
      e[a].seriesGroup = e, e[a].needsDrawMap = a === 0 && !e[a].getHostGeoModel(), e[a].setData(i.cloneShallow()), e[a].mainSeries = e[0];
  });
}
function yJ(r) {
  var t = {};
  r.eachSeriesByType("map", function(e) {
    var n = e.getMapType();
    if (!(e.getHostGeoModel() || t[n])) {
      var i = {};
      L(e.seriesGroup, function(o) {
        var s = o.coordinateSystem, l = o.originalData;
        o.get("showLegendSymbol") && r.getComponent("legend") && l.each(l.mapDimension("value"), function(u, c) {
          var f = l.getName(c), h = s.getRegion(f);
          if (!(!h || isNaN(u))) {
            var d = i[f] || 0, p = s.dataToPoint(h.getCenter());
            i[f] = d + 1, l.setItemLayout(c, {
              point: p,
              offset: d
            });
          }
        });
      });
      var a = e.getData();
      a.each(function(o) {
        var s = a.getName(o), l = a.getItemLayout(o) || {};
        l.showLabel = !i[s], a.setItemLayout(o, l);
      }), t[n] = !0;
    }
  });
}
var CD = rr, Pl = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e, n) {
      var i = r.call(this) || this;
      return i.type = "view", i.dimensions = ["x", "y"], i._roamTransformable = new Da(), i._rawTransformable = new Da(), i.name = e, i._opt = n, i;
    }
    return t.prototype.setBoundingRect = function(e, n, i, a) {
      return this._rect = new Bt(e, n, i, a), this._updateCenterAndZoom(), this._rect;
    }, t.prototype.getBoundingRect = function() {
      return this._rect;
    }, t.prototype.setViewRect = function(e, n, i, a) {
      this._transformTo(e, n, i, a), this._viewRect = new Bt(e, n, i, a);
    }, t.prototype._transformTo = function(e, n, i, a) {
      var o = this.getBoundingRect(), s = this._rawTransformable;
      s.transform = o.calculateTransform(new Bt(e, n, i, a));
      var l = s.parent;
      s.parent = null, s.decomposeTransform(), s.parent = l, this._updateTransform();
    }, t.prototype.setCenter = function(e) {
      var n = this._opt;
      n && n.api && n.ecModel && n.ecModel.getShallow("legacyViewCoordSysCenterBase") && e && (e = [dt(e[0], n.api.getWidth()), dt(e[1], n.api.getWidth())]), this._centerOption = Ct(e), this._updateCenterAndZoom();
    }, t.prototype.setZoom = function(e) {
      this._zoom = Vb(e || 1, this.zoomLimit), this._updateCenterAndZoom();
    }, t.prototype.getDefaultCenter = function() {
      var e = this.getBoundingRect(), n = e.x + e.width / 2, i = e.y + e.height / 2;
      return [n, i];
    }, t.prototype.getCenter = function() {
      return this._center || this.getDefaultCenter();
    }, t.prototype.getZoom = function() {
      return this._zoom || 1;
    }, t.prototype.getRoamTransform = function() {
      return this._roamTransformable.getLocalTransform();
    }, t.prototype._updateCenterAndZoom = function() {
      var e = this._centerOption, n = this._rect;
      e && n && (this._center = [dt(e[0], n.width, n.x), dt(e[1], n.height, n.y)]);
      var i = this._rawTransformable.getLocalTransform(), a = this._roamTransformable, o = this.getDefaultCenter(), s = this.getCenter(), l = this.getZoom();
      s = rr([], s, i), o = rr([], o, i), a.originX = s[0], a.originY = s[1], a.x = o[0] - s[0], a.y = o[1] - s[1], a.scaleX = a.scaleY = l, this._updateTransform();
    }, t.prototype._updateTransform = function() {
      var e = this._roamTransformable, n = this._rawTransformable;
      n.parent = e, e.updateTransform(), n.updateTransform(), Gg(this.transform || (this.transform = []), n.transform || kr()), this._rawTransform = n.getLocalTransform(), this.invTransform = this.invTransform || [], Si(this.invTransform, this.transform), this.decomposeTransform();
    }, t.prototype.getTransformInfo = function() {
      var e = this._rawTransformable, n = this._roamTransformable, i = new Da();
      return i.transform = n.transform, i.decomposeTransform(), {
        roam: {
          x: i.x,
          y: i.y,
          scaleX: i.scaleX,
          scaleY: i.scaleY
        },
        raw: {
          x: e.x,
          y: e.y,
          scaleX: e.scaleX,
          scaleY: e.scaleY
        }
      };
    }, t.prototype.getViewRect = function() {
      return this._viewRect;
    }, t.prototype.getViewRectAfterRoam = function() {
      var e = this.getBoundingRect().clone();
      return e.applyTransform(this.transform), e;
    }, t.prototype.dataToPoint = function(e, n, i) {
      var a = n ? this._rawTransform : this.transform;
      return i = i || [], a ? CD(i, e, a) : en(i, e);
    }, t.prototype.pointToData = function(e, n, i) {
      i = i || [];
      var a = this.invTransform;
      return a ? CD(i, e, a) : (i[0] = e[0], i[1] = e[1], i);
    }, t.prototype.convertToPixel = function(e, n, i) {
      var a = DD(n);
      return a === this ? a.dataToPoint(i) : null;
    }, t.prototype.convertFromPixel = function(e, n, i) {
      var a = DD(n);
      return a === this ? a.pointToData(i) : null;
    }, t.prototype.containPoint = function(e) {
      return this.getViewRectAfterRoam().contain(e[0], e[1]);
    }, t.dimensions = ["x", "y"], t;
  }(Da)
);
function DD(r) {
  var t = r.seriesModel;
  return t ? t.coordinateSystem : null;
}
var _J = {
  geoJSON: {
    aspectScale: 0.75,
    invertLongitute: !0
  },
  geoSVG: {
    aspectScale: 1,
    invertLongitute: !1
  }
}, Y3 = ["lng", "lat"], MS = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e, n, i) {
      var a = r.call(this, e, {
        api: i.api,
        ecModel: i.ecModel
      }) || this;
      a.dimensions = Y3, a.type = "geo", a._nameCoordMap = wt(), a.map = n;
      var o = i.projection, s = $a.load(n, i.nameMap, i.nameProperty), l = $a.getGeoResource(n), u = a.resourceType = l ? l.type : null, c = a.regions = s.regions, f = _J[l.type];
      a._regionsMap = s.regionsMap, a.regions = s.regions, process.env.NODE_ENV !== "production" && o && (u === "geoSVG" && (process.env.NODE_ENV !== "production" && Xe("Map " + n + " with SVG source can't use projection. Only GeoJSON source supports projection."), o = null), o.project && o.unproject || (process.env.NODE_ENV !== "production" && Xe("project and unproject must be both provided in the projeciton."), o = null)), a.projection = o;
      var h;
      if (o)
        for (var d = 0; d < c.length; d++) {
          var p = c[d].getBoundingRect(o);
          h = h || p.clone(), h.union(p);
        }
      else
        h = s.boundingRect;
      return a.setBoundingRect(h.x, h.y, h.width, h.height), a.aspectScale = o ? 1 : bt(i.aspectScale, f.aspectScale), a._invertLongitute = o ? !1 : f.invertLongitute, a;
    }
    return t.prototype._transformTo = function(e, n, i, a) {
      var o = this.getBoundingRect(), s = this._invertLongitute;
      o = o.clone(), s && (o.y = -o.y - o.height);
      var l = this._rawTransformable;
      l.transform = o.calculateTransform(new Bt(e, n, i, a));
      var u = l.parent;
      l.parent = null, l.decomposeTransform(), l.parent = u, s && (l.scaleY = -l.scaleY), this._updateTransform();
    }, t.prototype.getRegion = function(e) {
      return this._regionsMap.get(e);
    }, t.prototype.getRegionByCoord = function(e) {
      for (var n = this.regions, i = 0; i < n.length; i++) {
        var a = n[i];
        if (a.type === "geoJSON" && a.contain(e))
          return n[i];
      }
    }, t.prototype.addGeoCoord = function(e, n) {
      this._nameCoordMap.set(e, n);
    }, t.prototype.getGeoCoord = function(e) {
      var n = this._regionsMap.get(e);
      return this._nameCoordMap.get(e) || n && n.getCenter();
    }, t.prototype.dataToPoint = function(e, n, i) {
      if (pt(e) && (e = this.getGeoCoord(e)), e) {
        var a = this.projection;
        return a && (e = a.project(e)), e && this.projectedToPoint(e, n, i);
      }
    }, t.prototype.pointToData = function(e, n, i) {
      var a = this.projection;
      return a && (e = a.unproject(e)), e && this.pointToProjected(e, i);
    }, t.prototype.pointToProjected = function(e, n) {
      return r.prototype.pointToData.call(this, e, 0, n);
    }, t.prototype.projectedToPoint = function(e, n, i) {
      return r.prototype.dataToPoint.call(this, e, n, i);
    }, t.prototype.convertToPixel = function(e, n, i) {
      var a = LD(n);
      return a === this ? a.dataToPoint(i) : null;
    }, t.prototype.convertFromPixel = function(e, n, i) {
      var a = LD(n);
      return a === this ? a.pointToData(i) : null;
    }, t;
  }(Pl)
);
hr(MS, Pl);
function LD(r) {
  var t = r.geoModel, e = r.seriesModel;
  return t ? t.coordinateSystem : e ? e.coordinateSystem || (e.getReferringComponents("geo", Ke).models[0] || {}).coordinateSystem : null;
}
function RD(r, t) {
  var e = r.get("boundingCoords");
  if (e != null) {
    var n = e[0], i = e[1];
    if (!(isFinite(n[0]) && isFinite(n[1]) && isFinite(i[0]) && isFinite(i[1])))
      process.env.NODE_ENV !== "production" && console.error("Invalid boundingCoords");
    else {
      var a = this.projection;
      if (a) {
        var o = n[0], s = n[1], l = i[0], u = i[1];
        n = [1 / 0, 1 / 0], i = [-1 / 0, -1 / 0];
        var c = function(b, S, w, A) {
          for (var T = w - b, M = A - S, E = 0; E <= 100; E++) {
            var R = E / 100, C = a.project([b + T * R, S + M * R]);
            So(n, n, C), bo(i, i, C);
          }
        };
        c(o, s, l, s), c(l, s, l, u), c(l, u, o, u), c(o, u, l, s);
      }
      this.setBoundingRect(n[0], n[1], i[0] - n[0], i[1] - n[1]);
    }
  }
  var f = this.getBoundingRect(), h = r.get("layoutCenter"), d = r.get("layoutSize"), p = xr(r, t).refContainer, g = f.width / f.height * this.aspectScale, v = !1, m, y;
  h && d && (m = [dt(h[0], p.width) + p.x, dt(h[1], p.height) + p.y], y = dt(d, Math.min(p.width, p.height)), !isNaN(m[0]) && !isNaN(m[1]) && !isNaN(y) ? v = !0 : process.env.NODE_ENV !== "production" && console.warn("Given layoutCenter or layoutSize data are invalid. Use left/top/width/height instead."));
  var _;
  if (v)
    _ = {}, g > 1 ? (_.width = y, _.height = y / g) : (_.height = y, _.width = y * g), _.y = m[1] - _.height / 2, _.x = m[0] - _.width / 2;
  else {
    var x = r.getBoxLayoutParams();
    x.aspect = g, _ = He(x, p), _ = XN(r, _, g);
  }
  this.setViewRect(_.x, _.y, _.width, _.height), this.setCenter(r.get("center")), this.setZoom(r.get("zoom"));
}
function xJ(r, t) {
  L(t.get("geoCoord"), function(e, n) {
    r.addGeoCoord(n, e);
  });
}
var SJ = (
  /** @class */
  function() {
    function r() {
      this.dimensions = Y3;
    }
    return r.prototype.create = function(t, e) {
      var n = [];
      function i(o) {
        return {
          nameProperty: o.get("nameProperty"),
          aspectScale: o.get("aspectScale"),
          projection: o.get("projection")
        };
      }
      t.eachComponent("geo", function(o, s) {
        var l = o.get("map"), u = new MS(l + s, l, J({
          nameMap: o.get("nameMap"),
          api: e,
          ecModel: t
        }, i(o)));
        u.zoomLimit = o.get("scaleLimit"), n.push(u), o.coordinateSystem = u, u.model = o, u.resize = RD, u.resize(o, e);
      }), t.eachSeries(function(o) {
        zh({
          targetModel: o,
          coordSysType: "geo",
          coordSysProvider: function() {
            var s = o.subType === "map" ? o.getHostGeoModel() : o.getReferringComponents("geo", Ke).models[0];
            return s && s.coordinateSystem;
          },
          allowNotFound: !0
        });
      });
      var a = {};
      return t.eachSeriesByType("map", function(o) {
        if (!o.getHostGeoModel()) {
          var s = o.getMapType();
          a[s] = a[s] || [], a[s].push(o);
        }
      }), L(a, function(o, s) {
        var l = rt(o, function(c) {
          return c.get("nameMap");
        }), u = new MS(s, s, J({
          nameMap: x1(l),
          api: e,
          ecModel: t
        }, i(o[0])));
        u.zoomLimit = gr.apply(null, rt(o, function(c) {
          return c.get("scaleLimit");
        })), n.push(u), u.resize = RD, u.resize(o[0], e), L(o, function(c) {
          c.coordinateSystem = u, xJ(u, c);
        });
      }), n;
    }, r.prototype.getFilledRegions = function(t, e, n, i) {
      for (var a = (t || []).slice(), o = wt(), s = 0; s < a.length; s++)
        o.set(a[s].name, a[s]);
      var l = $a.load(e, n, i);
      return L(l.regions, function(u) {
        var c = u.name, f = o.get(c), h = u.properties && u.properties.echartsStyle;
        f || (f = {
          name: c
        }, a.push(f)), h && qt(f, h);
      }), a;
    }, r;
  }()
), $3 = new SJ(), bJ = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function(e, n, i) {
      this.mergeDefaultAndTheme(e, i);
      var a = $a.getGeoResource(e.map);
      if (a && a.type === "geoJSON") {
        var o = e.itemStyle = e.itemStyle || {};
        "color" in o || (o.color = e.defaultItemStyleColor || Y.color.backgroundTint);
      }
      hl(e, "label", ["show"]);
    }, t.prototype.optionUpdated = function() {
      var e = this, n = this.option;
      n.regions = $3.getFilledRegions(n.regions, n.map, n.nameMap, n.nameProperty);
      var i = {};
      this._optionModelMap = ea(n.regions || [], function(a, o) {
        var s = o.name;
        return s && (a.set(s, new ue(o, e, e.ecModel)), o.selected && (i[s] = !0)), a;
      }, wt()), n.selectedMap || (n.selectedMap = i);
    }, t.prototype.getRegionModel = function(e) {
      return this._optionModelMap.get(e) || new ue(null, this, this.ecModel);
    }, t.prototype.getFormattedLabel = function(e, n) {
      var i = this.getRegionModel(e), a = n === "normal" ? i.get(["label", "formatter"]) : i.get(["emphasis", "label", "formatter"]), o = {
        name: e
      };
      if (Tt(a))
        return o.status = n, a(o);
      if (pt(a))
        return a.replace("{a}", e ?? "");
    }, t.prototype.setZoom = function(e) {
      this.option.zoom = e;
    }, t.prototype.setCenter = function(e) {
      this.option.center = e;
    }, t.prototype.select = function(e) {
      var n = this.option, i = n.selectedMode;
      if (i) {
        i !== "multiple" && (n.selectedMap = null);
        var a = n.selectedMap || (n.selectedMap = {});
        a[e] = !0;
      }
    }, t.prototype.unSelect = function(e) {
      var n = this.option.selectedMap;
      n && (n[e] = !1);
    }, t.prototype.toggleSelected = function(e) {
      this[this.isSelected(e) ? "unSelect" : "select"](e);
    }, t.prototype.isSelected = function(e) {
      var n = this.option.selectedMap;
      return !!(n && n[e]);
    }, t.type = "geo", t.layoutMode = "box", t.defaultOption = {
      // zlevel: 0,
      z: 0,
      show: !0,
      left: "center",
      top: "center",
      // Default value:
      // for geoSVG source: 1,
      // for geoJSON source: 0.75.
      aspectScale: null,
      // /// Layout with center and size
      // If you want to put map in a fixed size box with right aspect ratio
      // This two properties may be more convenient
      // layoutCenter: [50%, 50%]
      // layoutSize: 100
      silent: !1,
      // Map type
      map: "",
      // Define left-top, right-bottom coords to control view
      // For example, [ [180, 90], [-180, -90] ]
      boundingCoords: null,
      // Default on center of map
      center: null,
      zoom: 1,
      scaleLimit: null,
      // selectedMode: false
      label: {
        show: !1,
        color: Y.color.tertiary
      },
      itemStyle: {
        borderWidth: 0.5,
        borderColor: Y.color.border
      },
      emphasis: {
        label: {
          show: !0,
          color: Y.color.primary
        },
        itemStyle: {
          color: Y.color.highlight
        }
      },
      select: {
        label: {
          show: !0,
          color: Y.color.primary
        },
        itemStyle: {
          color: Y.color.highlight
        }
      },
      regions: []
      // tooltip: {
      //     show: false
      // }
    }, t;
  }(re)
), wJ = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.focusBlurEnabled = !0, e;
    }
    return t.prototype.init = function(e, n) {
      this._api = n;
    }, t.prototype.render = function(e, n, i, a) {
      if (this._model = e, !e.get("show")) {
        this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
        return;
      }
      this._mapDraw || (this._mapDraw = new X3(i));
      var o = this._mapDraw;
      o.draw(e, n, i, this, a), o.group.on("click", this._handleRegionClick, this), o.group.silent = e.get("silent"), this.group.add(o.group), this.updateSelectStatus(e, n, i);
    }, t.prototype._handleRegionClick = function(e) {
      var n;
      Js(e.target, function(i) {
        return (n = zt(i).eventData) != null;
      }, !0), n && this._api.dispatchAction({
        type: "geoToggleSelect",
        geoId: this._model.id,
        name: n.name
      });
    }, t.prototype.updateSelectStatus = function(e, n, i) {
      var a = this;
      this._mapDraw.group.traverse(function(o) {
        var s = zt(o).eventData;
        if (s)
          return a._model.isSelected(s.name) ? i.enterSelect(o) : i.leaveSelect(o), !0;
      });
    }, t.prototype.findHighDownDispatchers = function(e) {
      return this._mapDraw && this._mapDraw.findHighDownDispatchers(e, this._model);
    }, t.prototype.dispose = function() {
      this._mapDraw && this._mapDraw.remove();
    }, t.type = "geo", t;
  }(Ue)
);
function MJ(r, t, e) {
  $a.registerMap(r, t, e);
}
function Z3(r) {
  r.registerCoordinateSystem("geo", $3), r.registerComponentModel(bJ), r.registerComponentView(wJ), r.registerImpl("registerMap", MJ), r.registerImpl("getMap", function(e) {
    return $a.getMapForUser(e);
  });
  function t(e, n) {
    n.update = "geo:updateSelectStatus", r.registerAction(n, function(i, a) {
      var o = {}, s = [];
      return a.eachComponent({
        mainType: "geo",
        query: i
      }, function(l) {
        l[e](i.name);
        var u = l.coordinateSystem;
        L(u.regions, function(f) {
          o[f.name] = l.isSelected(f.name) || !1;
        });
        var c = [];
        L(o, function(f, h) {
          o[h] && c.push(h);
        }), s.push({
          geoIndex: l.componentIndex,
          // Use singular, the same naming convention as the event `selectchanged`.
          name: c
        });
      }), {
        selected: o,
        allSelected: s,
        name: i.name
      };
    });
  }
  t("toggleSelected", {
    type: "geoToggleSelect",
    event: "geoselectchanged"
  }), t("select", {
    type: "geoSelect",
    event: "geoselected"
  }), t("unSelect", {
    type: "geoUnSelect",
    event: "geounselected"
  }), r.registerAction({
    type: "geoRoam",
    event: "geoRoam",
    update: "updateTransform"
  }, function(e, n, i) {
    var a = e.componentType;
    a || (e.geoId != null ? a = "geo" : e.seriesId != null && (a = "series")), a || (a = "series"), n.eachComponent({
      mainType: a,
      query: e
    }, function(o) {
      var s = o.coordinateSystem;
      if (s.type === "geo") {
        var l = _m(s, e, o.get("scaleLimit"));
        o.setCenter && o.setCenter(l.center), o.setZoom && o.setZoom(l.zoom), a === "series" && L(o.seriesGroup, function(u) {
          u.setCenter(l.center), u.setZoom(l.zoom);
        });
      }
    });
  });
}
function TJ(r) {
  jt(Z3), r.registerChartView(pJ), r.registerSeriesModel(vJ), r.registerLayout(yJ), r.registerProcessor(r.PRIORITY.PROCESSOR.STATISTIC, mJ), NO("map", r.registerAction);
}
function AJ(r) {
  var t = r;
  t.hierNode = {
    defaultAncestor: null,
    ancestor: t,
    prelim: 0,
    modifier: 0,
    change: 0,
    shift: 0,
    i: 0,
    thread: null
  };
  for (var e = [t], n, i; n = e.pop(); )
    if (i = n.children, n.isExpand && i.length)
      for (var a = i.length, o = a - 1; o >= 0; o--) {
        var s = i[o];
        s.hierNode = {
          defaultAncestor: null,
          ancestor: s,
          prelim: 0,
          modifier: 0,
          change: 0,
          shift: 0,
          i: o,
          thread: null
        }, e.push(s);
      }
}
function EJ(r, t) {
  var e = r.isExpand ? r.children : [], n = r.parentNode.children, i = r.hierNode.i ? n[r.hierNode.i - 1] : null;
  if (e.length) {
    DJ(r);
    var a = (e[0].hierNode.prelim + e[e.length - 1].hierNode.prelim) / 2;
    i ? (r.hierNode.prelim = i.hierNode.prelim + t(r, i), r.hierNode.modifier = r.hierNode.prelim - a) : r.hierNode.prelim = a;
  } else
    i && (r.hierNode.prelim = i.hierNode.prelim + t(r, i));
  r.parentNode.hierNode.defaultAncestor = LJ(r, i, r.parentNode.hierNode.defaultAncestor || n[0], t);
}
function CJ(r) {
  var t = r.hierNode.prelim + r.parentNode.hierNode.modifier;
  r.setLayout({
    x: t
  }, !0), r.hierNode.modifier += r.parentNode.hierNode.modifier;
}
function ID(r) {
  return arguments.length ? r : PJ;
}
function Of(r, t) {
  return r -= Math.PI / 2, {
    x: t * Math.cos(r),
    y: t * Math.sin(r)
  };
}
function DJ(r) {
  for (var t = r.children, e = t.length, n = 0, i = 0; --e >= 0; ) {
    var a = t[e];
    a.hierNode.prelim += n, a.hierNode.modifier += n, i += a.hierNode.change, n += a.hierNode.shift + i;
  }
}
function LJ(r, t, e, n) {
  if (t) {
    for (var i = r, a = r, o = a.parentNode.children[0], s = t, l = i.hierNode.modifier, u = a.hierNode.modifier, c = o.hierNode.modifier, f = s.hierNode.modifier; s = B0(s), a = V0(a), s && a; ) {
      i = B0(i), o = V0(o), i.hierNode.ancestor = r;
      var h = s.hierNode.prelim + f - a.hierNode.prelim - u + n(s, a);
      h > 0 && (IJ(RJ(s, r, e), r, h), u += h, l += h), f += s.hierNode.modifier, u += a.hierNode.modifier, l += i.hierNode.modifier, c += o.hierNode.modifier;
    }
    s && !B0(i) && (i.hierNode.thread = s, i.hierNode.modifier += f - l), a && !V0(o) && (o.hierNode.thread = a, o.hierNode.modifier += u - c, e = r);
  }
  return e;
}
function B0(r) {
  var t = r.children;
  return t.length && r.isExpand ? t[t.length - 1] : r.hierNode.thread;
}
function V0(r) {
  var t = r.children;
  return t.length && r.isExpand ? t[0] : r.hierNode.thread;
}
function RJ(r, t, e) {
  return r.hierNode.ancestor.parentNode === t.parentNode ? r.hierNode.ancestor : e;
}
function IJ(r, t, e) {
  var n = e / (t.hierNode.i - r.hierNode.i);
  t.hierNode.change -= n, t.hierNode.shift += e, t.hierNode.modifier += e, t.hierNode.prelim += e, r.hierNode.change += n;
}
function PJ(r, t) {
  return r.parentNode === t.parentNode ? 1 : 2;
}
var NJ = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
      this.parentPoint = [], this.childPoints = [];
    }
    return r;
  }()
), OJ = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e) {
      return r.call(this, e) || this;
    }
    return t.prototype.getDefaultStyle = function() {
      return {
        stroke: Y.color.neutral99,
        fill: null
      };
    }, t.prototype.getDefaultShape = function() {
      return new NJ();
    }, t.prototype.buildPath = function(e, n) {
      var i = n.childPoints, a = i.length, o = n.parentPoint, s = i[0], l = i[a - 1];
      if (a === 1) {
        e.moveTo(o[0], o[1]), e.lineTo(s[0], s[1]);
        return;
      }
      var u = n.orient, c = u === "TB" || u === "BT" ? 0 : 1, f = 1 - c, h = dt(n.forkPosition, 1), d = [];
      d[c] = o[c], d[f] = o[f] + (l[f] - o[f]) * h, e.moveTo(o[0], o[1]), e.lineTo(d[0], d[1]), e.moveTo(s[0], s[1]), d[c] = s[c], e.lineTo(d[0], d[1]), d[c] = l[c], e.lineTo(d[0], d[1]), e.lineTo(l[0], l[1]);
      for (var p = 1; p < a - 1; p++) {
        var g = i[p];
        e.moveTo(g[0], g[1]), d[c] = g[c], e.lineTo(d[0], d[1]);
      }
    }, t;
  }(ne)
), kJ = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e._mainGroup = new Et(), e;
    }
    return t.prototype.init = function(e, n) {
      this._controller = new Il(n.getZr()), this._controllerHost = {
        target: this.group
      }, this.group.add(this._mainGroup);
    }, t.prototype.render = function(e, n, i) {
      var a = e.getData(), o = e.layoutInfo, s = this._mainGroup, l = e.get("layout");
      l === "radial" ? (s.x = o.x + o.width / 2, s.y = o.y + o.height / 2) : (s.x = o.x, s.y = o.y), this._updateViewCoordSys(e, i), this._updateController(e, null, n, i);
      var u = this._data;
      a.diff(u).add(function(c) {
        PD(a, c) && ND(a, c, null, s, e);
      }).update(function(c, f) {
        var h = u.getItemGraphicEl(f);
        if (!PD(a, c)) {
          h && kD(u, f, h, s, e);
          return;
        }
        ND(a, c, h, s, e);
      }).remove(function(c) {
        var f = u.getItemGraphicEl(c);
        f && kD(u, c, f, s, e);
      }).execute(), this._nodeScaleRatio = e.get("nodeScaleRatio"), this._updateNodeAndLinkScale(e), e.get("expandAndCollapse") === !0 && a.eachItemGraphicEl(function(c, f) {
        c.off("click").on("click", function() {
          i.dispatchAction({
            type: "treeExpandAndCollapse",
            seriesId: e.id,
            dataIndex: f
          });
        });
      }), this._data = a;
    }, t.prototype._updateViewCoordSys = function(e, n) {
      var i = e.getData(), a = [];
      i.each(function(f) {
        var h = i.getItemLayout(f);
        h && !isNaN(h.x) && !isNaN(h.y) && a.push([+h.x, +h.y]);
      });
      var o = [], s = [];
      jg(a, o, s);
      var l = this._min, u = this._max;
      s[0] - o[0] === 0 && (o[0] = l ? l[0] : o[0] - 1, s[0] = u ? u[0] : s[0] + 1), s[1] - o[1] === 0 && (o[1] = l ? l[1] : o[1] - 1, s[1] = u ? u[1] : s[1] + 1);
      var c = e.coordinateSystem = new Pl(null, {
        api: n,
        ecModel: e.ecModel
      });
      c.zoomLimit = e.get("scaleLimit"), c.setBoundingRect(o[0], o[1], s[0] - o[0], s[1] - o[1]), c.setCenter(e.get("center")), c.setZoom(e.get("zoom")), this.group.attr({
        x: c.x,
        y: c.y,
        scaleX: c.scaleX,
        scaleY: c.scaleY
      }), this._min = o, this._max = s;
    }, t.prototype._updateController = function(e, n, i, a) {
      var o = this;
      F3(e, a, this.group, this._controller, this._controllerHost, n), this._controller.on("zoom", function(s) {
        o._updateNodeAndLinkScale(e);
      });
    }, t.prototype._updateNodeAndLinkScale = function(e) {
      var n = e.getData(), i = this._getNodeGlobalScale(e);
      n.eachItemGraphicEl(function(a, o) {
        a.setSymbolScale(i);
      });
    }, t.prototype._getNodeGlobalScale = function(e) {
      var n = e.coordinateSystem;
      if (n.type !== "view")
        return 1;
      var i = this._nodeScaleRatio, a = n.scaleX || 1, o = n.getZoom(), s = (o - 1) * i + 1;
      return s / a;
    }, t.prototype.dispose = function() {
      this._controller && this._controller.dispose(), this._controllerHost = null;
    }, t.prototype.remove = function() {
      this._mainGroup.removeAll(), this._data = null;
    }, t.type = "tree", t;
  }(Re)
);
function PD(r, t) {
  var e = r.getItemLayout(t);
  return e && !isNaN(e.x) && !isNaN(e.y);
}
function ND(r, t, e, n, i) {
  var a = !e, o = r.tree.getNodeByDataIndex(t), s = o.getModel(), l = o.getVisual("style").fill, u = o.isExpand === !1 && o.children.length !== 0 ? l : Y.color.neutral00, c = r.tree.root, f = o.parentNode === c ? o : o.parentNode || o, h = r.getItemGraphicEl(f.dataIndex), d = f.getLayout(), p = h ? {
    x: h.__oldX,
    y: h.__oldY,
    rawX: h.__radialOldRawX,
    rawY: h.__radialOldRawY
  } : d, g = o.getLayout();
  a ? (e = new Wh(r, t, null, {
    symbolInnerColor: u,
    useNameLabel: !0
  }), e.x = p.x, e.y = p.y) : e.updateData(r, t, null, {
    symbolInnerColor: u,
    useNameLabel: !0
  }), e.__radialOldRawX = e.__radialRawX, e.__radialOldRawY = e.__radialRawY, e.__radialRawX = g.rawX, e.__radialRawY = g.rawY, n.add(e), r.setItemGraphicEl(t, e), e.__oldX = e.x, e.__oldY = e.y, ve(e, {
    x: g.x,
    y: g.y
  }, i);
  var v = e.getSymbolPath();
  if (i.get("layout") === "radial") {
    var m = c.children[0], y = m.getLayout(), _ = m.children.length, x = void 0, b = void 0;
    if (g.x === y.x && o.isExpand === !0 && m.children.length) {
      var S = {
        x: (m.children[0].getLayout().x + m.children[_ - 1].getLayout().x) / 2,
        y: (m.children[0].getLayout().y + m.children[_ - 1].getLayout().y) / 2
      };
      x = Math.atan2(S.y - y.y, S.x - y.x), x < 0 && (x = Math.PI * 2 + x), b = S.x < y.x, b && (x = x - Math.PI);
    } else
      x = Math.atan2(g.y - y.y, g.x - y.x), x < 0 && (x = Math.PI * 2 + x), o.children.length === 0 || o.children.length !== 0 && o.isExpand === !1 ? (b = g.x < y.x, b && (x = x - Math.PI)) : (b = g.x > y.x, b || (x = x - Math.PI));
    var w = b ? "left" : "right", A = s.getModel("label"), T = A.get("rotate"), M = T * (Math.PI / 180), E = v.getTextContent();
    E && (v.setTextConfig({
      position: A.get("position") || w,
      rotation: T == null ? -x : M,
      origin: "center"
    }), E.setStyle("verticalAlign", "middle"));
  }
  var R = s.get(["emphasis", "focus"]), C = R === "relative" ? th(o.getAncestorsIndices(), o.getDescendantIndices()) : R === "ancestor" ? o.getAncestorsIndices() : R === "descendant" ? o.getDescendantIndices() : null;
  C && (zt(e).focus = C), BJ(i, o, c, e, p, d, g, n), e.__edge && (e.onHoverStateChange = function(D) {
    if (D !== "blur") {
      var I = o.parentNode && r.getItemGraphicEl(o.parentNode.dataIndex);
      I && I.hoverState === Nh || Pv(e.__edge, D);
    }
  });
}
function BJ(r, t, e, n, i, a, o, s) {
  var l = t.getModel(), u = r.get("edgeShape"), c = r.get("layout"), f = r.getOrient(), h = r.get(["lineStyle", "curveness"]), d = r.get("edgeForkPosition"), p = l.getModel("lineStyle").getLineStyle(), g = n.__edge;
  if (u === "curve")
    t.parentNode && t.parentNode !== e && (g || (g = n.__edge = new kh({
      shape: TS(c, f, h, i, i)
    })), ve(g, {
      shape: TS(c, f, h, a, o)
    }, r));
  else if (u === "polyline") {
    if (c === "orthogonal") {
      if (t !== e && t.children && t.children.length !== 0 && t.isExpand === !0) {
        for (var v = t.children, m = [], y = 0; y < v.length; y++) {
          var _ = v[y].getLayout();
          m.push([_.x, _.y]);
        }
        g || (g = n.__edge = new OJ({
          shape: {
            parentPoint: [o.x, o.y],
            childPoints: [[o.x, o.y]],
            orient: f,
            forkPosition: d
          }
        })), ve(g, {
          shape: {
            parentPoint: [o.x, o.y],
            childPoints: m
          }
        }, r);
      }
    } else if (process.env.NODE_ENV !== "production")
      throw new Error("The polyline edgeShape can only be used in orthogonal layout");
  }
  g && !(u === "polyline" && !t.isExpand) && (g.useStyle(kt({
    strokeNoScale: !0,
    fill: null
  }, p)), yr(g, l, "lineStyle"), vl(g), s.add(g));
}
function OD(r, t, e, n, i) {
  var a = t.tree.root, o = q3(a, r), s = o.source, l = o.sourceLayout, u = t.getItemGraphicEl(r.dataIndex);
  if (u) {
    var c = t.getItemGraphicEl(s.dataIndex), f = c.__edge, h = u.__edge || (s.isExpand === !1 || s.children.length === 1 ? f : void 0), d = n.get("edgeShape"), p = n.get("layout"), g = n.get("orient"), v = n.get(["lineStyle", "curveness"]);
    h && (d === "curve" ? Go(h, {
      shape: TS(p, g, v, l, l),
      style: {
        opacity: 0
      }
    }, n, {
      cb: function() {
        e.remove(h);
      },
      removeOpt: i
    }) : d === "polyline" && n.get("layout") === "orthogonal" && Go(h, {
      shape: {
        parentPoint: [l.x, l.y],
        childPoints: [[l.x, l.y]]
      },
      style: {
        opacity: 0
      }
    }, n, {
      cb: function() {
        e.remove(h);
      },
      removeOpt: i
    }));
  }
}
function q3(r, t) {
  for (var e = t.parentNode === r ? t : t.parentNode || t, n; n = e.getLayout(), n == null; )
    e = e.parentNode === r ? e : e.parentNode || e;
  return {
    source: e,
    sourceLayout: n
  };
}
function kD(r, t, e, n, i) {
  var a = r.tree.getNodeByDataIndex(t), o = r.tree.root, s = q3(o, a).sourceLayout, l = {
    duration: i.get("animationDurationUpdate"),
    easing: i.get("animationEasingUpdate")
  };
  Go(e, {
    x: s.x + 1,
    y: s.y + 1
  }, i, {
    cb: function() {
      n.remove(e), r.setItemGraphicEl(t, null);
    },
    removeOpt: l
  }), e.fadeOut(null, r.hostModel, {
    fadeLabel: !0,
    animation: l
  }), a.children.forEach(function(u) {
    OD(u, r, n, i, l);
  }), OD(a, r, n, i, l);
}
function TS(r, t, e, n, i) {
  var a, o, s, l, u, c, f, h;
  if (r === "radial") {
    u = n.rawX, f = n.rawY, c = i.rawX, h = i.rawY;
    var d = Of(u, f), p = Of(u, f + (h - f) * e), g = Of(c, h + (f - h) * e), v = Of(c, h);
    return {
      x1: d.x || 0,
      y1: d.y || 0,
      x2: v.x || 0,
      y2: v.y || 0,
      cpx1: p.x || 0,
      cpy1: p.y || 0,
      cpx2: g.x || 0,
      cpy2: g.y || 0
    };
  } else
    u = n.x, f = n.y, c = i.x, h = i.y, (t === "LR" || t === "RL") && (a = u + (c - u) * e, o = f, s = c + (u - c) * e, l = h), (t === "TB" || t === "BT") && (a = u, o = f + (h - f) * e, s = c, l = h + (f - h) * e);
  return {
    x1: u,
    y1: f,
    x2: c,
    y2: h,
    cpx1: a,
    cpy1: o,
    cpx2: s,
    cpy2: l
  };
}
var ni = ee();
function K3(r) {
  var t = r.mainData, e = r.datas;
  e || (e = {
    main: t
  }, r.datasAttr = {
    main: "data"
  }), r.datas = r.mainData = null, j3(t, e, r), L(e, function(n) {
    L(t.TRANSFERABLE_METHODS, function(i) {
      n.wrapMethod(i, Yt(VJ, r));
    });
  }), t.wrapMethod("cloneShallow", Yt(zJ, r)), L(t.CHANGABLE_METHODS, function(n) {
    t.wrapMethod(n, Yt(FJ, r));
  }), St(e[t.dataType] === t);
}
function VJ(r, t) {
  if (HJ(this)) {
    var e = J({}, ni(this).datas);
    e[this.dataType] = t, j3(t, e, r);
  } else
    zb(t, this.dataType, ni(this).mainData, r);
  return t;
}
function FJ(r, t) {
  return r.struct && r.struct.update(), t;
}
function zJ(r, t) {
  return L(ni(t).datas, function(e, n) {
    e !== t && zb(e.cloneShallow(), n, t, r);
  }), t;
}
function UJ(r) {
  var t = ni(this).mainData;
  return r == null || t == null ? t : ni(t).datas[r];
}
function GJ() {
  var r = ni(this).mainData;
  return r == null ? [{
    data: r
  }] : rt(se(ni(r).datas), function(t) {
    return {
      type: t,
      data: ni(r).datas[t]
    };
  });
}
function HJ(r) {
  return ni(r).mainData === r;
}
function j3(r, t, e) {
  ni(r).datas = {}, L(t, function(n, i) {
    zb(n, i, r, e);
  });
}
function zb(r, t, e, n) {
  ni(e).datas[t] = r, ni(r).mainData = e, r.dataType = t, n.struct && (r[n.structAttr] = n.struct, n.struct[n.datasAttr[t]] = r), r.getLinkedData = UJ, r.getLinkedDataAll = GJ;
}
var WJ = (
  /** @class */
  function() {
    function r(t, e) {
      this.depth = 0, this.height = 0, this.dataIndex = -1, this.children = [], this.viewChildren = [], this.isExpand = !1, this.name = t || "", this.hostTree = e;
    }
    return r.prototype.isRemoved = function() {
      return this.dataIndex < 0;
    }, r.prototype.eachNode = function(t, e, n) {
      Tt(t) && (n = e, e = t, t = null), t = t || {}, pt(t) && (t = {
        order: t
      });
      var i = t.order || "preorder", a = this[t.attr || "children"], o;
      i === "preorder" && (o = e.call(n, this));
      for (var s = 0; !o && s < a.length; s++)
        a[s].eachNode(t, e, n);
      i === "postorder" && e.call(n, this);
    }, r.prototype.updateDepthAndHeight = function(t) {
      var e = 0;
      this.depth = t;
      for (var n = 0; n < this.children.length; n++) {
        var i = this.children[n];
        i.updateDepthAndHeight(t + 1), i.height > e && (e = i.height);
      }
      this.height = e + 1;
    }, r.prototype.getNodeById = function(t) {
      if (this.getId() === t)
        return this;
      for (var e = 0, n = this.children, i = n.length; e < i; e++) {
        var a = n[e].getNodeById(t);
        if (a)
          return a;
      }
    }, r.prototype.contains = function(t) {
      if (t === this)
        return !0;
      for (var e = 0, n = this.children, i = n.length; e < i; e++) {
        var a = n[e].contains(t);
        if (a)
          return a;
      }
    }, r.prototype.getAncestors = function(t) {
      for (var e = [], n = t ? this : this.parentNode; n; )
        e.push(n), n = n.parentNode;
      return e.reverse(), e;
    }, r.prototype.getAncestorsIndices = function() {
      for (var t = [], e = this; e; )
        t.push(e.dataIndex), e = e.parentNode;
      return t.reverse(), t;
    }, r.prototype.getDescendantIndices = function() {
      var t = [];
      return this.eachNode(function(e) {
        t.push(e.dataIndex);
      }), t;
    }, r.prototype.getValue = function(t) {
      var e = this.hostTree.data;
      return e.getStore().get(e.getDimensionIndex(t || "value"), this.dataIndex);
    }, r.prototype.setLayout = function(t, e) {
      this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, t, e);
    }, r.prototype.getLayout = function() {
      return this.hostTree.data.getItemLayout(this.dataIndex);
    }, r.prototype.getModel = function(t) {
      if (!(this.dataIndex < 0)) {
        var e = this.hostTree, n = e.data.getItemModel(this.dataIndex);
        return n.getModel(t);
      }
    }, r.prototype.getLevelModel = function() {
      return (this.hostTree.levelModels || [])[this.depth];
    }, r.prototype.setVisual = function(t, e) {
      this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, t, e);
    }, r.prototype.getVisual = function(t) {
      return this.hostTree.data.getItemVisual(this.dataIndex, t);
    }, r.prototype.getRawIndex = function() {
      return this.hostTree.data.getRawIndex(this.dataIndex);
    }, r.prototype.getId = function() {
      return this.hostTree.data.getId(this.dataIndex);
    }, r.prototype.getChildIndex = function() {
      if (this.parentNode) {
        for (var t = this.parentNode.children, e = 0; e < t.length; ++e)
          if (t[e] === this)
            return e;
        return -1;
      }
      return -1;
    }, r.prototype.isAncestorOf = function(t) {
      for (var e = t.parentNode; e; ) {
        if (e === this)
          return !0;
        e = e.parentNode;
      }
      return !1;
    }, r.prototype.isDescendantOf = function(t) {
      return t !== this && t.isAncestorOf(this);
    }, r;
  }()
), Ub = (
  /** @class */
  function() {
    function r(t) {
      this.type = "tree", this._nodes = [], this.hostModel = t;
    }
    return r.prototype.eachNode = function(t, e, n) {
      this.root.eachNode(t, e, n);
    }, r.prototype.getNodeByDataIndex = function(t) {
      var e = this.data.getRawIndex(t);
      return this._nodes[e];
    }, r.prototype.getNodeById = function(t) {
      return this.root.getNodeById(t);
    }, r.prototype.update = function() {
      for (var t = this.data, e = this._nodes, n = 0, i = e.length; n < i; n++)
        e[n].dataIndex = -1;
      for (var n = 0, i = t.count(); n < i; n++)
        e[t.getRawIndex(n)].dataIndex = n;
    }, r.prototype.clearLayouts = function() {
      this.data.clearItemLayouts();
    }, r.createTree = function(t, e, n) {
      var i = new r(e), a = [], o = 1;
      s(t);
      function s(c, f) {
        var h = c.value;
        o = Math.max(o, et(h) ? h.length : 1), a.push(c);
        var d = new WJ(mr(c.name, ""), i);
        f ? XJ(d, f) : i.root = d, i._nodes.push(d);
        var p = c.children;
        if (p)
          for (var g = 0; g < p.length; g++)
            s(p[g], d);
      }
      i.root.updateDepthAndHeight(0);
      var l = Gh(a, {
        coordDimensions: ["value"],
        dimensionsCount: o
      }).dimensions, u = new un(l, e);
      return u.initData(a), n && n(u), K3({
        mainData: u,
        struct: i,
        structAttr: "tree"
      }), i.update(), i;
    }, r;
  }()
);
function XJ(r, t) {
  var e = t.children;
  r.parentNode !== t && (e.push(r), r.parentNode = t);
}
function xh(r, t, e) {
  if (r && Zt(t, r.type) >= 0) {
    var n = e.getData().tree.root, i = r.targetNode;
    if (pt(i) && (i = n.getNodeById(i)), i && n.contains(i))
      return {
        node: i
      };
    var a = r.targetNodeId;
    if (a != null && (i = n.getNodeById(a)))
      return {
        node: i
      };
  }
}
function J3(r) {
  for (var t = []; r; )
    r = r.parentNode, r && t.push(r);
  return t.reverse();
}
function Gb(r, t) {
  var e = J3(r);
  return Zt(e, t) >= 0;
}
function Sm(r, t) {
  for (var e = []; r; ) {
    var n = r.dataIndex;
    e.push({
      name: r.name,
      dataIndex: n,
      value: t.getRawValue(n)
    }), r = r.parentNode;
  }
  return e.reverse(), e;
}
var YJ = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.hasSymbolVisual = !0, e.ignoreStyleOnData = !0, e;
    }
    return t.prototype.getInitialData = function(e) {
      var n = {
        name: e.name,
        children: e.data
      }, i = e.leaves || {}, a = new ue(i, this, this.ecModel), o = Ub.createTree(n, this, s);
      function s(f) {
        f.wrapMethod("getItemModel", function(h, d) {
          var p = o.getNodeByDataIndex(d);
          return p && p.children.length && p.isExpand || (h.parentModel = a), h;
        });
      }
      var l = 0;
      o.eachNode("preorder", function(f) {
        f.depth > l && (l = f.depth);
      });
      var u = e.expandAndCollapse, c = u && e.initialTreeDepth >= 0 ? e.initialTreeDepth : l;
      return o.root.eachNode("preorder", function(f) {
        var h = f.hostTree.data.getRawDataItem(f.dataIndex);
        f.isExpand = h && h.collapsed != null ? !h.collapsed : f.depth <= c;
      }), o.data;
    }, t.prototype.getOrient = function() {
      var e = this.get("orient");
      return e === "horizontal" ? e = "LR" : e === "vertical" && (e = "TB"), e;
    }, t.prototype.setZoom = function(e) {
      this.option.zoom = e;
    }, t.prototype.setCenter = function(e) {
      this.option.center = e;
    }, t.prototype.formatTooltip = function(e, n, i) {
      for (var a = this.getData().tree, o = a.root.children[0], s = a.getNodeByDataIndex(e), l = s.getValue(), u = s.name; s && s !== o; )
        u = s.parentNode.name + "." + u, s = s.parentNode;
      return cr("nameValue", {
        name: u,
        value: l,
        noValue: isNaN(l) || l == null
      });
    }, t.prototype.getDataParams = function(e) {
      var n = r.prototype.getDataParams.apply(this, arguments), i = this.getData().tree.getNodeByDataIndex(e);
      return n.treeAncestors = Sm(i, this), n.collapsed = !i.isExpand, n;
    }, t.type = "series.tree", t.layoutMode = "box", t.defaultOption = {
      // zlevel: 0,
      z: 2,
      // `coordinateSystem` can be declared as 'matrix', 'calendar',
      //  which provides box layout container.
      coordinateSystemUsage: "box",
      // the position of the whole view
      left: "12%",
      top: "12%",
      right: "12%",
      bottom: "12%",
      // the layout of the tree, two value can be selected, 'orthogonal' or 'radial'
      layout: "orthogonal",
      // value can be 'polyline'
      edgeShape: "curve",
      edgeForkPosition: "50%",
      // true | false | 'move' | 'scale', see module:component/helper/RoamController.
      roam: !1,
      roamTrigger: "global",
      // Symbol size scale ratio in roam
      nodeScaleRatio: 0.4,
      // Default on center of graph
      center: null,
      zoom: 1,
      orient: "LR",
      symbol: "emptyCircle",
      symbolSize: 7,
      expandAndCollapse: !0,
      initialTreeDepth: 2,
      lineStyle: {
        color: Y.color.borderTint,
        width: 1.5,
        curveness: 0.5
      },
      itemStyle: {
        color: "lightsteelblue",
        // borderColor: '#c23531',
        borderWidth: 1.5
      },
      label: {
        show: !0
      },
      animationEasing: "linear",
      animationDuration: 700,
      animationDurationUpdate: 500
    }, t;
  }(ke)
);
function $J(r, t, e) {
  for (var n = [r], i = [], a; a = n.pop(); )
    if (i.push(a), a.isExpand) {
      var o = a.children;
      if (o.length)
        for (var s = 0; s < o.length; s++)
          n.push(o[s]);
    }
  for (; a = i.pop(); )
    t(a, e);
}
function pf(r, t) {
  for (var e = [r], n; n = e.pop(); )
    if (t(n), n.isExpand) {
      var i = n.children;
      if (i.length)
        for (var a = i.length - 1; a >= 0; a--)
          e.push(i[a]);
    }
}
function ZJ(r, t) {
  r.eachSeriesByType("tree", function(e) {
    qJ(e, t);
  });
}
function qJ(r, t) {
  var e = xr(r, t).refContainer, n = He(r.getBoxLayoutParams(), e);
  r.layoutInfo = n;
  var i = r.get("layout"), a = 0, o = 0, s = null;
  i === "radial" ? (a = 2 * Math.PI, o = Math.min(n.height, n.width) / 2, s = ID(function(x, b) {
    return (x.parentNode === b.parentNode ? 1 : 2) / x.depth;
  })) : (a = n.width, o = n.height, s = ID());
  var l = r.getData().tree.root, u = l.children[0];
  if (u) {
    AJ(l), $J(u, EJ, s), l.hierNode.modifier = -u.hierNode.prelim, pf(u, CJ);
    var c = u, f = u, h = u;
    pf(u, function(x) {
      var b = x.getLayout().x;
      b < c.getLayout().x && (c = x), b > f.getLayout().x && (f = x), x.depth > h.depth && (h = x);
    });
    var d = c === f ? 1 : s(c, f) / 2, p = d - c.getLayout().x, g = 0, v = 0, m = 0, y = 0;
    if (i === "radial")
      g = a / (f.getLayout().x + d + p), v = o / (h.depth - 1 || 1), pf(u, function(x) {
        m = (x.getLayout().x + p) * g, y = (x.depth - 1) * v;
        var b = Of(m, y);
        x.setLayout({
          x: b.x,
          y: b.y,
          rawX: m,
          rawY: y
        }, !0);
      });
    else {
      var _ = r.getOrient();
      _ === "RL" || _ === "LR" ? (v = o / (f.getLayout().x + d + p), g = a / (h.depth - 1 || 1), pf(u, function(x) {
        y = (x.getLayout().x + p) * v, m = _ === "LR" ? (x.depth - 1) * g : a - (x.depth - 1) * g, x.setLayout({
          x: m,
          y
        }, !0);
      })) : (_ === "TB" || _ === "BT") && (g = a / (f.getLayout().x + d + p), v = o / (h.depth - 1 || 1), pf(u, function(x) {
        m = (x.getLayout().x + p) * g, y = _ === "TB" ? (x.depth - 1) * v : o - (x.depth - 1) * v, x.setLayout({
          x: m,
          y
        }, !0);
      }));
    }
  }
}
function KJ(r) {
  r.eachSeriesByType("tree", function(t) {
    var e = t.getData(), n = e.tree;
    n.eachNode(function(i) {
      var a = i.getModel(), o = a.getModel("itemStyle").getItemStyle(), s = e.ensureUniqueItemVisual(i.dataIndex, "style");
      J(s, o);
    });
  });
}
function jJ(r) {
  r.registerAction({
    type: "treeExpandAndCollapse",
    event: "treeExpandAndCollapse",
    update: "update"
  }, function(t, e) {
    e.eachComponent({
      mainType: "series",
      subType: "tree",
      query: t
    }, function(n) {
      var i = t.dataIndex, a = n.getData().tree, o = a.getNodeByDataIndex(i);
      o.isExpand = !o.isExpand;
    });
  }), r.registerAction({
    type: "treeRoam",
    event: "treeRoam",
    // Here we set 'none' instead of 'update', because roam action
    // just need to update the transform matrix without having to recalculate
    // the layout. So don't need to go through the whole update process, such
    // as 'dataPrcocess', 'coordSystemUpdate', 'layout' and so on.
    update: "none"
  }, function(t, e, n) {
    e.eachComponent({
      mainType: "series",
      subType: "tree",
      query: t
    }, function(i) {
      var a = i.coordinateSystem, o = _m(a, t, i.get("scaleLimit"));
      i.setCenter(o.center), i.setZoom(o.zoom);
    });
  });
}
function JJ(r) {
  r.registerChartView(kJ), r.registerSeriesModel(YJ), r.registerLayout(ZJ), r.registerVisual(KJ), jJ(r);
}
var BD = ["treemapZoomToNode", "treemapRender", "treemapMove"];
function QJ(r) {
  for (var t = 0; t < BD.length; t++)
    r.registerAction({
      type: BD[t],
      update: "updateView"
    }, er);
  r.registerAction({
    type: "treemapRootToNode",
    update: "updateView"
  }, function(e, n) {
    n.eachComponent({
      mainType: "series",
      subType: "treemap",
      query: e
    }, i);
    function i(a, o) {
      var s = ["treemapZoomToNode", "treemapRootToNode"], l = xh(e, s, a);
      if (l) {
        var u = a.getViewRoot();
        u && (e.direction = Gb(u, l.node) ? "rollUp" : "drillDown"), a.resetViewRoot(l.node);
      }
    }
  });
}
function Q3(r) {
  var t = r.getData(), e = t.tree, n = {};
  e.eachNode(function(i) {
    for (var a = i; a && a.depth > 1; )
      a = a.parentNode;
    var o = Wx(r.ecModel, a.name || a.dataIndex + "", n);
    i.setVisual("decal", o);
  });
}
var tQ = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.preventUsingHoverLayer = !0, e;
    }
    return t.prototype.getInitialData = function(e, n) {
      var i = {
        name: e.name,
        children: e.data
      };
      tB(i);
      var a = e.levels || [], o = this.designatedVisualItemStyle = {}, s = new ue({
        itemStyle: o
      }, this, n);
      a = e.levels = eQ(a, n);
      var l = rt(a || [], function(f) {
        return new ue(f, s, n);
      }, this), u = Ub.createTree(i, this, c);
      function c(f) {
        f.wrapMethod("getItemModel", function(h, d) {
          var p = u.getNodeByDataIndex(d), g = p ? l[p.depth] : null;
          return h.parentModel = g || s, h;
        });
      }
      return u.data;
    }, t.prototype.optionUpdated = function() {
      this.resetViewRoot();
    }, t.prototype.formatTooltip = function(e, n, i) {
      var a = this.getData(), o = this.getRawValue(e), s = a.getName(e);
      return cr("nameValue", {
        name: s,
        value: o
      });
    }, t.prototype.getDataParams = function(e) {
      var n = r.prototype.getDataParams.apply(this, arguments), i = this.getData().tree.getNodeByDataIndex(e);
      return n.treeAncestors = Sm(i, this), n.treePathInfo = n.treeAncestors, n;
    }, t.prototype.setLayoutInfo = function(e) {
      this.layoutInfo = this.layoutInfo || {}, J(this.layoutInfo, e);
    }, t.prototype.mapIdToIndex = function(e) {
      var n = this._idIndexMap;
      n || (n = this._idIndexMap = wt(), this._idIndexMapCount = 0);
      var i = n.get(e);
      return i == null && n.set(e, i = this._idIndexMapCount++), i;
    }, t.prototype.getViewRoot = function() {
      return this._viewRoot;
    }, t.prototype.resetViewRoot = function(e) {
      e ? this._viewRoot = e : e = this._viewRoot;
      var n = this.getRawData().tree.root;
      (!e || e !== n && !n.contains(e)) && (this._viewRoot = n);
    }, t.prototype.enableAriaDecal = function() {
      Q3(this);
    }, t.type = "series.treemap", t.layoutMode = "box", t.defaultOption = {
      // Disable progressive rendering
      progressive: 0,
      // size: ['80%', '80%'],            // deprecated, compatible with ec2.
      // `coordinateSystem` can be declared as 'matrix', 'calendar',
      //  which provides box layout container.
      coordinateSystemUsage: "box",
      left: Y.size.l,
      top: Y.size.xxxl,
      right: Y.size.l,
      bottom: Y.size.xxxl,
      sort: !0,
      clipWindow: "origin",
      squareRatio: 0.5 * (1 + Math.sqrt(5)),
      leafDepth: null,
      drillDownIcon: "",
      // to align specialized icon. 
      zoomToNodeRatio: 0.32 * 0.32,
      scaleLimit: {
        max: 5,
        min: 0.2
      },
      roam: !0,
      roamTrigger: "global",
      nodeClick: "zoomToNode",
      animation: !0,
      animationDurationUpdate: 900,
      animationEasing: "quinticInOut",
      breadcrumb: {
        show: !0,
        height: 22,
        left: "center",
        bottom: Y.size.m,
        // right
        // bottom
        emptyItemWidth: 25,
        itemStyle: {
          color: Y.color.backgroundShade,
          textStyle: {
            color: Y.color.secondary
          }
        },
        emphasis: {
          itemStyle: {
            color: Y.color.background
          }
        }
      },
      label: {
        show: !0,
        // Do not use textDistance, for ellipsis rect just the same as treemap node rect.
        distance: 0,
        padding: 5,
        position: "inside",
        // formatter: null,
        color: Y.color.neutral00,
        overflow: "truncate"
        // align
        // verticalAlign
      },
      upperLabel: {
        show: !1,
        position: [0, "50%"],
        height: 20,
        // formatter: null,
        // color: '#fff',
        overflow: "truncate",
        // align: null,
        verticalAlign: "middle"
      },
      itemStyle: {
        color: null,
        colorAlpha: null,
        colorSaturation: null,
        borderWidth: 0,
        gapWidth: 0,
        borderColor: Y.color.neutral00,
        borderColorSaturation: null
        // If specified, borderColor will be ineffective, and the
        // border color is evaluated by color of current node and
        // borderColorSaturation.
      },
      emphasis: {
        upperLabel: {
          show: !0,
          position: [0, "50%"],
          overflow: "truncate",
          verticalAlign: "middle"
        }
      },
      visualDimension: 0,
      visualMin: null,
      visualMax: null,
      color: [],
      // level[n].color (if necessary).
      // + Specify color list of each level. level[0].color would be global
      // color list if not specified. (see method `setDefault`).
      // + But set as a empty array to forbid fetch color from global palette
      // when using nodeModel.get('color'), otherwise nodes on deep level
      // will always has color palette set and are not able to inherit color
      // from parent node.
      // + TreemapSeries.color can not be set as 'none', otherwise effect
      // legend color fetching (see seriesColor.js).
      colorAlpha: null,
      colorSaturation: null,
      colorMappingBy: "index",
      visibleMin: 10,
      // be rendered. Only works when sort is 'asc' or 'desc'.
      childrenVisibleMin: null,
      // grandchildren will not show.
      // Why grandchildren? If not grandchildren but children,
      // some siblings show children and some not,
      // the appearance may be mess and not consistent,
      levels: []
      // Each item: {
      //     visibleMin, itemStyle, visualDimension, label
      // }
    }, t;
  }(ke)
);
function tB(r) {
  var t = 0;
  L(r.children, function(n) {
    tB(n);
    var i = n.value;
    et(i) && (i = i[0]), t += i;
  });
  var e = r.value;
  et(e) && (e = e[0]), (e == null || isNaN(e)) && (e = t), e < 0 && (e = 0), et(r.value) ? r.value[0] = e : r.value = e;
}
function eQ(r, t) {
  var e = Ie(t.get("color")), n = Ie(t.get(["aria", "decal", "decals"]));
  if (e) {
    r = r || [];
    var i, a;
    L(r, function(s) {
      var l = new ue(s), u = l.get("color"), c = l.get("decal");
      (l.get(["itemStyle", "color"]) || u && u !== "none") && (i = !0), (l.get(["itemStyle", "decal"]) || c && c !== "none") && (a = !0);
    });
    var o = r[0] || (r[0] = {});
    return i || (o.color = e.slice()), !a && n && (o.decal = n.slice()), r;
  }
}
var rQ = 8, VD = 8, F0 = 5, nQ = (
  /** @class */
  function() {
    function r(t) {
      this.group = new Et(), t.add(this.group);
    }
    return r.prototype.render = function(t, e, n, i) {
      var a = t.getModel("breadcrumb"), o = this.group;
      if (o.removeAll(), !(!a.get("show") || !n)) {
        var s = a.getModel("itemStyle"), l = a.getModel("emphasis"), u = s.getModel("textStyle"), c = l.getModel(["itemStyle", "textStyle"]), f = xr(t, e).refContainer, h = {
          left: a.get("left"),
          right: a.get("right"),
          top: a.get("top"),
          bottom: a.get("bottom")
        }, d = {
          emptyItemWidth: a.get("emptyItemWidth"),
          totalWidth: 0,
          renderList: []
        }, p = He(h, f);
        this._prepare(n, d, u), this._renderContent(t, d, p, s, l, u, c, i), um(o, h, f);
      }
    }, r.prototype._prepare = function(t, e, n) {
      for (var i = t; i; i = i.parentNode) {
        var a = mr(i.getModel().get("name"), ""), o = n.getTextRect(a), s = Math.max(o.width + rQ * 2, e.emptyItemWidth);
        e.totalWidth += s + VD, e.renderList.push({
          node: i,
          text: a,
          width: s
        });
      }
    }, r.prototype._renderContent = function(t, e, n, i, a, o, s, l) {
      for (var u = 0, c = e.emptyItemWidth, f = t.get(["breadcrumb", "height"]), h = e.totalWidth, d = e.renderList, p = a.getModel("itemStyle").getItemStyle(), g = d.length - 1; g >= 0; g--) {
        var v = d[g], m = v.node, y = v.width, _ = v.text;
        h > n.width && (h -= y - c, y = c, _ = null);
        var x = new jr({
          shape: {
            points: iQ(u, 0, y, f, g === d.length - 1, g === 0)
          },
          style: kt(i.getItemStyle(), {
            lineJoin: "bevel"
          }),
          textContent: new pe({
            style: Oe(o, {
              text: _
            })
          }),
          textConfig: {
            position: "inside"
          },
          z2: bc * 1e4,
          onclick: Yt(l, m)
        });
        x.disableLabelAnimation = !0, x.getTextContent().ensureState("emphasis").style = Oe(s, {
          text: _
        }), x.ensureState("emphasis").style = p, Ge(x, a.get("focus"), a.get("blurScope"), a.get("disabled")), this.group.add(x), aQ(x, t, m), u += y + VD;
      }
    }, r.prototype.remove = function() {
      this.group.removeAll();
    }, r;
  }()
);
function iQ(r, t, e, n, i, a) {
  var o = [[i ? r : r - F0, t], [r + e, t], [r + e, t + n], [i ? r : r - F0, t + n]];
  return !a && o.splice(2, 0, [r + e + F0, t + n / 2]), !i && o.push([r, t + n / 2]), o;
}
function aQ(r, t, e) {
  zt(r).eventData = {
    componentType: "series",
    componentSubType: "treemap",
    componentIndex: t.componentIndex,
    seriesIndex: t.seriesIndex,
    seriesName: t.name,
    seriesType: "treemap",
    selfType: "breadcrumb",
    nodeData: {
      dataIndex: e && e.dataIndex,
      name: e && e.name
    },
    treePathInfo: e && Sm(e, t)
  };
}
var oQ = (
  /** @class */
  function() {
    function r() {
      this._storage = [], this._elExistsMap = {};
    }
    return r.prototype.add = function(t, e, n, i, a) {
      return this._elExistsMap[t.id] ? !1 : (this._elExistsMap[t.id] = !0, this._storage.push({
        el: t,
        target: e,
        duration: n,
        delay: i,
        easing: a
      }), !0);
    }, r.prototype.finished = function(t) {
      return this._finishedCallback = t, this;
    }, r.prototype.start = function() {
      for (var t = this, e = this._storage.length, n = function() {
        e--, e <= 0 && (t._storage.length = 0, t._elExistsMap = {}, t._finishedCallback && t._finishedCallback());
      }, i = 0, a = this._storage.length; i < a; i++) {
        var o = this._storage[i];
        o.el.animateTo(o.target, {
          duration: o.duration,
          delay: o.delay,
          easing: o.easing,
          setToFinal: !0,
          done: n,
          aborted: n
        });
      }
      return this;
    }, r;
  }()
);
function sQ() {
  return new oQ();
}
var AS = Et, FD = te, zD = 3, UD = "label", GD = "upperLabel", lQ = bc * 10, uQ = bc * 2, cQ = bc * 3, ks = pl([
  ["fill", "color"],
  // `borderColor` and `borderWidth` has been occupied,
  // so use `stroke` to indicate the stroke of the rect.
  ["stroke", "strokeColor"],
  ["lineWidth", "strokeWidth"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
]), HD = function(r) {
  var t = ks(r);
  return t.stroke = t.fill = t.lineWidth = null, t;
}, ug = ee(), fQ = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e._state = "ready", e._storage = vf(), e;
    }
    return t.prototype.render = function(e, n, i, a) {
      var o = n.findComponents({
        mainType: "series",
        subType: "treemap",
        query: a
      });
      if (!(Zt(o, e) < 0)) {
        this.seriesModel = e, this.api = i, this.ecModel = n;
        var s = ["treemapZoomToNode", "treemapRootToNode"], l = xh(a, s, e), u = a && a.type, c = e.layoutInfo, f = !this._oldTree, h = this._storage, d = u === "treemapRootToNode" && l && h ? {
          rootNodeGroup: h.nodeGroup[l.node.getRawIndex()],
          direction: a.direction
        } : null, p = this._giveContainerGroup(c), g = e.get("animation"), v = this._doRender(p, e, d);
        g && !f && (!u || u === "treemapZoomToNode" || u === "treemapRootToNode") ? this._doAnimation(p, v, e, d) : v.renderFinally(), this._resetController(i), this._renderBreadcrumb(e, i, l);
      }
    }, t.prototype._giveContainerGroup = function(e) {
      var n = this._containerGroup;
      return n || (n = this._containerGroup = new AS(), this._initEvents(n), this.group.add(n)), n.x = e.x, n.y = e.y, n;
    }, t.prototype._doRender = function(e, n, i) {
      var a = n.getData().tree, o = this._oldTree, s = vf(), l = vf(), u = this._storage, c = [];
      function f(y, _, x, b) {
        return hQ(n, l, u, i, s, c, y, _, x, b);
      }
      g(a.root ? [a.root] : [], o && o.root ? [o.root] : [], e, a === o || !o, 0);
      var h = v(u);
      if (this._oldTree = a, this._storage = l, this._controllerHost) {
        var d = this.seriesModel.layoutInfo, p = a.root.getLayout();
        p.width === d.width && p.height === d.height && (this._controllerHost.zoom = 1);
      }
      return {
        lastsForAnimation: s,
        willDeleteEls: h,
        renderFinally: m
      };
      function g(y, _, x, b, S) {
        b ? (_ = y, L(y, function(T, M) {
          !T.isRemoved() && A(M, M);
        })) : new Xa(_, y, w, w).add(A).update(A).remove(Yt(A, null)).execute();
        function w(T) {
          return T.getId();
        }
        function A(T, M) {
          var E = T != null ? y[T] : null, R = M != null ? _[M] : null, C = f(E, R, x, S);
          C && g(E && E.viewChildren || [], R && R.viewChildren || [], C, b, S + 1);
        }
      }
      function v(y) {
        var _ = vf();
        return y && L(y, function(x, b) {
          var S = _[b];
          L(x, function(w) {
            w && (S.push(w), ug(w).willDelete = !0);
          });
        }), _;
      }
      function m() {
        L(h, function(y) {
          L(y, function(_) {
            _.parent && _.parent.remove(_);
          });
        }), L(c, function(y) {
          y.invisible = !0, y.dirty();
        });
      }
    }, t.prototype._doAnimation = function(e, n, i, a) {
      var o = i.get("animationDurationUpdate"), s = i.get("animationEasing"), l = (Tt(o) ? 0 : o) || 0, u = (Tt(s) ? null : s) || "cubicOut", c = sQ();
      L(n.willDeleteEls, function(f, h) {
        L(f, function(d, p) {
          if (!d.invisible) {
            var g = d.parent, v, m = ug(g);
            if (a && a.direction === "drillDown")
              v = g === a.rootNodeGroup ? {
                shape: {
                  x: 0,
                  y: 0,
                  width: m.nodeWidth,
                  height: m.nodeHeight
                },
                style: {
                  opacity: 0
                }
              } : {
                style: {
                  opacity: 0
                }
              };
            else {
              var y = 0, _ = 0;
              m.willDelete || (y = m.nodeWidth / 2, _ = m.nodeHeight / 2), v = h === "nodeGroup" ? {
                x: y,
                y: _,
                style: {
                  opacity: 0
                }
              } : {
                shape: {
                  x: y,
                  y: _,
                  width: 0,
                  height: 0
                },
                style: {
                  opacity: 0
                }
              };
            }
            v && c.add(d, v, l, 0, u);
          }
        });
      }), L(this._storage, function(f, h) {
        L(f, function(d, p) {
          var g = n.lastsForAnimation[h][p], v = {};
          g && (d instanceof Et ? g.oldX != null && (v.x = d.x, v.y = d.y, d.x = g.oldX, d.y = g.oldY) : (g.oldShape && (v.shape = J({}, d.shape), d.setShape(g.oldShape)), g.fadein ? (d.setStyle("opacity", 0), v.style = {
            opacity: 1
          }) : d.style.opacity !== 1 && (v.style = {
            opacity: 1
          })), c.add(d, v, l, 0, u));
        });
      }, this), this._state = "animating", c.finished(mt(function() {
        this._state = "ready", n.renderFinally();
      }, this)).start();
    }, t.prototype._resetController = function(e) {
      var n = this, i = this._controller, a = this._controllerHost;
      a || (this._controllerHost = {
        target: this.group
      }, a = this._controllerHost);
      var o = this.seriesModel;
      i || (i = this._controller = new Il(e.getZr()), i.on("pan", mt(this._onPan, this)), i.on("zoom", mt(this._onZoom, this))), i.enable(o.get("roam"), {
        api: e,
        zInfo: {
          component: o
        },
        triggerInfo: {
          roamTrigger: o.get("roamTrigger"),
          isInSelf: function(s, l, u) {
            var c = n._containerGroup;
            return c ? c.getBoundingRect().contain(l - c.x, u - c.y) : !1;
          }
        }
      }), a.zoomLimit = o.get("scaleLimit"), a.zoom = o.get("zoom");
    }, t.prototype._clearController = function() {
      var e = this._controller;
      this._controllerHost = null, e && (e.dispose(), e = null);
    }, t.prototype._onPan = function(e) {
      if (this._state !== "animating" && (Math.abs(e.dx) > zD || Math.abs(e.dy) > zD)) {
        var n = this.seriesModel.getData().tree.root;
        if (!n)
          return;
        var i = n.getLayout();
        if (!i)
          return;
        this.api.dispatchAction({
          type: "treemapMove",
          from: this.uid,
          seriesId: this.seriesModel.id,
          rootRect: {
            x: i.x + e.dx,
            y: i.y + e.dy,
            width: i.width,
            height: i.height
          }
        });
      }
    }, t.prototype._onZoom = function(e) {
      var n = e.originX, i = e.originY, a = e.scale;
      if (this._state !== "animating") {
        var o = this.seriesModel.getData().tree.root;
        if (!o)
          return;
        var s = o.getLayout();
        if (!s)
          return;
        var l = new Bt(s.x, s.y, s.width, s.height), u = null, c = this._controllerHost;
        u = c.zoomLimit;
        var f = c.zoom = c.zoom || 1;
        if (f *= a, u) {
          var h = u.min || 0, d = u.max || 1 / 0;
          f = Math.max(Math.min(d, f), h);
        }
        var p = f / c.zoom;
        c.zoom = f;
        var g = this.seriesModel.layoutInfo;
        n -= g.x, i -= g.y;
        var v = kr();
        ra(v, v, [-n, -i]), M1(v, v, [p, p]), ra(v, v, [n, i]), l.applyTransform(v), this.api.dispatchAction({
          type: "treemapRender",
          from: this.uid,
          seriesId: this.seriesModel.id,
          rootRect: {
            x: l.x,
            y: l.y,
            width: l.width,
            height: l.height
          }
        });
      }
    }, t.prototype._initEvents = function(e) {
      var n = this;
      e.on("click", function(i) {
        if (n._state === "ready") {
          var a = n.seriesModel.get("nodeClick", !0);
          if (a) {
            var o = n.findTarget(i.offsetX, i.offsetY);
            if (o) {
              var s = o.node;
              if (s.getLayout().isLeafRoot)
                n._rootToNode(o);
              else if (a === "zoomToNode")
                n._zoomToNode(o);
              else if (a === "link") {
                var l = s.hostTree.data.getItemModel(s.dataIndex), u = l.get("link", !0), c = l.get("target", !0) || "blank";
                u && Bv(u, c);
              }
            }
          }
        }
      }, this);
    }, t.prototype._renderBreadcrumb = function(e, n, i) {
      var a = this;
      i || (i = e.get("leafDepth", !0) != null ? {
        node: e.getViewRoot()
      } : this.findTarget(n.getWidth() / 2, n.getHeight() / 2), i || (i = {
        node: e.getData().tree.root
      })), (this._breadcrumb || (this._breadcrumb = new nQ(this.group))).render(e, n, i.node, function(o) {
        a._state !== "animating" && (Gb(e.getViewRoot(), o) ? a._rootToNode({
          node: o
        }) : a._zoomToNode({
          node: o
        }));
      });
    }, t.prototype.remove = function() {
      this._clearController(), this._containerGroup && this._containerGroup.removeAll(), this._storage = vf(), this._state = "ready", this._breadcrumb && this._breadcrumb.remove();
    }, t.prototype.dispose = function() {
      this._clearController();
    }, t.prototype._zoomToNode = function(e) {
      this.api.dispatchAction({
        type: "treemapZoomToNode",
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: e.node
      });
    }, t.prototype._rootToNode = function(e) {
      this.api.dispatchAction({
        type: "treemapRootToNode",
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: e.node
      });
    }, t.prototype.findTarget = function(e, n) {
      var i, a = this.seriesModel.getViewRoot();
      return a.eachNode({
        attr: "viewChildren",
        order: "preorder"
      }, function(o) {
        var s = this._storage.background[o.getRawIndex()];
        if (s) {
          var l = s.transformCoordToLocal(e, n), u = s.shape;
          if (u.x <= l[0] && l[0] <= u.x + u.width && u.y <= l[1] && l[1] <= u.y + u.height)
            i = {
              node: o,
              offsetX: l[0],
              offsetY: l[1]
            };
          else
            return !1;
        }
      }, this), i;
    }, t.type = "treemap", t;
  }(Re)
);
function vf() {
  return {
    nodeGroup: [],
    background: [],
    content: []
  };
}
function hQ(r, t, e, n, i, a, o, s, l, u) {
  if (!o)
    return;
  var c = o.getLayout(), f = r.getData(), h = o.getModel();
  if (f.setItemGraphicEl(o.dataIndex, null), !c || !c.isInView)
    return;
  var d = c.width, p = c.height, g = c.borderWidth, v = c.invisible, m = o.getRawIndex(), y = s && s.getRawIndex(), _ = o.viewChildren, x = c.upperHeight, b = _ && _.length, S = h.getModel("itemStyle"), w = h.getModel(["emphasis", "itemStyle"]), A = h.getModel(["blur", "itemStyle"]), T = h.getModel(["select", "itemStyle"]), M = S.get("borderRadius") || 0, E = $("nodeGroup", AS);
  if (!E)
    return;
  if (l.add(E), E.x = c.x || 0, E.y = c.y || 0, E.markRedraw(), ug(E).nodeWidth = d, ug(E).nodeHeight = p, c.isAboveViewRoot)
    return E;
  var R = $("background", FD, u, uQ);
  R && F(E, R, b && c.upperLabelHeight);
  var C = h.getModel("emphasis"), D = C.get("focus"), I = C.get("blurScope"), P = C.get("disabled"), O = D === "ancestor" ? o.getAncestorsIndices() : D === "descendant" ? o.getDescendantIndices() : D;
  if (b)
    Uo(E) && Ks(E, !1), R && (Ks(R, !P), f.setItemGraphicEl(o.dataIndex, R), Lx(R, O, I));
  else {
    var N = $("content", FD, u, cQ);
    N && G(E, N), R.disableMorphing = !0, R && Uo(R) && Ks(R, !1), Ks(E, !P), f.setItemGraphicEl(o.dataIndex, E);
    var B = h.getShallow("cursor");
    B && N.attr("cursor", B), Lx(E, O, I);
  }
  return E;
  function F(lt, ot, H) {
    var st = zt(ot);
    if (st.dataIndex = o.dataIndex, st.seriesIndex = r.seriesIndex, ot.setShape({
      x: 0,
      y: 0,
      width: d,
      height: p,
      r: M
    }), v)
      X(ot);
    else {
      ot.invisible = !1;
      var ut = o.getVisual("style"), Gt = ut.stroke, gt = HD(S);
      gt.fill = Gt;
      var Lt = ks(w);
      Lt.fill = w.get("borderColor");
      var Vt = ks(A);
      Vt.fill = A.get("borderColor");
      var Kt = ks(T);
      if (Kt.fill = T.get("borderColor"), H) {
        var Ae = d - 2 * g;
        K(
          // PENDING: convert ZRColor to ColorString for text.
          ot,
          Gt,
          ut.opacity,
          {
            x: g,
            y: 0,
            width: Ae,
            height: x
          }
        );
      } else
        ot.removeTextContent();
      ot.setStyle(gt), ot.ensureState("emphasis").style = Lt, ot.ensureState("blur").style = Vt, ot.ensureState("select").style = Kt, vl(ot);
    }
    lt.add(ot);
  }
  function G(lt, ot) {
    var H = zt(ot);
    H.dataIndex = o.dataIndex, H.seriesIndex = r.seriesIndex;
    var st = Math.max(d - 2 * g, 0), ut = Math.max(p - 2 * g, 0);
    if (ot.culling = !0, ot.setShape({
      x: g,
      y: g,
      width: st,
      height: ut,
      r: M
    }), v)
      X(ot);
    else {
      ot.invisible = !1;
      var Gt = o.getVisual("style"), gt = Gt.fill, Lt = HD(S);
      Lt.fill = gt, Lt.decal = Gt.decal;
      var Vt = ks(w), Kt = ks(A), Ae = ks(T);
      K(ot, gt, Gt.opacity, null), ot.setStyle(Lt), ot.ensureState("emphasis").style = Vt, ot.ensureState("blur").style = Kt, ot.ensureState("select").style = Ae, vl(ot);
    }
    lt.add(ot);
  }
  function X(lt) {
    !lt.invisible && a.push(lt);
  }
  function K(lt, ot, H, st) {
    var ut = h.getModel(st ? GD : UD), Gt = mr(h.get("name"), null), gt = ut.getShallow("show");
    Er(lt, _r(h, st ? GD : UD), {
      defaultText: gt ? Gt : null,
      inheritColor: ot,
      defaultOpacity: H,
      labelFetcher: r,
      labelDataIndex: o.dataIndex
    });
    var Lt = lt.getTextContent();
    if (Lt) {
      var Vt = Lt.style, Kt = Fg(Vt.padding || 0);
      st && (lt.setTextConfig({
        layoutRect: st
      }), Lt.disableLabelLayout = !0), Lt.beforeUpdate = function() {
        var z = Math.max((st ? st.width : lt.shape.width) - Kt[1] - Kt[3], 0), k = Math.max((st ? st.height : lt.shape.height) - Kt[0] - Kt[2], 0);
        (Vt.width !== z || Vt.height !== k) && Lt.setStyle({
          width: z,
          height: k
        });
      }, Vt.truncateMinChar = 2, Vt.lineOverflow = "truncate", U(Vt, st, c);
      var Ae = Lt.getState("emphasis");
      U(Ae ? Ae.style : null, st, c);
    }
  }
  function U(lt, ot, H) {
    var st = lt ? lt.text : null;
    if (!ot && H.isLeafRoot && st != null) {
      var ut = r.get("drillDownIcon", !0);
      lt.text = ut ? ut + " " + st : st;
    }
  }
  function $(lt, ot, H, st) {
    var ut = y != null && e[lt][y], Gt = i[lt];
    return ut ? (e[lt][y] = null, ct(Gt, ut)) : v || (ut = new ot(), ut instanceof ii && (ut.z2 = dQ(H, st)), at(Gt, ut)), t[lt][m] = ut;
  }
  function ct(lt, ot) {
    var H = lt[m] = {};
    ot instanceof AS ? (H.oldX = ot.x, H.oldY = ot.y) : H.oldShape = J({}, ot.shape);
  }
  function at(lt, ot) {
    var H = lt[m] = {}, st = o.parentNode, ut = ot instanceof Et;
    if (st && (!n || n.direction === "drillDown")) {
      var Gt = 0, gt = 0, Lt = i.background[st.getRawIndex()];
      !n && Lt && Lt.oldShape && (Gt = Lt.oldShape.width, gt = Lt.oldShape.height), ut ? (H.oldX = 0, H.oldY = gt) : H.oldShape = {
        x: Gt,
        y: gt,
        width: 0,
        height: 0
      };
    }
    H.fadein = !ut;
  }
}
function dQ(r, t) {
  return r * lQ + t;
}
var Sh = L, pQ = Dt, cg = -1, Mr = (
  /** @class */
  function() {
    function r(t) {
      var e = t.mappingMethod, n = t.type, i = this.option = Ct(t);
      this.type = n, this.mappingMethod = e, this._normalizeData = mQ[e];
      var a = r.visualHandlers[n];
      this.applyVisual = a.applyVisual, this.getColorMapper = a.getColorMapper, this._normalizedToVisual = a._normalizedToVisual[e], e === "piecewise" ? (z0(i), vQ(i)) : e === "category" ? i.categories ? gQ(i) : z0(i, !0) : (St(e !== "linear" || i.dataExtent), z0(i));
    }
    return r.prototype.mapValueToVisual = function(t) {
      var e = this._normalizeData(t);
      return this._normalizedToVisual(e, t);
    }, r.prototype.getNormalizer = function() {
      return mt(this._normalizeData, this);
    }, r.listVisualTypes = function() {
      return se(r.visualHandlers);
    }, r.isValidType = function(t) {
      return r.visualHandlers.hasOwnProperty(t);
    }, r.eachVisual = function(t, e, n) {
      Dt(t) ? L(t, e, n) : e.call(n, t);
    }, r.mapVisual = function(t, e, n) {
      var i, a = et(t) ? [] : Dt(t) ? {} : (i = !0, null);
      return r.eachVisual(t, function(o, s) {
        var l = e.call(n, o, s);
        i ? a = l : a[s] = l;
      }), a;
    }, r.retrieveVisuals = function(t) {
      var e = {}, n;
      return t && Sh(r.visualHandlers, function(i, a) {
        t.hasOwnProperty(a) && (e[a] = t[a], n = !0);
      }), n ? e : null;
    }, r.prepareVisualTypes = function(t) {
      if (et(t))
        t = t.slice();
      else if (pQ(t)) {
        var e = [];
        Sh(t, function(n, i) {
          e.push(i);
        }), t = e;
      } else
        return [];
      return t.sort(function(n, i) {
        return i === "color" && n !== "color" && n.indexOf("color") === 0 ? 1 : -1;
      }), t;
    }, r.dependsOn = function(t, e) {
      return e === "color" ? !!(t && t.indexOf(e) === 0) : t === e;
    }, r.findPieceIndex = function(t, e, n) {
      for (var i, a = 1 / 0, o = 0, s = e.length; o < s; o++) {
        var l = e[o].value;
        if (l != null) {
          if (l === t || pt(l) && l === t + "")
            return o;
          n && h(l, o);
        }
      }
      for (var o = 0, s = e.length; o < s; o++) {
        var u = e[o], c = u.interval, f = u.close;
        if (c) {
          if (c[0] === -1 / 0) {
            if (mp(f[1], t, c[1]))
              return o;
          } else if (c[1] === 1 / 0) {
            if (mp(f[0], c[0], t))
              return o;
          } else if (mp(f[0], c[0], t) && mp(f[1], t, c[1]))
            return o;
          n && h(c[0], o), n && h(c[1], o);
        }
      }
      if (n)
        return t === 1 / 0 ? e.length - 1 : t === -1 / 0 ? 0 : i;
      function h(d, p) {
        var g = Math.abs(d - t);
        g < a && (a = g, i = p);
      }
    }, r.visualHandlers = {
      color: {
        applyVisual: gf("color"),
        getColorMapper: function() {
          var t = this.option;
          return mt(t.mappingMethod === "category" ? function(e, n) {
            return !n && (e = this._normalizeData(e)), kf.call(this, e);
          } : function(e, n, i) {
            var a = !!i;
            return !n && (e = this._normalizeData(e)), i = yy(e, t.parsedVisual, i), a ? i : Ji(i, "rgba");
          }, this);
        },
        _normalizedToVisual: {
          linear: function(t) {
            return Ji(yy(t, this.option.parsedVisual), "rgba");
          },
          category: kf,
          piecewise: function(t, e) {
            var n = CS.call(this, e);
            return n == null && (n = Ji(yy(t, this.option.parsedVisual), "rgba")), n;
          },
          fixed: Bs
        }
      },
      colorHue: gp(function(t, e) {
        return No(t, e);
      }),
      colorSaturation: gp(function(t, e) {
        return No(t, null, e);
      }),
      colorLightness: gp(function(t, e) {
        return No(t, null, null, e);
      }),
      colorAlpha: gp(function(t, e) {
        return wv(t, e);
      }),
      decal: {
        applyVisual: gf("decal"),
        _normalizedToVisual: {
          linear: null,
          category: kf,
          piecewise: null,
          fixed: null
        }
      },
      opacity: {
        applyVisual: gf("opacity"),
        _normalizedToVisual: ES([0, 1])
      },
      liftZ: {
        applyVisual: gf("liftZ"),
        _normalizedToVisual: {
          linear: Bs,
          category: Bs,
          piecewise: Bs,
          fixed: Bs
        }
      },
      symbol: {
        applyVisual: function(t, e, n) {
          var i = this.mapValueToVisual(t);
          n("symbol", i);
        },
        _normalizedToVisual: {
          linear: WD,
          category: kf,
          piecewise: function(t, e) {
            var n = CS.call(this, e);
            return n == null && (n = WD.call(this, t)), n;
          },
          fixed: Bs
        }
      },
      symbolSize: {
        applyVisual: gf("symbolSize"),
        _normalizedToVisual: ES([0, 1])
      }
    }, r;
  }()
);
function vQ(r) {
  var t = r.pieceList;
  r.hasSpecialVisual = !1, L(t, function(e, n) {
    e.originIndex = n, e.visual != null && (r.hasSpecialVisual = !0);
  });
}
function gQ(r) {
  var t = r.categories, e = r.categoryMap = {}, n = r.visual;
  if (Sh(t, function(o, s) {
    e[o] = s;
  }), !et(n)) {
    var i = [];
    Dt(n) ? Sh(n, function(o, s) {
      var l = e[s];
      i[l ?? cg] = o;
    }) : i[cg] = n, n = eB(r, i);
  }
  for (var a = t.length - 1; a >= 0; a--)
    n[a] == null && (delete e[t[a]], t.pop());
}
function z0(r, t) {
  var e = r.visual, n = [];
  Dt(e) ? Sh(e, function(a) {
    n.push(a);
  }) : e != null && n.push(e);
  var i = {
    color: 1,
    symbol: 1
  };
  !t && n.length === 1 && !i.hasOwnProperty(r.type) && (n[1] = n[0]), eB(r, n);
}
function gp(r) {
  return {
    applyVisual: function(t, e, n) {
      var i = this.mapValueToVisual(t);
      n("color", r(e("color"), i));
    },
    _normalizedToVisual: ES([0, 1])
  };
}
function WD(r) {
  var t = this.option.visual;
  return t[Math.round(Me(r, [0, 1], [0, t.length - 1], !0))] || {};
}
function gf(r) {
  return function(t, e, n) {
    n(r, this.mapValueToVisual(t));
  };
}
function kf(r) {
  var t = this.option.visual;
  return t[this.option.loop && r !== cg ? r % t.length : r];
}
function Bs() {
  return this.option.visual[0];
}
function ES(r) {
  return {
    linear: function(t) {
      return Me(t, r, this.option.visual, !0);
    },
    category: kf,
    piecewise: function(t, e) {
      var n = CS.call(this, e);
      return n == null && (n = Me(t, r, this.option.visual, !0)), n;
    },
    fixed: Bs
  };
}
function CS(r) {
  var t = this.option, e = t.pieceList;
  if (t.hasSpecialVisual) {
    var n = Mr.findPieceIndex(r, e), i = e[n];
    if (i && i.visual)
      return i.visual[this.type];
  }
}
function eB(r, t) {
  return r.visual = t, r.type === "color" && (r.parsedVisual = rt(t, function(e) {
    var n = bn(e);
    return !n && process.env.NODE_ENV !== "production" && Xe("'" + e + "' is an illegal color, fallback to '#000000'", !0), n || [0, 0, 0, 1];
  })), t;
}
var mQ = {
  linear: function(r) {
    return Me(r, this.option.dataExtent, [0, 1], !0);
  },
  piecewise: function(r) {
    var t = this.option.pieceList, e = Mr.findPieceIndex(r, t, !0);
    if (e != null)
      return Me(e, [0, t.length - 1], [0, 1], !0);
  },
  category: function(r) {
    var t = this.option.categories ? this.option.categoryMap[r] : r;
    return t ?? cg;
  },
  fixed: er
};
function mp(r, t, e) {
  return r ? t <= e : t < e;
}
var yQ = "itemStyle", rB = ee();
const _Q = {
  seriesType: "treemap",
  reset: function(r) {
    var t = r.getData().tree, e = t.root;
    e.isRemoved() || nB(
      e,
      // Visual should calculate from tree root but not view root.
      {},
      r.getViewRoot().getAncestors(),
      r
    );
  }
};
function nB(r, t, e, n) {
  var i = r.getModel(), a = r.getLayout(), o = r.hostTree.data;
  if (!(!a || a.invisible || !a.isInView)) {
    var s = i.getModel(yQ), l = xQ(s, t, n), u = o.ensureUniqueItemVisual(r.dataIndex, "style"), c = s.get("borderColor"), f = s.get("borderColorSaturation"), h;
    f != null && (h = XD(l), c = SQ(f, h)), u.stroke = c;
    var d = r.viewChildren;
    if (!d || !d.length)
      h = XD(l), u.fill = h;
    else {
      var p = bQ(r, i, a, s, l, d);
      L(d, function(g, v) {
        if (g.depth >= e.length || g === e[g.depth]) {
          var m = wQ(i, l, g, v, p, n);
          nB(g, m, e, n);
        }
      });
    }
  }
}
function xQ(r, t, e) {
  var n = J({}, t), i = e.designatedVisualItemStyle;
  return L(["color", "colorAlpha", "colorSaturation"], function(a) {
    i[a] = t[a];
    var o = r.get(a);
    i[a] = null, o != null && (n[a] = o);
  }), n;
}
function XD(r) {
  var t = U0(r, "color");
  if (t) {
    var e = U0(r, "colorAlpha"), n = U0(r, "colorSaturation");
    return n && (t = No(t, null, null, n)), e && (t = wv(t, e)), t;
  }
}
function SQ(r, t) {
  return t != null ? No(t, null, null, r) : null;
}
function U0(r, t) {
  var e = r[t];
  if (e != null && e !== "none")
    return e;
}
function bQ(r, t, e, n, i, a) {
  if (!(!a || !a.length)) {
    var o = G0(t, "color") || i.color != null && i.color !== "none" && (G0(t, "colorAlpha") || G0(t, "colorSaturation"));
    if (o) {
      var s = t.get("visualMin"), l = t.get("visualMax"), u = e.dataExtent.slice();
      s != null && s < u[0] && (u[0] = s), l != null && l > u[1] && (u[1] = l);
      var c = t.get("colorMappingBy"), f = {
        type: o.name,
        dataExtent: u,
        visual: o.range
      };
      f.type === "color" && (c === "index" || c === "id") ? (f.mappingMethod = "category", f.loop = !0) : f.mappingMethod = "linear";
      var h = new Mr(f);
      return rB(h).drColorMappingBy = c, h;
    }
  }
}
function G0(r, t) {
  var e = r.get(t);
  return et(e) && e.length ? {
    name: t,
    range: e
  } : null;
}
function wQ(r, t, e, n, i, a) {
  var o = J({}, t);
  if (i) {
    var s = i.type, l = s === "color" && rB(i).drColorMappingBy, u = l === "index" ? n : l === "id" ? a.mapIdToIndex(e.getId()) : e.getValue(r.get("visualDimension"));
    o[s] = i.mapValueToVisual(u);
  }
  return o;
}
var bh = Math.max, fg = Math.min, YD = gr, Hb = L, iB = ["itemStyle", "borderWidth"], MQ = ["itemStyle", "gapWidth"], TQ = ["upperLabel", "show"], AQ = ["upperLabel", "height"];
const EQ = {
  seriesType: "treemap",
  reset: function(r, t, e, n) {
    var i = r.option, a = xr(r, e).refContainer, o = He(r.getBoxLayoutParams(), a), s = i.size || [], l = dt(YD(o.width, s[0]), a.width), u = dt(YD(o.height, s[1]), a.height), c = n && n.type, f = ["treemapZoomToNode", "treemapRootToNode"], h = xh(n, f, r), d = c === "treemapRender" || c === "treemapMove" ? n.rootRect : null, p = r.getViewRoot(), g = J3(p);
    if (c !== "treemapMove") {
      var v = c === "treemapZoomToNode" ? PQ(r, h, p, l, u) : d ? [d.width, d.height] : [l, u], m = i.sort;
      m && m !== "asc" && m !== "desc" && (m = "desc");
      var y = {
        squareRatio: i.squareRatio,
        sort: m,
        leafDepth: i.leafDepth
      };
      p.hostTree.clearLayouts();
      var _ = {
        x: 0,
        y: 0,
        width: v[0],
        height: v[1],
        area: v[0] * v[1]
      };
      p.setLayout(_), aB(p, y, !1, 0), _ = p.getLayout(), Hb(g, function(b, S) {
        var w = (g[S + 1] || p).getValue();
        b.setLayout(J({
          dataExtent: [w, w],
          borderWidth: 0,
          upperHeight: 0
        }, _));
      });
    }
    var x = r.getData().tree.root;
    x.setLayout(NQ(o, d, h), !0), r.setLayoutInfo(o), oB(
      x,
      // Transform to base element coordinate system.
      new Bt(-o.x, -o.y, e.getWidth(), e.getHeight()),
      g,
      p,
      0
    );
  }
};
function aB(r, t, e, n) {
  var i, a;
  if (!r.isRemoved()) {
    var o = r.getLayout();
    i = o.width, a = o.height;
    var s = r.getModel(), l = s.get(iB), u = s.get(MQ) / 2, c = sB(s), f = Math.max(l, c), h = l - u, d = f - u;
    r.setLayout({
      borderWidth: l,
      upperHeight: f,
      upperLabelHeight: c
    }, !0), i = bh(i - 2 * h, 0), a = bh(a - h - d, 0);
    var p = i * a, g = CQ(r, s, p, t, e, n);
    if (g.length) {
      var v = {
        x: h,
        y: d,
        width: i,
        height: a
      }, m = fg(i, a), y = 1 / 0, _ = [];
      _.area = 0;
      for (var x = 0, b = g.length; x < b; ) {
        var S = g[x];
        _.push(S), _.area += S.getLayout().area;
        var w = IQ(_, m, t.squareRatio);
        w <= y ? (x++, y = w) : (_.area -= _.pop().getLayout().area, $D(_, m, v, u, !1), m = fg(v.width, v.height), _.length = _.area = 0, y = 1 / 0);
      }
      if (_.length && $D(_, m, v, u, !0), !e) {
        var A = s.get("childrenVisibleMin");
        A != null && p < A && (e = !0);
      }
      for (var x = 0, b = g.length; x < b; x++)
        aB(g[x], t, e, n + 1);
    }
  }
}
function CQ(r, t, e, n, i, a) {
  var o = r.children || [], s = n.sort;
  s !== "asc" && s !== "desc" && (s = null);
  var l = n.leafDepth != null && n.leafDepth <= a;
  if (i && !l)
    return r.viewChildren = [];
  o = Te(o, function(d) {
    return !d.isRemoved();
  }), LQ(o, s);
  var u = RQ(t, o, s);
  if (u.sum === 0)
    return r.viewChildren = [];
  if (u.sum = DQ(t, e, u.sum, s, o), u.sum === 0)
    return r.viewChildren = [];
  for (var c = 0, f = o.length; c < f; c++) {
    var h = o[c].getValue() / u.sum * e;
    o[c].setLayout({
      area: h
    });
  }
  return l && (o.length && r.setLayout({
    isLeafRoot: !0
  }, !0), o.length = 0), r.viewChildren = o, r.setLayout({
    dataExtent: u.dataExtent
  }, !0), o;
}
function DQ(r, t, e, n, i) {
  if (!n)
    return e;
  for (var a = r.get("visibleMin"), o = i.length, s = o, l = o - 1; l >= 0; l--) {
    var u = i[n === "asc" ? o - l - 1 : l].getValue();
    u / e * t < a && (s = l, e -= u);
  }
  return n === "asc" ? i.splice(0, o - s) : i.splice(s, o - s), e;
}
function LQ(r, t) {
  return t && r.sort(function(e, n) {
    var i = t === "asc" ? e.getValue() - n.getValue() : n.getValue() - e.getValue();
    return i === 0 ? t === "asc" ? e.dataIndex - n.dataIndex : n.dataIndex - e.dataIndex : i;
  }), r;
}
function RQ(r, t, e) {
  for (var n = 0, i = 0, a = t.length; i < a; i++)
    n += t[i].getValue();
  var o = r.get("visualDimension"), s;
  return !t || !t.length ? s = [NaN, NaN] : o === "value" && e ? (s = [t[t.length - 1].getValue(), t[0].getValue()], e === "asc" && s.reverse()) : (s = [1 / 0, -1 / 0], Hb(t, function(l) {
    var u = l.getValue(o);
    u < s[0] && (s[0] = u), u > s[1] && (s[1] = u);
  })), {
    sum: n,
    dataExtent: s
  };
}
function IQ(r, t, e) {
  for (var n = 0, i = 1 / 0, a = 0, o = void 0, s = r.length; a < s; a++)
    o = r[a].getLayout().area, o && (o < i && (i = o), o > n && (n = o));
  var l = r.area * r.area, u = t * t * e;
  return l ? bh(u * n / l, l / (u * i)) : 1 / 0;
}
function $D(r, t, e, n, i) {
  var a = t === e.width ? 0 : 1, o = 1 - a, s = ["x", "y"], l = ["width", "height"], u = e[s[a]], c = t ? r.area / t : 0;
  (i || c > e[l[o]]) && (c = e[l[o]]);
  for (var f = 0, h = r.length; f < h; f++) {
    var d = r[f], p = {}, g = c ? d.getLayout().area / c : 0, v = p[l[o]] = bh(c - 2 * n, 0), m = e[s[a]] + e[l[a]] - u, y = f === h - 1 || m < g ? m : g, _ = p[l[a]] = bh(y - 2 * n, 0);
    p[s[o]] = e[s[o]] + fg(n, v / 2), p[s[a]] = u + fg(n, _ / 2), u += y, d.setLayout(p, !0);
  }
  e[s[o]] += c, e[l[o]] -= c;
}
function PQ(r, t, e, n, i) {
  var a = (t || {}).node, o = [n, i];
  if (!a || a === e)
    return o;
  for (var s, l = n * i, u = l * r.option.zoomToNodeRatio; s = a.parentNode; ) {
    for (var c = 0, f = s.children, h = 0, d = f.length; h < d; h++)
      c += f[h].getValue();
    var p = a.getValue();
    if (p === 0)
      return o;
    u *= c / p;
    var g = s.getModel(), v = g.get(iB), m = Math.max(v, sB(g));
    u += 4 * v * v + (3 * v + m) * Math.pow(u, 0.5), u > KT && (u = KT), a = s;
  }
  u < l && (u = l);
  var y = Math.pow(u / l, 0.5);
  return [n * y, i * y];
}
function NQ(r, t, e) {
  if (t)
    return {
      x: t.x,
      y: t.y
    };
  var n = {
    x: 0,
    y: 0
  };
  if (!e)
    return n;
  var i = e.node, a = i.getLayout();
  if (!a)
    return n;
  for (var o = [a.width / 2, a.height / 2], s = i; s; ) {
    var l = s.getLayout();
    o[0] += l.x, o[1] += l.y, s = s.parentNode;
  }
  return {
    x: r.width / 2 - o[0],
    y: r.height / 2 - o[1]
  };
}
function oB(r, t, e, n, i) {
  var a = r.getLayout(), o = e[i], s = o && o === r;
  if (!(o && !s || i === e.length && r !== n)) {
    r.setLayout({
      // isInView means: viewRoot sub tree + viewAbovePath
      isInView: !0,
      // invisible only means: outside view clip so that the node can not
      // see but still layout for animation preparation but not render.
      invisible: !s && !t.intersect(a),
      isAboveViewRoot: s
    }, !0);
    var l = new Bt(t.x - a.x, t.y - a.y, t.width, t.height);
    Hb(r.viewChildren || [], function(u) {
      oB(u, l, e, n, i + 1);
    });
  }
}
function sB(r) {
  return r.get(TQ) ? r.get(AQ) : 0;
}
function OQ(r) {
  r.registerSeriesModel(tQ), r.registerChartView(fQ), r.registerVisual(_Q), r.registerLayout(EQ), QJ(r);
}
function kQ(r) {
  var t = r.findComponents({
    mainType: "legend"
  });
  !t || !t.length || r.eachSeriesByType("graph", function(e) {
    var n = e.getCategoriesData(), i = e.getGraph(), a = i.data, o = n.mapArray(n.getName);
    a.filterSelf(function(s) {
      var l = a.getItemModel(s), u = l.getShallow("category");
      if (u != null) {
        fe(u) && (u = o[u]);
        for (var c = 0; c < t.length; c++)
          if (!t[c].isSelected(u))
            return !1;
      }
      return !0;
    });
  });
}
function BQ(r) {
  var t = {};
  r.eachSeriesByType("graph", function(e) {
    var n = e.getCategoriesData(), i = e.getData(), a = {};
    n.each(function(o) {
      var s = n.getName(o);
      a["ec-" + s] = o;
      var l = n.getItemModel(o), u = l.getModel("itemStyle").getItemStyle();
      u.fill || (u.fill = e.getColorFromPalette(s, t)), n.setItemVisual(o, "style", u);
      for (var c = ["symbol", "symbolSize", "symbolKeepAspect"], f = 0; f < c.length; f++) {
        var h = l.getShallow(c[f], !0);
        h != null && n.setItemVisual(o, c[f], h);
      }
    }), n.count() && i.each(function(o) {
      var s = i.getItemModel(o), l = s.getShallow("category");
      if (l != null) {
        pt(l) && (l = a["ec-" + l]);
        var u = n.getItemVisual(l, "style"), c = i.ensureUniqueItemVisual(o, "style");
        J(c, u);
        for (var f = ["symbol", "symbolSize", "symbolKeepAspect"], h = 0; h < f.length; h++)
          i.setItemVisual(o, f[h], n.getItemVisual(l, f[h]));
      }
    });
  });
}
function yp(r) {
  return r instanceof Array || (r = [r, r]), r;
}
function VQ(r) {
  r.eachSeriesByType("graph", function(t) {
    var e = t.getGraph(), n = t.getEdgeData(), i = yp(t.get("edgeSymbol")), a = yp(t.get("edgeSymbolSize"));
    n.setVisual("fromSymbol", i && i[0]), n.setVisual("toSymbol", i && i[1]), n.setVisual("fromSymbolSize", a && a[0]), n.setVisual("toSymbolSize", a && a[1]), n.setVisual("style", t.getModel("lineStyle").getLineStyle()), n.each(function(o) {
      var s = n.getItemModel(o), l = e.getEdgeByIndex(o), u = yp(s.getShallow("symbol", !0)), c = yp(s.getShallow("symbolSize", !0)), f = s.getModel("lineStyle").getLineStyle(), h = n.ensureUniqueItemVisual(o, "style");
      switch (J(h, f), h.stroke) {
        case "source": {
          var d = l.node1.getVisual("style");
          h.stroke = d && d.fill;
          break;
        }
        case "target": {
          var d = l.node2.getVisual("style");
          h.stroke = d && d.fill;
          break;
        }
      }
      u[0] && l.setVisual("fromSymbol", u[0]), u[1] && l.setVisual("toSymbol", u[1]), c[0] && l.setVisual("fromSymbolSize", c[0]), c[1] && l.setVisual("toSymbolSize", c[1]);
    });
  });
}
var DS = "-->", bm = function(r) {
  return r.get("autoCurveness") || null;
}, lB = function(r, t) {
  var e = bm(r), n = 20, i = [];
  if (fe(e))
    n = e;
  else if (et(e)) {
    r.__curvenessList = e;
    return;
  }
  t > n && (n = t);
  var a = n % 2 ? n + 2 : n + 3;
  i = [];
  for (var o = 0; o < a; o++)
    i.push((o % 2 ? o + 1 : o) / 10 * (o % 2 ? -1 : 1));
  r.__curvenessList = i;
}, wh = function(r, t, e) {
  var n = [r.id, r.dataIndex].join("."), i = [t.id, t.dataIndex].join(".");
  return [e.uid, n, i].join(DS);
}, uB = function(r) {
  var t = r.split(DS);
  return [t[0], t[2], t[1]].join(DS);
}, FQ = function(r, t) {
  var e = wh(r.node1, r.node2, t);
  return t.__edgeMap[e];
}, zQ = function(r, t) {
  var e = LS(wh(r.node1, r.node2, t), t), n = LS(wh(r.node2, r.node1, t), t);
  return e + n;
}, LS = function(r, t) {
  var e = t.__edgeMap;
  return e[r] ? e[r].length : 0;
};
function UQ(r) {
  bm(r) && (r.__curvenessList = [], r.__edgeMap = {}, lB(r));
}
function GQ(r, t, e, n) {
  if (bm(e)) {
    var i = wh(r, t, e), a = e.__edgeMap, o = a[uB(i)];
    a[i] && !o ? a[i].isForward = !0 : o && a[i] && (o.isForward = !0, a[i].isForward = !1), a[i] = a[i] || [], a[i].push(n);
  }
}
function Wb(r, t, e, n) {
  var i = bm(t), a = et(i);
  if (!i)
    return null;
  var o = FQ(r, t);
  if (!o)
    return null;
  for (var s = -1, l = 0; l < o.length; l++)
    if (o[l] === e) {
      s = l;
      break;
    }
  var u = zQ(r, t);
  lB(t, u), r.lineStyle = r.lineStyle || {};
  var c = wh(r.node1, r.node2, t), f = t.__curvenessList, h = a || u % 2 ? 0 : 1;
  if (o.isForward)
    return f[h + s];
  var d = uB(c), p = LS(d, t), g = f[s + p + h];
  return n ? a ? i && i[0] === 0 ? (p + h) % 2 ? g : -g : ((p % 2 ? 0 : 1) + h) % 2 ? g : -g : (p + h) % 2 ? g : -g : f[s + p + h];
}
function cB(r) {
  var t = r.coordinateSystem;
  if (!(t && t.type !== "view")) {
    var e = r.getGraph();
    e.eachNode(function(n) {
      var i = n.getModel();
      n.setLayout([+i.get("x"), +i.get("y")]);
    }), Xb(e, r);
  }
}
function Xb(r, t) {
  r.eachEdge(function(e, n) {
    var i = ln(e.getModel().get(["lineStyle", "curveness"]), -Wb(e, t, n, !0), 0), a = Ia(e.node1.getLayout()), o = Ia(e.node2.getLayout()), s = [a, o];
    +i && s.push([(a[0] + o[0]) / 2 - (a[1] - o[1]) * i, (a[1] + o[1]) / 2 - (o[0] - a[0]) * i]), e.setLayout(s);
  });
}
function HQ(r, t) {
  r.eachSeriesByType("graph", function(e) {
    var n = e.get("layout"), i = e.coordinateSystem;
    if (i && i.type !== "view") {
      var a = e.getData(), o = [];
      L(i.dimensions, function(h) {
        o = o.concat(a.mapDimensionsAll(h));
      });
      for (var s = 0; s < a.count(); s++) {
        for (var l = [], u = !1, c = 0; c < o.length; c++) {
          var f = a.get(o[c], s);
          isNaN(f) || (u = !0), l.push(f);
        }
        u ? a.setItemLayout(s, i.dataToPoint(l)) : a.setItemLayout(s, [NaN, NaN]);
      }
      Xb(a.graph, e);
    } else
      (!n || n === "none") && cB(e);
  });
}
function Bf(r) {
  var t = r.coordinateSystem;
  if (t.type !== "view")
    return 1;
  var e = r.option.nodeScaleRatio, n = t.scaleX, i = t.getZoom(), a = (i - 1) * e + 1;
  return a / n;
}
function Vf(r) {
  var t = r.getVisual("symbolSize");
  return t instanceof Array && (t = (t[0] + t[1]) / 2), +t;
}
var ZD = Math.PI, H0 = [];
function Yb(r, t, e, n) {
  var i = r.coordinateSystem;
  if (!(i && i.type !== "view")) {
    var a = i.getBoundingRect(), o = r.getData(), s = o.graph, l = a.width / 2 + a.x, u = a.height / 2 + a.y, c = Math.min(a.width, a.height) / 2, f = o.count();
    if (o.setLayout({
      cx: l,
      cy: u
    }), !!f) {
      if (e) {
        var h = i.pointToData(n), d = h[0], p = h[1], g = [d - l, p - u];
        _c(g, g), Gp(g, g, c), e.setLayout([l + g[0], u + g[1]], !0);
        var v = r.get(["circular", "rotateLabel"]);
        fB(e, v, l, u);
      }
      WQ[t](r, s, o, c, l, u, f), s.eachEdge(function(m, y) {
        var _ = ln(m.getModel().get(["lineStyle", "curveness"]), Wb(m, r, y), 0), x = Ia(m.node1.getLayout()), b = Ia(m.node2.getLayout()), S, w = (x[0] + b[0]) / 2, A = (x[1] + b[1]) / 2;
        +_ && (_ *= 3, S = [l * _ + w * (1 - _), u * _ + A * (1 - _)]), m.setLayout([x, b, S]);
      });
    }
  }
}
var WQ = {
  value: function(r, t, e, n, i, a, o) {
    var s = 0, l = e.getSum("value"), u = Math.PI * 2 / (l || o);
    t.eachNode(function(c) {
      var f = c.getValue("value"), h = u * (l ? f : 1) / 2;
      s += h, c.setLayout([n * Math.cos(s) + i, n * Math.sin(s) + a]), s += h;
    });
  },
  symbolSize: function(r, t, e, n, i, a, o) {
    var s = 0;
    H0.length = o;
    var l = Bf(r);
    t.eachNode(function(f) {
      var h = Vf(f);
      isNaN(h) && (h = 2), h < 0 && (h = 0), h *= l;
      var d = Math.asin(h / 2 / n);
      isNaN(d) && (d = ZD / 2), H0[f.dataIndex] = d, s += d * 2;
    });
    var u = (2 * ZD - s) / o / 2, c = 0;
    t.eachNode(function(f) {
      var h = u + H0[f.dataIndex];
      c += h, (!f.getLayout() || !f.getLayout().fixed) && f.setLayout([n * Math.cos(c) + i, n * Math.sin(c) + a]), c += h;
    });
  }
};
function fB(r, t, e, n) {
  var i = r.getGraphicEl();
  if (i) {
    var a = r.getModel(), o = a.get(["label", "rotate"]) || 0, s = i.getSymbolPath();
    if (t) {
      var l = r.getLayout(), u = Math.atan2(l[1] - n, l[0] - e);
      u < 0 && (u = Math.PI * 2 + u);
      var c = l[0] < e;
      c && (u = u - Math.PI);
      var f = c ? "left" : "right";
      s.setTextConfig({
        rotation: -u,
        position: f,
        origin: "center"
      });
      var h = s.ensureState("emphasis");
      J(h.textConfig || (h.textConfig = {}), {
        position: f
      });
    } else
      s.setTextConfig({
        rotation: o *= Math.PI / 180
      });
  }
}
function XQ(r) {
  r.eachSeriesByType("graph", function(t) {
    t.get("layout") === "circular" && Yb(t, "symbolSize");
  });
}
var vu = q_;
function YQ(r, t, e) {
  for (var n = r, i = t, a = e.rect, o = a.width, s = a.height, l = [a.x + o / 2, a.y + s / 2], u = e.gravity == null ? 0.1 : e.gravity, c = 0; c < n.length; c++) {
    var f = n[c];
    f.p || (f.p = Ml(o * (Math.random() - 0.5) + l[0], s * (Math.random() - 0.5) + l[1])), f.pp = Ia(f.p), f.edges = null;
  }
  var h = e.friction == null ? 0.6 : e.friction, d = h, p, g;
  return {
    warmUp: function() {
      d = h * 0.8;
    },
    setFixed: function(v) {
      n[v].fixed = !0;
    },
    setUnfixed: function(v) {
      n[v].fixed = !1;
    },
    /**
     * Before step hook
     */
    beforeStep: function(v) {
      p = v;
    },
    /**
     * After step hook
     */
    afterStep: function(v) {
      g = v;
    },
    /**
     * Some formulas were originally copied from "d3.js"
     * https://github.com/d3/d3/blob/b516d77fb8566b576088e73410437494717ada26/src/layout/force.js
     * with some modifications made for this project.
     * See the license statement at the head of this file.
     */
    step: function(v) {
      p && p(n, i);
      for (var m = [], y = n.length, _ = 0; _ < i.length; _++) {
        var x = i[_];
        if (!x.ignoreForceLayout) {
          var b = x.n1, S = x.n2;
          Zs(m, S.p, b.p);
          var w = K_(m) - x.d, A = S.w / (b.w + S.w);
          isNaN(A) && (A = 0), _c(m, m), !b.fixed && vu(b.p, b.p, m, A * w * d), !S.fixed && vu(S.p, S.p, m, -(1 - A) * w * d);
        }
      }
      for (var _ = 0; _ < y; _++) {
        var T = n[_];
        T.fixed || (Zs(m, l, T.p), vu(T.p, T.p, m, u * d));
      }
      for (var _ = 0; _ < y; _++)
        for (var b = n[_], M = _ + 1; M < y; M++) {
          var S = n[M];
          Zs(m, S.p, b.p);
          var w = K_(m);
          w === 0 && (b1(m, Math.random() - 0.5, Math.random() - 0.5), w = 1);
          var E = (b.rep + S.rep) / w / w;
          !b.fixed && vu(b.pp, b.pp, m, E), !S.fixed && vu(S.pp, S.pp, m, -E);
        }
      for (var R = [], _ = 0; _ < y; _++) {
        var T = n[_];
        T.fixed || (Zs(R, T.p, T.pp), vu(T.p, T.p, R, d), en(T.pp, T.p));
      }
      d = d * 0.992;
      var C = d < 0.01;
      g && g(n, i, C), v && v(C);
    }
  };
}
function $Q(r) {
  r.eachSeriesByType("graph", function(t) {
    var e = t.coordinateSystem;
    if (!(e && e.type !== "view"))
      if (t.get("layout") === "force") {
        var n = t.preservedPoints || {}, i = t.getGraph(), a = i.data, o = i.edgeData, s = t.getModel("force"), l = s.get("initLayout");
        t.preservedPoints ? a.each(function(_) {
          var x = a.getId(_);
          a.setItemLayout(_, n[x] || [NaN, NaN]);
        }) : !l || l === "none" ? cB(t) : l === "circular" && Yb(t, "value");
        var u = a.getDataExtent("value"), c = o.getDataExtent("value"), f = s.get("repulsion"), h = s.get("edgeLength"), d = et(f) ? f : [f, f], p = et(h) ? h : [h, h];
        p = [p[1], p[0]];
        var g = a.mapArray("value", function(_, x) {
          var b = a.getItemLayout(x), S = Me(_, u, d);
          return isNaN(S) && (S = (d[0] + d[1]) / 2), {
            w: S,
            rep: S,
            fixed: a.getItemModel(x).get("fixed"),
            p: !b || isNaN(b[0]) || isNaN(b[1]) ? null : b
          };
        }), v = o.mapArray("value", function(_, x) {
          var b = i.getEdgeByIndex(x), S = Me(_, c, p);
          isNaN(S) && (S = (p[0] + p[1]) / 2);
          var w = b.getModel(), A = ln(b.getModel().get(["lineStyle", "curveness"]), -Wb(b, t, x, !0), 0);
          return {
            n1: g[b.node1.dataIndex],
            n2: g[b.node2.dataIndex],
            d: S,
            curveness: A,
            ignoreForceLayout: w.get("ignoreForceLayout")
          };
        }), m = e.getBoundingRect(), y = YQ(g, v, {
          rect: m,
          gravity: s.get("gravity"),
          friction: s.get("friction")
        });
        y.beforeStep(function(_, x) {
          for (var b = 0, S = _.length; b < S; b++)
            _[b].fixed && en(_[b].p, i.getNodeByIndex(b).getLayout());
        }), y.afterStep(function(_, x, b) {
          for (var S = 0, w = _.length; S < w; S++)
            _[S].fixed || i.getNodeByIndex(S).setLayout(_[S].p), n[a.getId(S)] = _[S].p;
          for (var S = 0, w = x.length; S < w; S++) {
            var A = x[S], T = i.getEdgeByIndex(S), M = A.n1.p, E = A.n2.p, R = T.getLayout();
            R = R ? R.slice() : [], R[0] = R[0] || [], R[1] = R[1] || [], en(R[0], M), en(R[1], E), +A.curveness && (R[2] = [(M[0] + E[0]) / 2 - (M[1] - E[1]) * A.curveness, (M[1] + E[1]) / 2 - (E[0] - M[0]) * A.curveness]), T.setLayout(R);
          }
        }), t.forceLayout = y, t.preservedPoints = n, y.step();
      } else
        t.forceLayout = null;
  });
}
function ZQ(r, t, e) {
  var n = xr(r, t), i = J(r.getBoxLayoutParams(), {
    aspect: e
  }), a = He(i, n.refContainer);
  return XN(r, a, e);
}
function qQ(r, t) {
  var e = [];
  return r.eachSeriesByType("graph", function(n) {
    zh({
      targetModel: n,
      coordSysType: "view",
      coordSysProvider: i,
      isDefaultDataCoordSys: !0
    });
    function i() {
      var a = n.getData(), o = a.mapArray(function(p) {
        var g = a.getItemModel(p);
        return [+g.get("x"), +g.get("y")];
      }), s = [], l = [];
      jg(o, s, l), l[0] - s[0] === 0 && (l[0] += 1, s[0] -= 1), l[1] - s[1] === 0 && (l[1] += 1, s[1] -= 1);
      var u = (l[0] - s[0]) / (l[1] - s[1]), c = ZQ(n, t, u);
      isNaN(u) && (s = [c.x, c.y], l = [c.x + c.width, c.y + c.height]);
      var f = l[0] - s[0], h = l[1] - s[1], d = new Pl(null, {
        api: t,
        ecModel: r
      });
      return d.zoomLimit = n.get("scaleLimit"), d.setBoundingRect(s[0], s[1], f, h), d.setViewRect(c.x, c.y, c.width, c.height), d.setCenter(n.get("center")), d.setZoom(n.get("zoom")), e.push(d), d;
    }
  }), e;
}
var qD = sr.prototype, W0 = kh.prototype, hB = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
    }
    return r;
  }()
);
(function(r) {
  W(t, r);
  function t() {
    return r !== null && r.apply(this, arguments) || this;
  }
  return t;
})(hB);
function X0(r) {
  return isNaN(+r.cpx1) || isNaN(+r.cpy1);
}
var dB = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e) {
      var n = r.call(this, e) || this;
      return n.type = "ec-line", n;
    }
    return t.prototype.getDefaultStyle = function() {
      return {
        stroke: Y.color.neutral99,
        fill: null
      };
    }, t.prototype.getDefaultShape = function() {
      return new hB();
    }, t.prototype.buildPath = function(e, n) {
      X0(n) ? qD.buildPath.call(this, e, n) : W0.buildPath.call(this, e, n);
    }, t.prototype.pointAt = function(e) {
      return X0(this.shape) ? qD.pointAt.call(this, e) : W0.pointAt.call(this, e);
    }, t.prototype.tangentAt = function(e) {
      var n = this.shape, i = X0(n) ? [n.x2 - n.x1, n.y2 - n.y1] : W0.tangentAt.call(this, e);
      return _c(i, i);
    }, t;
  }(ne)
), Y0 = ["fromSymbol", "toSymbol"];
function KD(r) {
  return "_" + r + "Type";
}
function jD(r, t, e) {
  var n = t.getItemVisual(e, r);
  if (!n || n === "none")
    return n;
  var i = t.getItemVisual(e, r + "Size"), a = t.getItemVisual(e, r + "Rotate"), o = t.getItemVisual(e, r + "Offset"), s = t.getItemVisual(e, r + "KeepAspect"), l = Lc(i), u = Dl(o || 0, l);
  return n + l + u + (a || "") + (s || "");
}
function JD(r, t, e) {
  var n = t.getItemVisual(e, r);
  if (!(!n || n === "none")) {
    var i = t.getItemVisual(e, r + "Size"), a = t.getItemVisual(e, r + "Rotate"), o = t.getItemVisual(e, r + "Offset"), s = t.getItemVisual(e, r + "KeepAspect"), l = Lc(i), u = Dl(o || 0, l), c = fr(n, -l[0] / 2 + u[0], -l[1] / 2 + u[1], l[0], l[1], null, s);
    return c.__specifiedRotation = a == null || isNaN(a) ? void 0 : +a * Math.PI / 180 || 0, c.name = r, c;
  }
}
function KQ(r) {
  var t = new dB({
    name: "line",
    subPixelOptimize: !0
  });
  return RS(t.shape, r), t;
}
function RS(r, t) {
  r.x1 = t[0][0], r.y1 = t[0][1], r.x2 = t[1][0], r.y2 = t[1][1], r.percent = 1;
  var e = t[2];
  e ? (r.cpx1 = e[0], r.cpy1 = e[1]) : (r.cpx1 = NaN, r.cpy1 = NaN);
}
var $b = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e, n, i) {
      var a = r.call(this) || this;
      return a._createLine(e, n, i), a;
    }
    return t.prototype._createLine = function(e, n, i) {
      var a = e.hostModel, o = e.getItemLayout(n), s = e.getItemVisual(n, "z2"), l = KQ(o);
      l.shape.percent = 0, ze(l, {
        z2: bt(s, 0),
        shape: {
          percent: 1
        }
      }, a, n), this.add(l), L(Y0, function(u) {
        var c = JD(u, e, n);
        this.add(c), this[KD(u)] = jD(u, e, n);
      }, this), this._updateCommonStl(e, n, i);
    }, t.prototype.updateData = function(e, n, i) {
      var a = e.hostModel, o = this.childOfName("line"), s = e.getItemLayout(n), l = {
        shape: {}
      };
      RS(l.shape, s), ve(o, l, a, n), L(Y0, function(u) {
        var c = jD(u, e, n), f = KD(u);
        if (this[f] !== c) {
          this.remove(this.childOfName(u));
          var h = JD(u, e, n);
          this.add(h);
        }
        this[f] = c;
      }, this), this._updateCommonStl(e, n, i);
    }, t.prototype.getLinePath = function() {
      return this.childAt(0);
    }, t.prototype._updateCommonStl = function(e, n, i) {
      var a = e.hostModel, o = this.childOfName("line"), s = i && i.emphasisLineStyle, l = i && i.blurLineStyle, u = i && i.selectLineStyle, c = i && i.labelStatesModels, f = i && i.emphasisDisabled, h = i && i.focus, d = i && i.blurScope;
      if (!i || e.hasItemOption) {
        var p = e.getItemModel(n), g = p.getModel("emphasis");
        s = g.getModel("lineStyle").getLineStyle(), l = p.getModel(["blur", "lineStyle"]).getLineStyle(), u = p.getModel(["select", "lineStyle"]).getLineStyle(), f = g.get("disabled"), h = g.get("focus"), d = g.get("blurScope"), c = _r(p);
      }
      var v = e.getItemVisual(n, "style"), m = v.stroke;
      o.useStyle(v), o.style.fill = null, o.style.strokeNoScale = !0, o.ensureState("emphasis").style = s, o.ensureState("blur").style = l, o.ensureState("select").style = u, L(Y0, function(S) {
        var w = this.childOfName(S);
        if (w) {
          w.setColor(m), w.style.opacity = v.opacity;
          for (var A = 0; A < dn.length; A++) {
            var T = dn[A], M = o.getState(T);
            if (M) {
              var E = M.style || {}, R = w.ensureState(T), C = R.style || (R.style = {});
              E.stroke != null && (C[w.__isEmptyBrush ? "stroke" : "fill"] = E.stroke), E.opacity != null && (C.opacity = E.opacity);
            }
          }
          w.markRedraw();
        }
      }, this);
      var y = a.getRawValue(n);
      Er(this, c, {
        labelDataIndex: n,
        labelFetcher: {
          getFormattedLabel: function(S, w) {
            return a.getFormattedLabel(S, w, e.dataType);
          }
        },
        inheritColor: m || Y.color.neutral99,
        defaultOpacity: v.opacity,
        defaultText: (y == null ? e.getName(n) : isFinite(y) ? or(y) : y) + ""
      });
      var _ = this.getTextContent();
      if (_) {
        var x = c.normal;
        _.__align = _.style.align, _.__verticalAlign = _.style.verticalAlign, _.__position = x.get("position") || "middle";
        var b = x.get("distance");
        et(b) || (b = [b, b]), _.__labelDistance = b;
      }
      this.setTextConfig({
        position: null,
        local: !0,
        inside: !1
        // Can't be inside for stroke element.
      }), Ge(this, h, d, f);
    }, t.prototype.highlight = function() {
      Ha(this);
    }, t.prototype.downplay = function() {
      Wa(this);
    }, t.prototype.updateLayout = function(e, n) {
      this.setLinePoints(e.getItemLayout(n));
    }, t.prototype.setLinePoints = function(e) {
      var n = this.childOfName("line");
      RS(n.shape, e), n.dirty();
    }, t.prototype.beforeUpdate = function() {
      var e = this, n = e.childOfName("fromSymbol"), i = e.childOfName("toSymbol"), a = e.getTextContent();
      if (!n && !i && (!a || a.ignore))
        return;
      for (var o = 1, s = this.parent; s; )
        s.scaleX && (o /= s.scaleX), s = s.parent;
      var l = e.childOfName("line");
      if (!this.__dirty && !l.__dirty)
        return;
      var u = l.shape.percent, c = l.pointAt(0), f = l.pointAt(u), h = Zs([], f, c);
      _c(h, h);
      function d(M, E) {
        var R = M.__specifiedRotation;
        if (R == null) {
          var C = l.tangentAt(E);
          M.attr("rotation", (E === 1 ? -1 : 1) * Math.PI / 2 - Math.atan2(C[1], C[0]));
        } else
          M.attr("rotation", R);
      }
      if (n && (n.setPosition(c), d(n, 0), n.scaleX = n.scaleY = o * u, n.markRedraw()), i && (i.setPosition(f), d(i, 1), i.scaleX = i.scaleY = o * u, i.markRedraw()), a && !a.ignore) {
        a.x = a.y = 0, a.originX = a.originY = 0;
        var p = void 0, g = void 0, v = a.__labelDistance, m = v[0] * o, y = v[1] * o, _ = u / 2, x = l.tangentAt(_), b = [x[1], -x[0]], S = l.pointAt(_);
        b[1] > 0 && (b[0] = -b[0], b[1] = -b[1]);
        var w = x[0] < 0 ? -1 : 1;
        if (a.__position !== "start" && a.__position !== "end") {
          var A = -Math.atan2(x[1], x[0]);
          f[0] < c[0] && (A = Math.PI + A), a.rotation = A;
        }
        var T = void 0;
        switch (a.__position) {
          case "insideStartTop":
          case "insideMiddleTop":
          case "insideEndTop":
          case "middle":
            T = -y, g = "bottom";
            break;
          case "insideStartBottom":
          case "insideMiddleBottom":
          case "insideEndBottom":
            T = y, g = "top";
            break;
          default:
            T = 0, g = "middle";
        }
        switch (a.__position) {
          case "end":
            a.x = h[0] * m + f[0], a.y = h[1] * y + f[1], p = h[0] > 0.8 ? "left" : h[0] < -0.8 ? "right" : "center", g = h[1] > 0.8 ? "top" : h[1] < -0.8 ? "bottom" : "middle";
            break;
          case "start":
            a.x = -h[0] * m + c[0], a.y = -h[1] * y + c[1], p = h[0] > 0.8 ? "right" : h[0] < -0.8 ? "left" : "center", g = h[1] > 0.8 ? "bottom" : h[1] < -0.8 ? "top" : "middle";
            break;
          case "insideStartTop":
          case "insideStart":
          case "insideStartBottom":
            a.x = m * w + c[0], a.y = c[1] + T, p = x[0] < 0 ? "right" : "left", a.originX = -m * w, a.originY = -T;
            break;
          case "insideMiddleTop":
          case "insideMiddle":
          case "insideMiddleBottom":
          case "middle":
            a.x = S[0], a.y = S[1] + T, p = "center", a.originY = -T;
            break;
          case "insideEndTop":
          case "insideEnd":
          case "insideEndBottom":
            a.x = -m * w + f[0], a.y = f[1] + T, p = x[0] >= 0 ? "right" : "left", a.originX = m * w, a.originY = -T;
            break;
        }
        a.scaleX = a.scaleY = o, a.setStyle({
          // Use the user specified text align and baseline first
          verticalAlign: a.__verticalAlign || g,
          align: a.__align || p
        });
      }
    }, t;
  }(Et)
), Zb = (
  /** @class */
  function() {
    function r(t) {
      this.group = new Et(), this._LineCtor = t || $b;
    }
    return r.prototype.updateData = function(t) {
      var e = this;
      this._progressiveEls = null;
      var n = this, i = n.group, a = n._lineData;
      n._lineData = t, a || i.removeAll();
      var o = QD(t);
      t.diff(a).add(function(s) {
        e._doAdd(t, s, o);
      }).update(function(s, l) {
        e._doUpdate(a, t, l, s, o);
      }).remove(function(s) {
        i.remove(a.getItemGraphicEl(s));
      }).execute();
    }, r.prototype.updateLayout = function() {
      var t = this._lineData;
      t && t.eachItemGraphicEl(function(e, n) {
        e.updateLayout(t, n);
      }, this);
    }, r.prototype.incrementalPrepareUpdate = function(t) {
      this._seriesScope = QD(t), this._lineData = null, this.group.removeAll();
    }, r.prototype.incrementalUpdate = function(t, e) {
      this._progressiveEls = [];
      function n(s) {
        !s.isGroup && !jQ(s) && (s.incremental = !0, s.ensureState("emphasis").hoverLayer = !0);
      }
      for (var i = t.start; i < t.end; i++) {
        var a = e.getItemLayout(i);
        if ($0(a)) {
          var o = new this._LineCtor(e, i, this._seriesScope);
          o.traverse(n), this.group.add(o), e.setItemGraphicEl(i, o), this._progressiveEls.push(o);
        }
      }
    }, r.prototype.remove = function() {
      this.group.removeAll();
    }, r.prototype.eachRendered = function(t) {
      Ko(this._progressiveEls || this.group, t);
    }, r.prototype._doAdd = function(t, e, n) {
      var i = t.getItemLayout(e);
      if ($0(i)) {
        var a = new this._LineCtor(t, e, n);
        t.setItemGraphicEl(e, a), this.group.add(a);
      }
    }, r.prototype._doUpdate = function(t, e, n, i, a) {
      var o = t.getItemGraphicEl(n);
      if (!$0(e.getItemLayout(i))) {
        this.group.remove(o);
        return;
      }
      o ? o.updateData(e, i, a) : o = new this._LineCtor(e, i, a), e.setItemGraphicEl(i, o), this.group.add(o);
    }, r;
  }()
);
function jQ(r) {
  return r.animators && r.animators.length > 0;
}
function QD(r) {
  var t = r.hostModel, e = t.getModel("emphasis");
  return {
    lineStyle: t.getModel("lineStyle").getLineStyle(),
    emphasisLineStyle: e.getModel(["lineStyle"]).getLineStyle(),
    blurLineStyle: t.getModel(["blur", "lineStyle"]).getLineStyle(),
    selectLineStyle: t.getModel(["select", "lineStyle"]).getLineStyle(),
    emphasisDisabled: e.get("disabled"),
    blurScope: e.get("blurScope"),
    focus: e.get("focus"),
    labelStatesModels: _r(t)
  };
}
function tL(r) {
  return isNaN(r[0]) || isNaN(r[1]);
}
function $0(r) {
  return r && !tL(r[0]) && !tL(r[1]);
}
var Z0 = [], q0 = [], K0 = [], gu = Ir, j0 = el, eL = Math.abs;
function rL(r, t, e) {
  for (var n = r[0], i = r[1], a = r[2], o = 1 / 0, s, l = e * e, u = 0.1, c = 0.1; c <= 0.9; c += 0.1) {
    Z0[0] = gu(n[0], i[0], a[0], c), Z0[1] = gu(n[1], i[1], a[1], c);
    var f = eL(j0(Z0, t) - l);
    f < o && (o = f, s = c);
  }
  for (var h = 0; h < 32; h++) {
    var d = s + u;
    q0[0] = gu(n[0], i[0], a[0], s), q0[1] = gu(n[1], i[1], a[1], s), K0[0] = gu(n[0], i[0], a[0], d), K0[1] = gu(n[1], i[1], a[1], d);
    var f = j0(q0, t) - l;
    if (eL(f) < 0.01)
      break;
    var p = j0(K0, t) - l;
    u /= 2, f < 0 ? p >= 0 ? s = s + u : s = s - u : p >= 0 ? s = s - u : s = s + u;
  }
  return s;
}
function J0(r, t) {
  var e = [], n = eh, i = [[], [], []], a = [[], []], o = [];
  t /= 2, r.eachEdge(function(s, l) {
    var u = s.getLayout(), c = s.getVisual("fromSymbol"), f = s.getVisual("toSymbol");
    u.__original || (u.__original = [Ia(u[0]), Ia(u[1])], u[2] && u.__original.push(Ia(u[2])));
    var h = u.__original;
    if (u[2] != null) {
      if (en(i[0], h[0]), en(i[1], h[2]), en(i[2], h[1]), c && c !== "none") {
        var d = Vf(s.node1), p = rL(i, h[0], d * t);
        n(i[0][0], i[1][0], i[2][0], p, e), i[0][0] = e[3], i[1][0] = e[4], n(i[0][1], i[1][1], i[2][1], p, e), i[0][1] = e[3], i[1][1] = e[4];
      }
      if (f && f !== "none") {
        var d = Vf(s.node2), p = rL(i, h[1], d * t);
        n(i[0][0], i[1][0], i[2][0], p, e), i[1][0] = e[1], i[2][0] = e[2], n(i[0][1], i[1][1], i[2][1], p, e), i[1][1] = e[1], i[2][1] = e[2];
      }
      en(u[0], i[0]), en(u[1], i[2]), en(u[2], i[1]);
    } else {
      if (en(a[0], h[0]), en(a[1], h[1]), Zs(o, a[1], a[0]), _c(o, o), c && c !== "none") {
        var d = Vf(s.node1);
        q_(a[0], a[0], o, d * t);
      }
      if (f && f !== "none") {
        var d = Vf(s.node2);
        q_(a[1], a[1], o, -d * t);
      }
      en(u[0], a[0]), en(u[1], a[1]);
    }
  });
}
var pB = ee();
function JQ(r) {
  if (r)
    return pB(r).bridge;
}
function nL(r, t) {
  r && (pB(r).bridge = t);
}
function iL(r) {
  return r.type === "view";
}
var QQ = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function(e, n) {
      var i = new Xh(), a = new Zb(), o = this.group, s = new Et();
      this._controller = new Il(n.getZr()), this._controllerHost = {
        target: s
      }, s.add(i.group), s.add(a.group), o.add(s), this._symbolDraw = i, this._lineDraw = a, this._mainGroup = s, this._firstRender = !0;
    }, t.prototype.render = function(e, n, i) {
      var a = this, o = e.coordinateSystem, s = !1;
      this._model = e, this._api = i, this._active = !0;
      var l = this._getThumbnailInfo();
      l && l.bridge.reset(i);
      var u = this._symbolDraw, c = this._lineDraw;
      if (iL(o)) {
        var f = {
          x: o.x,
          y: o.y,
          scaleX: o.scaleX,
          scaleY: o.scaleY
        };
        this._firstRender ? this._mainGroup.attr(f) : ve(this._mainGroup, f, e);
      }
      J0(e.getGraph(), Bf(e));
      var h = e.getData();
      u.updateData(h);
      var d = e.getEdgeData();
      c.updateData(d), this._updateNodeAndLinkScale(), this._updateController(null, e, i), clearTimeout(this._layoutTimeout);
      var p = e.forceLayout, g = e.get(["force", "layoutAnimation"]);
      p && (s = !0, this._startForceLayoutIteration(p, i, g));
      var v = e.get("layout");
      h.graph.eachNode(function(x) {
        var b = x.dataIndex, S = x.getGraphicEl(), w = x.getModel();
        if (S) {
          S.off("drag").off("dragend");
          var A = w.get("draggable");
          A && S.on("drag", function(M) {
            switch (v) {
              case "force":
                p.warmUp(), !a._layouting && a._startForceLayoutIteration(p, i, g), p.setFixed(b), h.setItemLayout(b, [S.x, S.y]);
                break;
              case "circular":
                h.setItemLayout(b, [S.x, S.y]), x.setLayout({
                  fixed: !0
                }, !0), Yb(e, "symbolSize", x, [M.offsetX, M.offsetY]), a.updateLayout(e);
                break;
              case "none":
              default:
                h.setItemLayout(b, [S.x, S.y]), Xb(e.getGraph(), e), a.updateLayout(e);
                break;
            }
          }).on("dragend", function() {
            p && p.setUnfixed(b);
          }), S.setDraggable(A, !!w.get("cursor"));
          var T = w.get(["emphasis", "focus"]);
          T === "adjacency" && (zt(S).focus = x.getAdjacentDataIndices());
        }
      }), h.graph.eachEdge(function(x) {
        var b = x.getGraphicEl(), S = x.getModel().get(["emphasis", "focus"]);
        b && S === "adjacency" && (zt(b).focus = {
          edge: [x.dataIndex],
          node: [x.node1.dataIndex, x.node2.dataIndex]
        });
      });
      var m = e.get("layout") === "circular" && e.get(["circular", "rotateLabel"]), y = h.getLayout("cx"), _ = h.getLayout("cy");
      h.graph.eachNode(function(x) {
        fB(x, m, y, _);
      }), this._firstRender = !1, s || this._renderThumbnail(e, i, this._symbolDraw, this._lineDraw);
    }, t.prototype.dispose = function() {
      this.remove(), this._controller && this._controller.dispose(), this._controllerHost = null;
    }, t.prototype._startForceLayoutIteration = function(e, n, i) {
      var a = this, o = !1;
      (function s() {
        e.step(function(l) {
          a.updateLayout(a._model), (l || !o) && (o = !0, a._renderThumbnail(a._model, n, a._symbolDraw, a._lineDraw)), (a._layouting = !l) && (i ? a._layoutTimeout = setTimeout(s, 16) : s());
        });
      })();
    }, t.prototype._updateController = function(e, n, i) {
      var a = this._controller, o = this._controllerHost, s = n.coordinateSystem;
      if (!iL(s)) {
        a.disable();
        return;
      }
      a.enable(n.get("roam"), {
        api: i,
        zInfo: {
          component: n
        },
        triggerInfo: {
          roamTrigger: n.get("roamTrigger"),
          isInSelf: function(l, u, c) {
            return s.containPoint([u, c]);
          },
          isInClip: function(l, u, c) {
            return !e || e.contain(u, c);
          }
        }
      }), o.zoomLimit = n.get("scaleLimit"), o.zoom = s.getZoom(), a.off("pan").off("zoom").on("pan", function(l) {
        i.dispatchAction({
          seriesId: n.id,
          type: "graphRoam",
          dx: l.dx,
          dy: l.dy
        });
      }).on("zoom", function(l) {
        i.dispatchAction({
          seriesId: n.id,
          type: "graphRoam",
          zoom: l.scale,
          originX: l.originX,
          originY: l.originY
        });
      });
    }, t.prototype.updateViewOnPan = function(e, n, i) {
      this._active && (kb(this._controllerHost, i.dx, i.dy), this._updateThumbnailWindow());
    }, t.prototype.updateViewOnZoom = function(e, n, i) {
      this._active && (Bb(this._controllerHost, i.zoom, i.originX, i.originY), this._updateNodeAndLinkScale(), J0(e.getGraph(), Bf(e)), this._lineDraw.updateLayout(), n.updateLabelLayout(), this._updateThumbnailWindow());
    }, t.prototype._updateNodeAndLinkScale = function() {
      var e = this._model, n = e.getData(), i = Bf(e);
      n.eachItemGraphicEl(function(a, o) {
        a && a.setSymbolScale(i);
      });
    }, t.prototype.updateLayout = function(e) {
      this._active && (J0(e.getGraph(), Bf(e)), this._symbolDraw.updateLayout(), this._lineDraw.updateLayout());
    }, t.prototype.remove = function() {
      this._active = !1, clearTimeout(this._layoutTimeout), this._layouting = !1, this._layoutTimeout = null, this._symbolDraw && this._symbolDraw.remove(), this._lineDraw && this._lineDraw.remove(), this._controller && this._controller.disable();
    }, t.prototype._getThumbnailInfo = function() {
      var e = this._model, n = e.coordinateSystem;
      if (n.type === "view") {
        var i = JQ(e);
        if (i)
          return {
            bridge: i,
            coordSys: n
          };
      }
    }, t.prototype._updateThumbnailWindow = function() {
      var e = this._getThumbnailInfo();
      e && e.bridge.updateWindow(e.coordSys.transform, this._api);
    }, t.prototype._renderThumbnail = function(e, n, i, a) {
      var o = this._getThumbnailInfo();
      if (o) {
        var s = new Et(), l = i.group.children(), u = a.group.children(), c = new Et(), f = new Et();
        s.add(f), s.add(c);
        for (var h = 0; h < l.length; h++) {
          var d = l[h], p = d.children()[0], g = d.x, v = d.y, m = Ct(p.shape), y = J(m, {
            width: p.scaleX,
            height: p.scaleY,
            x: g - p.scaleX / 2,
            y: v - p.scaleY / 2
          }), _ = Ct(p.style), x = new p.constructor({
            shape: y,
            style: _,
            z2: 151
          });
          f.add(x);
        }
        for (var h = 0; h < u.length; h++) {
          var d = u[h], b = d.children()[0], _ = Ct(b.style), y = Ct(b.shape), S = new dB({
            style: _,
            shape: y,
            z2: 151
          });
          c.add(S);
        }
        o.bridge.renderContent({
          api: n,
          roamType: e.get("roam"),
          viewportRect: null,
          group: s,
          targetTrans: o.coordSys.transform
        });
      }
    }, t.type = "graph", t;
  }(Re)
);
function mu(r) {
  return "_EC_" + r;
}
var ttt = (
  /** @class */
  function() {
    function r(t) {
      this.type = "graph", this.nodes = [], this.edges = [], this._nodesMap = {}, this._edgesMap = {}, this._directed = t || !1;
    }
    return r.prototype.isDirected = function() {
      return this._directed;
    }, r.prototype.addNode = function(t, e) {
      t = t == null ? "" + e : "" + t;
      var n = this._nodesMap;
      if (n[mu(t)]) {
        process.env.NODE_ENV !== "production" && console.error("Graph nodes have duplicate name or id");
        return;
      }
      var i = new Vs(t, e);
      return i.hostGraph = this, this.nodes.push(i), n[mu(t)] = i, i;
    }, r.prototype.getNodeByIndex = function(t) {
      var e = this.data.getRawIndex(t);
      return this.nodes[e];
    }, r.prototype.getNodeById = function(t) {
      return this._nodesMap[mu(t)];
    }, r.prototype.addEdge = function(t, e, n) {
      var i = this._nodesMap, a = this._edgesMap;
      if (fe(t) && (t = this.nodes[t]), fe(e) && (e = this.nodes[e]), t instanceof Vs || (t = i[mu(t)]), e instanceof Vs || (e = i[mu(e)]), !(!t || !e)) {
        var o = t.id + "-" + e.id, s = new vB(t, e, n);
        return s.hostGraph = this, this._directed && (t.outEdges.push(s), e.inEdges.push(s)), t.edges.push(s), t !== e && e.edges.push(s), this.edges.push(s), a[o] = s, s;
      }
    }, r.prototype.getEdgeByIndex = function(t) {
      var e = this.edgeData.getRawIndex(t);
      return this.edges[e];
    }, r.prototype.getEdge = function(t, e) {
      t instanceof Vs && (t = t.id), e instanceof Vs && (e = e.id);
      var n = this._edgesMap;
      return this._directed ? n[t + "-" + e] : n[t + "-" + e] || n[e + "-" + t];
    }, r.prototype.eachNode = function(t, e) {
      for (var n = this.nodes, i = n.length, a = 0; a < i; a++)
        n[a].dataIndex >= 0 && t.call(e, n[a], a);
    }, r.prototype.eachEdge = function(t, e) {
      for (var n = this.edges, i = n.length, a = 0; a < i; a++)
        n[a].dataIndex >= 0 && n[a].node1.dataIndex >= 0 && n[a].node2.dataIndex >= 0 && t.call(e, n[a], a);
    }, r.prototype.breadthFirstTraverse = function(t, e, n, i) {
      if (e instanceof Vs || (e = this._nodesMap[mu(e)]), !!e) {
        for (var a = n === "out" ? "outEdges" : n === "in" ? "inEdges" : "edges", o = 0; o < this.nodes.length; o++)
          this.nodes[o].__visited = !1;
        if (!t.call(i, e, null))
          for (var s = [e]; s.length; )
            for (var l = s.shift(), u = l[a], o = 0; o < u.length; o++) {
              var c = u[o], f = c.node1 === l ? c.node2 : c.node1;
              if (!f.__visited) {
                if (t.call(i, f, l))
                  return;
                s.push(f), f.__visited = !0;
              }
            }
      }
    }, r.prototype.update = function() {
      for (var t = this.data, e = this.edgeData, n = this.nodes, i = this.edges, a = 0, o = n.length; a < o; a++)
        n[a].dataIndex = -1;
      for (var a = 0, o = t.count(); a < o; a++)
        n[t.getRawIndex(a)].dataIndex = a;
      e.filterSelf(function(s) {
        var l = i[e.getRawIndex(s)];
        return l.node1.dataIndex >= 0 && l.node2.dataIndex >= 0;
      });
      for (var a = 0, o = i.length; a < o; a++)
        i[a].dataIndex = -1;
      for (var a = 0, o = e.count(); a < o; a++)
        i[e.getRawIndex(a)].dataIndex = a;
    }, r.prototype.clone = function() {
      for (var t = new r(this._directed), e = this.nodes, n = this.edges, i = 0; i < e.length; i++)
        t.addNode(e[i].id, e[i].dataIndex);
      for (var i = 0; i < n.length; i++) {
        var a = n[i];
        t.addEdge(a.node1.id, a.node2.id, a.dataIndex);
      }
      return t;
    }, r;
  }()
), Vs = (
  /** @class */
  function() {
    function r(t, e) {
      this.inEdges = [], this.outEdges = [], this.edges = [], this.dataIndex = -1, this.id = t ?? "", this.dataIndex = e ?? -1;
    }
    return r.prototype.degree = function() {
      return this.edges.length;
    }, r.prototype.inDegree = function() {
      return this.inEdges.length;
    }, r.prototype.outDegree = function() {
      return this.outEdges.length;
    }, r.prototype.getModel = function(t) {
      if (!(this.dataIndex < 0)) {
        var e = this.hostGraph, n = e.data.getItemModel(this.dataIndex);
        return n.getModel(t);
      }
    }, r.prototype.getAdjacentDataIndices = function() {
      for (var t = {
        edge: [],
        node: []
      }, e = 0; e < this.edges.length; e++) {
        var n = this.edges[e];
        n.dataIndex < 0 || (t.edge.push(n.dataIndex), t.node.push(n.node1.dataIndex, n.node2.dataIndex));
      }
      return t;
    }, r.prototype.getTrajectoryDataIndices = function() {
      for (var t = wt(), e = wt(), n = 0, i = this.edges.length; n < i; n++) {
        var a = this.edges[n];
        if (!(a.dataIndex < 0)) {
          t.set(a.dataIndex, !0);
          for (var o = [a.node1], s = [a.node2], l = 0; l < o.length; ) {
            var u = o[l];
            l++, e.set(u.dataIndex, !0);
            for (var c = u.inEdges, f = 0, h = c.length, d = void 0, p = void 0; f < h; f++)
              d = c[f], p = d.dataIndex, p >= 0 && !t.hasKey(p) && (t.set(p, !0), o.push(d.node1));
          }
          for (l = 0; l < s.length; ) {
            var g = s[l];
            l++, e.set(g.dataIndex, !0);
            for (var v = g.outEdges, f = 0, m = v.length, y = void 0, _ = void 0; f < m; f++)
              y = v[f], _ = y.dataIndex, _ >= 0 && !t.hasKey(_) && (t.set(_, !0), s.push(y.node2));
          }
        }
      }
      return {
        edge: t.keys(),
        node: e.keys()
      };
    }, r;
  }()
), vB = (
  /** @class */
  function() {
    function r(t, e, n) {
      this.dataIndex = -1, this.node1 = t, this.node2 = e, this.dataIndex = n ?? -1;
    }
    return r.prototype.getModel = function(t) {
      if (!(this.dataIndex < 0)) {
        var e = this.hostGraph, n = e.edgeData.getItemModel(this.dataIndex);
        return n.getModel(t);
      }
    }, r.prototype.getAdjacentDataIndices = function() {
      return {
        edge: [this.dataIndex],
        node: [this.node1.dataIndex, this.node2.dataIndex]
      };
    }, r.prototype.getTrajectoryDataIndices = function() {
      var t = wt(), e = wt();
      t.set(this.dataIndex, !0);
      for (var n = [this.node1], i = [this.node2], a = 0; a < n.length; ) {
        var o = n[a];
        a++, e.set(o.dataIndex, !0);
        for (var s = o.inEdges, l = 0, u = s.length, c = void 0, f = void 0; l < u; l++)
          c = o.inEdges[l], f = c.dataIndex, f >= 0 && !t.hasKey(f) && (t.set(f, !0), n.push(c.node1));
      }
      for (a = 0; a < i.length; ) {
        var h = i[a];
        a++, e.set(h.dataIndex, !0);
        for (var d = h.outEdges, l = 0, u = d.length, p = void 0, g = void 0; l < u; l++)
          p = h.outEdges[l], g = p.dataIndex, g >= 0 && !t.hasKey(g) && (t.set(g, !0), i.push(p.node2));
      }
      return {
        edge: t.keys(),
        node: e.keys()
      };
    }, r;
  }()
);
function gB(r, t) {
  return {
    /**
     * @param Default 'value'. can be 'a', 'b', 'c', 'd', 'e'.
     */
    getValue: function(e) {
      var n = this[r][t];
      return n.getStore().get(n.getDimensionIndex(e || "value"), this.dataIndex);
    },
    // TODO: TYPE stricter type.
    setVisual: function(e, n) {
      this.dataIndex >= 0 && this[r][t].setItemVisual(this.dataIndex, e, n);
    },
    getVisual: function(e) {
      return this[r][t].getItemVisual(this.dataIndex, e);
    },
    setLayout: function(e, n) {
      this.dataIndex >= 0 && this[r][t].setItemLayout(this.dataIndex, e, n);
    },
    getLayout: function() {
      return this[r][t].getItemLayout(this.dataIndex);
    },
    getGraphicEl: function() {
      return this[r][t].getItemGraphicEl(this.dataIndex);
    },
    getRawIndex: function() {
      return this[r][t].getRawIndex(this.dataIndex);
    }
  };
}
hr(Vs, gB("hostGraph", "data"));
hr(vB, gB("hostGraph", "edgeData"));
function qb(r, t, e, n, i) {
  for (var a = new ttt(n), o = 0; o < r.length; o++)
    a.addNode(gr(
      // Id, name, dataIndex
      r[o].id,
      r[o].name,
      o
    ), o);
  for (var s = [], l = [], u = 0, o = 0; o < t.length; o++) {
    var c = t[o], f = c.source, h = c.target;
    a.addEdge(f, h, u) && (l.push(c), s.push(gr(mr(c.id, null), f + " > " + h)), u++);
  }
  var d = e.get("coordinateSystem"), p;
  if (d === "cartesian2d" || d === "polar" || d === "matrix")
    p = ja(r, e);
  else {
    var g = Ec.get(d), v = g ? g.dimensions || [] : [];
    Zt(v, "value") < 0 && v.concat(["value"]);
    var m = Gh(r, {
      coordDimensions: v,
      encodeDefine: e.getEncode()
    }).dimensions;
    p = new un(m, e), p.initData(r);
  }
  var y = new un(["value"], e);
  return y.initData(l, s), i && i(p, y), K3({
    mainData: p,
    struct: a,
    structAttr: "graph",
    datas: {
      node: p,
      edge: y
    },
    datasAttr: {
      node: "data",
      edge: "edgeData"
    }
  }), a.update(), a;
}
var ett = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.hasSymbolVisual = !0, e;
    }
    return t.prototype.init = function(e) {
      r.prototype.init.apply(this, arguments);
      var n = this;
      function i() {
        return n._categoriesData;
      }
      this.legendVisualProvider = new Nc(i, i), this.fillDataTextStyle(e.edges || e.links), this._updateCategoriesData();
    }, t.prototype.mergeOption = function(e) {
      r.prototype.mergeOption.apply(this, arguments), this.fillDataTextStyle(e.edges || e.links), this._updateCategoriesData();
    }, t.prototype.mergeDefaultAndTheme = function(e) {
      r.prototype.mergeDefaultAndTheme.apply(this, arguments), hl(e, "edgeLabel", ["show"]);
    }, t.prototype.getInitialData = function(e, n) {
      var i = e.edges || e.links || [], a = e.data || e.nodes || [], o = this;
      if (a && i) {
        UQ(this);
        var s = qb(a, i, this, !0, l);
        return L(s.edges, function(u) {
          GQ(u.node1, u.node2, this, u.dataIndex);
        }, this), s.data;
      }
      function l(u, c) {
        u.wrapMethod("getItemModel", function(p) {
          var g = o._categoriesModels, v = p.getShallow("category"), m = g[v];
          return m && (m.parentModel = p.parentModel, p.parentModel = m), p;
        });
        var f = ue.prototype.getModel;
        function h(p, g) {
          var v = f.call(this, p, g);
          return v.resolveParentPath = d, v;
        }
        c.wrapMethod("getItemModel", function(p) {
          return p.resolveParentPath = d, p.getModel = h, p;
        });
        function d(p) {
          if (p && (p[0] === "label" || p[1] === "label")) {
            var g = p.slice();
            return p[0] === "label" ? g[0] = "edgeLabel" : p[1] === "label" && (g[1] = "edgeLabel"), g;
          }
          return p;
        }
      }
    }, t.prototype.getGraph = function() {
      return this.getData().graph;
    }, t.prototype.getEdgeData = function() {
      return this.getGraph().edgeData;
    }, t.prototype.getCategoriesData = function() {
      return this._categoriesData;
    }, t.prototype.formatTooltip = function(e, n, i) {
      if (i === "edge") {
        var a = this.getData(), o = this.getDataParams(e, i), s = a.graph.getEdgeByIndex(e), l = a.getName(s.node1.dataIndex), u = a.getName(s.node2.dataIndex), c = [];
        return l != null && c.push(l), u != null && c.push(u), cr("nameValue", {
          name: c.join(" > "),
          value: o.value,
          noValue: o.value == null
        });
      }
      var f = MO({
        series: this,
        dataIndex: e,
        multipleSeries: n
      });
      return f;
    }, t.prototype._updateCategoriesData = function() {
      var e = rt(this.option.categories || [], function(i) {
        return i.value != null ? i : J({
          value: 0
        }, i);
      }), n = new un(["value"], this);
      n.initData(e), this._categoriesData = n, this._categoriesModels = n.mapArray(function(i) {
        return n.getItemModel(i);
      });
    }, t.prototype.setZoom = function(e) {
      this.option.zoom = e;
    }, t.prototype.setCenter = function(e) {
      this.option.center = e;
    }, t.prototype.isAnimationEnabled = function() {
      return r.prototype.isAnimationEnabled.call(this) && !(this.get("layout") === "force" && this.get(["force", "layoutAnimation"]));
    }, t.type = "series.graph", t.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"], t.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "view",
      // Default option for all coordinate systems
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // polarIndex: 0,
      // geoIndex: 0,
      legendHoverLink: !0,
      layout: null,
      // Configuration of circular layout
      circular: {
        rotateLabel: !1
      },
      // Configuration of force directed layout
      force: {
        initLayout: null,
        // Node repulsion. Can be an array to represent range.
        repulsion: [0, 50],
        gravity: 0.1,
        // Initial friction
        friction: 0.6,
        // Edge length. Can be an array to represent range.
        edgeLength: 30,
        layoutAnimation: !0
      },
      left: "center",
      top: "center",
      // right: null,
      // bottom: null,
      // width: '80%',
      // height: '80%',
      symbol: "circle",
      symbolSize: 10,
      edgeSymbol: ["none", "none"],
      edgeSymbolSize: 10,
      edgeLabel: {
        position: "middle",
        distance: 5
      },
      draggable: !1,
      roam: !1,
      // Default on center of graph
      center: null,
      zoom: 1,
      // Symbol size scale ratio in roam
      nodeScaleRatio: 0.6,
      // cursor: null,
      // categories: [],
      // data: []
      // Or
      // nodes: []
      //
      // links: []
      // Or
      // edges: []
      label: {
        show: !1,
        formatter: "{b}"
      },
      itemStyle: {},
      lineStyle: {
        // Don't use tokens.color.border because of the opacity
        color: Y.color.neutral50,
        width: 1,
        opacity: 0.5
      },
      emphasis: {
        scale: !0,
        label: {
          show: !0
        }
      },
      select: {
        itemStyle: {
          borderColor: Y.color.primary
        }
      }
    }, t;
  }(ke)
);
function rtt(r) {
  r.registerChartView(QQ), r.registerSeriesModel(ett), r.registerProcessor(kQ), r.registerVisual(BQ), r.registerVisual(VQ), r.registerLayout(HQ), r.registerLayout(r.PRIORITY.VISUAL.POST_CHART_LAYOUT, XQ), r.registerLayout($Q), r.registerCoordinateSystem("graphView", {
    dimensions: Pl.dimensions,
    create: qQ
  }), r.registerAction({
    type: "focusNodeAdjacency",
    event: "focusNodeAdjacency",
    update: "series:focusNodeAdjacency"
  }, er), r.registerAction({
    type: "unfocusNodeAdjacency",
    event: "unfocusNodeAdjacency",
    update: "series:unfocusNodeAdjacency"
  }, er), r.registerAction({
    type: "graphRoam",
    event: "graphRoam",
    update: "none"
  }, function(t, e, n) {
    e.eachComponent({
      mainType: "series",
      query: t
    }, function(i) {
      var a = n.getViewOfSeriesModel(i);
      a && (t.dx != null && t.dy != null && a.updateViewOnPan(i, n, t), t.zoom != null && t.originX != null && t.originY != null && a.updateViewOnZoom(i, n, t));
      var o = i.coordinateSystem, s = _m(o, t, i.get("scaleLimit"));
      i.setCenter && i.setCenter(s.center), i.setZoom && i.setZoom(s.zoom);
    });
  });
}
var aL = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e, n, i) {
      var a = r.call(this) || this;
      zt(a).dataType = "node", a.z2 = 2;
      var o = new pe();
      return a.setTextContent(o), a.updateData(e, n, i, !0), a;
    }
    return t.prototype.updateData = function(e, n, i, a) {
      var o = this, s = e.graph.getNodeByIndex(n), l = e.hostModel, u = s.getModel(), c = u.getModel("emphasis"), f = e.getItemLayout(n), h = J(Ki(u.getModel("itemStyle"), f, !0), f), d = this;
      if (isNaN(h.startAngle)) {
        d.setShape(h);
        return;
      }
      a ? d.setShape(h) : ve(d, {
        shape: h
      }, l, n);
      var p = J(Ki(u.getModel("itemStyle"), f, !0), f);
      o.setShape(p), o.useStyle(e.getItemVisual(n, "style")), yr(o, u), this._updateLabel(l, u, s), e.setItemGraphicEl(n, d), yr(d, u, "itemStyle");
      var g = c.get("focus");
      Ge(this, g === "adjacency" ? s.getAdjacentDataIndices() : g, c.get("blurScope"), c.get("disabled"));
    }, t.prototype._updateLabel = function(e, n, i) {
      var a = this.getTextContent(), o = i.getLayout(), s = (o.startAngle + o.endAngle) / 2, l = Math.cos(s), u = Math.sin(s), c = n.getModel("label");
      a.ignore = !c.get("show");
      var f = _r(n), h = i.getVisual("style");
      Er(a, f, {
        labelFetcher: {
          getFormattedLabel: function(y, _, x, b, S, w) {
            return e.getFormattedLabel(
              y,
              _,
              "node",
              b,
              // ensure edgeLabel formatter is provided
              // to prevent the inheritance from `label.formatter` of the series
              ln(S, f.normal && f.normal.get("formatter"), n.get("name")),
              w
            );
          }
        },
        labelDataIndex: i.dataIndex,
        defaultText: i.dataIndex + "",
        inheritColor: h.fill,
        defaultOpacity: h.opacity,
        defaultOutsidePosition: "startArc"
      });
      var d = c.get("position") || "outside", p = c.get("distance") || 0, g;
      d === "outside" ? g = o.r + p : g = (o.r + o.r0) / 2, this.textConfig = {
        inside: d !== "outside"
      };
      var v = d !== "outside" ? c.get("align") || "center" : l > 0 ? "left" : "right", m = d !== "outside" ? c.get("verticalAlign") || "middle" : u > 0 ? "top" : "bottom";
      a.attr({
        x: l * g + o.cx,
        y: u * g + o.cy,
        rotation: 0,
        style: {
          align: v,
          verticalAlign: m
        }
      });
    }, t;
  }(Kr)
), ntt = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e, n, i, a) {
      var o = r.call(this) || this;
      return zt(o).dataType = "edge", o.updateData(e, n, i, a, !0), o;
    }
    return t.prototype.buildPath = function(e, n) {
      e.moveTo(n.s1[0], n.s1[1]);
      var i = 0.7, a = n.clockwise;
      e.arc(n.cx, n.cy, n.r, n.sStartAngle, n.sEndAngle, !a), e.bezierCurveTo((n.cx - n.s2[0]) * i + n.s2[0], (n.cy - n.s2[1]) * i + n.s2[1], (n.cx - n.t1[0]) * i + n.t1[0], (n.cy - n.t1[1]) * i + n.t1[1], n.t1[0], n.t1[1]), e.arc(n.cx, n.cy, n.r, n.tStartAngle, n.tEndAngle, !a), e.bezierCurveTo((n.cx - n.t2[0]) * i + n.t2[0], (n.cy - n.t2[1]) * i + n.t2[1], (n.cx - n.s1[0]) * i + n.s1[0], (n.cy - n.s1[1]) * i + n.s1[1], n.s1[0], n.s1[1]), e.closePath();
    }, t.prototype.updateData = function(e, n, i, a, o) {
      var s = e.hostModel, l = n.graph.getEdgeByIndex(i), u = l.getLayout(), c = l.node1.getModel(), f = n.getItemModel(l.dataIndex), h = f.getModel("lineStyle"), d = f.getModel("emphasis"), p = d.get("focus"), g = J(Ki(c.getModel("itemStyle"), u, !0), u), v = this;
      if (isNaN(g.sStartAngle) || isNaN(g.tStartAngle)) {
        v.setShape(g);
        return;
      }
      o ? (v.setShape(g), oL(v, l, e, h)) : (ai(v), oL(v, l, e, h), ve(v, {
        shape: g
      }, s, i)), Ge(this, p === "adjacency" ? l.getAdjacentDataIndices() : p, d.get("blurScope"), d.get("disabled")), yr(v, f, "lineStyle"), n.setItemGraphicEl(l.dataIndex, v);
    }, t;
  }(ne)
);
function oL(r, t, e, n) {
  var i = t.node1, a = t.node2, o = r.style;
  r.setStyle(n.getLineStyle());
  var s = n.get("color");
  switch (s) {
    case "source":
      o.fill = e.getItemVisual(i.dataIndex, "style").fill, o.decal = i.getVisual("style").decal;
      break;
    case "target":
      o.fill = e.getItemVisual(a.dataIndex, "style").fill, o.decal = a.getVisual("style").decal;
      break;
    case "gradient":
      var l = e.getItemVisual(i.dataIndex, "style").fill, u = e.getItemVisual(a.dataIndex, "style").fill;
      if (pt(l) && pt(u)) {
        var c = r.shape, f = (c.s1[0] + c.s2[0]) / 2, h = (c.s1[1] + c.s2[1]) / 2, d = (c.t1[0] + c.t2[0]) / 2, p = (c.t1[1] + c.t2[1]) / 2;
        o.fill = new wc(f, h, d, p, [{
          offset: 0,
          color: l
        }, {
          offset: 1,
          color: u
        }], !0);
      }
      break;
  }
}
var itt = Math.PI / 180, att = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function(e, n) {
    }, t.prototype.render = function(e, n, i) {
      var a = e.getData(), o = this._data, s = this.group, l = -e.get("startAngle") * itt;
      if (a.diff(o).add(function(c) {
        var f = a.getItemLayout(c);
        if (f) {
          var h = new aL(a, c, l);
          zt(h).dataIndex = c, s.add(h);
        }
      }).update(function(c, f) {
        var h = o.getItemGraphicEl(f), d = a.getItemLayout(c);
        if (!d) {
          h && Pa(h, e, f);
          return;
        }
        h ? h.updateData(a, c, l) : h = new aL(a, c, l), s.add(h);
      }).remove(function(c) {
        var f = o.getItemGraphicEl(c);
        f && Pa(f, e, c);
      }).execute(), !o) {
        var u = e.get("center");
        this.group.scaleX = 0.01, this.group.scaleY = 0.01, this.group.originX = dt(u[0], i.getWidth()), this.group.originY = dt(u[1], i.getHeight()), ze(this.group, {
          scaleX: 1,
          scaleY: 1
        }, e);
      }
      this._data = a, this.renderEdges(e, l);
    }, t.prototype.renderEdges = function(e, n) {
      var i = e.getData(), a = e.getEdgeData(), o = this._edgeData, s = this.group;
      a.diff(o).add(function(l) {
        var u = new ntt(i, a, l, n);
        zt(u).dataIndex = l, s.add(u);
      }).update(function(l, u) {
        var c = o.getItemGraphicEl(u);
        c.updateData(i, a, l, n), s.add(c);
      }).remove(function(l) {
        var u = o.getItemGraphicEl(l);
        u && Pa(u, e, l);
      }).execute(), this._edgeData = a;
    }, t.prototype.dispose = function() {
    }, t.type = "chord", t;
  }(Re)
), ott = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function(e) {
      r.prototype.init.apply(this, arguments), this.fillDataTextStyle(e.edges || e.links), this.legendVisualProvider = new Nc(mt(this.getData, this), mt(this.getRawData, this));
    }, t.prototype.mergeOption = function(e) {
      r.prototype.mergeOption.apply(this, arguments), this.fillDataTextStyle(e.edges || e.links);
    }, t.prototype.getInitialData = function(e, n) {
      var i = e.edges || e.links || [], a = e.data || e.nodes || [];
      if (a && i) {
        var o = qb(a, i, this, !0, s);
        return o.data;
      }
      function s(l, u) {
        var c = ue.prototype.getModel;
        function f(d, p) {
          var g = c.call(this, d, p);
          return g.resolveParentPath = h, g;
        }
        u.wrapMethod("getItemModel", function(d) {
          return d.resolveParentPath = h, d.getModel = f, d;
        });
        function h(d) {
          if (d && (d[0] === "label" || d[1] === "label")) {
            var p = d.slice();
            return d[0] === "label" ? p[0] = "edgeLabel" : d[1] === "label" && (p[1] = "edgeLabel"), p;
          }
          return d;
        }
      }
    }, t.prototype.getGraph = function() {
      return this.getData().graph;
    }, t.prototype.getEdgeData = function() {
      return this.getGraph().edgeData;
    }, t.prototype.formatTooltip = function(e, n, i) {
      var a = this.getDataParams(e, i);
      if (i === "edge") {
        var o = this.getData(), s = o.graph.getEdgeByIndex(e), l = o.getName(s.node1.dataIndex), u = o.getName(s.node2.dataIndex), c = [];
        return l != null && c.push(l), u != null && c.push(u), cr("nameValue", {
          name: c.join(" > "),
          value: a.value,
          noValue: a.value == null
        });
      }
      return cr("nameValue", {
        name: a.name,
        value: a.value,
        noValue: a.value == null
      });
    }, t.prototype.getDataParams = function(e, n) {
      var i = r.prototype.getDataParams.call(this, e, n);
      if (n === "node") {
        var a = this.getData(), o = this.getGraph().getNodeByIndex(e);
        if (i.name == null && (i.name = a.getName(e)), i.value == null) {
          var s = o.getLayout().value;
          i.value = s;
        }
      }
      return i;
    }, t.type = "series.chord", t.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "none",
      legendHoverLink: !0,
      colorBy: "data",
      left: 0,
      top: 0,
      right: 0,
      bottom: 0,
      width: null,
      height: null,
      center: ["50%", "50%"],
      radius: ["70%", "80%"],
      clockwise: !0,
      startAngle: 90,
      endAngle: "auto",
      minAngle: 0,
      padAngle: 3,
      itemStyle: {
        borderRadius: [0, 0, 5, 5]
      },
      lineStyle: {
        width: 0,
        color: "source",
        opacity: 0.2
      },
      label: {
        show: !0,
        position: "outside",
        distance: 5
      },
      emphasis: {
        focus: "adjacency",
        lineStyle: {
          opacity: 0.5
        }
      }
    }, t;
  }(ke)
), Q0 = Math.PI / 180;
function stt(r, t) {
  r.eachSeriesByType("chord", function(e) {
    ltt(e, t);
  });
}
function ltt(r, t) {
  var e = r.getData(), n = e.graph, i = r.getEdgeData(), a = i.count();
  if (a) {
    var o = WN(r, t), s = o.cx, l = o.cy, u = o.r, c = o.r0, f = Math.max((r.get("padAngle") || 0) * Q0, 0), h = Math.max((r.get("minAngle") || 0) * Q0, 0), d = -r.get("startAngle") * Q0, p = d + Math.PI * 2, g = r.get("clockwise"), v = g ? 1 : -1, m = [d, p];
    Jg(m, !g);
    var y = m[0], _ = m[1], x = _ - y, b = e.getSum("value") === 0 && i.getSum("value") === 0, S = [], w = 0;
    n.eachEdge(function(N) {
      var B = b ? 1 : N.getValue("value");
      b && (B > 0 || h) && (w += 2);
      var F = N.node1.dataIndex, G = N.node2.dataIndex;
      S[F] = (S[F] || 0) + B, S[G] = (S[G] || 0) + B;
    });
    var A = 0;
    if (n.eachNode(function(N) {
      var B = N.getValue("value");
      isNaN(B) || (S[N.dataIndex] = Math.max(B, S[N.dataIndex] || 0)), !b && (S[N.dataIndex] > 0 || h) && w++, A += S[N.dataIndex] || 0;
    }), !(w === 0 || A === 0)) {
      f * w >= Math.abs(x) && (f = Math.max(0, (Math.abs(x) - h * w) / w)), (f + h) * w >= Math.abs(x) && (h = (Math.abs(x) - f * w) / w);
      var T = (x - f * w * v) / A, M = 0, E = 0, R = 0;
      n.eachNode(function(N) {
        var B = S[N.dataIndex] || 0, F = T * (A ? B : 1) * v;
        Math.abs(F) < h ? M += h - Math.abs(F) : (E += Math.abs(F) - h, R += Math.abs(F)), N.setLayout({
          angle: F,
          value: B
        });
      });
      var C = !1;
      if (M > E) {
        var D = M / E;
        n.eachNode(function(N) {
          var B = N.getLayout().angle;
          Math.abs(B) >= h ? N.setLayout({
            angle: B * D,
            ratio: D
          }, !0) : N.setLayout({
            angle: h,
            ratio: h === 0 ? 1 : B / h
          }, !0);
        });
      } else
        n.eachNode(function(N) {
          if (!C) {
            var B = N.getLayout().angle, F = Math.min(B / R, 1), G = F * M;
            B - G < h && (C = !0);
          }
        });
      var I = M;
      n.eachNode(function(N) {
        if (!(I <= 0)) {
          var B = N.getLayout().angle;
          if (B > h && h > 0) {
            var F = C ? 1 : Math.min(B / R, 1), G = B - h, X = Math.min(G, Math.min(I, M * F));
            I -= X, N.setLayout({
              angle: B - X,
              ratio: (B - X) / B
            }, !0);
          } else
            h > 0 && N.setLayout({
              angle: h,
              ratio: B === 0 ? 1 : h / B
            }, !0);
        }
      });
      var P = y, O = [];
      n.eachNode(function(N) {
        var B = Math.max(N.getLayout().angle, h);
        N.setLayout({
          cx: s,
          cy: l,
          r0: c,
          r: u,
          startAngle: P,
          endAngle: P + B * v,
          clockwise: g
        }, !0), O[N.dataIndex] = P, P += (B + f) * v;
      }), n.eachEdge(function(N) {
        var B = b ? 1 : N.getValue("value"), F = T * (A ? B : 1) * v, G = N.node1.dataIndex, X = O[G] || 0, K = Math.abs((N.node1.getLayout().ratio || 1) * F), U = X + K * v, $ = [s + c * Math.cos(X), l + c * Math.sin(X)], ct = [s + c * Math.cos(U), l + c * Math.sin(U)], at = N.node2.dataIndex, lt = O[at] || 0, ot = Math.abs((N.node2.getLayout().ratio || 1) * F), H = lt + ot * v, st = [s + c * Math.cos(lt), l + c * Math.sin(lt)], ut = [s + c * Math.cos(H), l + c * Math.sin(H)];
        N.setLayout({
          s1: $,
          s2: ct,
          sStartAngle: X,
          sEndAngle: U,
          t1: st,
          t2: ut,
          tStartAngle: lt,
          tEndAngle: H,
          cx: s,
          cy: l,
          r: c,
          value: B,
          clockwise: g
        }), O[G] = U, O[at] = H;
      });
    }
  }
}
function utt(r) {
  r.registerChartView(att), r.registerSeriesModel(ott), r.registerLayout(r.PRIORITY.VISUAL.POST_CHART_LAYOUT, stt), r.registerProcessor(Ic("chord"));
}
var ctt = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
      this.angle = 0, this.width = 10, this.r = 10, this.x = 0, this.y = 0;
    }
    return r;
  }()
), ftt = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e) {
      var n = r.call(this, e) || this;
      return n.type = "pointer", n;
    }
    return t.prototype.getDefaultShape = function() {
      return new ctt();
    }, t.prototype.buildPath = function(e, n) {
      var i = Math.cos, a = Math.sin, o = n.r, s = n.width, l = n.angle, u = n.x - i(l) * s * (s >= o / 3 ? 1 : 2), c = n.y - a(l) * s * (s >= o / 3 ? 1 : 2);
      l = n.angle - Math.PI / 2, e.moveTo(u, c), e.lineTo(n.x + i(l) * s, n.y + a(l) * s), e.lineTo(n.x + i(n.angle) * o, n.y + a(n.angle) * o), e.lineTo(n.x - i(l) * s, n.y - a(l) * s), e.lineTo(u, c);
    }, t;
  }(ne)
);
function htt(r, t) {
  var e = r.get("center"), n = t.getWidth(), i = t.getHeight(), a = Math.min(n, i), o = dt(e[0], t.getWidth()), s = dt(e[1], t.getHeight()), l = dt(r.get("radius"), a / 2);
  return {
    cx: o,
    cy: s,
    r: l
  };
}
function _p(r, t) {
  var e = r == null ? "" : r + "";
  return t && (pt(t) ? e = t.replace("{value}", e) : Tt(t) && (e = t(r))), e;
}
var dtt = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n, i) {
      this.group.removeAll();
      var a = e.get(["axisLine", "lineStyle", "color"]), o = htt(e, i);
      this._renderMain(e, n, i, a, o), this._data = e.getData();
    }, t.prototype.dispose = function() {
    }, t.prototype._renderMain = function(e, n, i, a, o) {
      var s = this.group, l = e.get("clockwise"), u = -e.get("startAngle") / 180 * Math.PI, c = -e.get("endAngle") / 180 * Math.PI, f = e.getModel("axisLine"), h = f.get("roundCap"), d = h ? ig : Kr, p = f.get("show"), g = f.getModel("lineStyle"), v = g.get("width"), m = [u, c];
      Jg(m, !l), u = m[0], c = m[1];
      for (var y = c - u, _ = u, x = [], b = 0; p && b < a.length; b++) {
        var S = Math.min(Math.max(a[b][0], 0), 1);
        c = u + y * S;
        var w = new d({
          shape: {
            startAngle: _,
            endAngle: c,
            cx: o.cx,
            cy: o.cy,
            clockwise: l,
            r0: o.r - v,
            r: o.r
          },
          silent: !0
        });
        w.setStyle({
          fill: a[b][1]
        }), w.setStyle(g.getLineStyle(
          // Because we use sector to simulate arc
          // so the properties for stroking are useless
          ["color", "width"]
        )), x.push(w), _ = c;
      }
      x.reverse(), L(x, function(T) {
        return s.add(T);
      });
      var A = function(T) {
        if (T <= 0)
          return a[0][1];
        var M;
        for (M = 0; M < a.length; M++)
          if (a[M][0] >= T && (M === 0 ? 0 : a[M - 1][0]) < T)
            return a[M][1];
        return a[M - 1][1];
      };
      this._renderTicks(e, n, i, A, o, u, c, l, v), this._renderTitleAndDetail(e, n, i, A, o), this._renderAnchor(e, o), this._renderPointer(e, n, i, A, o, u, c, l, v);
    }, t.prototype._renderTicks = function(e, n, i, a, o, s, l, u, c) {
      for (var f = this.group, h = o.cx, d = o.cy, p = o.r, g = +e.get("min"), v = +e.get("max"), m = e.getModel("splitLine"), y = e.getModel("axisTick"), _ = e.getModel("axisLabel"), x = e.get("splitNumber"), b = y.get("splitNumber"), S = dt(m.get("length"), p), w = dt(y.get("length"), p), A = s, T = (l - s) / x, M = T / b, E = m.getModel("lineStyle").getLineStyle(), R = y.getModel("lineStyle").getLineStyle(), C = m.get("distance"), D, I, P = 0; P <= x; P++) {
        if (D = Math.cos(A), I = Math.sin(A), m.get("show")) {
          var O = C ? C + c : c, N = new sr({
            shape: {
              x1: D * (p - O) + h,
              y1: I * (p - O) + d,
              x2: D * (p - S - O) + h,
              y2: I * (p - S - O) + d
            },
            style: E,
            silent: !0
          });
          E.stroke === "auto" && N.setStyle({
            stroke: a(P / x)
          }), f.add(N);
        }
        if (_.get("show")) {
          var O = _.get("distance") + C, B = _p(or(P / x * (v - g) + g), _.get("formatter")), F = a(P / x), G = D * (p - S - O) + h, X = I * (p - S - O) + d, K = _.get("rotate"), U = 0;
          K === "radial" ? (U = -A + 2 * Math.PI, U > Math.PI / 2 && (U += Math.PI)) : K === "tangential" ? U = -A - Math.PI / 2 : fe(K) && (U = K * Math.PI / 180), U === 0 ? f.add(new pe({
            style: Oe(_, {
              text: B,
              x: G,
              y: X,
              verticalAlign: I < -0.8 ? "top" : I > 0.8 ? "bottom" : "middle",
              align: D < -0.4 ? "left" : D > 0.4 ? "right" : "center"
            }, {
              inheritColor: F
            }),
            silent: !0
          })) : f.add(new pe({
            style: Oe(_, {
              text: B,
              x: G,
              y: X,
              verticalAlign: "middle",
              align: "center"
            }, {
              inheritColor: F
            }),
            silent: !0,
            originX: G,
            originY: X,
            rotation: U
          }));
        }
        if (y.get("show") && P !== x) {
          var O = y.get("distance");
          O = O ? O + c : c;
          for (var $ = 0; $ <= b; $++) {
            D = Math.cos(A), I = Math.sin(A);
            var ct = new sr({
              shape: {
                x1: D * (p - O) + h,
                y1: I * (p - O) + d,
                x2: D * (p - w - O) + h,
                y2: I * (p - w - O) + d
              },
              silent: !0,
              style: R
            });
            R.stroke === "auto" && ct.setStyle({
              stroke: a((P + $ / b) / x)
            }), f.add(ct), A += M;
          }
          A -= M;
        } else
          A += T;
      }
    }, t.prototype._renderPointer = function(e, n, i, a, o, s, l, u, c) {
      var f = this.group, h = this._data, d = this._progressEls, p = [], g = e.get(["pointer", "show"]), v = e.getModel("progress"), m = v.get("show"), y = e.getData(), _ = y.mapDimension("value"), x = +e.get("min"), b = +e.get("max"), S = [x, b], w = [s, l];
      function A(M, E) {
        var R = y.getItemModel(M), C = R.getModel("pointer"), D = dt(C.get("width"), o.r), I = dt(C.get("length"), o.r), P = e.get(["pointer", "icon"]), O = C.get("offsetCenter"), N = dt(O[0], o.r), B = dt(O[1], o.r), F = C.get("keepAspect"), G;
        return P ? G = fr(P, N - D / 2, B - I, D, I, null, F) : G = new ftt({
          shape: {
            angle: -Math.PI / 2,
            width: D,
            r: I,
            x: N,
            y: B
          }
        }), G.rotation = -(E + Math.PI / 2), G.x = o.cx, G.y = o.cy, G;
      }
      function T(M, E) {
        var R = v.get("roundCap"), C = R ? ig : Kr, D = v.get("overlap"), I = D ? v.get("width") : c / y.count(), P = D ? o.r - I : o.r - (M + 1) * I, O = D ? o.r : o.r - M * I, N = new C({
          shape: {
            startAngle: s,
            endAngle: E,
            cx: o.cx,
            cy: o.cy,
            clockwise: u,
            r0: P,
            r: O
          }
        });
        return D && (N.z2 = Me(y.get(_, M), [x, b], [100, 0], !0)), N;
      }
      (m || g) && (y.diff(h).add(function(M) {
        var E = y.get(_, M);
        if (g) {
          var R = A(M, s);
          ze(R, {
            rotation: -((isNaN(+E) ? w[0] : Me(E, S, w, !0)) + Math.PI / 2)
          }, e), f.add(R), y.setItemGraphicEl(M, R);
        }
        if (m) {
          var C = T(M, s), D = v.get("clip");
          ze(C, {
            shape: {
              endAngle: Me(E, S, w, D)
            }
          }, e), f.add(C), Ax(e.seriesIndex, y.dataType, M, C), p[M] = C;
        }
      }).update(function(M, E) {
        var R = y.get(_, M);
        if (g) {
          var C = h.getItemGraphicEl(E), D = C ? C.rotation : s, I = A(M, D);
          I.rotation = D, ve(I, {
            rotation: -((isNaN(+R) ? w[0] : Me(R, S, w, !0)) + Math.PI / 2)
          }, e), f.add(I), y.setItemGraphicEl(M, I);
        }
        if (m) {
          var P = d[E], O = P ? P.shape.endAngle : s, N = T(M, O), B = v.get("clip");
          ve(N, {
            shape: {
              endAngle: Me(R, S, w, B)
            }
          }, e), f.add(N), Ax(e.seriesIndex, y.dataType, M, N), p[M] = N;
        }
      }).execute(), y.each(function(M) {
        var E = y.getItemModel(M), R = E.getModel("emphasis"), C = R.get("focus"), D = R.get("blurScope"), I = R.get("disabled");
        if (g) {
          var P = y.getItemGraphicEl(M), O = y.getItemVisual(M, "style"), N = O.fill;
          if (P instanceof Vr) {
            var B = P.style;
            P.useStyle(J({
              image: B.image,
              x: B.x,
              y: B.y,
              width: B.width,
              height: B.height
            }, O));
          } else
            P.useStyle(O), P.type !== "pointer" && P.setColor(N);
          P.setStyle(E.getModel(["pointer", "itemStyle"]).getItemStyle()), P.style.fill === "auto" && P.setStyle("fill", a(Me(y.get(_, M), S, [0, 1], !0))), P.z2EmphasisLift = 0, yr(P, E), Ge(P, C, D, I);
        }
        if (m) {
          var F = p[M];
          F.useStyle(y.getItemVisual(M, "style")), F.setStyle(E.getModel(["progress", "itemStyle"]).getItemStyle()), F.z2EmphasisLift = 0, yr(F, E), Ge(F, C, D, I);
        }
      }), this._progressEls = p);
    }, t.prototype._renderAnchor = function(e, n) {
      var i = e.getModel("anchor"), a = i.get("show");
      if (a) {
        var o = i.get("size"), s = i.get("icon"), l = i.get("offsetCenter"), u = i.get("keepAspect"), c = fr(s, n.cx - o / 2 + dt(l[0], n.r), n.cy - o / 2 + dt(l[1], n.r), o, o, null, u);
        c.z2 = i.get("showAbove") ? 1 : 0, c.setStyle(i.getModel("itemStyle").getItemStyle()), this.group.add(c);
      }
    }, t.prototype._renderTitleAndDetail = function(e, n, i, a, o) {
      var s = this, l = e.getData(), u = l.mapDimension("value"), c = +e.get("min"), f = +e.get("max"), h = new Et(), d = [], p = [], g = e.isAnimationEnabled(), v = e.get(["pointer", "showAbove"]);
      l.diff(this._data).add(function(m) {
        d[m] = new pe({
          silent: !0
        }), p[m] = new pe({
          silent: !0
        });
      }).update(function(m, y) {
        d[m] = s._titleEls[y], p[m] = s._detailEls[y];
      }).execute(), l.each(function(m) {
        var y = l.getItemModel(m), _ = l.get(u, m), x = new Et(), b = a(Me(_, [c, f], [0, 1], !0)), S = y.getModel("title");
        if (S.get("show")) {
          var w = S.get("offsetCenter"), A = o.cx + dt(w[0], o.r), T = o.cy + dt(w[1], o.r), M = d[m];
          M.attr({
            z2: v ? 0 : 2,
            style: Oe(S, {
              x: A,
              y: T,
              text: l.getName(m),
              align: "center",
              verticalAlign: "middle"
            }, {
              inheritColor: b
            })
          }), x.add(M);
        }
        var E = y.getModel("detail");
        if (E.get("show")) {
          var R = E.get("offsetCenter"), C = o.cx + dt(R[0], o.r), D = o.cy + dt(R[1], o.r), I = dt(E.get("width"), o.r), P = dt(E.get("height"), o.r), O = e.get(["progress", "show"]) ? l.getItemVisual(m, "style").fill : b, M = p[m], N = E.get("formatter");
          M.attr({
            z2: v ? 0 : 2,
            style: Oe(E, {
              x: C,
              y: D,
              text: _p(_, N),
              width: isNaN(I) ? null : I,
              height: isNaN(P) ? null : P,
              align: "center",
              verticalAlign: "middle"
            }, {
              inheritColor: O
            })
          }), MN(M, {
            normal: E
          }, _, function(F) {
            return _p(F, N);
          }), g && TN(M, m, l, e, {
            getFormattedLabel: function(F, G, X, K, U, $) {
              return _p($ ? $.interpolatedValue : _, N);
            }
          }), x.add(M);
        }
        h.add(x);
      }), this.group.add(h), this._titleEls = d, this._detailEls = p;
    }, t.type = "gauge", t;
  }(Re)
), ptt = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.visualStyleAccessPath = "itemStyle", e;
    }
    return t.prototype.getInitialData = function(e, n) {
      return Pc(this, ["value"]);
    }, t.type = "series.gauge", t.defaultOption = {
      // zlevel: 0,
      z: 2,
      colorBy: "data",
      // 
      center: ["50%", "50%"],
      legendHoverLink: !0,
      radius: "75%",
      startAngle: 225,
      endAngle: -45,
      clockwise: !0,
      // 
      min: 0,
      // 
      max: 100,
      // 10
      splitNumber: 10,
      // 
      axisLine: {
        // show
        show: !0,
        roundCap: !1,
        lineStyle: {
          color: [[1, Y.color.neutral10]],
          width: 10
        }
      },
      // 
      progress: {
        // show
        show: !1,
        overlap: !0,
        width: 10,
        roundCap: !1,
        clip: !0
      },
      // 
      splitLine: {
        // show
        show: !0,
        // length
        length: 10,
        distance: 10,
        // lineStylelineStyle
        lineStyle: {
          color: Y.color.axisTick,
          width: 3,
          type: "solid"
        }
      },
      // 
      axisTick: {
        // show
        show: !0,
        // split
        splitNumber: 5,
        // length
        length: 6,
        distance: 10,
        // lineStyle
        lineStyle: {
          color: Y.color.axisTickMinor,
          width: 1,
          type: "solid"
        }
      },
      axisLabel: {
        show: !0,
        distance: 15,
        // formatter: null,
        color: Y.color.axisLabel,
        fontSize: 12,
        rotate: 0
      },
      pointer: {
        icon: null,
        offsetCenter: [0, 0],
        show: !0,
        showAbove: !0,
        length: "60%",
        width: 6,
        keepAspect: !1
      },
      anchor: {
        show: !1,
        showAbove: !1,
        size: 6,
        icon: "circle",
        offsetCenter: [0, 0],
        keepAspect: !1,
        itemStyle: {
          color: Y.color.neutral00,
          borderWidth: 0,
          borderColor: Y.color.theme[0]
        }
      },
      title: {
        show: !0,
        // x, ypx
        offsetCenter: [0, "20%"],
        // TEXTSTYLE
        color: Y.color.secondary,
        fontSize: 16,
        valueAnimation: !1
      },
      detail: {
        show: !0,
        backgroundColor: Y.color.transparent,
        borderWidth: 0,
        borderColor: Y.color.neutral40,
        width: 100,
        height: null,
        padding: [5, 10],
        // x, ypx
        offsetCenter: [0, "40%"],
        // formatter: null,
        // TEXTSTYLE
        color: Y.color.primary,
        fontSize: 30,
        fontWeight: "bold",
        lineHeight: 30,
        valueAnimation: !1
      }
    }, t;
  }(ke)
);
function vtt(r) {
  r.registerChartView(dtt), r.registerSeriesModel(ptt);
}
var gtt = ["itemStyle", "opacity"], mtt = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e, n) {
      var i = r.call(this) || this, a = i, o = new Ur(), s = new pe();
      return a.setTextContent(s), i.setTextGuideLine(o), i.updateData(e, n, !0), i;
    }
    return t.prototype.updateData = function(e, n, i) {
      var a = this, o = e.hostModel, s = e.getItemModel(n), l = e.getItemLayout(n), u = s.getModel("emphasis"), c = s.get(gtt);
      c = c ?? 1, i || ai(a), a.useStyle(e.getItemVisual(n, "style")), a.style.lineJoin = "round", i ? (a.setShape({
        points: l.points
      }), a.style.opacity = 0, ze(a, {
        style: {
          opacity: c
        }
      }, o, n)) : ve(a, {
        style: {
          opacity: c
        },
        shape: {
          points: l.points
        }
      }, o, n), yr(a, s), this._updateLabel(e, n), Ge(this, u.get("focus"), u.get("blurScope"), u.get("disabled"));
    }, t.prototype._updateLabel = function(e, n) {
      var i = this, a = this.getTextGuideLine(), o = i.getTextContent(), s = e.hostModel, l = e.getItemModel(n), u = e.getItemLayout(n), c = u.label, f = e.getItemVisual(n, "style"), h = f.fill;
      Er(
        // position will not be used in setLabelStyle
        o,
        _r(l),
        {
          labelFetcher: e.hostModel,
          labelDataIndex: n,
          defaultOpacity: f.opacity,
          defaultText: e.getName(n)
        },
        {
          normal: {
            align: c.textAlign,
            verticalAlign: c.verticalAlign
          }
        }
      );
      var d = l.getModel("label"), p = d.get("color"), g = p === "inherit" ? h : null;
      i.setTextConfig({
        local: !0,
        inside: !!c.inside,
        insideStroke: g,
        outsideFill: g
      });
      var v = c.linePoints;
      a.setShape({
        points: v
      }), i.textGuideLineConfig = {
        anchor: v ? new Nt(v[0][0], v[0][1]) : null
      }, ve(o, {
        style: {
          x: c.x,
          y: c.y
        }
      }, s, n), o.attr({
        rotation: c.rotation,
        originX: c.x,
        originY: c.y,
        z2: 10
      }), bb(i, wb(l), {
        // Default use item visual color
        stroke: h
      });
    }, t;
  }(jr)
), ytt = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.ignoreLabelLineUpdate = !0, e;
    }
    return t.prototype.render = function(e, n, i) {
      var a = e.getData(), o = this._data, s = this.group;
      a.diff(o).add(function(l) {
        var u = new mtt(a, l);
        a.setItemGraphicEl(l, u), s.add(u);
      }).update(function(l, u) {
        var c = o.getItemGraphicEl(u);
        c.updateData(a, l), s.add(c), a.setItemGraphicEl(l, c);
      }).remove(function(l) {
        var u = o.getItemGraphicEl(l);
        Pa(u, e, l);
      }).execute(), this._data = a;
    }, t.prototype.remove = function() {
      this.group.removeAll(), this._data = null;
    }, t.prototype.dispose = function() {
    }, t.type = "funnel", t;
  }(Re)
), _tt = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function(e) {
      r.prototype.init.apply(this, arguments), this.legendVisualProvider = new Nc(mt(this.getData, this), mt(this.getRawData, this)), this._defaultLabelLine(e);
    }, t.prototype.getInitialData = function(e, n) {
      return Pc(this, {
        coordDimensions: ["value"],
        encodeDefaulter: Yt(rb, this)
      });
    }, t.prototype._defaultLabelLine = function(e) {
      hl(e, "labelLine", ["show"]);
      var n = e.labelLine, i = e.emphasis.labelLine;
      n.show = n.show && e.label.show, i.show = i.show && e.emphasis.label.show;
    }, t.prototype.getDataParams = function(e) {
      var n = this.getData(), i = r.prototype.getDataParams.call(this, e), a = n.mapDimension("value"), o = n.getSum(a);
      return i.percent = o ? +(n.get(a, e) / o * 100).toFixed(2) : 0, i.$vars.push("percent"), i;
    }, t.type = "series.funnel", t.defaultOption = {
      coordinateSystemUsage: "box",
      // zlevel: 0,                  // 
      z: 2,
      legendHoverLink: !0,
      colorBy: "data",
      left: 80,
      top: 60,
      right: 80,
      bottom: 65,
      // width: {totalWidth} - left - right,
      // height: {totalHeight} - top - bottom,
      // 
      // min: 0,
      // max: 100,
      minSize: "0%",
      maxSize: "100%",
      sort: "descending",
      orient: "vertical",
      gap: 0,
      funnelAlign: "center",
      label: {
        show: !0,
        position: "outer"
        // formatter: Tooltip.formatter
      },
      labelLine: {
        show: !0,
        length: 20,
        lineStyle: {
          // color: ,
          width: 1
        }
      },
      itemStyle: {
        // color: ,
        borderColor: Y.color.neutral00,
        borderWidth: 1
      },
      emphasis: {
        label: {
          show: !0
        }
      },
      select: {
        itemStyle: {
          borderColor: Y.color.primary
        }
      }
    }, t;
  }(ke)
);
function xtt(r, t) {
  for (var e = r.mapDimension("value"), n = r.mapArray(e, function(l) {
    return l;
  }), i = [], a = t === "ascending", o = 0, s = r.count(); o < s; o++)
    i[o] = o;
  return Tt(t) ? i.sort(t) : t !== "none" && i.sort(function(l, u) {
    return a ? n[l] - n[u] : n[u] - n[l];
  }), i;
}
function Stt(r) {
  var t = r.hostModel, e = t.get("orient");
  r.each(function(n) {
    var i = r.getItemModel(n), a = i.getModel("label"), o = a.get("position"), s = i.getModel("labelLine"), l = r.getItemLayout(n), u = l.points, c = o === "inner" || o === "inside" || o === "center" || o === "insideLeft" || o === "insideRight", f, h, d, p;
    if (c)
      o === "insideLeft" ? (h = (u[0][0] + u[3][0]) / 2 + 5, d = (u[0][1] + u[3][1]) / 2, f = "left") : o === "insideRight" ? (h = (u[1][0] + u[2][0]) / 2 - 5, d = (u[1][1] + u[2][1]) / 2, f = "right") : (h = (u[0][0] + u[1][0] + u[2][0] + u[3][0]) / 4, d = (u[0][1] + u[1][1] + u[2][1] + u[3][1]) / 4, f = "center"), p = [[h, d], [h, d]];
    else {
      var g = void 0, v = void 0, m = void 0, y = void 0, _ = s.get("length");
      process.env.NODE_ENV !== "production" && (e === "vertical" && ["top", "bottom"].indexOf(o) > -1 && (o = "left", console.warn("Position error: Funnel chart on vertical orient dose not support top and bottom.")), e === "horizontal" && ["left", "right"].indexOf(o) > -1 && (o = "bottom", console.warn("Position error: Funnel chart on horizontal orient dose not support left and right."))), o === "left" ? (g = (u[3][0] + u[0][0]) / 2, v = (u[3][1] + u[0][1]) / 2, m = g - _, h = m - 5, f = "right") : o === "right" ? (g = (u[1][0] + u[2][0]) / 2, v = (u[1][1] + u[2][1]) / 2, m = g + _, h = m + 5, f = "left") : o === "top" ? (g = (u[3][0] + u[0][0]) / 2, v = (u[3][1] + u[0][1]) / 2, y = v - _, d = y - 5, f = "center") : o === "bottom" ? (g = (u[1][0] + u[2][0]) / 2, v = (u[1][1] + u[2][1]) / 2, y = v + _, d = y + 5, f = "center") : o === "rightTop" ? (g = e === "horizontal" ? u[3][0] : u[1][0], v = e === "horizontal" ? u[3][1] : u[1][1], e === "horizontal" ? (y = v - _, d = y - 5, f = "center") : (m = g + _, h = m + 5, f = "top")) : o === "rightBottom" ? (g = u[2][0], v = u[2][1], e === "horizontal" ? (y = v + _, d = y + 5, f = "center") : (m = g + _, h = m + 5, f = "bottom")) : o === "leftTop" ? (g = u[0][0], v = e === "horizontal" ? u[0][1] : u[1][1], e === "horizontal" ? (y = v - _, d = y - 5, f = "center") : (m = g - _, h = m - 5, f = "right")) : o === "leftBottom" ? (g = e === "horizontal" ? u[1][0] : u[3][0], v = e === "horizontal" ? u[1][1] : u[2][1], e === "horizontal" ? (y = v + _, d = y + 5, f = "center") : (m = g - _, h = m - 5, f = "right")) : (g = (u[1][0] + u[2][0]) / 2, v = (u[1][1] + u[2][1]) / 2, e === "horizontal" ? (y = v + _, d = y + 5, f = "center") : (m = g + _, h = m + 5, f = "left")), e === "horizontal" ? (m = g, h = m) : (y = v, d = y), p = [[g, v], [m, y]];
    }
    l.label = {
      linePoints: p,
      x: h,
      y: d,
      verticalAlign: "middle",
      textAlign: f,
      inside: c
    };
  });
}
function btt(r, t) {
  r.eachSeriesByType("funnel", function(e) {
    var n = e.getData(), i = n.mapDimension("value"), a = e.get("sort"), o = xr(e, t), s = He(e.getBoxLayoutParams(), o.refContainer), l = e.get("orient"), u = s.width, c = s.height, f = xtt(n, a), h = s.x, d = s.y, p = l === "horizontal" ? [dt(e.get("minSize"), c), dt(e.get("maxSize"), c)] : [dt(e.get("minSize"), u), dt(e.get("maxSize"), u)], g = n.getDataExtent(i), v = e.get("min"), m = e.get("max");
    v == null && (v = Math.min(g[0], 0)), m == null && (m = g[1]);
    var y = e.get("funnelAlign"), _ = e.get("gap"), x = l === "horizontal" ? u : c, b = (x - _ * (n.count() - 1)) / n.count(), S = function(I, P) {
      if (l === "horizontal") {
        var O = n.get(i, I) || 0, N = Me(O, [v, m], p, !0), B = void 0;
        switch (y) {
          case "top":
            B = d;
            break;
          case "center":
            B = d + (c - N) / 2;
            break;
          case "bottom":
            B = d + (c - N);
            break;
        }
        return [[P, B], [P, B + N]];
      }
      var F = n.get(i, I) || 0, G = Me(F, [v, m], p, !0), X;
      switch (y) {
        case "left":
          X = h;
          break;
        case "center":
          X = h + (u - G) / 2;
          break;
        case "right":
          X = h + u - G;
          break;
      }
      return [[X, P], [X + G, P]];
    };
    a === "ascending" && (b = -b, _ = -_, l === "horizontal" ? h += u : d += c, f = f.reverse());
    for (var w = 0; w < f.length; w++) {
      var A = f[w], T = f[w + 1], M = n.getItemModel(A);
      if (l === "horizontal") {
        var E = M.get(["itemStyle", "width"]);
        E == null ? E = b : (E = dt(E, u), a === "ascending" && (E = -E));
        var R = S(A, h), C = S(T, h + E);
        h += E + _, n.setItemLayout(A, {
          points: R.concat(C.slice().reverse())
        });
      } else {
        var D = M.get(["itemStyle", "height"]);
        D == null ? D = b : (D = dt(D, c), a === "ascending" && (D = -D));
        var R = S(A, d), C = S(T, d + D);
        d += D + _, n.setItemLayout(A, {
          points: R.concat(C.slice().reverse())
        });
      }
    }
    Stt(n);
  });
}
function wtt(r) {
  r.registerChartView(ytt), r.registerSeriesModel(_tt), r.registerLayout(btt), r.registerProcessor(Ic("funnel"));
}
var Mtt = 0.3, Ttt = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e._dataGroup = new Et(), e._initialized = !1, e;
    }
    return t.prototype.init = function() {
      this.group.add(this._dataGroup);
    }, t.prototype.render = function(e, n, i, a) {
      this._progressiveEls = null;
      var o = this._dataGroup, s = e.getData(), l = this._data, u = e.coordinateSystem, c = u.dimensions, f = lL(e);
      s.diff(l).add(h).update(d).remove(p).execute();
      function h(v) {
        var m = sL(s, o, v, c, u);
        t_(m, s, v, f);
      }
      function d(v, m) {
        var y = l.getItemGraphicEl(m), _ = mB(s, v, c, u);
        s.setItemGraphicEl(v, y), ve(y, {
          shape: {
            points: _
          }
        }, e, v), ai(y), t_(y, s, v, f);
      }
      function p(v) {
        var m = l.getItemGraphicEl(v);
        o.remove(m);
      }
      if (!this._initialized) {
        this._initialized = !0;
        var g = Att(u, e, function() {
          setTimeout(function() {
            o.removeClipPath();
          });
        });
        o.setClipPath(g);
      }
      this._data = s;
    }, t.prototype.incrementalPrepareRender = function(e, n, i) {
      this._initialized = !0, this._data = null, this._dataGroup.removeAll();
    }, t.prototype.incrementalRender = function(e, n, i) {
      for (var a = n.getData(), o = n.coordinateSystem, s = o.dimensions, l = lL(n), u = this._progressiveEls = [], c = e.start; c < e.end; c++) {
        var f = sL(a, this._dataGroup, c, s, o);
        f.incremental = !0, t_(f, a, c, l), u.push(f);
      }
    }, t.prototype.remove = function() {
      this._dataGroup && this._dataGroup.removeAll(), this._data = null;
    }, t.type = "parallel", t;
  }(Re)
);
function Att(r, t, e) {
  var n = r.model, i = r.getRect(), a = new te({
    shape: {
      x: i.x,
      y: i.y,
      width: i.width,
      height: i.height
    }
  }), o = n.get("layout") === "horizontal" ? "width" : "height";
  return a.setShape(o, 0), ze(a, {
    shape: {
      width: i.width,
      height: i.height
    }
  }, t, e), a;
}
function mB(r, t, e, n) {
  for (var i = [], a = 0; a < e.length; a++) {
    var o = e[a], s = r.get(r.mapDimension(o), t);
    Ett(s, n.getAxis(o).type) || i.push(n.dataToPoint(s, o));
  }
  return i;
}
function sL(r, t, e, n, i) {
  var a = mB(r, e, n, i), o = new Ur({
    shape: {
      points: a
    },
    // silent: true,
    z2: 10
  });
  return t.add(o), r.setItemGraphicEl(e, o), o;
}
function lL(r) {
  var t = r.get("smooth", !0);
  return t === !0 && (t = Mtt), t = Ga(t), Or(t) && (t = 0), {
    smooth: t
  };
}
function t_(r, t, e, n) {
  r.useStyle(t.getItemVisual(e, "style")), r.style.fill = null, r.setShape("smooth", n.smooth);
  var i = t.getItemModel(e), a = i.getModel("emphasis");
  yr(r, i, "lineStyle"), Ge(r, a.get("focus"), a.get("blurScope"), a.get("disabled"));
}
function Ett(r, t) {
  return t === "category" ? r == null : r == null || isNaN(r);
}
var Ctt = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.visualStyleAccessPath = "lineStyle", e.visualDrawType = "stroke", e;
    }
    return t.prototype.getInitialData = function(e, n) {
      return ja(null, this, {
        useEncodeDefaulter: mt(Dtt, null, this)
      });
    }, t.prototype.getRawIndicesByActiveState = function(e) {
      var n = this.coordinateSystem, i = this.getData(), a = [];
      return n.eachActiveState(i, function(o, s) {
        e === o && a.push(i.getRawIndex(s));
      }), a;
    }, t.type = "series.parallel", t.dependencies = ["parallel"], t.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "parallel",
      parallelIndex: 0,
      label: {
        show: !1
      },
      inactiveOpacity: 0.05,
      activeOpacity: 1,
      lineStyle: {
        width: 1,
        opacity: 0.45,
        type: "solid"
      },
      emphasis: {
        label: {
          show: !1
        }
      },
      progressive: 500,
      smooth: !1,
      animationEasing: "linear"
    }, t;
  }(ke)
);
function Dtt(r) {
  var t = r.ecModel.getComponent("parallel", r.get("parallelIndex"));
  if (t) {
    var e = {};
    return L(t.dimensions, function(n) {
      var i = Ltt(n);
      e[n] = i;
    }), e;
  }
}
function Ltt(r) {
  return +r.replace("dim", "");
}
var Rtt = ["lineStyle", "opacity"], Itt = {
  seriesType: "parallel",
  reset: function(r, t) {
    var e = r.coordinateSystem, n = {
      normal: r.get(["lineStyle", "opacity"]),
      active: r.get("activeOpacity"),
      inactive: r.get("inactiveOpacity")
    };
    return {
      progress: function(i, a) {
        e.eachActiveState(a, function(o, s) {
          var l = n[o];
          if (o === "normal" && a.hasItemOption) {
            var u = a.getItemModel(s).get(Rtt, !0);
            u != null && (l = u);
          }
          var c = a.ensureUniqueItemVisual(s, "style");
          c.opacity = l;
        }, i.start, i.end);
      }
    };
  }
};
function Ptt(r) {
  Ntt(r), Ott(r);
}
function Ntt(r) {
  if (!r.parallel) {
    var t = !1;
    L(r.series, function(e) {
      e && e.type === "parallel" && (t = !0);
    }), t && (r.parallel = [{}]);
  }
}
function Ott(r) {
  var t = Ie(r.parallelAxis);
  L(t, function(e) {
    if (Dt(e)) {
      var n = e.parallelIndex || 0, i = Ie(r.parallel)[n];
      i && i.parallelAxisDefault && qt(e, i.parallelAxisDefault, !1);
    }
  });
}
var ktt = 5, Btt = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n, i) {
      this._model = e, this._api = i, this._handlers || (this._handlers = {}, L(Vtt, function(a, o) {
        i.getZr().on(o, this._handlers[o] = mt(a, this));
      }, this)), Dc(this, "_throttledDispatchExpand", e.get("axisExpandRate"), "fixRate");
    }, t.prototype.dispose = function(e, n) {
      ch(this, "_throttledDispatchExpand"), L(this._handlers, function(i, a) {
        n.getZr().off(a, i);
      }), this._handlers = null;
    }, t.prototype._throttledDispatchExpand = function(e) {
      this._dispatchExpand(e);
    }, t.prototype._dispatchExpand = function(e) {
      e && this._api.dispatchAction(J({
        type: "parallelAxisExpand"
      }, e));
    }, t.type = "parallel", t;
  }(Ue)
), Vtt = {
  mousedown: function(r) {
    e_(this, "click") && (this._mouseDownPoint = [r.offsetX, r.offsetY]);
  },
  mouseup: function(r) {
    var t = this._mouseDownPoint;
    if (e_(this, "click") && t) {
      var e = [r.offsetX, r.offsetY], n = Math.pow(t[0] - e[0], 2) + Math.pow(t[1] - e[1], 2);
      if (n > ktt)
        return;
      var i = this._model.coordinateSystem.getSlidedAxisExpandWindow([r.offsetX, r.offsetY]);
      i.behavior !== "none" && this._dispatchExpand({
        axisExpandWindow: i.axisExpandWindow
      });
    }
    this._mouseDownPoint = null;
  },
  mousemove: function(r) {
    if (!(this._mouseDownPoint || !e_(this, "mousemove"))) {
      var t = this._model, e = t.coordinateSystem.getSlidedAxisExpandWindow([r.offsetX, r.offsetY]), n = e.behavior;
      n === "jump" && this._throttledDispatchExpand.debounceNextCall(t.get("axisExpandDebounce")), this._throttledDispatchExpand(n === "none" ? null : {
        axisExpandWindow: e.axisExpandWindow,
        // Jumping uses animation, and sliding suppresses animation.
        animation: n === "jump" ? null : {
          duration: 0
          // Disable animation.
        }
      });
    }
  }
};
function e_(r, t) {
  var e = r._model;
  return e.get("axisExpandable") && e.get("axisExpandTriggerOn") === t;
}
var Ftt = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function() {
      r.prototype.init.apply(this, arguments), this.mergeOption({});
    }, t.prototype.mergeOption = function(e) {
      var n = this.option;
      e && qt(n, e, !0), this._initDimensions();
    }, t.prototype.contains = function(e, n) {
      var i = e.get("parallelIndex");
      return i != null && n.getComponent("parallel", i) === this;
    }, t.prototype.setAxisExpand = function(e) {
      L(["axisExpandable", "axisExpandCenter", "axisExpandCount", "axisExpandWidth", "axisExpandWindow"], function(n) {
        e.hasOwnProperty(n) && (this.option[n] = e[n]);
      }, this);
    }, t.prototype._initDimensions = function() {
      var e = this.dimensions = [], n = this.parallelAxisIndex = [], i = Te(this.ecModel.queryComponents({
        mainType: "parallelAxis"
      }), function(a) {
        return (a.get("parallelIndex") || 0) === this.componentIndex;
      }, this);
      L(i, function(a) {
        e.push("dim" + a.get("dim")), n.push(a.componentIndex);
      });
    }, t.type = "parallel", t.dependencies = ["parallelAxis"], t.layoutMode = "box", t.defaultOption = {
      // zlevel: 0,
      z: 0,
      left: 80,
      top: 60,
      right: 80,
      bottom: 60,
      // width: {totalWidth} - left - right,
      // height: {totalHeight} - top - bottom,
      layout: "horizontal",
      // FIXME
      // naming?
      axisExpandable: !1,
      axisExpandCenter: null,
      axisExpandCount: 0,
      axisExpandWidth: 50,
      axisExpandRate: 17,
      axisExpandDebounce: 50,
      // [out, in, jumpTarget]. In percentage. If use [null, 0.05], null means full.
      // Do not doc to user until necessary.
      axisExpandSlideTriggerArea: [-0.15, 0.05, 0.4],
      axisExpandTriggerOn: "click",
      parallelAxisDefault: null
    }, t;
  }(re)
), ztt = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e, n, i, a, o) {
      var s = r.call(this, e, n, i) || this;
      return s.type = a || "value", s.axisIndex = o, s;
    }
    return t.prototype.isHorizontal = function() {
      return this.coordinateSystem.getModel().get("layout") !== "horizontal";
    }, t;
  }(Ai)
);
function Xo(r, t, e, n, i, a) {
  r = r || 0;
  var o = e[1] - e[0];
  if (i != null && (i = yu(i, [0, o])), a != null && (a = Math.max(a, i ?? 0)), n === "all") {
    var s = Math.abs(t[1] - t[0]);
    s = yu(s, [0, o]), i = a = yu(s, [i, a]), n = 0;
  }
  t[0] = yu(t[0], e), t[1] = yu(t[1], e);
  var l = r_(t, n);
  t[n] += r;
  var u = i || 0, c = e.slice();
  l.sign < 0 ? c[0] += u : c[1] -= u, t[n] = yu(t[n], c);
  var f;
  return f = r_(t, n), i != null && (f.sign !== l.sign || f.span < i) && (t[1 - n] = t[n] + l.sign * i), f = r_(t, n), a != null && f.span > a && (t[1 - n] = t[n] + f.sign * a), t;
}
function r_(r, t) {
  var e = r[t] - r[1 - t];
  return {
    span: Math.abs(e),
    sign: e > 0 ? -1 : e < 0 ? 1 : t ? -1 : 1
  };
}
function yu(r, t) {
  return Math.min(t[1] != null ? t[1] : 1 / 0, Math.max(t[0] != null ? t[0] : -1 / 0, r));
}
var n_ = L, yB = Math.min, _B = Math.max, uL = Math.floor, Utt = Math.ceil, cL = or, Gtt = Math.PI, Htt = (
  /** @class */
  function() {
    function r(t, e, n) {
      this.type = "parallel", this._axesMap = wt(), this._axesLayout = {}, this.dimensions = t.dimensions, this._model = t, this._init(t, e, n);
    }
    return r.prototype._init = function(t, e, n) {
      var i = t.dimensions, a = t.parallelAxisIndex;
      n_(i, function(o, s) {
        var l = a[s], u = e.getComponent("parallelAxis", l), c = this._axesMap.set(o, new ztt(o, pm(u), [0, 0], u.get("type"), l)), f = c.type === "category";
        c.onBand = f && u.get("boundaryGap"), c.inverse = u.get("inverse"), u.axis = c, c.model = u, c.coordinateSystem = u.coordinateSystem = this;
      }, this);
    }, r.prototype.update = function(t, e) {
      this._updateAxesFromSeries(this._model, t);
    }, r.prototype.containPoint = function(t) {
      var e = this._makeLayoutInfo(), n = e.axisBase, i = e.layoutBase, a = e.pixelDimIndex, o = t[1 - a], s = t[a];
      return o >= n && o <= n + e.axisLength && s >= i && s <= i + e.layoutLength;
    }, r.prototype.getModel = function() {
      return this._model;
    }, r.prototype._updateAxesFromSeries = function(t, e) {
      e.eachSeries(function(n) {
        if (t.contains(n, e)) {
          var i = n.getData();
          n_(this.dimensions, function(a) {
            var o = this._axesMap.get(a);
            o.scale.unionExtentFromData(i, i.mapDimension(a)), sc(o.scale, o.model);
          }, this);
        }
      }, this);
    }, r.prototype.resize = function(t, e) {
      var n = xr(t, e).refContainer;
      this._rect = He(t.getBoxLayoutParams(), n), this._layoutAxes();
    }, r.prototype.getRect = function() {
      return this._rect;
    }, r.prototype._makeLayoutInfo = function() {
      var t = this._model, e = this._rect, n = ["x", "y"], i = ["width", "height"], a = t.get("layout"), o = a === "horizontal" ? 0 : 1, s = e[i[o]], l = [0, s], u = this.dimensions.length, c = xp(t.get("axisExpandWidth"), l), f = xp(t.get("axisExpandCount") || 0, [0, u]), h = t.get("axisExpandable") && u > 3 && u > f && f > 1 && c > 0 && s > 0, d = t.get("axisExpandWindow"), p;
      if (d)
        p = xp(d[1] - d[0], l), d[1] = d[0] + p;
      else {
        p = xp(c * (f - 1), l);
        var g = t.get("axisExpandCenter") || uL(u / 2);
        d = [c * g - p / 2], d[1] = d[0] + p;
      }
      var v = (s - p) / (u - f);
      v < 3 && (v = 0);
      var m = [uL(cL(d[0] / c, 1)) + 1, Utt(cL(d[1] / c, 1)) - 1], y = v / c * d[0];
      return {
        layout: a,
        pixelDimIndex: o,
        layoutBase: e[n[o]],
        layoutLength: s,
        axisBase: e[n[1 - o]],
        axisLength: e[i[1 - o]],
        axisExpandable: h,
        axisExpandWidth: c,
        axisCollapseWidth: v,
        axisExpandWindow: d,
        axisCount: u,
        winInnerIndices: m,
        axisExpandWindow0Pos: y
      };
    }, r.prototype._layoutAxes = function() {
      var t = this._rect, e = this._axesMap, n = this.dimensions, i = this._makeLayoutInfo(), a = i.layout;
      e.each(function(o) {
        var s = [0, i.axisLength], l = o.inverse ? 1 : 0;
        o.setExtent(s[l], s[1 - l]);
      }), n_(n, function(o, s) {
        var l = (i.axisExpandable ? Xtt : Wtt)(s, i), u = {
          horizontal: {
            x: l.position,
            y: i.axisLength
          },
          vertical: {
            x: 0,
            y: l.position
          }
        }, c = {
          horizontal: Gtt / 2,
          vertical: 0
        }, f = [u[a].x + t.x, u[a].y + t.y], h = c[a], d = kr();
        qo(d, d, h), ra(d, d, f), this._axesLayout[o] = {
          position: f,
          rotation: h,
          transform: d,
          axisNameAvailableWidth: l.axisNameAvailableWidth,
          axisLabelShow: l.axisLabelShow,
          nameTruncateMaxWidth: l.nameTruncateMaxWidth,
          tickDirection: 1,
          labelDirection: 1
        };
      }, this);
    }, r.prototype.getAxis = function(t) {
      return this._axesMap.get(t);
    }, r.prototype.dataToPoint = function(t, e) {
      return this.axisCoordToPoint(this._axesMap.get(e).dataToCoord(t), e);
    }, r.prototype.eachActiveState = function(t, e, n, i) {
      n == null && (n = 0), i == null && (i = t.count());
      var a = this._axesMap, o = this.dimensions, s = [], l = [];
      L(o, function(v) {
        s.push(t.mapDimension(v)), l.push(a.get(v).model);
      });
      for (var u = this.hasAxisBrushed(), c = n; c < i; c++) {
        var f = void 0;
        if (!u)
          f = "normal";
        else {
          f = "active";
          for (var h = t.getValues(s, c), d = 0, p = o.length; d < p; d++) {
            var g = l[d].getActiveState(h[d]);
            if (g === "inactive") {
              f = "inactive";
              break;
            }
          }
        }
        e(f, c);
      }
    }, r.prototype.hasAxisBrushed = function() {
      for (var t = this.dimensions, e = this._axesMap, n = !1, i = 0, a = t.length; i < a; i++)
        e.get(t[i]).model.getActiveState() !== "normal" && (n = !0);
      return n;
    }, r.prototype.axisCoordToPoint = function(t, e) {
      var n = this._axesLayout[e];
      return yi([t, 0], n.transform);
    }, r.prototype.getAxisLayout = function(t) {
      return Ct(this._axesLayout[t]);
    }, r.prototype.getSlidedAxisExpandWindow = function(t) {
      var e = this._makeLayoutInfo(), n = e.pixelDimIndex, i = e.axisExpandWindow.slice(), a = i[1] - i[0], o = [0, e.axisExpandWidth * (e.axisCount - 1)];
      if (!this.containPoint(t))
        return {
          behavior: "none",
          axisExpandWindow: i
        };
      var s = t[n] - e.layoutBase - e.axisExpandWindow0Pos, l, u = "slide", c = e.axisCollapseWidth, f = this._model.get("axisExpandSlideTriggerArea"), h = f[0] != null;
      if (c)
        h && c && s < a * f[0] ? (u = "jump", l = s - a * f[2]) : h && c && s > a * (1 - f[0]) ? (u = "jump", l = s - a * (1 - f[2])) : (l = s - a * f[1]) >= 0 && (l = s - a * (1 - f[1])) <= 0 && (l = 0), l *= e.axisExpandWidth / c, l ? Xo(l, i, o, "all") : u = "none";
      else {
        var d = i[1] - i[0], p = o[1] * s / d;
        i = [_B(0, p - d / 2)], i[1] = yB(o[1], i[0] + d), i[0] = i[1] - d;
      }
      return {
        axisExpandWindow: i,
        behavior: u
      };
    }, r;
  }()
);
function xp(r, t) {
  return yB(_B(r, t[0]), t[1]);
}
function Wtt(r, t) {
  var e = t.layoutLength / (t.axisCount - 1);
  return {
    position: e * r,
    axisNameAvailableWidth: e,
    axisLabelShow: !0
  };
}
function Xtt(r, t) {
  var e = t.layoutLength, n = t.axisExpandWidth, i = t.axisCount, a = t.axisCollapseWidth, o = t.winInnerIndices, s, l = a, u = !1, c;
  return r < o[0] ? (s = r * a, c = a) : r <= o[1] ? (s = t.axisExpandWindow0Pos + r * n - t.axisExpandWindow[0], l = n, u = !0) : (s = e - (i - 1 - r) * a, c = a), {
    position: s,
    axisNameAvailableWidth: l,
    axisLabelShow: u,
    nameTruncateMaxWidth: c
  };
}
function Ytt(r, t) {
  var e = [];
  return r.eachComponent("parallel", function(n, i) {
    var a = new Htt(n, r, t);
    a.name = "parallel_" + i, a.resize(n, t), n.coordinateSystem = a, a.model = n, e.push(a);
  }), r.eachSeries(function(n) {
    if (n.get("coordinateSystem") === "parallel") {
      var i = n.getReferringComponents("parallel", Ke).models[0];
      n.coordinateSystem = i.coordinateSystem;
    }
  }), e;
}
var $tt = {
  create: Ytt
}, IS = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.activeIntervals = [], e;
    }
    return t.prototype.getAreaSelectStyle = function() {
      return pl([
        ["fill", "color"],
        ["lineWidth", "borderWidth"],
        ["stroke", "borderColor"],
        ["width", "width"],
        ["opacity", "opacity"]
        // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
        // So do not transfer decal directly.
      ])(this.getModel("areaSelectStyle"));
    }, t.prototype.setActiveIntervals = function(e) {
      var n = this.activeIntervals = Ct(e);
      if (n)
        for (var i = n.length - 1; i >= 0; i--)
          ei(n[i]);
    }, t.prototype.getActiveState = function(e) {
      var n = this.activeIntervals;
      if (!n.length)
        return "normal";
      if (e == null || isNaN(+e))
        return "inactive";
      if (n.length === 1) {
        var i = n[0];
        if (i[0] <= e && e <= i[1])
          return "active";
      } else
        for (var a = 0, o = n.length; a < o; a++)
          if (n[a][0] <= e && e <= n[a][1])
            return "active";
      return "inactive";
    }, t;
  }(re)
);
hr(IS, Hh);
var _l = !0, Mh = Math.min, hc = Math.max, Ztt = Math.pow, qtt = 1e4, Ktt = 6, jtt = 6, fL = "globalPan", Jtt = {
  w: [0, 0],
  e: [0, 1],
  n: [1, 0],
  s: [1, 1]
}, Qtt = {
  w: "ew",
  e: "ew",
  n: "ns",
  s: "ns",
  ne: "nesw",
  sw: "nesw",
  nw: "nwse",
  se: "nwse"
}, hL = {
  brushStyle: {
    lineWidth: 2,
    stroke: Y.color.backgroundTint,
    fill: Y.color.borderTint
  },
  transformable: !0,
  brushMode: "single",
  removeOnClick: !1
}, tet = 0, Kb = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e) {
      var n = r.call(this) || this;
      return n._track = [], n._covers = [], n._handlers = {}, process.env.NODE_ENV !== "production" && St(e), n._zr = e, n.group = new Et(), n._uid = "brushController_" + tet++, L(set, function(i, a) {
        this._handlers[a] = mt(i, this);
      }, n), n;
    }
    return t.prototype.enableBrush = function(e) {
      return process.env.NODE_ENV !== "production" && St(this._mounted), this._brushType && this._doDisableBrush(), e.brushType && this._doEnableBrush(e), this;
    }, t.prototype._doEnableBrush = function(e) {
      var n = this._zr;
      this._enableGlobalPan || Bj(n, fL, this._uid), L(this._handlers, function(i, a) {
        n.on(a, i);
      }), this._brushType = e.brushType, this._brushOption = qt(Ct(hL), e, !0);
    }, t.prototype._doDisableBrush = function() {
      var e = this._zr;
      Vj(e, fL, this._uid), L(this._handlers, function(n, i) {
        e.off(i, n);
      }), this._brushType = this._brushOption = null;
    }, t.prototype.setPanels = function(e) {
      if (e && e.length) {
        var n = this._panels = {};
        L(e, function(i) {
          n[i.panelId] = Ct(i);
        });
      } else
        this._panels = null;
      return this;
    }, t.prototype.mount = function(e) {
      e = e || {}, process.env.NODE_ENV !== "production" && (this._mounted = !0), this._enableGlobalPan = e.enableGlobalPan;
      var n = this.group;
      return this._zr.add(n), n.attr({
        x: e.x || 0,
        y: e.y || 0,
        rotation: e.rotation || 0,
        scaleX: e.scaleX || 1,
        scaleY: e.scaleY || 1
      }), this._transform = n.getLocalTransform(), this;
    }, t.prototype.updateCovers = function(e) {
      process.env.NODE_ENV !== "production" && St(this._mounted), e = rt(e, function(h) {
        return qt(Ct(hL), h, !0);
      });
      var n = "\0-brush-index-", i = this._covers, a = this._covers = [], o = this, s = this._creatingCover;
      return new Xa(i, e, u, l).add(c).update(c).remove(f).execute(), this;
      function l(h, d) {
        return (h.id != null ? h.id : n + d) + "-" + h.brushType;
      }
      function u(h, d) {
        return l(h.__brushOption, d);
      }
      function c(h, d) {
        var p = e[h];
        if (d != null && i[d] === s)
          a[h] = i[d];
        else {
          var g = a[h] = d != null ? (i[d].__brushOption = p, i[d]) : SB(o, xB(o, p));
          jb(o, g);
        }
      }
      function f(h) {
        i[h] !== s && o.group.remove(i[h]);
      }
    }, t.prototype.unmount = function() {
      if (!(process.env.NODE_ENV !== "production" && !this._mounted))
        return this.enableBrush(!1), PS(this), this._zr.remove(this.group), process.env.NODE_ENV !== "production" && (this._mounted = !1), this;
    }, t.prototype.dispose = function() {
      this.unmount(), this.off();
    }, t;
  }(oi)
);
function xB(r, t) {
  var e = wm[t.brushType].createCover(r, t);
  return e.__brushOption = t, wB(e, t), r.group.add(e), e;
}
function SB(r, t) {
  var e = Jb(t);
  return e.endCreating && (e.endCreating(r, t), wB(t, t.__brushOption)), t;
}
function bB(r, t) {
  var e = t.__brushOption;
  Jb(t).updateCoverShape(r, t, e.range, e);
}
function wB(r, t) {
  var e = t.z;
  e == null && (e = qtt), r.traverse(function(n) {
    n.z = e, n.z2 = e;
  });
}
function jb(r, t) {
  Jb(t).updateCommon(r, t), bB(r, t);
}
function Jb(r) {
  return wm[r.__brushOption.brushType];
}
function Qb(r, t, e) {
  var n = r._panels;
  if (!n)
    return _l;
  var i, a = r._transform;
  return L(n, function(o) {
    o.isTargetByCursor(t, e, a) && (i = o);
  }), i;
}
function MB(r, t) {
  var e = r._panels;
  if (!e)
    return _l;
  var n = t.__brushOption.panelId;
  return n != null ? e[n] : _l;
}
function PS(r) {
  var t = r._covers, e = t.length;
  return L(t, function(n) {
    r.group.remove(n);
  }, r), t.length = 0, !!e;
}
function xl(r, t) {
  var e = rt(r._covers, function(n) {
    var i = n.__brushOption, a = Ct(i.range);
    return {
      brushType: i.brushType,
      panelId: i.panelId,
      range: a
    };
  });
  r.trigger("brush", {
    areas: e,
    isEnd: !!t.isEnd,
    removeOnClick: !!t.removeOnClick
  });
}
function eet(r) {
  var t = r._track;
  if (!t.length)
    return !1;
  var e = t[t.length - 1], n = t[0], i = e[0] - n[0], a = e[1] - n[1], o = Ztt(i * i + a * a, 0.5);
  return o > Ktt;
}
function TB(r) {
  var t = r.length - 1;
  return t < 0 && (t = 0), [r[0], r[t]];
}
function AB(r, t, e, n) {
  var i = new Et();
  return i.add(new te({
    name: "main",
    style: tw(e),
    silent: !0,
    draggable: !0,
    cursor: "move",
    drift: Yt(dL, r, t, i, ["n", "s", "w", "e"]),
    ondragend: Yt(xl, t, {
      isEnd: !0
    })
  })), L(n, function(a) {
    i.add(new te({
      name: a.join(""),
      style: {
        opacity: 0
      },
      draggable: !0,
      silent: !0,
      invisible: !0,
      drift: Yt(dL, r, t, i, a),
      ondragend: Yt(xl, t, {
        isEnd: !0
      })
    }));
  }), i;
}
function EB(r, t, e, n) {
  var i = n.brushStyle.lineWidth || 0, a = hc(i, jtt), o = e[0][0], s = e[1][0], l = o - i / 2, u = s - i / 2, c = e[0][1], f = e[1][1], h = c - a + i / 2, d = f - a + i / 2, p = c - o, g = f - s, v = p + i, m = g + i;
  Sa(r, t, "main", o, s, p, g), n.transformable && (Sa(r, t, "w", l, u, a, m), Sa(r, t, "e", h, u, a, m), Sa(r, t, "n", l, u, v, a), Sa(r, t, "s", l, d, v, a), Sa(r, t, "nw", l, u, a, a), Sa(r, t, "ne", h, u, a, a), Sa(r, t, "sw", l, d, a, a), Sa(r, t, "se", h, d, a, a));
}
function NS(r, t) {
  var e = t.__brushOption, n = e.transformable, i = t.childAt(0);
  i.useStyle(tw(e)), i.attr({
    silent: !n,
    cursor: n ? "move" : "default"
  }), L([["w"], ["e"], ["n"], ["s"], ["s", "e"], ["s", "w"], ["n", "e"], ["n", "w"]], function(a) {
    var o = t.childOfName(a.join("")), s = a.length === 1 ? OS(r, a[0]) : net(r, a);
    o && o.attr({
      silent: !n,
      invisible: !n,
      cursor: n ? Qtt[s] + "-resize" : null
    });
  });
}
function Sa(r, t, e, n, i, a, o) {
  var s = t.childOfName(e);
  s && s.setShape(aet(ew(r, t, [[n, i], [n + a, i + o]])));
}
function tw(r) {
  return kt({
    strokeNoScale: !0
  }, r.brushStyle);
}
function CB(r, t, e, n) {
  var i = [Mh(r, e), Mh(t, n)], a = [hc(r, e), hc(t, n)];
  return [
    [i[0], a[0]],
    [i[1], a[1]]
    // y range
  ];
}
function ret(r) {
  return ol(r.group);
}
function OS(r, t) {
  var e = {
    w: "left",
    e: "right",
    n: "top",
    s: "bottom"
  }, n = {
    left: "w",
    right: "e",
    top: "n",
    bottom: "s"
  }, i = am(e[t], ret(r));
  return n[i];
}
function net(r, t) {
  var e = [OS(r, t[0]), OS(r, t[1])];
  return (e[0] === "e" || e[0] === "w") && e.reverse(), e.join("");
}
function dL(r, t, e, n, i, a) {
  var o = e.__brushOption, s = r.toRectRange(o.range), l = DB(t, i, a);
  L(n, function(u) {
    var c = Jtt[u];
    s[c[0]][c[1]] += l[c[0]];
  }), o.range = r.fromRectRange(CB(s[0][0], s[1][0], s[0][1], s[1][1])), jb(t, e), xl(t, {
    isEnd: !1
  });
}
function iet(r, t, e, n) {
  var i = t.__brushOption.range, a = DB(r, e, n);
  L(i, function(o) {
    o[0] += a[0], o[1] += a[1];
  }), jb(r, t), xl(r, {
    isEnd: !1
  });
}
function DB(r, t, e) {
  var n = r.group, i = n.transformCoordToLocal(t, e), a = n.transformCoordToLocal(0, 0);
  return [i[0] - a[0], i[1] - a[1]];
}
function ew(r, t, e) {
  var n = MB(r, t);
  return n && n !== _l ? n.clipPath(e, r._transform) : Ct(e);
}
function aet(r) {
  var t = Mh(r[0][0], r[1][0]), e = Mh(r[0][1], r[1][1]), n = hc(r[0][0], r[1][0]), i = hc(r[0][1], r[1][1]);
  return {
    x: t,
    y: e,
    width: n - t,
    height: i - e
  };
}
function oet(r, t, e) {
  if (
    // Check active
    !(!r._brushType || uet(r, t.offsetX, t.offsetY))
  ) {
    var n = r._zr, i = r._covers, a = Qb(r, t, e);
    if (!r._dragging)
      for (var o = 0; o < i.length; o++) {
        var s = i[o].__brushOption;
        if (a && (a === _l || s.panelId === a.panelId) && wm[s.brushType].contain(i[o], e[0], e[1]))
          return;
      }
    a && n.setCursorStyle("crosshair");
  }
}
function kS(r) {
  var t = r.event;
  t.preventDefault && t.preventDefault();
}
function BS(r, t, e) {
  return r.childOfName("main").contain(t, e);
}
function LB(r, t, e, n) {
  var i = r._creatingCover, a = r._creatingPanel, o = r._brushOption, s;
  if (r._track.push(e.slice()), eet(r) || i) {
    if (a && !i) {
      o.brushMode === "single" && PS(r);
      var l = Ct(o);
      l.brushType = pL(l.brushType, a), l.panelId = a === _l ? null : a.panelId, i = r._creatingCover = xB(r, l), r._covers.push(i);
    }
    if (i) {
      var u = wm[pL(r._brushType, a)], c = i.__brushOption;
      c.range = u.getCreatingRange(ew(r, i, r._track)), n && (SB(r, i), u.updateCommon(r, i)), bB(r, i), s = {
        isEnd: n
      };
    }
  } else
    n && o.brushMode === "single" && o.removeOnClick && Qb(r, t, e) && PS(r) && (s = {
      isEnd: n,
      removeOnClick: !0
    });
  return s;
}
function pL(r, t) {
  return r === "auto" ? (process.env.NODE_ENV !== "production" && St(t && t.defaultBrushType, 'MUST have defaultBrushType when brushType is "atuo"'), t.defaultBrushType) : r;
}
var set = {
  mousedown: function(r) {
    if (this._dragging)
      vL(this, r);
    else if (!r.target || !r.target.draggable) {
      kS(r);
      var t = this.group.transformCoordToLocal(r.offsetX, r.offsetY);
      this._creatingCover = null;
      var e = this._creatingPanel = Qb(this, r, t);
      e && (this._dragging = !0, this._track = [t.slice()]);
    }
  },
  mousemove: function(r) {
    var t = r.offsetX, e = r.offsetY, n = this.group.transformCoordToLocal(t, e);
    if (oet(this, r, n), this._dragging) {
      kS(r);
      var i = LB(this, r, n, !1);
      i && xl(this, i);
    }
  },
  mouseup: function(r) {
    vL(this, r);
  }
};
function vL(r, t) {
  if (r._dragging) {
    kS(t);
    var e = t.offsetX, n = t.offsetY, i = r.group.transformCoordToLocal(e, n), a = LB(r, t, i, !0);
    r._dragging = !1, r._track = [], r._creatingCover = null, a && xl(r, a);
  }
}
function uet(r, t, e) {
  var n = r._zr;
  return t < 0 || t > n.getWidth() || e < 0 || e > n.getHeight();
}
var wm = {
  lineX: gL(0),
  lineY: gL(1),
  rect: {
    createCover: function(r, t) {
      function e(n) {
        return n;
      }
      return AB({
        toRectRange: e,
        fromRectRange: e
      }, r, t, [["w"], ["e"], ["n"], ["s"], ["s", "e"], ["s", "w"], ["n", "e"], ["n", "w"]]);
    },
    getCreatingRange: function(r) {
      var t = TB(r);
      return CB(t[1][0], t[1][1], t[0][0], t[0][1]);
    },
    updateCoverShape: function(r, t, e, n) {
      EB(r, t, e, n);
    },
    updateCommon: NS,
    contain: BS
  },
  polygon: {
    createCover: function(r, t) {
      var e = new Et();
      return e.add(new Ur({
        name: "main",
        style: tw(t),
        silent: !0
      })), e;
    },
    getCreatingRange: function(r) {
      return r;
    },
    endCreating: function(r, t) {
      t.remove(t.childAt(0)), t.add(new jr({
        name: "main",
        draggable: !0,
        drift: Yt(iet, r, t),
        ondragend: Yt(xl, r, {
          isEnd: !0
        })
      }));
    },
    updateCoverShape: function(r, t, e, n) {
      t.childAt(0).setShape({
        points: ew(r, t, e)
      });
    },
    updateCommon: NS,
    contain: BS
  }
};
function gL(r) {
  return {
    createCover: function(t, e) {
      return AB({
        toRectRange: function(n) {
          var i = [n, [0, 100]];
          return r && i.reverse(), i;
        },
        fromRectRange: function(n) {
          return n[r];
        }
      }, t, e, [[["w"], ["e"]], [["n"], ["s"]]][r]);
    },
    getCreatingRange: function(t) {
      var e = TB(t), n = Mh(e[0][r], e[1][r]), i = hc(e[0][r], e[1][r]);
      return [n, i];
    },
    updateCoverShape: function(t, e, n, i) {
      var a, o = MB(t, e);
      if (o !== _l && o.getLinearBrushOtherExtent)
        a = o.getLinearBrushOtherExtent(r);
      else {
        var s = t._zr;
        a = [0, [s.getWidth(), s.getHeight()][1 - r]];
      }
      var l = [n, a];
      r && l.reverse(), EB(t, e, l, i);
    },
    updateCommon: NS,
    contain: BS
  };
}
function RB(r) {
  return r = rw(r), function(t) {
    return _N(t, r);
  };
}
function IB(r, t) {
  return r = rw(r), function(e) {
    var n = t ?? e, i = n ? r.width : r.height, a = n ? r.x : r.y;
    return [a, a + (i || 0)];
  };
}
function PB(r, t, e) {
  var n = rw(r);
  return function(i, a) {
    return n.contain(a[0], a[1]) && !V3(i, t, e);
  };
}
function rw(r) {
  return Bt.create(r);
}
var cet = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function(e, n) {
      r.prototype.init.apply(this, arguments), (this._brushController = new Kb(n.getZr())).on("brush", mt(this._onBrush, this));
    }, t.prototype.render = function(e, n, i, a) {
      if (!fet(e, n, a)) {
        this.axisModel = e, this.api = i, this.group.removeAll();
        var o = this._axisGroup;
        if (this._axisGroup = new Et(), this.group.add(this._axisGroup), !!e.get("show")) {
          var s = det(e, n), l = s.coordinateSystem, u = e.getAreaSelectStyle(), c = u.width, f = e.axis.dim, h = l.getAxisLayout(f), d = J({
            strokeContainThreshold: c
          }, h), p = new cn(e, i, d);
          p.build(), this._axisGroup.add(p.group), this._refreshBrushController(d, u, e, s, c, i), Bh(o, this._axisGroup, e);
        }
      }
    }, t.prototype._refreshBrushController = function(e, n, i, a, o, s) {
      var l = i.axis.getExtent(), u = l[1] - l[0], c = Math.min(30, Math.abs(u) * 0.1), f = Bt.create({
        x: l[0],
        y: -o / 2,
        width: u,
        height: o
      });
      f.x -= c, f.width += 2 * c, this._brushController.mount({
        enableGlobalPan: !0,
        rotation: e.rotation,
        x: e.position[0],
        y: e.position[1]
      }).setPanels([{
        panelId: "pl",
        clipPath: RB(f),
        isTargetByCursor: PB(f, s, a),
        getLinearBrushOtherExtent: IB(f, 0)
      }]).enableBrush({
        brushType: "lineX",
        brushStyle: n,
        removeOnClick: !0
      }).updateCovers(het(i));
    }, t.prototype._onBrush = function(e) {
      var n = e.areas, i = this.axisModel, a = i.axis, o = rt(n, function(s) {
        return [a.coordToData(s.range[0], !0), a.coordToData(s.range[1], !0)];
      });
      (!i.option.realtime === e.isEnd || e.removeOnClick) && this.api.dispatchAction({
        type: "axisAreaSelect",
        parallelAxisId: i.id,
        intervals: o
      });
    }, t.prototype.dispose = function() {
      this._brushController.dispose();
    }, t.type = "parallelAxis", t;
  }(Ue)
);
function fet(r, t, e) {
  return e && e.type === "axisAreaSelect" && t.findComponents({
    mainType: "parallelAxis",
    query: e
  })[0] === r;
}
function het(r) {
  var t = r.axis;
  return rt(r.activeIntervals, function(e) {
    return {
      brushType: "lineX",
      panelId: "pl",
      range: [t.dataToCoord(e[0], !0), t.dataToCoord(e[1], !0)]
    };
  });
}
function det(r, t) {
  return t.getComponent("parallel", r.get("parallelIndex"));
}
var pet = {
  type: "axisAreaSelect",
  event: "axisAreaSelected"
  // update: 'updateVisual'
};
function vet(r) {
  r.registerAction(pet, function(t, e) {
    e.eachComponent({
      mainType: "parallelAxis",
      query: t
    }, function(n) {
      n.axis.model.setActiveIntervals(t.intervals);
    });
  }), r.registerAction("parallelAxisExpand", function(t, e) {
    e.eachComponent({
      mainType: "parallel",
      query: t
    }, function(n) {
      n.setAxisExpand(t);
    });
  });
}
var get = {
  type: "value",
  areaSelectStyle: {
    width: 20,
    borderWidth: 1,
    borderColor: "rgba(160,197,232)",
    color: "rgba(160,197,232)",
    opacity: 0.3
  },
  realtime: !0,
  z: 10
};
function NB(r) {
  r.registerComponentView(Btt), r.registerComponentModel(Ftt), r.registerCoordinateSystem("parallel", $tt), r.registerPreprocessor(Ptt), r.registerComponentModel(IS), r.registerComponentView(cet), cc(r, "parallel", IS, get), vet(r);
}
function met(r) {
  jt(NB), r.registerChartView(Ttt), r.registerSeriesModel(Ctt), r.registerVisual(r.PRIORITY.VISUAL.BRUSH, Itt);
}
var yet = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.cpx2 = 0, this.cpy2 = 0, this.extent = 0;
    }
    return r;
  }()
), _et = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e) {
      return r.call(this, e) || this;
    }
    return t.prototype.getDefaultShape = function() {
      return new yet();
    }, t.prototype.buildPath = function(e, n) {
      var i = n.extent;
      e.moveTo(n.x1, n.y1), e.bezierCurveTo(n.cpx1, n.cpy1, n.cpx2, n.cpy2, n.x2, n.y2), n.orient === "vertical" ? (e.lineTo(n.x2 + i, n.y2), e.bezierCurveTo(n.cpx2 + i, n.cpy2, n.cpx1 + i, n.cpy1, n.x1 + i, n.y1)) : (e.lineTo(n.x2, n.y2 + i), e.bezierCurveTo(n.cpx2, n.cpy2 + i, n.cpx1, n.cpy1 + i, n.x1, n.y1 + i)), e.closePath();
    }, t.prototype.highlight = function() {
      Ha(this);
    }, t.prototype.downplay = function() {
      Wa(this);
    }, t;
  }(ne)
), xet = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e._mainGroup = new Et(), e._focusAdjacencyDisabled = !1, e;
    }
    return t.prototype.init = function(e, n) {
      this._controller = new Il(n.getZr()), this._controllerHost = {
        target: this.group
      }, this.group.add(this._mainGroup);
    }, t.prototype.render = function(e, n, i) {
      var a = this, o = e.getGraph(), s = this._mainGroup, l = e.layoutInfo, u = l.width, c = l.height, f = e.getData(), h = e.getData("edge"), d = e.get("orient");
      this._model = e, s.removeAll(), s.x = l.x, s.y = l.y, this._updateViewCoordSys(e, i), F3(e, i, s, this._controller, this._controllerHost, null), o.eachEdge(function(p) {
        var g = new _et(), v = zt(g);
        v.dataIndex = p.dataIndex, v.seriesIndex = e.seriesIndex, v.dataType = "edge";
        var m = p.getModel(), y = m.getModel("lineStyle"), _ = y.get("curveness"), x = p.node1.getLayout(), b = p.node1.getModel(), S = b.get("localX"), w = b.get("localY"), A = p.node2.getLayout(), T = p.node2.getModel(), M = T.get("localX"), E = T.get("localY"), R = p.getLayout(), C, D, I, P, O, N, B, F;
        g.shape.extent = Math.max(1, R.dy), g.shape.orient = d, d === "vertical" ? (C = (S != null ? S * u : x.x) + R.sy, D = (w != null ? w * c : x.y) + x.dy, I = (M != null ? M * u : A.x) + R.ty, P = E != null ? E * c : A.y, O = C, N = D * (1 - _) + P * _, B = I, F = D * _ + P * (1 - _)) : (C = (S != null ? S * u : x.x) + x.dx, D = (w != null ? w * c : x.y) + R.sy, I = M != null ? M * u : A.x, P = (E != null ? E * c : A.y) + R.ty, O = C * (1 - _) + I * _, N = D, B = C * _ + I * (1 - _), F = P), g.setShape({
          x1: C,
          y1: D,
          x2: I,
          y2: P,
          cpx1: O,
          cpy1: N,
          cpx2: B,
          cpy2: F
        }), g.useStyle(y.getItemStyle()), mL(g.style, d, p);
        var G = "" + m.get("value"), X = _r(m, "edgeLabel");
        Er(g, X, {
          labelFetcher: {
            getFormattedLabel: function($, ct, at, lt, ot, H) {
              return e.getFormattedLabel(
                $,
                ct,
                "edge",
                lt,
                // ensure edgeLabel formatter is provided
                // to prevent the inheritance from `label.formatter` of the series
                ln(ot, X.normal && X.normal.get("formatter"), G),
                H
              );
            }
          },
          labelDataIndex: p.dataIndex,
          defaultText: G
        }), g.setTextConfig({
          position: "inside"
        });
        var K = m.getModel("emphasis");
        yr(g, m, "lineStyle", function($) {
          var ct = $.getItemStyle();
          return mL(ct, d, p), ct;
        }), s.add(g), h.setItemGraphicEl(p.dataIndex, g);
        var U = K.get("focus");
        Ge(g, U === "adjacency" ? p.getAdjacentDataIndices() : U === "trajectory" ? p.getTrajectoryDataIndices() : U, K.get("blurScope"), K.get("disabled"));
      }), o.eachNode(function(p) {
        var g = p.getLayout(), v = p.getModel(), m = v.get("localX"), y = v.get("localY"), _ = v.getModel("emphasis"), x = v.get(["itemStyle", "borderRadius"]) || 0, b = new te({
          shape: {
            x: m != null ? m * u : g.x,
            y: y != null ? y * c : g.y,
            width: g.dx,
            height: g.dy,
            r: x
          },
          style: v.getModel("itemStyle").getItemStyle(),
          z2: 10
        });
        Er(b, _r(v), {
          labelFetcher: {
            getFormattedLabel: function(w, A) {
              return e.getFormattedLabel(w, A, "node");
            }
          },
          labelDataIndex: p.dataIndex,
          defaultText: p.id
        }), b.disableLabelAnimation = !0, b.setStyle("fill", p.getVisual("color")), b.setStyle("decal", p.getVisual("style").decal), yr(b, v), s.add(b), f.setItemGraphicEl(p.dataIndex, b), zt(b).dataType = "node";
        var S = _.get("focus");
        Ge(b, S === "adjacency" ? p.getAdjacentDataIndices() : S === "trajectory" ? p.getTrajectoryDataIndices() : S, _.get("blurScope"), _.get("disabled"));
      }), f.eachItemGraphicEl(function(p, g) {
        var v = f.getItemModel(g);
        v.get("draggable") && (p.drift = function(m, y) {
          a._focusAdjacencyDisabled = !0, this.shape.x += m, this.shape.y += y, this.dirty(), i.dispatchAction({
            type: "dragNode",
            seriesId: e.id,
            dataIndex: f.getRawIndex(g),
            localX: this.shape.x / u,
            localY: this.shape.y / c
          });
        }, p.ondragend = function() {
          a._focusAdjacencyDisabled = !1;
        }, p.draggable = !0, p.cursor = "move");
      }), !this._data && e.isAnimationEnabled() && s.setClipPath(bet(s.getBoundingRect(), e, function() {
        s.removeClipPath();
      })), this._data = e.getData();
    }, t.prototype.dispose = function() {
      this._controller && this._controller.dispose(), this._controllerHost = null;
    }, t.prototype._updateViewCoordSys = function(e, n) {
      var i = e.layoutInfo, a = i.width, o = i.height, s = e.coordinateSystem = new Pl(null, {
        api: n,
        ecModel: e.ecModel
      });
      s.zoomLimit = e.get("scaleLimit"), s.setBoundingRect(0, 0, a, o), s.setCenter(e.get("center")), s.setZoom(e.get("zoom")), this._controllerHost.target.attr({
        x: s.x,
        y: s.y,
        scaleX: s.scaleX,
        scaleY: s.scaleY
      });
    }, t.type = "sankey", t;
  }(Re)
);
function mL(r, t, e) {
  switch (r.fill) {
    case "source":
      r.fill = e.node1.getVisual("color"), r.decal = e.node1.getVisual("style").decal;
      break;
    case "target":
      r.fill = e.node2.getVisual("color"), r.decal = e.node2.getVisual("style").decal;
      break;
    case "gradient":
      var n = e.node1.getVisual("color"), i = e.node2.getVisual("color");
      pt(n) && pt(i) && (r.fill = new wc(0, 0, +(t === "horizontal"), +(t === "vertical"), [{
        color: n,
        offset: 0
      }, {
        color: i,
        offset: 1
      }]));
  }
}
function bet(r, t, e) {
  var n = new te({
    shape: {
      x: r.x - 10,
      y: r.y - 10,
      width: 0,
      height: r.height + 20
    }
  });
  return ze(n, {
    shape: {
      width: r.width + 20
    }
  }, t, e), n;
}
var wet = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.getInitialData = function(e, n) {
      var i = e.edges || e.links || [], a = e.data || e.nodes || [], o = e.levels || [];
      this.levelModels = [];
      for (var s = this.levelModels, l = 0; l < o.length; l++)
        if (o[l].depth != null && o[l].depth >= 0)
          s[o[l].depth] = new ue(o[l], this, n);
        else if (process.env.NODE_ENV !== "production")
          throw new Error("levels[i].depth is mandatory and should be natural number");
      var u = qb(a, i, this, !0, c);
      return u.data;
      function c(f, h) {
        f.wrapMethod("getItemModel", function(d, p) {
          var g = d.parentModel, v = g.getData().getItemLayout(p);
          if (v) {
            var m = v.depth, y = g.levelModels[m];
            y && (d.parentModel = y);
          }
          return d;
        }), h.wrapMethod("getItemModel", function(d, p) {
          var g = d.parentModel, v = g.getGraph().getEdgeByIndex(p), m = v.node1.getLayout();
          if (m) {
            var y = m.depth, _ = g.levelModels[y];
            _ && (d.parentModel = _);
          }
          return d;
        });
      }
    }, t.prototype.setNodePosition = function(e, n) {
      var i = this.option.data || this.option.nodes, a = i[e];
      a.localX = n[0], a.localY = n[1];
    }, t.prototype.setCenter = function(e) {
      this.option.center = e;
    }, t.prototype.setZoom = function(e) {
      this.option.zoom = e;
    }, t.prototype.getGraph = function() {
      return this.getData().graph;
    }, t.prototype.getEdgeData = function() {
      return this.getGraph().edgeData;
    }, t.prototype.formatTooltip = function(e, n, i) {
      function a(d) {
        return isNaN(d) || d == null;
      }
      if (i === "edge") {
        var o = this.getDataParams(e, i), s = o.data, l = o.value, u = s.source + " -- " + s.target;
        return cr("nameValue", {
          name: u,
          value: l,
          noValue: a(l)
        });
      } else {
        var c = this.getGraph().getNodeByIndex(e), f = c.getLayout().value, h = this.getDataParams(e, i).data.name;
        return cr("nameValue", {
          name: h != null ? h + "" : null,
          value: f,
          noValue: a(f)
        });
      }
    }, t.prototype.optionUpdated = function() {
    }, t.prototype.getDataParams = function(e, n) {
      var i = r.prototype.getDataParams.call(this, e, n);
      if (i.value == null && n === "node") {
        var a = this.getGraph().getNodeByIndex(e), o = a.getLayout().value;
        i.value = o;
      }
      return i;
    }, t.type = "series.sankey", t.layoutMode = "box", t.defaultOption = {
      // zlevel: 0,
      z: 2,
      // `coordinateSystem` can be declared as 'matrix', 'calendar',
      //  which provides box layout container.
      coordinateSystemUsage: "box",
      left: "5%",
      top: "5%",
      right: "20%",
      bottom: "5%",
      orient: "horizontal",
      nodeWidth: 20,
      nodeGap: 8,
      draggable: !0,
      layoutIterations: 32,
      // true | false | 'move' | 'scale', see module:component/helper/RoamController.
      roam: !1,
      roamTrigger: "global",
      center: null,
      zoom: 1,
      label: {
        show: !0,
        position: "right",
        fontSize: 12
      },
      edgeLabel: {
        show: !1,
        fontSize: 12
      },
      levels: [],
      nodeAlign: "justify",
      lineStyle: {
        color: Y.color.neutral50,
        opacity: 0.2,
        curveness: 0.5
      },
      emphasis: {
        label: {
          show: !0
        },
        lineStyle: {
          opacity: 0.5
        }
      },
      select: {
        itemStyle: {
          borderColor: Y.color.primary
        }
      },
      animationEasing: "linear",
      animationDuration: 1e3
    }, t;
  }(ke)
);
function Met(r, t) {
  r.eachSeriesByType("sankey", function(e) {
    var n = e.get("nodeWidth"), i = e.get("nodeGap"), a = xr(e, t).refContainer, o = He(e.getBoxLayoutParams(), a);
    e.layoutInfo = o;
    var s = o.width, l = o.height, u = e.getGraph(), c = u.nodes, f = u.edges;
    Aet(c);
    var h = Te(c, function(v) {
      return v.getLayout().value === 0;
    }), d = h.length !== 0 ? 0 : e.get("layoutIterations"), p = e.get("orient"), g = e.get("nodeAlign");
    Tet(c, f, n, i, s, l, d, p, g);
  });
}
function Tet(r, t, e, n, i, a, o, s, l) {
  Eet(r, t, e, i, a, s, l), Ret(r, t, a, i, n, o, s), zet(r, s);
}
function Aet(r) {
  L(r, function(t) {
    var e = Bo(t.outEdges, hg), n = Bo(t.inEdges, hg), i = t.getValue() || 0, a = Math.max(e, n, i);
    t.setLayout({
      value: a
    }, !0);
  });
}
function Eet(r, t, e, n, i, a, o) {
  for (var s = [], l = [], u = [], c = [], f = 0, h = 0; h < t.length; h++)
    s[h] = 1;
  for (var h = 0; h < r.length; h++)
    l[h] = r[h].inEdges.length, l[h] === 0 && u.push(r[h]);
  for (var d = -1; u.length; ) {
    for (var p = 0; p < u.length; p++) {
      var g = u[p], v = g.hostGraph.data.getRawDataItem(g.dataIndex), m = v.depth != null && v.depth >= 0;
      m && v.depth > d && (d = v.depth), g.setLayout({
        depth: m ? v.depth : f
      }, !0), a === "vertical" ? g.setLayout({
        dy: e
      }, !0) : g.setLayout({
        dx: e
      }, !0);
      for (var y = 0; y < g.outEdges.length; y++) {
        var _ = g.outEdges[y], x = t.indexOf(_);
        s[x] = 0;
        var b = _.node2, S = r.indexOf(b);
        --l[S] === 0 && c.indexOf(b) < 0 && c.push(b);
      }
    }
    ++f, u = c, c = [];
  }
  for (var h = 0; h < s.length; h++)
    if (s[h] === 1)
      throw new Error("Sankey is a DAG, the original data has cycle!");
  var w = d > f - 1 ? d : f - 1;
  o && o !== "left" && Cet(r, o, a, w);
  var A = a === "vertical" ? (i - e) / w : (n - e) / w;
  Let(r, A, a);
}
function OB(r) {
  var t = r.hostGraph.data.getRawDataItem(r.dataIndex);
  return t.depth != null && t.depth >= 0;
}
function Cet(r, t, e, n) {
  if (t === "right") {
    for (var i = [], a = r, o = 0; a.length; ) {
      for (var s = 0; s < a.length; s++) {
        var l = a[s];
        l.setLayout({
          skNodeHeight: o
        }, !0);
        for (var u = 0; u < l.inEdges.length; u++) {
          var c = l.inEdges[u];
          i.indexOf(c.node1) < 0 && i.push(c.node1);
        }
      }
      a = i, i = [], ++o;
    }
    L(r, function(f) {
      OB(f) || f.setLayout({
        depth: Math.max(0, n - f.getLayout().skNodeHeight)
      }, !0);
    });
  } else
    t === "justify" && Det(r, n);
}
function Det(r, t) {
  L(r, function(e) {
    !OB(e) && !e.outEdges.length && e.setLayout({
      depth: t
    }, !0);
  });
}
function Let(r, t, e) {
  L(r, function(n) {
    var i = n.getLayout().depth * t;
    e === "vertical" ? n.setLayout({
      y: i
    }, !0) : n.setLayout({
      x: i
    }, !0);
  });
}
function Ret(r, t, e, n, i, a, o) {
  var s = Iet(r, o);
  Pet(s, t, e, n, i, o), i_(s, i, e, n, o);
  for (var l = 1; a > 0; a--)
    l *= 0.99, Net(s, l, o), i_(s, i, e, n, o), Fet(s, l, o), i_(s, i, e, n, o);
}
function Iet(r, t) {
  var e = [], n = t === "vertical" ? "y" : "x", i = xx(r, function(a) {
    return a.getLayout()[n];
  });
  return i.keys.sort(function(a, o) {
    return a - o;
  }), L(i.keys, function(a) {
    e.push(i.buckets.get(a));
  }), e;
}
function Pet(r, t, e, n, i, a) {
  var o = 1 / 0;
  L(r, function(s) {
    var l = s.length, u = 0;
    L(s, function(f) {
      u += f.getLayout().value;
    });
    var c = a === "vertical" ? (n - (l - 1) * i) / u : (e - (l - 1) * i) / u;
    c < o && (o = c);
  }), L(r, function(s) {
    L(s, function(l, u) {
      var c = l.getLayout().value * o;
      a === "vertical" ? (l.setLayout({
        x: u
      }, !0), l.setLayout({
        dx: c
      }, !0)) : (l.setLayout({
        y: u
      }, !0), l.setLayout({
        dy: c
      }, !0));
    });
  }), L(t, function(s) {
    var l = +s.getValue() * o;
    s.setLayout({
      dy: l
    }, !0);
  });
}
function i_(r, t, e, n, i) {
  var a = i === "vertical" ? "x" : "y";
  L(r, function(o) {
    o.sort(function(g, v) {
      return g.getLayout()[a] - v.getLayout()[a];
    });
    for (var s, l, u, c = 0, f = o.length, h = i === "vertical" ? "dx" : "dy", d = 0; d < f; d++)
      l = o[d], u = c - l.getLayout()[a], u > 0 && (s = l.getLayout()[a] + u, i === "vertical" ? l.setLayout({
        x: s
      }, !0) : l.setLayout({
        y: s
      }, !0)), c = l.getLayout()[a] + l.getLayout()[h] + t;
    var p = i === "vertical" ? n : e;
    if (u = c - t - p, u > 0) {
      s = l.getLayout()[a] - u, i === "vertical" ? l.setLayout({
        x: s
      }, !0) : l.setLayout({
        y: s
      }, !0), c = s;
      for (var d = f - 2; d >= 0; --d)
        l = o[d], u = l.getLayout()[a] + l.getLayout()[h] + t - c, u > 0 && (s = l.getLayout()[a] - u, i === "vertical" ? l.setLayout({
          x: s
        }, !0) : l.setLayout({
          y: s
        }, !0)), c = l.getLayout()[a];
    }
  });
}
function Net(r, t, e) {
  L(r.slice().reverse(), function(n) {
    L(n, function(i) {
      if (i.outEdges.length) {
        var a = Bo(i.outEdges, Oet, e) / Bo(i.outEdges, hg);
        if (isNaN(a)) {
          var o = i.outEdges.length;
          a = o ? Bo(i.outEdges, ket, e) / o : 0;
        }
        if (e === "vertical") {
          var s = i.getLayout().x + (a - Yo(i, e)) * t;
          i.setLayout({
            x: s
          }, !0);
        } else {
          var l = i.getLayout().y + (a - Yo(i, e)) * t;
          i.setLayout({
            y: l
          }, !0);
        }
      }
    });
  });
}
function Oet(r, t) {
  return Yo(r.node2, t) * r.getValue();
}
function ket(r, t) {
  return Yo(r.node2, t);
}
function Bet(r, t) {
  return Yo(r.node1, t) * r.getValue();
}
function Vet(r, t) {
  return Yo(r.node1, t);
}
function Yo(r, t) {
  return t === "vertical" ? r.getLayout().x + r.getLayout().dx / 2 : r.getLayout().y + r.getLayout().dy / 2;
}
function hg(r) {
  return r.getValue();
}
function Bo(r, t, e) {
  for (var n = 0, i = r.length, a = -1; ++a < i; ) {
    var o = +t(r[a], e);
    isNaN(o) || (n += o);
  }
  return n;
}
function Fet(r, t, e) {
  L(r, function(n) {
    L(n, function(i) {
      if (i.inEdges.length) {
        var a = Bo(i.inEdges, Bet, e) / Bo(i.inEdges, hg);
        if (isNaN(a)) {
          var o = i.inEdges.length;
          a = o ? Bo(i.inEdges, Vet, e) / o : 0;
        }
        if (e === "vertical") {
          var s = i.getLayout().x + (a - Yo(i, e)) * t;
          i.setLayout({
            x: s
          }, !0);
        } else {
          var l = i.getLayout().y + (a - Yo(i, e)) * t;
          i.setLayout({
            y: l
          }, !0);
        }
      }
    });
  });
}
function zet(r, t) {
  var e = t === "vertical" ? "x" : "y";
  L(r, function(n) {
    n.outEdges.sort(function(i, a) {
      return i.node2.getLayout()[e] - a.node2.getLayout()[e];
    }), n.inEdges.sort(function(i, a) {
      return i.node1.getLayout()[e] - a.node1.getLayout()[e];
    });
  }), L(r, function(n) {
    var i = 0, a = 0;
    L(n.outEdges, function(o) {
      o.setLayout({
        sy: i
      }, !0), i += o.getLayout().dy;
    }), L(n.inEdges, function(o) {
      o.setLayout({
        ty: a
      }, !0), a += o.getLayout().dy;
    });
  });
}
function Uet(r) {
  r.eachSeriesByType("sankey", function(t) {
    var e = t.getGraph(), n = e.nodes, i = e.edges;
    if (n.length) {
      var a = 1 / 0, o = -1 / 0;
      L(n, function(s) {
        var l = s.getLayout().value;
        l < a && (a = l), l > o && (o = l);
      }), L(n, function(s) {
        var l = new Mr({
          type: "color",
          mappingMethod: "linear",
          dataExtent: [a, o],
          visual: t.get("color")
        }), u = l.mapValueToVisual(s.getLayout().value), c = s.getModel().get(["itemStyle", "color"]);
        c != null ? (s.setVisual("color", c), s.setVisual("style", {
          fill: c
        })) : (s.setVisual("color", u), s.setVisual("style", {
          fill: u
        }));
      });
    }
    i.length && L(i, function(s) {
      var l = s.getModel().get("lineStyle");
      s.setVisual("style", l);
    });
  });
}
function Get(r) {
  r.registerChartView(xet), r.registerSeriesModel(wet), r.registerLayout(Met), r.registerVisual(Uet), r.registerAction({
    type: "dragNode",
    event: "dragnode",
    // here can only use 'update' now, other value is not support in echarts.
    update: "update"
  }, function(t, e) {
    e.eachComponent({
      mainType: "series",
      subType: "sankey",
      query: t
    }, function(n) {
      n.setNodePosition(t.dataIndex, [t.localX, t.localY]);
    });
  }), r.registerAction({
    type: "sankeyRoam",
    event: "sankeyRoam",
    update: "none"
  }, function(t, e, n) {
    e.eachComponent({
      mainType: "series",
      subType: "sankey",
      query: t
    }, function(i) {
      var a = i.coordinateSystem, o = _m(a, t, i.get("scaleLimit"));
      i.setCenter(o.center), i.setZoom(o.zoom);
    });
  });
}
var kB = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype._hasEncodeRule = function(t) {
      var e = this.getEncode();
      return e && e.get(t) != null;
    }, r.prototype.getInitialData = function(t, e) {
      var n, i = e.getComponent("xAxis", this.get("xAxisIndex")), a = e.getComponent("yAxis", this.get("yAxisIndex")), o = i.get("type"), s = a.get("type"), l;
      o === "category" ? (t.layout = "horizontal", n = i.getOrdinalMeta(), l = !this._hasEncodeRule("x")) : s === "category" ? (t.layout = "vertical", n = a.getOrdinalMeta(), l = !this._hasEncodeRule("y")) : t.layout = t.layout || "horizontal";
      var u = ["x", "y"], c = t.layout === "horizontal" ? 0 : 1, f = this._baseAxisDim = u[c], h = u[1 - c], d = [i, a], p = d[c].get("type"), g = d[1 - c].get("type"), v = t.data;
      if (v && l) {
        var m = [];
        L(v, function(x, b) {
          var S;
          et(x) ? (S = x.slice(), x.unshift(b)) : et(x.value) ? (S = J({}, x), S.value = S.value.slice(), x.value.unshift(b)) : S = x, m.push(S);
        }), t.data = m;
      }
      var y = this.defaultValueDimensions, _ = [{
        name: f,
        type: qv(p),
        ordinalMeta: n,
        otherDims: {
          tooltip: !1,
          itemName: 0
        },
        dimsDef: ["base"]
      }, {
        name: h,
        type: qv(g),
        dimsDef: y.slice()
      }];
      return Pc(this, {
        coordDimensions: _,
        dimensionsCount: y.length + 1,
        encodeDefaulter: Yt(jN, _, this)
      });
    }, r.prototype.getBaseAxis = function() {
      var t = this._baseAxisDim;
      return this.ecModel.getComponent(t + "Axis", this.get(t + "AxisIndex")).axis;
    }, r;
  }()
), BB = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.defaultValueDimensions = [{
        name: "min",
        defaultTooltip: !0
      }, {
        name: "Q1",
        defaultTooltip: !0
      }, {
        name: "median",
        defaultTooltip: !0
      }, {
        name: "Q3",
        defaultTooltip: !0
      }, {
        name: "max",
        defaultTooltip: !0
      }], e.visualDrawType = "stroke", e;
    }
    return t.type = "series.boxplot", t.dependencies = ["xAxis", "yAxis", "grid"], t.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      layout: null,
      boxWidth: [7, 50],
      itemStyle: {
        color: Y.color.neutral00,
        borderWidth: 1
      },
      emphasis: {
        scale: !0,
        itemStyle: {
          borderWidth: 2,
          shadowBlur: 5,
          shadowOffsetX: 1,
          shadowOffsetY: 1,
          shadowColor: Y.color.shadow
        }
      },
      animationDuration: 800
    }, t;
  }(ke)
);
hr(BB, kB, !0);
var Het = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n, i) {
      var a = e.getData(), o = this.group, s = this._data;
      this._data || o.removeAll();
      var l = e.get("layout") === "horizontal" ? 1 : 0;
      a.diff(s).add(function(u) {
        if (a.hasValue(u)) {
          var c = a.getItemLayout(u), f = yL(c, a, u, l, !0);
          a.setItemGraphicEl(u, f), o.add(f);
        }
      }).update(function(u, c) {
        var f = s.getItemGraphicEl(c);
        if (!a.hasValue(u)) {
          o.remove(f);
          return;
        }
        var h = a.getItemLayout(u);
        f ? (ai(f), VB(h, f, a, u)) : f = yL(h, a, u, l), o.add(f), a.setItemGraphicEl(u, f);
      }).remove(function(u) {
        var c = s.getItemGraphicEl(u);
        c && o.remove(c);
      }).execute(), this._data = a;
    }, t.prototype.remove = function(e) {
      var n = this.group, i = this._data;
      this._data = null, i && i.eachItemGraphicEl(function(a) {
        a && n.remove(a);
      });
    }, t.type = "boxplot", t;
  }(Re)
), Wet = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
    }
    return r;
  }()
), Xet = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e) {
      var n = r.call(this, e) || this;
      return n.type = "boxplotBoxPath", n;
    }
    return t.prototype.getDefaultShape = function() {
      return new Wet();
    }, t.prototype.buildPath = function(e, n) {
      var i = n.points, a = 0;
      for (e.moveTo(i[a][0], i[a][1]), a++; a < 4; a++)
        e.lineTo(i[a][0], i[a][1]);
      for (e.closePath(); a < i.length; a++)
        e.moveTo(i[a][0], i[a][1]), a++, e.lineTo(i[a][0], i[a][1]);
    }, t;
  }(ne)
);
function yL(r, t, e, n, i) {
  var a = r.ends, o = new Xet({
    shape: {
      points: i ? Yet(a, n, r) : a
    }
  });
  return VB(r, o, t, e, i), o;
}
function VB(r, t, e, n, i) {
  var a = e.hostModel, o = Al[i ? "initProps" : "updateProps"];
  o(t, {
    shape: {
      points: r.ends
    }
  }, a, n), t.useStyle(e.getItemVisual(n, "style")), t.style.strokeNoScale = !0, t.z2 = 100;
  var s = e.getItemModel(n), l = s.getModel("emphasis");
  yr(t, s), Ge(t, l.get("focus"), l.get("blurScope"), l.get("disabled"));
}
function Yet(r, t, e) {
  return rt(r, function(n) {
    return n = n.slice(), n[t] = e.initBaseline, n;
  });
}
var jf = L;
function $et(r) {
  var t = Zet(r);
  jf(t, function(e) {
    var n = e.seriesModels;
    n.length && (qet(e), jf(n, function(i, a) {
      Ket(i, e.boxOffsetList[a], e.boxWidthList[a]);
    }));
  });
}
function Zet(r) {
  var t = [], e = [];
  return r.eachSeriesByType("boxplot", function(n) {
    var i = n.getBaseAxis(), a = Zt(e, i);
    a < 0 && (a = e.length, e[a] = i, t[a] = {
      axis: i,
      seriesModels: []
    }), t[a].seriesModels.push(n);
  }), t;
}
function qet(r) {
  var t = r.axis, e = r.seriesModels, n = e.length, i = r.boxWidthList = [], a = r.boxOffsetList = [], o = [], s;
  if (t.type === "category")
    s = t.getBandWidth();
  else {
    var l = 0;
    jf(e, function(p) {
      l = Math.max(l, p.getData().count());
    });
    var u = t.getExtent();
    s = Math.abs(u[1] - u[0]) / l;
  }
  jf(e, function(p) {
    var g = p.get("boxWidth");
    et(g) || (g = [g, g]), o.push([dt(g[0], s) || 0, dt(g[1], s) || 0]);
  });
  var c = s * 0.8 - 2, f = c / n * 0.3, h = (c - f * (n - 1)) / n, d = h / 2 - c / 2;
  jf(e, function(p, g) {
    a.push(d), d += f + h, i.push(Math.min(Math.max(h, o[g][0]), o[g][1]));
  });
}
function Ket(r, t, e) {
  var n = r.coordinateSystem, i = r.getData(), a = e / 2, o = r.get("layout") === "horizontal" ? 0 : 1, s = 1 - o, l = ["x", "y"], u = i.mapDimension(l[o]), c = i.mapDimensionsAll(l[s]);
  if (u == null || c.length < 5)
    return;
  for (var f = 0; f < i.count(); f++) {
    var h = i.get(u, f), d = _(h, c[2], f), p = _(h, c[0], f), g = _(h, c[1], f), v = _(h, c[3], f), m = _(h, c[4], f), y = [];
    x(y, g, !1), x(y, v, !0), y.push(p, g, m, v), b(y, p), b(y, m), b(y, d), i.setItemLayout(f, {
      initBaseline: d[s],
      ends: y
    });
  }
  function _(S, w, A) {
    var T = i.get(w, A), M = [];
    M[o] = S, M[s] = T;
    var E;
    return isNaN(S) || isNaN(T) ? E = [NaN, NaN] : (E = n.dataToPoint(M), E[o] += t), E;
  }
  function x(S, w, A) {
    var T = w.slice(), M = w.slice();
    T[o] += a, M[o] -= a, A ? S.push(T, M) : S.push(M, T);
  }
  function b(S, w) {
    var A = w.slice(), T = w.slice();
    A[o] -= a, T[o] += a, S.push(A, T);
  }
}
function jet(r, t) {
  t = t || {};
  for (var e = [], n = [], i = t.boundIQR, a = i === "none" || i === 0, o = 0; o < r.length; o++) {
    var s = ei(r[o].slice()), l = Ry(s, 0.25), u = Ry(s, 0.5), c = Ry(s, 0.75), f = s[0], h = s[s.length - 1], d = (i ?? 1.5) * (c - l), p = a ? f : Math.max(f, l - d), g = a ? h : Math.min(h, c + d), v = t.itemNameFormatter, m = Tt(v) ? v({
      value: o
    }) : pt(v) ? v.replace("{value}", o + "") : o + "";
    e.push([m, p, l, u, c, g]);
    for (var y = 0; y < s.length; y++) {
      var _ = s[y];
      if (_ < p || _ > g) {
        var x = [m, _];
        n.push(x);
      }
    }
  }
  return {
    boxData: e,
    outliers: n
  };
}
var Jet = {
  type: "echarts:boxplot",
  transform: function(t) {
    var e = t.upstream;
    if (e.sourceFormat !== Br) {
      var n = "";
      process.env.NODE_ENV !== "production" && (n = hn("source data is not applicable for this boxplot transform. Expect number[][].")), we(n);
    }
    var i = jet(e.getRawData(), t.config);
    return [{
      dimensions: ["ItemName", "Low", "Q1", "Q2", "Q3", "High"],
      data: i.boxData
    }, {
      data: i.outliers
    }];
  }
};
function Qet(r) {
  r.registerSeriesModel(BB), r.registerChartView(Het), r.registerLayout($et), r.registerTransform(Jet);
}
var trt = ["itemStyle", "borderColor"], ert = ["itemStyle", "borderColor0"], rrt = ["itemStyle", "borderColorDoji"], nrt = ["itemStyle", "color"], irt = ["itemStyle", "color0"];
function nw(r, t) {
  return t.get(r > 0 ? nrt : irt);
}
function iw(r, t) {
  return t.get(r === 0 ? rrt : r > 0 ? trt : ert);
}
var art = {
  seriesType: "candlestick",
  plan: Cc(),
  // For legend.
  performRawSeries: !0,
  reset: function(r, t) {
    if (!t.isSeriesFiltered(r)) {
      var e = r.pipelineContext.large;
      return !e && {
        progress: function(n, i) {
          for (var a; (a = n.next()) != null; ) {
            var o = i.getItemModel(a), s = i.getItemLayout(a).sign, l = o.getItemStyle();
            l.fill = nw(s, o), l.stroke = iw(s, o) || l.fill;
            var u = i.ensureUniqueItemVisual(a, "style");
            J(u, l);
          }
        }
      };
    }
  }
}, ort = ["color", "borderColor"], srt = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n, i) {
      this.group.removeClipPath(), this._progressiveEls = null, this._updateDrawMode(e), this._isLargeDraw ? this._renderLarge(e) : this._renderNormal(e);
    }, t.prototype.incrementalPrepareRender = function(e, n, i) {
      this._clear(), this._updateDrawMode(e);
    }, t.prototype.incrementalRender = function(e, n, i, a) {
      this._progressiveEls = [], this._isLargeDraw ? this._incrementalRenderLarge(e, n) : this._incrementalRenderNormal(e, n);
    }, t.prototype.eachRendered = function(e) {
      Ko(this._progressiveEls || this.group, e);
    }, t.prototype._updateDrawMode = function(e) {
      var n = e.pipelineContext.large;
      (this._isLargeDraw == null || n !== this._isLargeDraw) && (this._isLargeDraw = n, this._clear());
    }, t.prototype._renderNormal = function(e) {
      var n = e.getData(), i = this._data, a = this.group, o = n.getLayout("isSimpleBox"), s = e.get("clip", !0), l = e.coordinateSystem, u = l.getArea && l.getArea();
      this._data || a.removeAll(), n.diff(i).add(function(c) {
        if (n.hasValue(c)) {
          var f = n.getItemLayout(c);
          if (s && _L(u, f))
            return;
          var h = a_(f, c, !0);
          ze(h, {
            shape: {
              points: f.ends
            }
          }, e, c), o_(h, n, c, o), a.add(h), n.setItemGraphicEl(c, h);
        }
      }).update(function(c, f) {
        var h = i.getItemGraphicEl(f);
        if (!n.hasValue(c)) {
          a.remove(h);
          return;
        }
        var d = n.getItemLayout(c);
        if (s && _L(u, d)) {
          a.remove(h);
          return;
        }
        h ? (ve(h, {
          shape: {
            points: d.ends
          }
        }, e, c), ai(h)) : h = a_(d), o_(h, n, c, o), a.add(h), n.setItemGraphicEl(c, h);
      }).remove(function(c) {
        var f = i.getItemGraphicEl(c);
        f && a.remove(f);
      }).execute(), this._data = n;
    }, t.prototype._renderLarge = function(e) {
      this._clear(), xL(e, this.group);
      var n = e.get("clip", !0) ? Yh(e.coordinateSystem, !1, e) : null;
      n ? this.group.setClipPath(n) : this.group.removeClipPath();
    }, t.prototype._incrementalRenderNormal = function(e, n) {
      for (var i = n.getData(), a = i.getLayout("isSimpleBox"), o; (o = e.next()) != null; ) {
        var s = i.getItemLayout(o), l = a_(s);
        o_(l, i, o, a), l.incremental = !0, this.group.add(l), this._progressiveEls.push(l);
      }
    }, t.prototype._incrementalRenderLarge = function(e, n) {
      xL(n, this.group, this._progressiveEls, !0);
    }, t.prototype.remove = function(e) {
      this._clear();
    }, t.prototype._clear = function() {
      this.group.removeAll(), this._data = null;
    }, t.type = "candlestick", t;
  }(Re)
), lrt = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
    }
    return r;
  }()
), urt = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e) {
      var n = r.call(this, e) || this;
      return n.type = "normalCandlestickBox", n;
    }
    return t.prototype.getDefaultShape = function() {
      return new lrt();
    }, t.prototype.buildPath = function(e, n) {
      var i = n.points;
      this.__simpleBox ? (e.moveTo(i[4][0], i[4][1]), e.lineTo(i[6][0], i[6][1])) : (e.moveTo(i[0][0], i[0][1]), e.lineTo(i[1][0], i[1][1]), e.lineTo(i[2][0], i[2][1]), e.lineTo(i[3][0], i[3][1]), e.closePath(), e.moveTo(i[4][0], i[4][1]), e.lineTo(i[5][0], i[5][1]), e.moveTo(i[6][0], i[6][1]), e.lineTo(i[7][0], i[7][1]));
    }, t;
  }(ne)
);
function a_(r, t, e) {
  var n = r.ends;
  return new urt({
    shape: {
      points: e ? crt(n, r) : n
    },
    z2: 100
  });
}
function _L(r, t) {
  for (var e = !0, n = 0; n < t.ends.length; n++)
    if (r.contain(t.ends[n][0], t.ends[n][1])) {
      e = !1;
      break;
    }
  return e;
}
function o_(r, t, e, n) {
  var i = t.getItemModel(e);
  r.useStyle(t.getItemVisual(e, "style")), r.style.strokeNoScale = !0, r.__simpleBox = n, yr(r, i);
  var a = t.getItemLayout(e).sign;
  L(r.states, function(s, l) {
    var u = i.getModel(l), c = nw(a, u), f = iw(a, u) || c, h = s.style || (s.style = {});
    c && (h.fill = c), f && (h.stroke = f);
  });
  var o = i.getModel("emphasis");
  Ge(r, o.get("focus"), o.get("blurScope"), o.get("disabled"));
}
function crt(r, t) {
  return rt(r, function(e) {
    return e = e.slice(), e[1] = t.initBaseline, e;
  });
}
var frt = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
    }
    return r;
  }()
), s_ = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e) {
      var n = r.call(this, e) || this;
      return n.type = "largeCandlestickBox", n;
    }
    return t.prototype.getDefaultShape = function() {
      return new frt();
    }, t.prototype.buildPath = function(e, n) {
      for (var i = n.points, a = 0; a < i.length; )
        if (this.__sign === i[a++]) {
          var o = i[a++];
          e.moveTo(o, i[a++]), e.lineTo(o, i[a++]);
        } else
          a += 3;
    }, t;
  }(ne)
);
function xL(r, t, e, n) {
  var i = r.getData(), a = i.getLayout("largePoints"), o = new s_({
    shape: {
      points: a
    },
    __sign: 1,
    ignoreCoarsePointer: !0
  });
  t.add(o);
  var s = new s_({
    shape: {
      points: a
    },
    __sign: -1,
    ignoreCoarsePointer: !0
  });
  t.add(s);
  var l = new s_({
    shape: {
      points: a
    },
    __sign: 0,
    ignoreCoarsePointer: !0
  });
  t.add(l), l_(1, o, r), l_(-1, s, r), l_(0, l, r), n && (o.incremental = !0, s.incremental = !0), e && e.push(o, s);
}
function l_(r, t, e, n) {
  var i = iw(r, e) || nw(r, e), a = e.getModel("itemStyle").getItemStyle(ort);
  t.useStyle(a), t.style.fill = null, t.style.stroke = i;
}
var FB = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.defaultValueDimensions = [{
        name: "open",
        defaultTooltip: !0
      }, {
        name: "close",
        defaultTooltip: !0
      }, {
        name: "lowest",
        defaultTooltip: !0
      }, {
        name: "highest",
        defaultTooltip: !0
      }], e;
    }
    return t.prototype.getShadowDim = function() {
      return "open";
    }, t.prototype.brushSelector = function(e, n, i) {
      var a = n.getItemLayout(e);
      return a && i.rect(a.brushRect);
    }, t.type = "series.candlestick", t.dependencies = ["xAxis", "yAxis", "grid"], t.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      layout: null,
      clip: !0,
      itemStyle: {
        color: "#eb5454",
        color0: "#47b262",
        borderColor: "#eb5454",
        borderColor0: "#47b262",
        borderColorDoji: null,
        // borderColor: '#d24040',
        // borderColor0: '#398f4f',
        borderWidth: 1
      },
      emphasis: {
        itemStyle: {
          borderWidth: 2
        }
      },
      barMaxWidth: null,
      barMinWidth: null,
      barWidth: null,
      large: !0,
      largeThreshold: 600,
      progressive: 3e3,
      progressiveThreshold: 1e4,
      progressiveChunkMode: "mod",
      animationEasing: "linear",
      animationDuration: 300
    }, t;
  }(ke)
);
hr(FB, kB, !0);
function hrt(r) {
  !r || !et(r.series) || L(r.series, function(t) {
    Dt(t) && t.type === "k" && (t.type = "candlestick");
  });
}
var drt = {
  seriesType: "candlestick",
  plan: Cc(),
  reset: function(r) {
    var t = r.coordinateSystem, e = r.getData(), n = prt(r, e), i = 0, a = 1, o = ["x", "y"], s = e.getDimensionIndex(e.mapDimension(o[i])), l = rt(e.mapDimensionsAll(o[a]), e.getDimensionIndex, e), u = l[0], c = l[1], f = l[2], h = l[3];
    if (e.setLayout({
      candleWidth: n,
      // The value is experimented visually.
      isSimpleBox: n <= 1.3
    }), s < 0 || l.length < 4)
      return;
    return {
      progress: r.pipelineContext.large ? p : d
    };
    function d(g, v) {
      for (var m, y = v.getStore(); (m = g.next()) != null; ) {
        var _ = y.get(s, m), x = y.get(u, m), b = y.get(c, m), S = y.get(f, m), w = y.get(h, m), A = Math.min(x, b), T = Math.max(x, b), M = O(A, _), E = O(T, _), R = O(S, _), C = O(w, _), D = [];
        N(D, E, 0), N(D, M, 1), D.push(F(C), F(E), F(R), F(M));
        var I = v.getItemModel(m), P = !!I.get(["itemStyle", "borderColorDoji"]);
        v.setItemLayout(m, {
          sign: SL(y, m, x, b, c, P),
          initBaseline: x > b ? E[a] : M[a],
          ends: D,
          brushRect: B(S, w, _)
        });
      }
      function O(G, X) {
        var K = [];
        return K[i] = X, K[a] = G, isNaN(X) || isNaN(G) ? [NaN, NaN] : t.dataToPoint(K);
      }
      function N(G, X, K) {
        var U = X.slice(), $ = X.slice();
        U[i] = qp(U[i] + n / 2, 1, !1), $[i] = qp($[i] - n / 2, 1, !0), K ? G.push(U, $) : G.push($, U);
      }
      function B(G, X, K) {
        var U = O(G, K), $ = O(X, K);
        return U[i] -= n / 2, $[i] -= n / 2, {
          x: U[0],
          y: U[1],
          width: n,
          height: $[1] - U[1]
        };
      }
      function F(G) {
        return G[i] = qp(G[i], 1), G;
      }
    }
    function p(g, v) {
      for (var m = Zi(g.count * 4), y = 0, _, x = [], b = [], S, w = v.getStore(), A = !!r.get(["itemStyle", "borderColorDoji"]); (S = g.next()) != null; ) {
        var T = w.get(s, S), M = w.get(u, S), E = w.get(c, S), R = w.get(f, S), C = w.get(h, S);
        if (isNaN(T) || isNaN(R) || isNaN(C)) {
          m[y++] = NaN, y += 3;
          continue;
        }
        m[y++] = SL(w, S, M, E, c, A), x[i] = T, x[a] = R, _ = t.dataToPoint(x, null, b), m[y++] = _ ? _[0] : NaN, m[y++] = _ ? _[1] : NaN, x[a] = C, _ = t.dataToPoint(x, null, b), m[y++] = _ ? _[1] : NaN;
      }
      v.setLayout("largePoints", m);
    }
  }
};
function SL(r, t, e, n, i, a) {
  var o;
  return e > n ? o = -1 : e < n ? o = 1 : o = a ? 0 : t > 0 ? r.get(i, t - 1) <= n ? 1 : -1 : 1, o;
}
function prt(r, t) {
  var e = r.getBaseAxis(), n, i = e.type === "category" ? e.getBandWidth() : (n = e.getExtent(), Math.abs(n[1] - n[0]) / t.count()), a = dt(bt(r.get("barMaxWidth"), i), i), o = dt(bt(r.get("barMinWidth"), 1), i), s = r.get("barWidth");
  return s != null ? dt(s, i) : Math.max(Math.min(i / 2, a), o);
}
function vrt(r) {
  r.registerChartView(srt), r.registerSeriesModel(FB), r.registerPreprocessor(hrt), r.registerVisual(art), r.registerLayout(drt);
}
function bL(r, t) {
  var e = t.rippleEffectColor || t.color;
  r.eachChild(function(n) {
    n.attr({
      z: t.z,
      zlevel: t.zlevel,
      style: {
        stroke: t.brushType === "stroke" ? e : null,
        fill: t.brushType === "fill" ? e : null
      }
    });
  });
}
var grt = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e, n) {
      var i = r.call(this) || this, a = new Wh(e, n), o = new Et();
      return i.add(a), i.add(o), i.updateData(e, n), i;
    }
    return t.prototype.stopEffectAnimation = function() {
      this.childAt(1).removeAll();
    }, t.prototype.startEffectAnimation = function(e) {
      for (var n = e.symbolType, i = e.color, a = e.rippleNumber, o = this.childAt(1), s = 0; s < a; s++) {
        var l = fr(n, -1, -1, 2, 2, i);
        l.attr({
          style: {
            strokeNoScale: !0
          },
          z2: 99,
          silent: !0,
          scaleX: 0.5,
          scaleY: 0.5
        });
        var u = -s / a * e.period + e.effectOffset;
        l.animate("", !0).when(e.period, {
          scaleX: e.rippleScale / 2,
          scaleY: e.rippleScale / 2
        }).delay(u).start(), l.animateStyle(!0).when(e.period, {
          opacity: 0
        }).delay(u).start(), o.add(l);
      }
      bL(o, e);
    }, t.prototype.updateEffectAnimation = function(e) {
      for (var n = this._effectCfg, i = this.childAt(1), a = ["symbolType", "period", "rippleScale", "rippleNumber"], o = 0; o < a.length; o++) {
        var s = a[o];
        if (n[s] !== e[s]) {
          this.stopEffectAnimation(), this.startEffectAnimation(e);
          return;
        }
      }
      bL(i, e);
    }, t.prototype.highlight = function() {
      Ha(this);
    }, t.prototype.downplay = function() {
      Wa(this);
    }, t.prototype.getSymbolType = function() {
      var e = this.childAt(0);
      return e && e.getSymbolType();
    }, t.prototype.updateData = function(e, n) {
      var i = this, a = e.hostModel;
      this.childAt(0).updateData(e, n);
      var o = this.childAt(1), s = e.getItemModel(n), l = e.getItemVisual(n, "symbol"), u = Lc(e.getItemVisual(n, "symbolSize")), c = e.getItemVisual(n, "style"), f = c && c.fill, h = s.getModel("emphasis");
      o.setScale(u), o.traverse(function(v) {
        v.setStyle("fill", f);
      });
      var d = Dl(e.getItemVisual(n, "symbolOffset"), u);
      d && (o.x = d[0], o.y = d[1]);
      var p = e.getItemVisual(n, "symbolRotate");
      o.rotation = (p || 0) * Math.PI / 180 || 0;
      var g = {};
      g.showEffectOn = a.get("showEffectOn"), g.rippleScale = s.get(["rippleEffect", "scale"]), g.brushType = s.get(["rippleEffect", "brushType"]), g.period = s.get(["rippleEffect", "period"]) * 1e3, g.effectOffset = n / e.count(), g.z = a.getShallow("z") || 0, g.zlevel = a.getShallow("zlevel") || 0, g.symbolType = l, g.color = f, g.rippleEffectColor = s.get(["rippleEffect", "color"]), g.rippleNumber = s.get(["rippleEffect", "number"]), g.showEffectOn === "render" ? (this._effectCfg ? this.updateEffectAnimation(g) : this.startEffectAnimation(g), this._effectCfg = g) : (this._effectCfg = null, this.stopEffectAnimation(), this.onHoverStateChange = function(v) {
        v === "emphasis" ? g.showEffectOn !== "render" && i.startEffectAnimation(g) : v === "normal" && g.showEffectOn !== "render" && i.stopEffectAnimation();
      }), this._effectCfg = g, Ge(this, h.get("focus"), h.get("blurScope"), h.get("disabled"));
    }, t.prototype.fadeOut = function(e) {
      e && e();
    }, t;
  }(Et)
), mrt = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function() {
      this._symbolDraw = new Xh(grt);
    }, t.prototype.render = function(e, n, i) {
      var a = e.getData(), o = this._symbolDraw;
      o.updateData(a, {
        clipShape: this._getClipShape(e)
      }), this.group.add(o.group);
    }, t.prototype._getClipShape = function(e) {
      var n = e.coordinateSystem, i = n && n.getArea && n.getArea();
      return e.get("clip", !0) ? i : null;
    }, t.prototype.updateTransform = function(e, n, i) {
      var a = e.getData();
      this.group.dirty();
      var o = $h("").reset(e, n, i);
      o.progress && o.progress({
        start: 0,
        end: a.count(),
        count: a.count()
      }, a), this._symbolDraw.updateLayout();
    }, t.prototype._updateGroupTransform = function(e) {
      var n = e.coordinateSystem;
      n && n.getRoamTransform && (this.group.transform = OW(n.getRoamTransform()), this.group.decomposeTransform());
    }, t.prototype.remove = function(e, n) {
      this._symbolDraw && this._symbolDraw.remove(!0);
    }, t.type = "effectScatter", t;
  }(Re)
), yrt = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.hasSymbolVisual = !0, e;
    }
    return t.prototype.getInitialData = function(e, n) {
      return ja(null, this, {
        useEncodeDefaulter: !0
      });
    }, t.prototype.brushSelector = function(e, n, i) {
      return i.point(n.getItemLayout(e));
    }, t.type = "series.effectScatter", t.dependencies = ["grid", "polar"], t.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      effectType: "ripple",
      progressive: 0,
      // When to show the effect, option: 'render'|'emphasis'
      showEffectOn: "render",
      clip: !0,
      // Ripple effect config
      rippleEffect: {
        period: 4,
        // Scale of ripple
        scale: 2.5,
        // Brush type can be fill or stroke
        brushType: "fill",
        // Ripple number
        number: 3
      },
      universalTransition: {
        divideShape: "clone"
      },
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // Polar coordinate system
      // polarIndex: 0,
      // Geo coordinate system
      // geoIndex: 0,
      // symbol: null,        // 
      symbolSize: 10
      // symbolSize * 2
      // symbolRotate: null,  // 
      // itemStyle: {
      //     opacity: 1
      // }
    }, t;
  }(ke)
);
function _rt(r) {
  r.registerChartView(mrt), r.registerSeriesModel(yrt), r.registerLayout($h("effectScatter"));
}
var zB = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e, n, i) {
      var a = r.call(this) || this;
      return a.add(a.createLine(e, n, i)), a._updateEffectSymbol(e, n), a;
    }
    return t.prototype.createLine = function(e, n, i) {
      return new $b(e, n, i);
    }, t.prototype._updateEffectSymbol = function(e, n) {
      var i = e.getItemModel(n), a = i.getModel("effect"), o = a.get("symbolSize"), s = a.get("symbol");
      et(o) || (o = [o, o]);
      var l = e.getItemVisual(n, "style"), u = a.get("color") || l && l.stroke, c = this.childAt(1);
      this._symbolType !== s && (this.remove(c), c = fr(s, -0.5, -0.5, 1, 1, u), c.z2 = 100, c.culling = !0, this.add(c)), c && (c.setStyle("shadowColor", u), c.setStyle(a.getItemStyle(["color"])), c.scaleX = o[0], c.scaleY = o[1], c.setColor(u), this._symbolType = s, this._symbolScale = o, this._updateEffectAnimation(e, a, n));
    }, t.prototype._updateEffectAnimation = function(e, n, i) {
      var a = this.childAt(1);
      if (a) {
        var o = e.getItemLayout(i), s = n.get("period") * 1e3, l = n.get("loop"), u = n.get("roundTrip"), c = n.get("constantSpeed"), f = gr(n.get("delay"), function(d) {
          return d / e.count() * s / 3;
        });
        if (a.ignore = !0, this._updateAnimationPoints(a, o), c > 0 && (s = this._getLineLength(a) / c * 1e3), s !== this._period || l !== this._loop || u !== this._roundTrip) {
          a.stopAnimation();
          var h = void 0;
          Tt(f) ? h = f(i) : h = f, a.__t > 0 && (h = -s * a.__t), this._animateSymbol(a, s, h, l, u);
        }
        this._period = s, this._loop = l, this._roundTrip = u;
      }
    }, t.prototype._animateSymbol = function(e, n, i, a, o) {
      if (n > 0) {
        e.__t = 0;
        var s = this, l = e.animate("", a).when(o ? n * 2 : n, {
          __t: o ? 2 : 1
        }).delay(i).during(function() {
          s._updateSymbolPosition(e);
        });
        a || l.done(function() {
          s.remove(e);
        }), l.start();
      }
    }, t.prototype._getLineLength = function(e) {
      return xo(e.__p1, e.__cp1) + xo(e.__cp1, e.__p2);
    }, t.prototype._updateAnimationPoints = function(e, n) {
      e.__p1 = n[0], e.__p2 = n[1], e.__cp1 = n[2] || [(n[0][0] + n[1][0]) / 2, (n[0][1] + n[1][1]) / 2];
    }, t.prototype.updateData = function(e, n, i) {
      this.childAt(0).updateData(e, n, i), this._updateEffectSymbol(e, n);
    }, t.prototype._updateSymbolPosition = function(e) {
      var n = e.__p1, i = e.__p2, a = e.__cp1, o = e.__t < 1 ? e.__t : 2 - e.__t, s = [e.x, e.y], l = s.slice(), u = Ir, c = ix;
      s[0] = u(n[0], a[0], i[0], o), s[1] = u(n[1], a[1], i[1], o);
      var f = e.__t < 1 ? c(n[0], a[0], i[0], o) : c(i[0], a[0], n[0], 1 - o), h = e.__t < 1 ? c(n[1], a[1], i[1], o) : c(i[1], a[1], n[1], 1 - o);
      e.rotation = -Math.atan2(h, f) - Math.PI / 2, (this._symbolType === "line" || this._symbolType === "rect" || this._symbolType === "roundRect") && (e.__lastT !== void 0 && e.__lastT < e.__t ? (e.scaleY = xo(l, s) * 1.05, o === 1 && (s[0] = l[0] + (s[0] - l[0]) / 2, s[1] = l[1] + (s[1] - l[1]) / 2)) : e.__lastT === 1 ? e.scaleY = 2 * xo(n, s) : e.scaleY = this._symbolScale[1]), e.__lastT = e.__t, e.ignore = !1, e.x = s[0], e.y = s[1];
    }, t.prototype.updateLayout = function(e, n) {
      this.childAt(0).updateLayout(e, n);
      var i = e.getItemModel(n).getModel("effect");
      this._updateEffectAnimation(e, i, n);
    }, t;
  }(Et)
), UB = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e, n, i) {
      var a = r.call(this) || this;
      return a._createPolyline(e, n, i), a;
    }
    return t.prototype._createPolyline = function(e, n, i) {
      var a = e.getItemLayout(n), o = new Ur({
        shape: {
          points: a
        }
      });
      this.add(o), this._updateCommonStl(e, n, i);
    }, t.prototype.updateData = function(e, n, i) {
      var a = e.hostModel, o = this.childAt(0), s = {
        shape: {
          points: e.getItemLayout(n)
        }
      };
      ve(o, s, a, n), this._updateCommonStl(e, n, i);
    }, t.prototype._updateCommonStl = function(e, n, i) {
      var a = this.childAt(0), o = e.getItemModel(n), s = i && i.emphasisLineStyle, l = i && i.focus, u = i && i.blurScope, c = i && i.emphasisDisabled;
      if (!i || e.hasItemOption) {
        var f = o.getModel("emphasis");
        s = f.getModel("lineStyle").getLineStyle(), c = f.get("disabled"), l = f.get("focus"), u = f.get("blurScope");
      }
      a.useStyle(e.getItemVisual(n, "style")), a.style.fill = null, a.style.strokeNoScale = !0;
      var h = a.ensureState("emphasis");
      h.style = s, Ge(this, l, u, c);
    }, t.prototype.updateLayout = function(e, n) {
      var i = this.childAt(0);
      i.setShape("points", e.getItemLayout(n));
    }, t;
  }(Et)
), xrt = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e._lastFrame = 0, e._lastFramePercent = 0, e;
    }
    return t.prototype.createLine = function(e, n, i) {
      return new UB(e, n, i);
    }, t.prototype._updateAnimationPoints = function(e, n) {
      this._points = n;
      for (var i = [0], a = 0, o = 1; o < n.length; o++) {
        var s = n[o - 1], l = n[o];
        a += xo(s, l), i.push(a);
      }
      if (a === 0) {
        this._length = 0;
        return;
      }
      for (var o = 0; o < i.length; o++)
        i[o] /= a;
      this._offsets = i, this._length = a;
    }, t.prototype._getLineLength = function() {
      return this._length;
    }, t.prototype._updateSymbolPosition = function(e) {
      var n = e.__t < 1 ? e.__t : 2 - e.__t, i = this._points, a = this._offsets, o = i.length;
      if (a) {
        var s = this._lastFrame, l;
        if (n < this._lastFramePercent) {
          var u = Math.min(s + 1, o - 1);
          for (l = u; l >= 0 && !(a[l] <= n); l--)
            ;
          l = Math.min(l, o - 2);
        } else {
          for (l = s; l < o && !(a[l] > n); l++)
            ;
          l = Math.min(l - 1, o - 2);
        }
        var c = (n - a[l]) / (a[l + 1] - a[l]), f = i[l], h = i[l + 1];
        e.x = f[0] * (1 - c) + c * h[0], e.y = f[1] * (1 - c) + c * h[1];
        var d = e.__t < 1 ? h[0] - f[0] : f[0] - h[0], p = e.__t < 1 ? h[1] - f[1] : f[1] - h[1];
        e.rotation = -Math.atan2(p, d) - Math.PI / 2, this._lastFrame = l, this._lastFramePercent = n, e.ignore = !1;
      }
    }, t;
  }(zB)
), Srt = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
      this.polyline = !1, this.curveness = 0, this.segs = [];
    }
    return r;
  }()
), brt = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e) {
      var n = r.call(this, e) || this;
      return n._off = 0, n.hoverDataIdx = -1, n;
    }
    return t.prototype.reset = function() {
      this.notClear = !1, this._off = 0;
    }, t.prototype.getDefaultStyle = function() {
      return {
        stroke: Y.color.neutral99,
        fill: null
      };
    }, t.prototype.getDefaultShape = function() {
      return new Srt();
    }, t.prototype.buildPath = function(e, n) {
      var i = n.segs, a = n.curveness, o;
      if (n.polyline)
        for (o = this._off; o < i.length; ) {
          var s = i[o++];
          if (s > 0) {
            e.moveTo(i[o++], i[o++]);
            for (var l = 1; l < s; l++)
              e.lineTo(i[o++], i[o++]);
          }
        }
      else
        for (o = this._off; o < i.length; ) {
          var u = i[o++], c = i[o++], f = i[o++], h = i[o++];
          if (e.moveTo(u, c), a > 0) {
            var d = (u + f) / 2 - (c - h) * a, p = (c + h) / 2 - (f - u) * a;
            e.quadraticCurveTo(d, p, f, h);
          } else
            e.lineTo(f, h);
        }
      this.incremental && (this._off = o, this.notClear = !0);
    }, t.prototype.findDataIndex = function(e, n) {
      var i = this.shape, a = i.segs, o = i.curveness, s = this.style.lineWidth;
      if (i.polyline)
        for (var l = 0, u = 0; u < a.length; ) {
          var c = a[u++];
          if (c > 0)
            for (var f = a[u++], h = a[u++], d = 1; d < c; d++) {
              var p = a[u++], g = a[u++];
              if (mo(f, h, p, g, s, e, n))
                return l;
            }
          l++;
        }
      else
        for (var l = 0, u = 0; u < a.length; ) {
          var f = a[u++], h = a[u++], p = a[u++], g = a[u++];
          if (o > 0) {
            var v = (f + p) / 2 - (h - g) * o, m = (h + g) / 2 - (p - f) * o;
            if (XP(f, h, v, m, p, g, s, e, n))
              return l;
          } else if (mo(f, h, p, g, s, e, n))
            return l;
          l++;
        }
      return -1;
    }, t.prototype.contain = function(e, n) {
      var i = this.transformCoordToLocal(e, n), a = this.getBoundingRect();
      if (e = i[0], n = i[1], a.contain(e, n)) {
        var o = this.hoverDataIdx = this.findDataIndex(e, n);
        return o >= 0;
      }
      return this.hoverDataIdx = -1, !1;
    }, t.prototype.getBoundingRect = function() {
      var e = this._rect;
      if (!e) {
        for (var n = this.shape, i = n.segs, a = 1 / 0, o = 1 / 0, s = -1 / 0, l = -1 / 0, u = 0; u < i.length; ) {
          var c = i[u++], f = i[u++];
          a = Math.min(c, a), s = Math.max(c, s), o = Math.min(f, o), l = Math.max(f, l);
        }
        e = this._rect = new Bt(a, o, s, l);
      }
      return e;
    }, t;
  }(ne)
), wrt = (
  /** @class */
  function() {
    function r() {
      this.group = new Et();
    }
    return r.prototype.updateData = function(t) {
      this._clear();
      var e = this._create();
      e.setShape({
        segs: t.getLayout("linesPoints")
      }), this._setCommon(e, t);
    }, r.prototype.incrementalPrepareUpdate = function(t) {
      this.group.removeAll(), this._clear();
    }, r.prototype.incrementalUpdate = function(t, e) {
      var n = this._newAdded[0], i = e.getLayout("linesPoints"), a = n && n.shape.segs;
      if (a && a.length < 2e4) {
        var o = a.length, s = new Float32Array(o + i.length);
        s.set(a), s.set(i, o), n.setShape({
          segs: s
        });
      } else {
        this._newAdded = [];
        var l = this._create();
        l.incremental = !0, l.setShape({
          segs: i
        }), this._setCommon(l, e), l.__startIndex = t.start;
      }
    }, r.prototype.remove = function() {
      this._clear();
    }, r.prototype.eachRendered = function(t) {
      this._newAdded[0] && t(this._newAdded[0]);
    }, r.prototype._create = function() {
      var t = new brt({
        cursor: "default",
        ignoreCoarsePointer: !0
      });
      return this._newAdded.push(t), this.group.add(t), t;
    }, r.prototype._setCommon = function(t, e, n) {
      var i = e.hostModel;
      t.setShape({
        polyline: i.get("polyline"),
        curveness: i.get(["lineStyle", "curveness"])
      }), t.useStyle(i.getModel("lineStyle").getLineStyle()), t.style.strokeNoScale = !0;
      var a = e.getVisual("style");
      a && a.stroke && t.setStyle("stroke", a.stroke), t.setStyle("fill", null);
      var o = zt(t);
      o.seriesIndex = i.seriesIndex, t.on("mousemove", function(s) {
        o.dataIndex = null;
        var l = t.hoverDataIdx;
        l > 0 && (o.dataIndex = l + t.__startIndex);
      });
    }, r.prototype._clear = function() {
      this._newAdded = [], this.group.removeAll();
    }, r;
  }()
), GB = {
  seriesType: "lines",
  plan: Cc(),
  reset: function(r) {
    var t = r.coordinateSystem;
    if (!t) {
      process.env.NODE_ENV !== "production" && ce("The lines series must have a coordinate system.");
      return;
    }
    var e = r.get("polyline"), n = r.pipelineContext.large;
    return {
      progress: function(i, a) {
        var o = [];
        if (n) {
          var s = void 0, l = i.end - i.start;
          if (e) {
            for (var u = 0, c = i.start; c < i.end; c++)
              u += r.getLineCoordsCount(c);
            s = new Float32Array(l + u * 2);
          } else
            s = new Float32Array(l * 4);
          for (var f = 0, h = [], c = i.start; c < i.end; c++) {
            var d = r.getLineCoords(c, o);
            e && (s[f++] = d);
            for (var p = 0; p < d; p++)
              h = t.dataToPoint(o[p], !1, h), s[f++] = h[0], s[f++] = h[1];
          }
          a.setLayout("linesPoints", s);
        } else
          for (var c = i.start; c < i.end; c++) {
            var g = a.getItemModel(c), d = r.getLineCoords(c, o), v = [];
            if (e)
              for (var m = 0; m < d; m++)
                v.push(t.dataToPoint(o[m]));
            else {
              v[0] = t.dataToPoint(o[0]), v[1] = t.dataToPoint(o[1]);
              var y = g.get(["lineStyle", "curveness"]);
              +y && (v[2] = [(v[0][0] + v[1][0]) / 2 - (v[0][1] - v[1][1]) * y, (v[0][1] + v[1][1]) / 2 - (v[1][0] - v[0][0]) * y]);
            }
            a.setItemLayout(c, v);
          }
      }
    };
  }
}, Mrt = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n, i) {
      var a = e.getData(), o = this._updateLineDraw(a, e), s = e.get("zlevel"), l = e.get(["effect", "trailLength"]), u = i.getZr(), c = u.painter.getType() === "svg";
      c || u.painter.getLayer(s).clear(!0), this._lastZlevel != null && !c && u.configLayer(this._lastZlevel, {
        motionBlur: !1
      }), this._showEffect(e) && l > 0 && (c ? process.env.NODE_ENV !== "production" && console.warn("SVG render mode doesn't support lines with trail effect") : u.configLayer(s, {
        motionBlur: !0,
        lastFrameAlpha: Math.max(Math.min(l / 10 + 0.9, 1), 0)
      })), o.updateData(a);
      var f = e.get("clip", !0) && Yh(e.coordinateSystem, !1, e);
      f ? this.group.setClipPath(f) : this.group.removeClipPath(), this._lastZlevel = s, this._finished = !0;
    }, t.prototype.incrementalPrepareRender = function(e, n, i) {
      var a = e.getData(), o = this._updateLineDraw(a, e);
      o.incrementalPrepareUpdate(a), this._clearLayer(i), this._finished = !1;
    }, t.prototype.incrementalRender = function(e, n, i) {
      this._lineDraw.incrementalUpdate(e, n.getData()), this._finished = e.end === n.getData().count();
    }, t.prototype.eachRendered = function(e) {
      this._lineDraw && this._lineDraw.eachRendered(e);
    }, t.prototype.updateTransform = function(e, n, i) {
      var a = e.getData(), o = e.pipelineContext;
      if (!this._finished || o.large || o.progressiveRender)
        return {
          update: !0
        };
      var s = GB.reset(e, n, i);
      s.progress && s.progress({
        start: 0,
        end: a.count(),
        count: a.count()
      }, a), this._lineDraw.updateLayout(), this._clearLayer(i);
    }, t.prototype._updateLineDraw = function(e, n) {
      var i = this._lineDraw, a = this._showEffect(n), o = !!n.get("polyline"), s = n.pipelineContext, l = s.large;
      return process.env.NODE_ENV !== "production" && a && l && console.warn("Large lines not support effect"), (!i || a !== this._hasEffet || o !== this._isPolyline || l !== this._isLargeDraw) && (i && i.remove(), i = this._lineDraw = l ? new wrt() : new Zb(o ? a ? xrt : UB : a ? zB : $b), this._hasEffet = a, this._isPolyline = o, this._isLargeDraw = l), this.group.add(i.group), i;
    }, t.prototype._showEffect = function(e) {
      return !!e.get(["effect", "show"]);
    }, t.prototype._clearLayer = function(e) {
      var n = e.getZr(), i = n.painter.getType() === "svg";
      !i && this._lastZlevel != null && n.painter.getLayer(this._lastZlevel).clear(!0);
    }, t.prototype.remove = function(e, n) {
      this._lineDraw && this._lineDraw.remove(), this._lineDraw = null, this._clearLayer(n);
    }, t.prototype.dispose = function(e, n) {
      this.remove(e, n);
    }, t.type = "lines", t;
  }(Re)
), Trt = typeof Uint32Array > "u" ? Array : Uint32Array, Art = typeof Float64Array > "u" ? Array : Float64Array;
function wL(r) {
  var t = r.data;
  t && t[0] && t[0][0] && t[0][0].coord && (process.env.NODE_ENV !== "production" && console.warn("Lines data configuration has been changed to { coords:[[1,2],[2,3]] }"), r.data = rt(t, function(e) {
    var n = [e[0].coord, e[1].coord], i = {
      coords: n
    };
    return e[0].name && (i.fromName = e[0].name), e[1].name && (i.toName = e[1].name), x1([i, e[0], e[1]]);
  }));
}
var Ert = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.visualStyleAccessPath = "lineStyle", e.visualDrawType = "stroke", e;
    }
    return t.prototype.init = function(e) {
      e.data = e.data || [], wL(e);
      var n = this._processFlatCoordsArray(e.data);
      this._flatCoords = n.flatCoords, this._flatCoordsOffset = n.flatCoordsOffset, n.flatCoords && (e.data = new Float32Array(n.count)), r.prototype.init.apply(this, arguments);
    }, t.prototype.mergeOption = function(e) {
      if (wL(e), e.data) {
        var n = this._processFlatCoordsArray(e.data);
        this._flatCoords = n.flatCoords, this._flatCoordsOffset = n.flatCoordsOffset, n.flatCoords && (e.data = new Float32Array(n.count));
      }
      r.prototype.mergeOption.apply(this, arguments);
    }, t.prototype.appendData = function(e) {
      var n = this._processFlatCoordsArray(e.data);
      n.flatCoords && (this._flatCoords ? (this._flatCoords = th(this._flatCoords, n.flatCoords), this._flatCoordsOffset = th(this._flatCoordsOffset, n.flatCoordsOffset)) : (this._flatCoords = n.flatCoords, this._flatCoordsOffset = n.flatCoordsOffset), e.data = new Float32Array(n.count)), this.getRawData().appendData(e.data);
    }, t.prototype._getCoordsFromItemModel = function(e) {
      var n = this.getData().getItemModel(e), i = n.option instanceof Array ? n.option : n.getShallow("coords");
      if (process.env.NODE_ENV !== "production" && !(i instanceof Array && i.length > 0 && i[0] instanceof Array))
        throw new Error("Invalid coords " + JSON.stringify(i) + ". Lines must have 2d coords array in data item.");
      return i;
    }, t.prototype.getLineCoordsCount = function(e) {
      return this._flatCoordsOffset ? this._flatCoordsOffset[e * 2 + 1] : this._getCoordsFromItemModel(e).length;
    }, t.prototype.getLineCoords = function(e, n) {
      if (this._flatCoordsOffset) {
        for (var i = this._flatCoordsOffset[e * 2], a = this._flatCoordsOffset[e * 2 + 1], o = 0; o < a; o++)
          n[o] = n[o] || [], n[o][0] = this._flatCoords[i + o * 2], n[o][1] = this._flatCoords[i + o * 2 + 1];
        return a;
      } else {
        for (var s = this._getCoordsFromItemModel(e), o = 0; o < s.length; o++)
          n[o] = n[o] || [], n[o][0] = s[o][0], n[o][1] = s[o][1];
        return s.length;
      }
    }, t.prototype._processFlatCoordsArray = function(e) {
      var n = 0;
      if (this._flatCoords && (n = this._flatCoords.length), fe(e[0])) {
        for (var i = e.length, a = new Trt(i), o = new Art(i), s = 0, l = 0, u = 0, c = 0; c < i; ) {
          u++;
          var f = e[c++];
          a[l++] = s + n, a[l++] = f;
          for (var h = 0; h < f; h++) {
            var d = e[c++], p = e[c++];
            if (o[s++] = d, o[s++] = p, c > i && process.env.NODE_ENV !== "production")
              throw new Error("Invalid data format.");
          }
        }
        return {
          flatCoordsOffset: new Uint32Array(a.buffer, 0, l),
          flatCoords: o,
          count: u
        };
      }
      return {
        flatCoordsOffset: null,
        flatCoords: null,
        count: e.length
      };
    }, t.prototype.getInitialData = function(e, n) {
      if (process.env.NODE_ENV !== "production") {
        var i = Ec.get(e.coordinateSystem);
        if (!i)
          throw new Error("Unknown coordinate system " + e.coordinateSystem);
      }
      var a = new un(["value"], this);
      return a.hasItemOption = !1, a.initData(e.data, [], function(o, s, l, u) {
        if (o instanceof Array)
          return NaN;
        a.hasItemOption = !0;
        var c = o.value;
        if (c != null)
          return c instanceof Array ? c[u] : c;
      }), a;
    }, t.prototype.formatTooltip = function(e, n, i) {
      var a = this.getData(), o = a.getItemModel(e), s = o.get("name");
      if (s)
        return s;
      var l = o.get("fromName"), u = o.get("toName"), c = [];
      return l != null && c.push(l), u != null && c.push(u), cr("nameValue", {
        name: c.join(" > ")
      });
    }, t.prototype.preventIncremental = function() {
      return !!this.get(["effect", "show"]);
    }, t.prototype.getProgressive = function() {
      var e = this.option.progressive;
      return e ?? (this.option.large ? 1e4 : this.get("progressive"));
    }, t.prototype.getProgressiveThreshold = function() {
      var e = this.option.progressiveThreshold;
      return e ?? (this.option.large ? 2e4 : this.get("progressiveThreshold"));
    }, t.prototype.getZLevelKey = function() {
      var e = this.getModel("effect"), n = e.get("trailLength");
      return this.getData().count() > this.getProgressiveThreshold() ? this.id : e.get("show") && n > 0 ? n + "" : "";
    }, t.type = "series.lines", t.dependencies = ["grid", "polar", "geo", "calendar"], t.defaultOption = {
      coordinateSystem: "geo",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      // Cartesian coordinate system
      xAxisIndex: 0,
      yAxisIndex: 0,
      symbol: ["none", "none"],
      symbolSize: [10, 10],
      // Geo coordinate system
      geoIndex: 0,
      effect: {
        show: !1,
        period: 4,
        constantSpeed: 0,
        symbol: "circle",
        symbolSize: 3,
        loop: !0,
        trailLength: 0.2
      },
      large: !1,
      // Available when large is true
      largeThreshold: 2e3,
      polyline: !1,
      clip: !0,
      label: {
        show: !1,
        position: "end"
        // distance: 5,
        // formatter: Tooltip.formatter
      },
      lineStyle: {
        opacity: 0.5
      }
    }, t;
  }(ke)
);
function Sp(r) {
  return r instanceof Array || (r = [r, r]), r;
}
var Crt = {
  seriesType: "lines",
  reset: function(r) {
    var t = Sp(r.get("symbol")), e = Sp(r.get("symbolSize")), n = r.getData();
    n.setVisual("fromSymbol", t && t[0]), n.setVisual("toSymbol", t && t[1]), n.setVisual("fromSymbolSize", e && e[0]), n.setVisual("toSymbolSize", e && e[1]);
    function i(a, o) {
      var s = a.getItemModel(o), l = Sp(s.getShallow("symbol", !0)), u = Sp(s.getShallow("symbolSize", !0));
      l[0] && a.setItemVisual(o, "fromSymbol", l[0]), l[1] && a.setItemVisual(o, "toSymbol", l[1]), u[0] && a.setItemVisual(o, "fromSymbolSize", u[0]), u[1] && a.setItemVisual(o, "toSymbolSize", u[1]);
    }
    return {
      dataEach: n.hasItemOption ? i : null
    };
  }
};
function Drt(r) {
  r.registerChartView(Mrt), r.registerSeriesModel(Ert), r.registerLayout(GB), r.registerVisual(Crt);
}
var Lrt = 256, Rrt = (
  /** @class */
  function() {
    function r() {
      this.blurSize = 30, this.pointSize = 20, this.maxOpacity = 1, this.minOpacity = 0, this._gradientPixels = {
        inRange: null,
        outOfRange: null
      };
      var t = xi.createCanvas();
      this.canvas = t;
    }
    return r.prototype.update = function(t, e, n, i, a, o) {
      var s = this._getBrush(), l = this._getGradient(a, "inRange"), u = this._getGradient(a, "outOfRange"), c = this.pointSize + this.blurSize, f = this.canvas, h = f.getContext("2d"), d = t.length;
      f.width = e, f.height = n;
      for (var p = 0; p < d; ++p) {
        var g = t[p], v = g[0], m = g[1], y = g[2], _ = i(y);
        h.globalAlpha = _, h.drawImage(s, v - c, m - c);
      }
      if (!f.width || !f.height)
        return f;
      for (var x = h.getImageData(0, 0, f.width, f.height), b = x.data, S = 0, w = b.length, A = this.minOpacity, T = this.maxOpacity, M = T - A; S < w; ) {
        var _ = b[S + 3] / 256, E = Math.floor(_ * (Lrt - 1)) * 4;
        if (_ > 0) {
          var R = o(_) ? l : u;
          _ > 0 && (_ = _ * M + A), b[S++] = R[E], b[S++] = R[E + 1], b[S++] = R[E + 2], b[S++] = R[E + 3] * _ * 256;
        } else
          S += 4;
      }
      return h.putImageData(x, 0, 0), f;
    }, r.prototype._getBrush = function() {
      var t = this._brushCanvas || (this._brushCanvas = xi.createCanvas()), e = this.pointSize + this.blurSize, n = e * 2;
      t.width = n, t.height = n;
      var i = t.getContext("2d");
      return i.clearRect(0, 0, n, n), i.shadowOffsetX = n, i.shadowBlur = this.blurSize, i.shadowColor = Y.color.neutral99, i.beginPath(), i.arc(-e, e, this.pointSize, 0, Math.PI * 2, !0), i.closePath(), i.fill(), t;
    }, r.prototype._getGradient = function(t, e) {
      for (var n = this._gradientPixels, i = n[e] || (n[e] = new Uint8ClampedArray(256 * 4)), a = [0, 0, 0, 0], o = 0, s = 0; s < 256; s++)
        t[e](s / 255, !0, a), i[o++] = a[0], i[o++] = a[1], i[o++] = a[2], i[o++] = a[3];
      return i;
    }, r;
  }()
);
function Irt(r, t, e) {
  var n = r[1] - r[0];
  t = rt(t, function(o) {
    return {
      interval: [(o.interval[0] - r[0]) / n, (o.interval[1] - r[0]) / n]
    };
  });
  var i = t.length, a = 0;
  return function(o) {
    var s;
    for (s = a; s < i; s++) {
      var l = t[s].interval;
      if (l[0] <= o && o <= l[1]) {
        a = s;
        break;
      }
    }
    if (s === i)
      for (s = a - 1; s >= 0; s--) {
        var l = t[s].interval;
        if (l[0] <= o && o <= l[1]) {
          a = s;
          break;
        }
      }
    return s >= 0 && s < i && e[s];
  };
}
function Prt(r, t) {
  var e = r[1] - r[0];
  return t = [(t[0] - r[0]) / e, (t[1] - r[0]) / e], function(n) {
    return n >= t[0] && n <= t[1];
  };
}
function ML(r) {
  var t = r.dimensions;
  return t[0] === "lng" && t[1] === "lat";
}
var Nrt = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n, i) {
      var a;
      if (n.eachComponent("visualMap", function(s) {
        s.eachTargetSeries(function(l) {
          l === e && (a = s);
        });
      }), process.env.NODE_ENV !== "production" && !a)
        throw new Error("Heatmap must use with visualMap");
      this._progressiveEls = null, this.group.removeAll();
      var o = e.coordinateSystem;
      o.type === "cartesian2d" || o.type === "calendar" || o.type === "matrix" ? this._renderOnGridLike(e, i, 0, e.getData().count()) : ML(o) && this._renderOnGeo(o, e, a, i);
    }, t.prototype.incrementalPrepareRender = function(e, n, i) {
      this.group.removeAll();
    }, t.prototype.incrementalRender = function(e, n, i, a) {
      var o = n.coordinateSystem;
      o && (ML(o) ? this.render(n, i, a) : (this._progressiveEls = [], this._renderOnGridLike(n, a, e.start, e.end, !0)));
    }, t.prototype.eachRendered = function(e) {
      Ko(this._progressiveEls || this.group, e);
    }, t.prototype._renderOnGridLike = function(e, n, i, a, o) {
      var s = e.coordinateSystem, l = Wo(s, "cartesian2d"), u = Wo(s, "matrix"), c, f, h, d;
      if (l) {
        var p = s.getAxis("x"), g = s.getAxis("y");
        if (process.env.NODE_ENV !== "production") {
          if (!(p.type === "category" && g.type === "category"))
            throw new Error("Heatmap on cartesian must have two category axes");
          if (!(p.onBand && g.onBand))
            throw new Error("Heatmap on cartesian must have two axes with boundaryGap true");
        }
        c = p.getBandWidth() + 0.5, f = g.getBandWidth() + 0.5, h = p.scale.getExtent(), d = g.scale.getExtent();
      }
      for (var v = this.group, m = e.getData(), y = e.getModel(["emphasis", "itemStyle"]).getItemStyle(), _ = e.getModel(["blur", "itemStyle"]).getItemStyle(), x = e.getModel(["select", "itemStyle"]).getItemStyle(), b = e.get(["itemStyle", "borderRadius"]), S = _r(e), w = e.getModel("emphasis"), A = w.get("focus"), T = w.get("blurScope"), M = w.get("disabled"), E = l || u ? [m.mapDimension("x"), m.mapDimension("y"), m.mapDimension("value")] : [m.mapDimension("time"), m.mapDimension("value")], R = i; R < a; R++) {
        var C = void 0, D = m.getItemVisual(R, "style");
        if (l) {
          var I = m.get(E[0], R), P = m.get(E[1], R);
          if (isNaN(m.get(E[2], R)) || isNaN(I) || isNaN(P) || I < h[0] || I > h[1] || P < d[0] || P > d[1])
            continue;
          var O = s.dataToPoint([I, P]);
          C = new te({
            shape: {
              x: O[0] - c / 2,
              y: O[1] - f / 2,
              width: c,
              height: f
            },
            style: D
          });
        } else if (u) {
          var N = s.dataToLayout([m.get(E[0], R), m.get(E[1], R)]).rect;
          if (Or(N.x))
            continue;
          C = new te({
            z2: 1,
            shape: N,
            style: D
          });
        } else {
          if (isNaN(m.get(E[1], R)))
            continue;
          var B = s.dataToLayout([m.get(E[0], R)]), N = B.contentRect || B.rect;
          if (Or(N.x) || Or(N.y))
            continue;
          C = new te({
            z2: 1,
            shape: N,
            style: D
          });
        }
        if (m.hasItemOption) {
          var F = m.getItemModel(R), G = F.getModel("emphasis");
          y = G.getModel("itemStyle").getItemStyle(), _ = F.getModel(["blur", "itemStyle"]).getItemStyle(), x = F.getModel(["select", "itemStyle"]).getItemStyle(), b = F.get(["itemStyle", "borderRadius"]), A = G.get("focus"), T = G.get("blurScope"), M = G.get("disabled"), S = _r(F);
        }
        C.shape.r = b;
        var X = e.getRawValue(R), K = "-";
        X && X[2] != null && (K = X[2] + ""), Er(C, S, {
          labelFetcher: e,
          labelDataIndex: R,
          defaultOpacity: D.opacity,
          defaultText: K
        }), C.ensureState("emphasis").style = y, C.ensureState("blur").style = _, C.ensureState("select").style = x, Ge(C, A, T, M), C.incremental = o, o && (C.states.emphasis.hoverLayer = !0), v.add(C), m.setItemGraphicEl(R, C), this._progressiveEls && this._progressiveEls.push(C);
      }
    }, t.prototype._renderOnGeo = function(e, n, i, a) {
      var o = i.targetVisuals.inRange, s = i.targetVisuals.outOfRange, l = n.getData(), u = this._hmLayer || this._hmLayer || new Rrt();
      u.blurSize = n.get("blurSize"), u.pointSize = n.get("pointSize"), u.minOpacity = n.get("minOpacity"), u.maxOpacity = n.get("maxOpacity");
      var c = e.getViewRect().clone(), f = e.getRoamTransform();
      c.applyTransform(f);
      var h = Math.max(c.x, 0), d = Math.max(c.y, 0), p = Math.min(c.width + c.x, a.getWidth()), g = Math.min(c.height + c.y, a.getHeight()), v = p - h, m = g - d, y = [l.mapDimension("lng"), l.mapDimension("lat"), l.mapDimension("value")], _ = l.mapArray(y, function(w, A, T) {
        var M = e.dataToPoint([w, A]);
        return M[0] -= h, M[1] -= d, M.push(T), M;
      }), x = i.getExtent(), b = i.type === "visualMap.continuous" ? Prt(x, i.option.range) : Irt(x, i.getPieceList(), i.option.selected);
      u.update(_, v, m, o.color.getNormalizer(), {
        inRange: o.color.getColorMapper(),
        outOfRange: s.color.getColorMapper()
      }, b);
      var S = new Vr({
        style: {
          width: v,
          height: m,
          x: h,
          y: d,
          image: u.canvas
        },
        silent: !0
      });
      this.group.add(S);
    }, t.type = "heatmap", t;
  }(Re)
), Ort = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.getInitialData = function(e, n) {
      return ja(null, this, {
        generateCoord: "value"
      });
    }, t.prototype.preventIncremental = function() {
      var e = Ec.get(this.get("coordinateSystem"));
      if (e && e.dimensions)
        return e.dimensions[0] === "lng" && e.dimensions[1] === "lat";
    }, t.type = "series.heatmap", t.dependencies = ["grid", "geo", "calendar", "matrix"], t.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // Geo coordinate system
      geoIndex: 0,
      blurSize: 30,
      pointSize: 20,
      maxOpacity: 1,
      minOpacity: 0,
      select: {
        itemStyle: {
          borderColor: Y.color.primary
        }
      }
    }, t;
  }(ke)
);
function krt(r) {
  r.registerChartView(Nrt), r.registerSeriesModel(Ort);
}
var Brt = ["itemStyle", "borderWidth"], TL = [{
  xy: "x",
  wh: "width",
  index: 0,
  posDesc: ["left", "right"]
}, {
  xy: "y",
  wh: "height",
  index: 1,
  posDesc: ["top", "bottom"]
}], u_ = new qa(), Vrt = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n, i) {
      var a = this.group, o = e.getData(), s = this._data, l = e.coordinateSystem, u = l.getBaseAxis(), c = u.isHorizontal(), f = l.master.getRect(), h = {
        ecSize: {
          width: i.getWidth(),
          height: i.getHeight()
        },
        seriesModel: e,
        coordSys: l,
        coordSysExtent: [[f.x, f.x + f.width], [f.y, f.y + f.height]],
        isHorizontal: c,
        valueDim: TL[+c],
        categoryDim: TL[1 - +c]
      };
      o.diff(s).add(function(p) {
        if (o.hasValue(p)) {
          var g = EL(o, p), v = AL(o, p, g, h), m = CL(o, h, v);
          o.setItemGraphicEl(p, m), a.add(m), LL(m, h, v);
        }
      }).update(function(p, g) {
        var v = s.getItemGraphicEl(g);
        if (!o.hasValue(p)) {
          a.remove(v);
          return;
        }
        var m = EL(o, p), y = AL(o, p, m, h), _ = ZB(o, y);
        v && _ !== v.__pictorialShapeStr && (a.remove(v), o.setItemGraphicEl(p, null), v = null), v ? Xrt(v, h, y) : v = CL(o, h, y, !0), o.setItemGraphicEl(p, v), v.__pictorialSymbolMeta = y, a.add(v), LL(v, h, y);
      }).remove(function(p) {
        var g = s.getItemGraphicEl(p);
        g && DL(s, p, g.__pictorialSymbolMeta.animationModel, g);
      }).execute();
      var d = e.get("clip", !0) ? Yh(e.coordinateSystem, !1, e) : null;
      return d ? a.setClipPath(d) : a.removeClipPath(), this._data = o, this.group;
    }, t.prototype.remove = function(e, n) {
      var i = this.group, a = this._data;
      e.get("animation") ? a && a.eachItemGraphicEl(function(o) {
        DL(a, zt(o).dataIndex, e, o);
      }) : i.removeAll();
    }, t.type = "pictorialBar", t;
  }(Re)
);
function AL(r, t, e, n) {
  var i = r.getItemLayout(t), a = e.get("symbolRepeat"), o = e.get("symbolClip"), s = e.get("symbolPosition") || "start", l = e.get("symbolRotate"), u = (l || 0) * Math.PI / 180 || 0, c = e.get("symbolPatternSize") || 2, f = e.isAnimationEnabled(), h = {
    dataIndex: t,
    layout: i,
    itemModel: e,
    symbolType: r.getItemVisual(t, "symbol") || "circle",
    style: r.getItemVisual(t, "style"),
    symbolClip: o,
    symbolRepeat: a,
    symbolRepeatDirection: e.get("symbolRepeatDirection"),
    symbolPatternSize: c,
    rotation: u,
    animationModel: f ? e : null,
    hoverScale: f && e.get(["emphasis", "scale"]),
    z2: e.getShallow("z", !0) || 0
  };
  Frt(e, a, i, n, h), zrt(r, t, i, a, o, h.boundingLength, h.pxSign, c, n, h), Urt(e, h.symbolScale, u, n, h);
  var d = h.symbolSize, p = Dl(e.get("symbolOffset"), d);
  return Grt(e, d, i, a, o, p, s, h.valueLineWidth, h.boundingLength, h.repeatCutLength, n, h), h;
}
function Frt(r, t, e, n, i) {
  var a = n.valueDim, o = r.get("symbolBoundingData"), s = n.coordSys.getOtherAxis(n.coordSys.getBaseAxis()), l = s.toGlobalCoord(s.dataToCoord(0)), u = 1 - +(e[a.wh] <= 0), c;
  if (et(o)) {
    var f = [c_(s, o[0]) - l, c_(s, o[1]) - l];
    f[1] < f[0] && f.reverse(), c = f[u];
  } else
    o != null ? c = c_(s, o) - l : t ? c = n.coordSysExtent[a.index][u] - l : c = e[a.wh];
  i.boundingLength = c, t && (i.repeatCutLength = e[a.wh]);
  var h = a.xy === "x", d = s.inverse;
  i.pxSign = h && !d || !h && d ? c >= 0 ? 1 : -1 : c > 0 ? 1 : -1;
}
function c_(r, t) {
  return r.toGlobalCoord(r.dataToCoord(r.scale.parse(t)));
}
function zrt(r, t, e, n, i, a, o, s, l, u) {
  var c = l.valueDim, f = l.categoryDim, h = Math.abs(e[f.wh]), d = r.getItemVisual(t, "symbolSize"), p;
  et(d) ? p = d.slice() : d == null ? p = ["100%", "100%"] : p = [d, d], p[f.index] = dt(p[f.index], h), p[c.index] = dt(p[c.index], n ? h : Math.abs(a)), u.symbolSize = p;
  var g = u.symbolScale = [p[0] / s, p[1] / s];
  g[c.index] *= (l.isHorizontal ? -1 : 1) * o;
}
function Urt(r, t, e, n, i) {
  var a = r.get(Brt) || 0;
  a && (u_.attr({
    scaleX: t[0],
    scaleY: t[1],
    rotation: e
  }), u_.updateTransform(), a /= u_.getLineScale(), a *= t[n.valueDim.index]), i.valueLineWidth = a || 0;
}
function Grt(r, t, e, n, i, a, o, s, l, u, c, f) {
  var h = c.categoryDim, d = c.valueDim, p = f.pxSign, g = Math.max(t[d.index] + s, 0), v = g;
  if (n) {
    var m = Math.abs(l), y = gr(r.get("symbolMargin"), "15%") + "", _ = !1;
    y.lastIndexOf("!") === y.length - 1 && (_ = !0, y = y.slice(0, y.length - 1));
    var x = dt(y, t[d.index]), b = Math.max(g + x * 2, 0), S = _ ? 0 : x * 2, w = C1(n), A = w ? n : RL((m + S) / b), T = m - A * g;
    x = T / 2 / (_ ? A : Math.max(A - 1, 1)), b = g + x * 2, S = _ ? 0 : x * 2, !w && n !== "fixed" && (A = u ? RL((Math.abs(u) + S) / b) : 0), v = A * b - S, f.repeatTimes = A, f.symbolMargin = x;
  }
  var M = p * (v / 2), E = f.pathPosition = [];
  E[h.index] = e[h.wh] / 2, E[d.index] = o === "start" ? M : o === "end" ? l - M : l / 2, a && (E[0] += a[0], E[1] += a[1]);
  var R = f.bundlePosition = [];
  R[h.index] = e[h.xy], R[d.index] = e[d.xy];
  var C = f.barRectShape = J({}, e);
  C[d.wh] = p * Math.max(Math.abs(e[d.wh]), Math.abs(E[d.index] + M)), C[h.wh] = e[h.wh];
  var D = f.clipShape = {};
  D[h.xy] = -e[h.xy], D[h.wh] = c.ecSize[h.wh], D[d.xy] = 0, D[d.wh] = e[d.wh];
}
function HB(r) {
  var t = r.symbolPatternSize, e = fr(
    // Consider texture img, make a big size.
    r.symbolType,
    -t / 2,
    -t / 2,
    t,
    t
  );
  return e.attr({
    culling: !0
  }), e.type !== "image" && e.setStyle({
    strokeNoScale: !0
  }), e;
}
function WB(r, t, e, n) {
  var i = r.__pictorialBundle, a = e.symbolSize, o = e.valueLineWidth, s = e.pathPosition, l = t.valueDim, u = e.repeatTimes || 0, c = 0, f = a[t.valueDim.index] + o + e.symbolMargin * 2;
  for (aw(r, function(g) {
    g.__pictorialAnimationIndex = c, g.__pictorialRepeatTimes = u, c < u ? $u(g, null, p(c), e, n) : $u(g, null, {
      scaleX: 0,
      scaleY: 0
    }, e, n, function() {
      i.remove(g);
    }), c++;
  }); c < u; c++) {
    var h = HB(e);
    h.__pictorialAnimationIndex = c, h.__pictorialRepeatTimes = u, i.add(h);
    var d = p(c);
    $u(h, {
      x: d.x,
      y: d.y,
      scaleX: 0,
      scaleY: 0
    }, {
      scaleX: d.scaleX,
      scaleY: d.scaleY,
      rotation: d.rotation
    }, e, n);
  }
  function p(g) {
    var v = s.slice(), m = e.pxSign, y = g;
    return (e.symbolRepeatDirection === "start" ? m > 0 : m < 0) && (y = u - 1 - g), v[l.index] = f * (y - u / 2 + 0.5) + s[l.index], {
      x: v[0],
      y: v[1],
      scaleX: e.symbolScale[0],
      scaleY: e.symbolScale[1],
      rotation: e.rotation
    };
  }
}
function XB(r, t, e, n) {
  var i = r.__pictorialBundle, a = r.__pictorialMainPath;
  a ? $u(a, null, {
    x: e.pathPosition[0],
    y: e.pathPosition[1],
    scaleX: e.symbolScale[0],
    scaleY: e.symbolScale[1],
    rotation: e.rotation
  }, e, n) : (a = r.__pictorialMainPath = HB(e), i.add(a), $u(a, {
    x: e.pathPosition[0],
    y: e.pathPosition[1],
    scaleX: 0,
    scaleY: 0,
    rotation: e.rotation
  }, {
    scaleX: e.symbolScale[0],
    scaleY: e.symbolScale[1]
  }, e, n));
}
function YB(r, t, e) {
  var n = J({}, t.barRectShape), i = r.__pictorialBarRect;
  i ? $u(i, null, {
    shape: n
  }, t, e) : (i = r.__pictorialBarRect = new te({
    z2: 2,
    shape: n,
    silent: !0,
    style: {
      stroke: "transparent",
      fill: "transparent",
      lineWidth: 0
    }
  }), i.disableMorphing = !0, r.add(i));
}
function $B(r, t, e, n) {
  if (e.symbolClip) {
    var i = r.__pictorialClipPath, a = J({}, e.clipShape), o = t.valueDim, s = e.animationModel, l = e.dataIndex;
    if (i)
      ve(i, {
        shape: a
      }, s, l);
    else {
      a[o.wh] = 0, i = new te({
        shape: a
      }), r.__pictorialBundle.setClipPath(i), r.__pictorialClipPath = i;
      var u = {};
      u[o.wh] = e.clipShape[o.wh], Al[n ? "updateProps" : "initProps"](i, {
        shape: u
      }, s, l);
    }
  }
}
function EL(r, t) {
  var e = r.getItemModel(t);
  return e.getAnimationDelayParams = Hrt, e.isAnimationEnabled = Wrt, e;
}
function Hrt(r) {
  return {
    index: r.__pictorialAnimationIndex,
    count: r.__pictorialRepeatTimes
  };
}
function Wrt() {
  return this.parentModel.isAnimationEnabled() && !!this.getShallow("animation");
}
function CL(r, t, e, n) {
  var i = new Et(), a = new Et();
  return i.add(a), i.__pictorialBundle = a, a.x = e.bundlePosition[0], a.y = e.bundlePosition[1], e.symbolRepeat ? WB(i, t, e) : XB(i, t, e), YB(i, e, n), $B(i, t, e, n), i.__pictorialShapeStr = ZB(r, e), i.__pictorialSymbolMeta = e, i;
}
function Xrt(r, t, e) {
  var n = e.animationModel, i = e.dataIndex, a = r.__pictorialBundle;
  ve(a, {
    x: e.bundlePosition[0],
    y: e.bundlePosition[1]
  }, n, i), e.symbolRepeat ? WB(r, t, e, !0) : XB(r, t, e, !0), YB(r, e, !0), $B(r, t, e, !0);
}
function DL(r, t, e, n) {
  var i = n.__pictorialBarRect;
  i && i.removeTextContent();
  var a = [];
  aw(n, function(o) {
    a.push(o);
  }), n.__pictorialMainPath && a.push(n.__pictorialMainPath), n.__pictorialClipPath && (e = null), L(a, function(o) {
    Go(o, {
      scaleX: 0,
      scaleY: 0
    }, e, t, function() {
      n.parent && n.parent.remove(n);
    });
  }), r.setItemGraphicEl(t, null);
}
function ZB(r, t) {
  return [r.getItemVisual(t.dataIndex, "symbol") || "none", !!t.symbolRepeat, !!t.symbolClip].join(":");
}
function aw(r, t, e) {
  L(r.__pictorialBundle.children(), function(n) {
    n !== r.__pictorialBarRect && t.call(e, n);
  });
}
function $u(r, t, e, n, i, a) {
  t && r.attr(t), n.symbolClip && !i ? e && r.attr(e) : e && Al[i ? "updateProps" : "initProps"](r, e, n.animationModel, n.dataIndex, a);
}
function LL(r, t, e) {
  var n = e.dataIndex, i = e.itemModel, a = i.getModel("emphasis"), o = a.getModel("itemStyle").getItemStyle(), s = i.getModel(["blur", "itemStyle"]).getItemStyle(), l = i.getModel(["select", "itemStyle"]).getItemStyle(), u = i.getShallow("cursor"), c = a.get("focus"), f = a.get("blurScope"), h = a.get("scale");
  aw(r, function(g) {
    if (g instanceof Vr) {
      var v = g.style;
      g.useStyle(J({
        // TODO other properties like dx, dy ?
        image: v.image,
        x: v.x,
        y: v.y,
        width: v.width,
        height: v.height
      }, e.style));
    } else
      g.useStyle(e.style);
    var m = g.ensureState("emphasis");
    m.style = o, h && (m.scaleX = g.scaleX * 1.1, m.scaleY = g.scaleY * 1.1), g.ensureState("blur").style = s, g.ensureState("select").style = l, u && (g.cursor = u), g.z2 = e.z2;
  });
  var d = t.valueDim.posDesc[+(e.boundingLength > 0)], p = r.__pictorialBarRect;
  p.ignoreClip = !0, Er(p, _r(i), {
    labelFetcher: t.seriesModel,
    labelDataIndex: n,
    defaultText: uc(t.seriesModel.getData(), n),
    inheritColor: e.style.fill,
    defaultOpacity: e.style.opacity,
    defaultOutsidePosition: d
  }), Ge(r, c, f, a.get("disabled"));
}
function RL(r) {
  var t = Math.round(r);
  return Math.abs(r - t) < 1e-4 ? t : Math.ceil(r);
}
var Yrt = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.hasSymbolVisual = !0, e.defaultSymbol = "roundRect", e;
    }
    return t.prototype.getInitialData = function(e) {
      return e.stack = null, r.prototype.getInitialData.apply(this, arguments);
    }, t.type = "series.pictorialBar", t.dependencies = ["grid"], t.defaultOption = jo(yh.defaultOption, {
      symbol: "circle",
      symbolSize: null,
      symbolRotate: null,
      symbolPosition: null,
      symbolOffset: null,
      symbolMargin: null,
      symbolRepeat: !1,
      symbolRepeatDirection: "end",
      symbolClip: !1,
      symbolBoundingData: null,
      symbolPatternSize: 400,
      barGap: "-100%",
      // Pictorial bar do not clip by default because in many cases
      // xAxis and yAxis are not displayed and it's expected not to clip
      clip: !1,
      // z can be set in data item, which is z2 actually.
      // Disable progressive
      progressive: 0,
      emphasis: {
        // By default pictorialBar do not hover scale. Hover scale is not suitable
        // for the case that both has foreground and background.
        scale: !1
      },
      select: {
        itemStyle: {
          borderColor: Y.color.primary
        }
      }
    }), t;
  }(yh)
);
function $rt(r) {
  r.registerChartView(Vrt), r.registerSeriesModel(Yrt), r.registerLayout(r.PRIORITY.VISUAL.LAYOUT, Yt(pk, "pictorialBar")), r.registerLayout(r.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, vk("pictorialBar"));
}
var Zrt = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e._layers = [], e;
    }
    return t.prototype.render = function(e, n, i) {
      var a = e.getData(), o = this, s = this.group, l = e.getLayerSeries(), u = a.getLayout("layoutInfo"), c = u.rect, f = u.boundaryGap;
      s.x = 0, s.y = c.y + f[0];
      function h(v) {
        return v.name;
      }
      var d = new Xa(this._layersSeries || [], l, h, h), p = [];
      d.add(mt(g, this, "add")).update(mt(g, this, "update")).remove(mt(g, this, "remove")).execute();
      function g(v, m, y) {
        var _ = o._layers;
        if (v === "remove") {
          s.remove(_[m]);
          return;
        }
        for (var x = [], b = [], S, w = l[m].indices, A = 0; A < w.length; A++) {
          var T = a.getItemLayout(w[A]), M = T.x, E = T.y0, R = T.y;
          x.push(M, E), b.push(M, E + R), S = a.getItemVisual(w[A], "style");
        }
        var C, D = a.getItemLayout(w[0]), I = e.getModel("label"), P = I.get("margin"), O = e.getModel("emphasis");
        if (v === "add") {
          var N = p[m] = new Et();
          C = new a3({
            shape: {
              points: x,
              stackedOnPoints: b,
              smooth: 0.4,
              stackedOnSmooth: 0.4,
              smoothConstraint: !1
            },
            z2: 0
          }), N.add(C), s.add(N), e.isAnimationEnabled() && C.setClipPath(qrt(C.getBoundingRect(), e, function() {
            C.removeClipPath();
          }));
        } else {
          var N = _[y];
          C = N.childAt(0), s.add(N), p[m] = N, ve(C, {
            shape: {
              points: x,
              stackedOnPoints: b
            }
          }, e), ai(C);
        }
        Er(C, _r(e), {
          labelDataIndex: w[A - 1],
          defaultText: a.getName(w[A - 1]),
          inheritColor: S.fill
        }, {
          normal: {
            verticalAlign: "middle"
            // align: 'right'
          }
        }), C.setTextConfig({
          position: null,
          local: !0
        });
        var B = C.getTextContent();
        B && (B.x = D.x - P, B.y = D.y0 + D.y / 2), C.useStyle(S), a.setItemGraphicEl(m, C), yr(C, e), Ge(C, O.get("focus"), O.get("blurScope"), O.get("disabled"));
      }
      this._layersSeries = l, this._layers = p;
    }, t.type = "themeRiver", t;
  }(Re)
);
function qrt(r, t, e) {
  var n = new te({
    shape: {
      x: r.x - 10,
      y: r.y - 10,
      width: 0,
      height: r.height + 20
    }
  });
  return ze(n, {
    shape: {
      x: r.x - 50,
      width: r.width + 100,
      height: r.height + 20
    }
  }, t, e), n;
}
var f_ = 2, Krt = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function(e) {
      r.prototype.init.apply(this, arguments), this.legendVisualProvider = new Nc(mt(this.getData, this), mt(this.getRawData, this));
    }, t.prototype.fixData = function(e) {
      var n = e.length, i = {}, a = xx(e, function(h) {
        return i.hasOwnProperty(h[0] + "") || (i[h[0] + ""] = -1), h[2];
      }), o = [];
      a.buckets.each(function(h, d) {
        o.push({
          name: d,
          dataList: h
        });
      });
      for (var s = o.length, l = 0; l < s; ++l) {
        for (var u = o[l].name, c = 0; c < o[l].dataList.length; ++c) {
          var f = o[l].dataList[c][0] + "";
          i[f] = l;
        }
        for (var f in i)
          i.hasOwnProperty(f) && i[f] !== l && (i[f] = l, e[n] = [f, 0, u], n++);
      }
      return e;
    }, t.prototype.getInitialData = function(e, n) {
      for (var i = this.getReferringComponents("singleAxis", Ke).models[0], a = i.get("type"), o = Te(e.data, function(p) {
        return p[2] !== void 0;
      }), s = this.fixData(o || []), l = [], u = this.nameMap = wt(), c = 0, f = 0; f < s.length; ++f)
        l.push(s[f][f_]), u.get(s[f][f_]) || (u.set(s[f][f_], c), c++);
      var h = Gh(s, {
        coordDimensions: ["single"],
        dimensionsDefine: [{
          name: "time",
          type: qv(a)
        }, {
          name: "value",
          type: "float"
        }, {
          name: "name",
          type: "ordinal"
        }],
        encodeDefine: {
          single: 0,
          value: 1,
          itemName: 2
        }
      }).dimensions, d = new un(h, this);
      return d.initData(s), d;
    }, t.prototype.getLayerSeries = function() {
      for (var e = this.getData(), n = e.count(), i = [], a = 0; a < n; ++a)
        i[a] = a;
      var o = e.mapDimension("single"), s = xx(i, function(u) {
        return e.get("name", u);
      }), l = [];
      return s.buckets.each(function(u, c) {
        u.sort(function(f, h) {
          return e.get(o, f) - e.get(o, h);
        }), l.push({
          name: c,
          indices: u
        });
      }), l;
    }, t.prototype.getAxisTooltipData = function(e, n, i) {
      et(e) || (e = e ? [e] : []);
      for (var a = this.getData(), o = this.getLayerSeries(), s = [], l = o.length, u, c = 0; c < l; ++c) {
        for (var f = Number.MAX_VALUE, h = -1, d = o[c].indices.length, p = 0; p < d; ++p) {
          var g = a.get(e[0], o[c].indices[p]), v = Math.abs(g - n);
          v <= f && (u = g, f = v, h = o[c].indices[p]);
        }
        s.push(h);
      }
      return {
        dataIndices: s,
        nestestValue: u
      };
    }, t.prototype.formatTooltip = function(e, n, i) {
      var a = this.getData(), o = a.getName(e), s = a.get(a.mapDimension("value"), e);
      return cr("nameValue", {
        name: o,
        value: s
      });
    }, t.type = "series.themeRiver", t.dependencies = ["singleAxis"], t.defaultOption = {
      // zlevel: 0,
      z: 2,
      colorBy: "data",
      coordinateSystem: "singleAxis",
      // gap in axis's orthogonal orientation
      boundaryGap: ["10%", "10%"],
      // legendHoverLink: true,
      singleAxisIndex: 0,
      animationEasing: "linear",
      label: {
        margin: 4,
        show: !0,
        position: "left",
        fontSize: 11
      },
      emphasis: {
        label: {
          show: !0
        }
      }
    }, t;
  }(ke)
);
function jrt(r, t) {
  r.eachSeriesByType("themeRiver", function(e) {
    var n = e.getData(), i = e.coordinateSystem, a = {}, o = i.getRect();
    a.rect = o;
    var s = e.get("boundaryGap"), l = i.getAxis();
    if (a.boundaryGap = s, l.orient === "horizontal") {
      s[0] = dt(s[0], o.height), s[1] = dt(s[1], o.height);
      var u = o.height - s[0] - s[1];
      IL(n, e, u);
    } else {
      s[0] = dt(s[0], o.width), s[1] = dt(s[1], o.width);
      var c = o.width - s[0] - s[1];
      IL(n, e, c);
    }
    n.setLayout("layoutInfo", a);
  });
}
function IL(r, t, e) {
  if (r.count())
    for (var n = t.coordinateSystem, i = t.getLayerSeries(), a = r.mapDimension("single"), o = r.mapDimension("value"), s = rt(i, function(v) {
      return rt(v.indices, function(m) {
        var y = n.dataToPoint(r.get(a, m));
        return y[1] = r.get(o, m), y;
      });
    }), l = Jrt(s), u = l.y0, c = e / l.max, f = i.length, h = i[0].indices.length, d, p = 0; p < h; ++p) {
      d = u[p] * c, r.setItemLayout(i[0].indices[p], {
        layerIndex: 0,
        x: s[0][p][0],
        y0: d,
        y: s[0][p][1] * c
      });
      for (var g = 1; g < f; ++g)
        d += s[g - 1][p][1] * c, r.setItemLayout(i[g].indices[p], {
          layerIndex: g,
          x: s[g][p][0],
          y0: d,
          y: s[g][p][1] * c
        });
    }
}
function Jrt(r) {
  for (var t = r.length, e = r[0].length, n = [], i = [], a = 0, o = 0; o < e; ++o) {
    for (var s = 0, l = 0; l < t; ++l)
      s += r[l][o][1];
    s > a && (a = s), n.push(s);
  }
  for (var u = 0; u < e; ++u)
    i[u] = (a - n[u]) / 2;
  a = 0;
  for (var c = 0; c < e; ++c) {
    var f = n[c] + i[c];
    f > a && (a = f);
  }
  return {
    y0: i,
    max: a
  };
}
function Qrt(r) {
  r.registerChartView(Zrt), r.registerSeriesModel(Krt), r.registerLayout(jrt), r.registerProcessor(Ic("themeRiver"));
}
var tnt = 2, ent = 4, PL = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e, n, i, a) {
      var o = r.call(this) || this;
      o.z2 = tnt, o.textConfig = {
        inside: !0
      }, zt(o).seriesIndex = n.seriesIndex;
      var s = new pe({
        z2: ent,
        silent: e.getModel().get(["label", "silent"])
      });
      return o.setTextContent(s), o.updateData(!0, e, n, i, a), o;
    }
    return t.prototype.updateData = function(e, n, i, a, o) {
      this.node = n, n.piece = this, i = i || this._seriesModel, a = a || this._ecModel;
      var s = this;
      zt(s).dataIndex = n.dataIndex;
      var l = n.getModel(), u = l.getModel("emphasis"), c = n.getLayout(), f = J({}, c);
      f.label = null;
      var h = n.getVisual("style");
      h.lineJoin = "bevel";
      var d = n.getVisual("decal");
      d && (h.decal = ac(d, o));
      var p = Ki(l.getModel("itemStyle"), f, !0);
      J(f, p), L(dn, function(y) {
        var _ = s.ensureState(y), x = l.getModel([y, "itemStyle"]);
        _.style = x.getItemStyle();
        var b = Ki(x, f);
        b && (_.shape = b);
      }), e ? (s.setShape(f), s.shape.r = c.r0, ze(s, {
        shape: {
          r: c.r
        }
      }, i, n.dataIndex)) : (ve(s, {
        shape: f
      }, i), ai(s)), s.useStyle(h), this._updateLabel(i);
      var g = l.getShallow("cursor");
      g && s.attr("cursor", g), this._seriesModel = i || this._seriesModel, this._ecModel = a || this._ecModel;
      var v = u.get("focus"), m = v === "relative" ? th(n.getAncestorsIndices(), n.getDescendantIndices()) : v === "ancestor" ? n.getAncestorsIndices() : v === "descendant" ? n.getDescendantIndices() : v;
      Ge(this, m, u.get("blurScope"), u.get("disabled"));
    }, t.prototype._updateLabel = function(e) {
      var n = this, i = this.node.getModel(), a = i.getModel("label"), o = this.node.getLayout(), s = o.endAngle - o.startAngle, l = (o.startAngle + o.endAngle) / 2, u = Math.cos(l), c = Math.sin(l), f = this, h = f.getTextContent(), d = this.node.dataIndex, p = a.get("minAngle") / 180 * Math.PI, g = a.get("show") && !(p != null && Math.abs(s) < p);
      h.ignore = !g, L(ah, function(m) {
        var y = m === "normal" ? i.getModel("label") : i.getModel([m, "label"]), _ = m === "normal", x = _ ? h : h.ensureState(m), b = e.getFormattedLabel(d, m);
        _ && (b = b || n.node.name), x.style = Oe(y, {}, null, m !== "normal", !0), b && (x.style.text = b);
        var S = y.get("show");
        S != null && !_ && (x.ignore = !S);
        var w = v(y, "position"), A = _ ? f : f.states[m], T = A.style.fill;
        A.textConfig = {
          outsideFill: y.get("color") === "inherit" ? T : null,
          inside: w !== "outside"
        };
        var M, E = v(y, "distance") || 0, R = v(y, "align"), C = v(y, "rotate"), D = Math.PI * 0.5, I = Math.PI * 1.5, P = Pn(C === "tangential" ? Math.PI / 2 - l : l), O = P > D && !ih(P - D) && P < I;
        w === "outside" ? (M = o.r + E, R = O ? "right" : "left") : !R || R === "center" ? (s === 2 * Math.PI && o.r0 === 0 ? M = 0 : M = (o.r + o.r0) / 2, R = "center") : R === "left" ? (M = o.r0 + E, R = O ? "right" : "left") : R === "right" && (M = o.r - E, R = O ? "left" : "right"), x.style.align = R, x.style.verticalAlign = v(y, "verticalAlign") || "middle", x.x = M * u + o.cx, x.y = M * c + o.cy;
        var N = 0;
        C === "radial" ? N = Pn(-l) + (O ? Math.PI : 0) : C === "tangential" ? N = Pn(Math.PI / 2 - l) + (O ? Math.PI : 0) : fe(C) && (N = C * Math.PI / 180), x.rotation = Pn(N);
      });
      function v(m, y) {
        var _ = m.get(y);
        return _ ?? a.get(y);
      }
      h.dirtyStyle();
    }, t;
  }(Kr)
), VS = "sunburstRootToNode", NL = "sunburstHighlight", rnt = "sunburstUnhighlight";
function nnt(r) {
  r.registerAction({
    type: VS,
    update: "updateView"
  }, function(t, e) {
    e.eachComponent({
      mainType: "series",
      subType: "sunburst",
      query: t
    }, n);
    function n(i, a) {
      var o = xh(t, [VS], i);
      if (o) {
        var s = i.getViewRoot();
        s && (t.direction = Gb(s, o.node) ? "rollUp" : "drillDown"), i.resetViewRoot(o.node);
      }
    }
  }), r.registerAction({
    type: NL,
    update: "none"
  }, function(t, e, n) {
    t = J({}, t), e.eachComponent({
      mainType: "series",
      subType: "sunburst",
      query: t
    }, i);
    function i(a) {
      var o = xh(t, [NL], a);
      o && (t.dataIndex = o.node.dataIndex);
    }
    process.env.NODE_ENV !== "production" && ar("sunburstHighlight", "highlight"), n.dispatchAction(J(t, {
      type: "highlight"
    }));
  }), r.registerAction({
    type: rnt,
    update: "updateView"
  }, function(t, e, n) {
    t = J({}, t), process.env.NODE_ENV !== "production" && ar("sunburstUnhighlight", "downplay"), n.dispatchAction(J(t, {
      type: "downplay"
    }));
  });
}
var int = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n, i, a) {
      var o = this;
      this.seriesModel = e, this.api = i, this.ecModel = n;
      var s = e.getData(), l = s.tree.root, u = e.getViewRoot(), c = this.group, f = e.get("renderLabelForZeroData"), h = [];
      u.eachNode(function(y) {
        h.push(y);
      });
      var d = this._oldChildren || [];
      p(h, d), m(l, u), this._initEvents(), this._oldChildren = h;
      function p(y, _) {
        if (y.length === 0 && _.length === 0)
          return;
        new Xa(_, y, x, x).add(b).update(b).remove(Yt(b, null)).execute();
        function x(S) {
          return S.getId();
        }
        function b(S, w) {
          var A = S == null ? null : y[S], T = w == null ? null : _[w];
          g(A, T);
        }
      }
      function g(y, _) {
        if (!f && y && !y.getValue() && (y = null), y !== l && _ !== l) {
          if (_ && _.piece)
            y ? (_.piece.updateData(!1, y, e, n, i), s.setItemGraphicEl(y.dataIndex, _.piece)) : v(_);
          else if (y) {
            var x = new PL(y, e, n, i);
            c.add(x), s.setItemGraphicEl(y.dataIndex, x);
          }
        }
      }
      function v(y) {
        y && y.piece && (c.remove(y.piece), y.piece = null);
      }
      function m(y, _) {
        _.depth > 0 ? (o.virtualPiece ? o.virtualPiece.updateData(!1, y, e, n, i) : (o.virtualPiece = new PL(y, e, n, i), c.add(o.virtualPiece)), _.piece.off("click"), o.virtualPiece.on("click", function(x) {
          o._rootToNode(_.parentNode);
        })) : o.virtualPiece && (c.remove(o.virtualPiece), o.virtualPiece = null);
      }
    }, t.prototype._initEvents = function() {
      var e = this;
      this.group.off("click"), this.group.on("click", function(n) {
        var i = !1, a = e.seriesModel.getViewRoot();
        a.eachNode(function(o) {
          if (!i && o.piece && o.piece === n.target) {
            var s = o.getModel().get("nodeClick");
            if (s === "rootToNode")
              e._rootToNode(o);
            else if (s === "link") {
              var l = o.getModel(), u = l.get("link");
              if (u) {
                var c = l.get("target", !0) || "_blank";
                Bv(u, c);
              }
            }
            i = !0;
          }
        });
      });
    }, t.prototype._rootToNode = function(e) {
      e !== this.seriesModel.getViewRoot() && this.api.dispatchAction({
        type: VS,
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: e
      });
    }, t.prototype.containPoint = function(e, n) {
      var i = n.getData(), a = i.getItemLayout(0);
      if (a) {
        var o = e[0] - a.cx, s = e[1] - a.cy, l = Math.sqrt(o * o + s * s);
        return l <= a.r && l >= a.r0;
      }
    }, t.type = "sunburst", t;
  }(Re)
), ant = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.ignoreStyleOnData = !0, e;
    }
    return t.prototype.getInitialData = function(e, n) {
      var i = {
        name: e.name,
        children: e.data
      };
      qB(i);
      var a = this._levelModels = rt(e.levels || [], function(l) {
        return new ue(l, this, n);
      }, this), o = Ub.createTree(i, this, s);
      function s(l) {
        l.wrapMethod("getItemModel", function(u, c) {
          var f = o.getNodeByDataIndex(c), h = a[f.depth];
          return h && (u.parentModel = h), u;
        });
      }
      return o.data;
    }, t.prototype.optionUpdated = function() {
      this.resetViewRoot();
    }, t.prototype.getDataParams = function(e) {
      var n = r.prototype.getDataParams.apply(this, arguments), i = this.getData().tree.getNodeByDataIndex(e);
      return n.treePathInfo = Sm(i, this), n;
    }, t.prototype.getLevelModel = function(e) {
      return this._levelModels && this._levelModels[e.depth];
    }, t.prototype.getViewRoot = function() {
      return this._viewRoot;
    }, t.prototype.resetViewRoot = function(e) {
      e ? this._viewRoot = e : e = this._viewRoot;
      var n = this.getRawData().tree.root;
      (!e || e !== n && !n.contains(e)) && (this._viewRoot = n);
    }, t.prototype.enableAriaDecal = function() {
      Q3(this);
    }, t.type = "series.sunburst", t.defaultOption = {
      // zlevel: 0,
      z: 2,
      // 
      center: ["50%", "50%"],
      radius: [0, "75%"],
      // 
      clockwise: !0,
      startAngle: 90,
      // 0
      minAngle: 0,
      // If still show when all data zero.
      stillShowZeroSum: !0,
      // 'rootToNode', 'link', or false
      nodeClick: "rootToNode",
      renderLabelForZeroData: !1,
      label: {
        // could be: 'radial', 'tangential', or 'none'
        rotate: "radial",
        show: !0,
        opacity: 1,
        // 'left' is for inner side of inside, and 'right' is for outer
        // side for inside
        align: "center",
        position: "inside",
        distance: 5,
        silent: !0
      },
      itemStyle: {
        borderWidth: 1,
        borderColor: "white",
        borderType: "solid",
        shadowBlur: 0,
        shadowColor: "rgba(0, 0, 0, 0.2)",
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        opacity: 1
      },
      emphasis: {
        focus: "descendant"
      },
      blur: {
        itemStyle: {
          opacity: 0.2
        },
        label: {
          opacity: 0.1
        }
      },
      // Animation type can be expansion, scale.
      animationType: "expansion",
      animationDuration: 1e3,
      animationDurationUpdate: 500,
      data: [],
      /**
       * Sort order.
       *
       * Valid values: 'desc', 'asc', null, or callback function.
       * 'desc' and 'asc' for descend and ascendant order;
       * null for not sorting;
       * example of callback function:
       * function(nodeA, nodeB) {
       *     return nodeA.getValue() - nodeB.getValue();
       * }
       */
      sort: "desc"
    }, t;
  }(ke)
);
function qB(r) {
  var t = 0;
  L(r.children, function(n) {
    qB(n);
    var i = n.value;
    et(i) && (i = i[0]), t += i;
  });
  var e = r.value;
  et(e) && (e = e[0]), (e == null || isNaN(e)) && (e = t), e < 0 && (e = 0), et(r.value) ? r.value[0] = e : r.value = e;
}
var OL = Math.PI / 180;
function ont(r, t, e) {
  t.eachSeriesByType(r, function(n) {
    var i = n.get("center"), a = n.get("radius");
    et(a) || (a = [0, a]), et(i) || (i = [i, i]);
    var o = e.getWidth(), s = e.getHeight(), l = Math.min(o, s), u = dt(i[0], o), c = dt(i[1], s), f = dt(a[0], l / 2), h = dt(a[1], l / 2), d = -n.get("startAngle") * OL, p = n.get("minAngle") * OL, g = n.getData().tree.root, v = n.getViewRoot(), m = v.depth, y = n.get("sort");
    y != null && KB(v, y);
    var _ = 0;
    L(v.children, function(P) {
      !isNaN(P.getValue()) && _++;
    });
    var x = v.getValue(), b = Math.PI / (x || _) * 2, S = v.depth > 0, w = v.height - (S ? -1 : 1), A = (h - f) / (w || 1), T = n.get("clockwise"), M = n.get("stillShowZeroSum"), E = T ? 1 : -1, R = function(P, O) {
      if (P) {
        var N = O;
        if (P !== g) {
          var B = P.getValue(), F = x === 0 && M ? b : B * b;
          F < p && (F = p), N = O + E * F;
          var G = P.depth - m - (S ? -1 : 1), X = f + A * G, K = f + A * (G + 1), U = n.getLevelModel(P);
          if (U) {
            var $ = U.get("r0", !0), ct = U.get("r", !0), at = U.get("radius", !0);
            at != null && ($ = at[0], ct = at[1]), $ != null && (X = dt($, l / 2)), ct != null && (K = dt(ct, l / 2));
          }
          P.setLayout({
            angle: F,
            startAngle: O,
            endAngle: N,
            clockwise: T,
            cx: u,
            cy: c,
            r0: X,
            r: K
          });
        }
        if (P.children && P.children.length) {
          var lt = 0;
          L(P.children, function(ot) {
            lt += R(ot, O + lt);
          });
        }
        return N - O;
      }
    };
    if (S) {
      var C = f, D = f + A, I = Math.PI * 2;
      g.setLayout({
        angle: I,
        startAngle: d,
        endAngle: d + I,
        clockwise: T,
        cx: u,
        cy: c,
        r0: C,
        r: D
      });
    }
    R(v, d);
  });
}
function KB(r, t) {
  var e = r.children || [];
  r.children = snt(e, t), e.length && L(r.children, function(n) {
    KB(n, t);
  });
}
function snt(r, t) {
  if (Tt(t)) {
    var e = rt(r, function(i, a) {
      var o = i.getValue();
      return {
        params: {
          depth: i.depth,
          height: i.height,
          dataIndex: i.dataIndex,
          getValue: function() {
            return o;
          }
        },
        index: a
      };
    });
    return e.sort(function(i, a) {
      return t(i.params, a.params);
    }), rt(e, function(i) {
      return r[i.index];
    });
  } else {
    var n = t === "asc";
    return r.sort(function(i, a) {
      var o = (i.getValue() - a.getValue()) * (n ? 1 : -1);
      return o === 0 ? (i.dataIndex - a.dataIndex) * (n ? -1 : 1) : o;
    });
  }
}
function lnt(r) {
  var t = {};
  function e(n, i, a) {
    if (n.depth === 0)
      return Y.color.neutral50;
    for (var o = n; o && o.depth > 1; )
      o = o.parentNode;
    var s = i.getColorFromPalette(o.name || o.dataIndex + "", t);
    return n.depth > 1 && pt(s) && (s = sx(s, (n.depth - 1) / (a - 1) * 0.5)), s;
  }
  r.eachSeriesByType("sunburst", function(n) {
    var i = n.getData(), a = i.tree;
    a.eachNode(function(o) {
      var s = o.getModel(), l = s.getModel("itemStyle").getItemStyle();
      l.fill || (l.fill = e(o, n, a.root.height));
      var u = i.ensureUniqueItemVisual(o.dataIndex, "style");
      J(u, l);
    });
  });
}
function unt(r) {
  r.registerChartView(int), r.registerSeriesModel(ant), r.registerLayout(Yt(ont, "sunburst")), r.registerProcessor(Yt(Ic, "sunburst")), r.registerVisual(lnt), nnt(r);
}
var kL = {
  color: "fill",
  borderColor: "stroke"
}, cnt = {
  symbol: 1,
  symbolSize: 1,
  symbolKeepAspect: 1,
  legendIcon: 1,
  visualMeta: 1,
  liftZ: 1,
  decal: 1
}, Oa = ee(), fnt = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.optionUpdated = function() {
      this.currentZLevel = this.get("zlevel", !0), this.currentZ = this.get("z", !0);
    }, t.prototype.getInitialData = function(e, n) {
      return ja(null, this);
    }, t.prototype.getDataParams = function(e, n, i) {
      var a = r.prototype.getDataParams.call(this, e, n);
      return i && (a.info = Oa(i).info), a;
    }, t.type = "series.custom", t.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar", "matrix"], t.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      // Custom series will not clip by default.
      // Some case will use custom series to draw label
      // For example https://echarts.apache.org/examples/en/editor.html?c=custom-gantt-flight
      clip: !1
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // Polar coordinate system
      // polarIndex: 0,
      // Geo coordinate system
      // geoIndex: 0,
    }, t;
  }(ke)
);
function hnt(r, t) {
  return t = t || [0, 0], rt(["x", "y"], function(e, n) {
    var i = this.getAxis(e), a = t[n], o = r[n] / 2;
    return i.type === "category" ? i.getBandWidth() : Math.abs(i.dataToCoord(a - o) - i.dataToCoord(a + o));
  }, this);
}
function dnt(r) {
  var t = r.master.getRect();
  return {
    coordSys: {
      // The name exposed to user is always 'cartesian2d' but not 'grid'.
      type: "cartesian2d",
      x: t.x,
      y: t.y,
      width: t.width,
      height: t.height
    },
    api: {
      coord: function(e) {
        return r.dataToPoint(e);
      },
      size: mt(hnt, r)
    }
  };
}
function pnt(r, t) {
  return t = t || [0, 0], rt([0, 1], function(e) {
    var n = t[e], i = r[e] / 2, a = [], o = [];
    return a[e] = n - i, o[e] = n + i, a[1 - e] = o[1 - e] = t[1 - e], Math.abs(this.dataToPoint(a)[e] - this.dataToPoint(o)[e]);
  }, this);
}
function vnt(r) {
  var t = r.getBoundingRect();
  return {
    coordSys: {
      type: "geo",
      x: t.x,
      y: t.y,
      width: t.width,
      height: t.height,
      zoom: r.getZoom()
    },
    api: {
      coord: function(e) {
        return r.dataToPoint(e);
      },
      size: mt(pnt, r)
    }
  };
}
function gnt(r, t) {
  var e = this.getAxis(), n = t instanceof Array ? t[0] : t, i = (r instanceof Array ? r[0] : r) / 2;
  return e.type === "category" ? e.getBandWidth() : Math.abs(e.dataToCoord(n - i) - e.dataToCoord(n + i));
}
function mnt(r) {
  var t = r.getRect();
  return {
    coordSys: {
      type: "singleAxis",
      x: t.x,
      y: t.y,
      width: t.width,
      height: t.height
    },
    api: {
      coord: function(e) {
        return r.dataToPoint(e);
      },
      size: mt(gnt, r)
    }
  };
}
function ynt(r, t) {
  return t = t || [0, 0], rt(["Radius", "Angle"], function(e, n) {
    var i = "get" + e + "Axis", a = this[i](), o = t[n], s = r[n] / 2, l = a.type === "category" ? a.getBandWidth() : Math.abs(a.dataToCoord(o - s) - a.dataToCoord(o + s));
    return e === "Angle" && (l = l * Math.PI / 180), l;
  }, this);
}
function _nt(r) {
  var t = r.getRadiusAxis(), e = r.getAngleAxis(), n = t.getExtent();
  return n[0] > n[1] && n.reverse(), {
    coordSys: {
      type: "polar",
      cx: r.cx,
      cy: r.cy,
      r: n[1],
      r0: n[0]
    },
    api: {
      coord: function(i) {
        var a = t.dataToRadius(i[0]), o = e.dataToAngle(i[1]), s = r.coordToPoint([a, o]);
        return s.push(a, o * Math.PI / 180), s;
      },
      size: mt(ynt, r)
    }
  };
}
function xnt(r) {
  var t = r.getRect(), e = r.getRangeInfo();
  return {
    coordSys: {
      type: "calendar",
      x: t.x,
      y: t.y,
      width: t.width,
      height: t.height,
      cellWidth: r.getCellWidth(),
      cellHeight: r.getCellHeight(),
      rangeInfo: {
        start: e.start,
        end: e.end,
        weeks: e.weeks,
        dayCount: e.allDay
      }
    },
    api: {
      coord: function(n, i) {
        return r.dataToPoint(n, i);
      },
      layout: function(n, i) {
        return r.dataToLayout(n, i);
      }
    }
  };
}
function Snt(r) {
  var t = r.getRect();
  return {
    coordSys: {
      type: "matrix",
      x: t.x,
      y: t.y,
      width: t.width,
      height: t.height
    },
    api: {
      coord: function(e, n) {
        return r.dataToPoint(e, n);
      },
      layout: function(e, n) {
        return r.dataToLayout(e, n);
      }
    }
  };
}
var BL = {};
function jB(r, t, e, n) {
  return r && (r.legacy || r.legacy !== !1 && !e && !n && t !== "tspan" && (t === "text" || _t(r, "text")));
}
function JB(r, t, e) {
  var n = r, i, a, o;
  if (t === "text")
    o = n;
  else {
    o = {}, _t(n, "text") && (o.text = n.text), _t(n, "rich") && (o.rich = n.rich), _t(n, "textFill") && (o.fill = n.textFill), _t(n, "textStroke") && (o.stroke = n.textStroke), _t(n, "fontFamily") && (o.fontFamily = n.fontFamily), _t(n, "fontSize") && (o.fontSize = n.fontSize), _t(n, "fontStyle") && (o.fontStyle = n.fontStyle), _t(n, "fontWeight") && (o.fontWeight = n.fontWeight), a = {
      type: "text",
      style: o,
      // ec4 does not support rectText trigger.
      // And when text position is different in normal and emphasis
      // => hover text trigger emphasis;
      // => text position changed, leave mouse pointer immediately;
      // That might cause incorrect state.
      silent: !0
    }, i = {};
    var s = _t(n, "textPosition");
    e ? i.position = s ? n.textPosition : "inside" : s && (i.position = n.textPosition), _t(n, "textPosition") && (i.position = n.textPosition), _t(n, "textOffset") && (i.offset = n.textOffset), _t(n, "textRotation") && (i.rotation = n.textRotation), _t(n, "textDistance") && (i.distance = n.textDistance);
  }
  return VL(o, r), L(o.rich, function(l) {
    VL(l, l);
  }), {
    textConfig: i,
    textContent: a
  };
}
function VL(r, t) {
  t && (t.font = t.textFont || t.font, _t(t, "textStrokeWidth") && (r.lineWidth = t.textStrokeWidth), _t(t, "textAlign") && (r.align = t.textAlign), _t(t, "textVerticalAlign") && (r.verticalAlign = t.textVerticalAlign), _t(t, "textLineHeight") && (r.lineHeight = t.textLineHeight), _t(t, "textWidth") && (r.width = t.textWidth), _t(t, "textHeight") && (r.height = t.textHeight), _t(t, "textBackgroundColor") && (r.backgroundColor = t.textBackgroundColor), _t(t, "textPadding") && (r.padding = t.textPadding), _t(t, "textBorderColor") && (r.borderColor = t.textBorderColor), _t(t, "textBorderWidth") && (r.borderWidth = t.textBorderWidth), _t(t, "textBorderRadius") && (r.borderRadius = t.textBorderRadius), _t(t, "textBoxShadowColor") && (r.shadowColor = t.textBoxShadowColor), _t(t, "textBoxShadowBlur") && (r.shadowBlur = t.textBoxShadowBlur), _t(t, "textBoxShadowOffsetX") && (r.shadowOffsetX = t.textBoxShadowOffsetX), _t(t, "textBoxShadowOffsetY") && (r.shadowOffsetY = t.textBoxShadowOffsetY));
}
function FL(r, t, e) {
  var n = r;
  n.textPosition = n.textPosition || e.position || "inside", e.offset != null && (n.textOffset = e.offset), e.rotation != null && (n.textRotation = e.rotation), e.distance != null && (n.textDistance = e.distance);
  var i = n.textPosition.indexOf("inside") >= 0, a = r.fill || Y.color.neutral99;
  zL(n, t);
  var o = n.textFill == null;
  return i ? o && (n.textFill = e.insideFill || Y.color.neutral00, !n.textStroke && e.insideStroke && (n.textStroke = e.insideStroke), !n.textStroke && (n.textStroke = a), n.textStrokeWidth == null && (n.textStrokeWidth = 2)) : (o && (n.textFill = r.fill || e.outsideFill || Y.color.neutral00), !n.textStroke && e.outsideStroke && (n.textStroke = e.outsideStroke)), n.text = t.text, n.rich = t.rich, L(t.rich, function(s) {
    zL(s, s);
  }), n;
}
function zL(r, t) {
  t && (_t(t, "fill") && (r.textFill = t.fill), _t(t, "stroke") && (r.textStroke = t.fill), _t(t, "lineWidth") && (r.textStrokeWidth = t.lineWidth), _t(t, "font") && (r.font = t.font), _t(t, "fontStyle") && (r.fontStyle = t.fontStyle), _t(t, "fontWeight") && (r.fontWeight = t.fontWeight), _t(t, "fontSize") && (r.fontSize = t.fontSize), _t(t, "fontFamily") && (r.fontFamily = t.fontFamily), _t(t, "align") && (r.textAlign = t.align), _t(t, "verticalAlign") && (r.textVerticalAlign = t.verticalAlign), _t(t, "lineHeight") && (r.textLineHeight = t.lineHeight), _t(t, "width") && (r.textWidth = t.width), _t(t, "height") && (r.textHeight = t.height), _t(t, "backgroundColor") && (r.textBackgroundColor = t.backgroundColor), _t(t, "padding") && (r.textPadding = t.padding), _t(t, "borderColor") && (r.textBorderColor = t.borderColor), _t(t, "borderWidth") && (r.textBorderWidth = t.borderWidth), _t(t, "borderRadius") && (r.textBorderRadius = t.borderRadius), _t(t, "shadowColor") && (r.textBoxShadowColor = t.shadowColor), _t(t, "shadowBlur") && (r.textBoxShadowBlur = t.shadowBlur), _t(t, "shadowOffsetX") && (r.textBoxShadowOffsetX = t.shadowOffsetX), _t(t, "shadowOffsetY") && (r.textBoxShadowOffsetY = t.shadowOffsetY), _t(t, "textShadowColor") && (r.textShadowColor = t.textShadowColor), _t(t, "textShadowBlur") && (r.textShadowBlur = t.textShadowBlur), _t(t, "textShadowOffsetX") && (r.textShadowOffsetX = t.textShadowOffsetX), _t(t, "textShadowOffsetY") && (r.textShadowOffsetY = t.textShadowOffsetY));
}
function UL(r, t) {
  if (process.env.NODE_ENV !== "production") {
    var e = r + "^_^" + t;
    BL[e] || (console.warn('[ECharts] DEPRECATED: "' + r + '" has been deprecated. ' + t), BL[e] = !0);
  }
}
var QB = {
  position: ["x", "y"],
  scale: ["scaleX", "scaleY"],
  origin: ["originX", "originY"]
}, GL = se(QB), dg = ea(na, function(r, t) {
  return r[t] = 1, r;
}, {}), HL = na.join(", "), pg = ["", "style", "shape", "extra"], dc = ee();
function ow(r, t, e, n, i) {
  var a = r + "Animation", o = Mc(r, n, i) || {}, s = dc(t).userDuring;
  return o.duration > 0 && (o.during = s ? mt(Ant, {
    el: t,
    userDuring: s
  }) : null, o.setToFinal = !0, o.scope = r), J(o, e[a]), o;
}
function nv(r, t, e, n) {
  n = n || {};
  var i = n.dataIndex, a = n.isInit, o = n.clearStyle, s = e.isAnimationEnabled(), l = dc(r), u = t.style;
  l.userDuring = t.during;
  var c = {}, f = {};
  if (Cnt(r, t, f), r.type === "compound")
    for (var h = r.shape.paths, d = t.shape.paths, p = 0; p < d.length; p++) {
      var g = d[p];
      h_("shape", g, h[p]);
    }
  else
    h_("shape", t, f), h_("extra", t, f);
  if (!a && s && (Ent(r, t, c), WL("shape", r, t, c), WL("extra", r, t, c), Dnt(r, t, u, c)), f.style = u, bnt(r, f, o), Mnt(r, t), s)
    if (a) {
      var v = {};
      L(pg, function(y) {
        var _ = y ? t[y] : t;
        _ && _.enterFrom && (y && (v[y] = v[y] || {}), J(y ? v[y] : v, _.enterFrom));
      });
      var m = ow("enter", r, t, e, i);
      m.duration > 0 && r.animateFrom(v, m);
    } else
      wnt(r, t, i || 0, e, c);
  tV(r, t), u ? r.dirty() : r.markRedraw();
}
function tV(r, t) {
  for (var e = dc(r).leaveToProps, n = 0; n < pg.length; n++) {
    var i = pg[n], a = i ? t[i] : t;
    a && a.leaveTo && (e || (e = dc(r).leaveToProps = {}), i && (e[i] = e[i] || {}), J(i ? e[i] : e, a.leaveTo));
  }
}
function Mm(r, t, e, n) {
  if (r) {
    var i = r.parent, a = dc(r).leaveToProps;
    if (a) {
      var o = ow("update", r, t, e, 0);
      o.done = function() {
        i && i.remove(r);
      }, r.animateTo(a, o);
    } else
      i && i.remove(r);
  }
}
function ul(r) {
  return r === "all";
}
function bnt(r, t, e) {
  var n = t.style;
  if (!r.isGroup && n) {
    if (e) {
      r.useStyle({});
      for (var i = r.animators, a = 0; a < i.length; a++) {
        var o = i[a];
        o.targetName === "style" && o.changeTarget(r.style);
      }
    }
    r.setStyle(n);
  }
  t && (t.style = null, t && r.attr(t), t.style = n);
}
function wnt(r, t, e, n, i) {
  if (i) {
    var a = ow("update", r, t, n, e);
    a.duration > 0 && r.animateFrom(i, a);
  }
}
function Mnt(r, t) {
  _t(t, "silent") && (r.silent = t.silent), _t(t, "ignore") && (r.ignore = t.ignore), r instanceof ii && _t(t, "invisible") && (r.invisible = t.invisible), r instanceof ne && _t(t, "autoBatch") && (r.autoBatch = t.autoBatch);
}
var Oi = {}, Tnt = {
  // Usually other props do not need to be changed in animation during.
  setTransform: function(r, t) {
    return process.env.NODE_ENV !== "production" && St(_t(dg, r), "Only " + HL + " available in `setTransform`."), Oi.el[r] = t, this;
  },
  getTransform: function(r) {
    return process.env.NODE_ENV !== "production" && St(_t(dg, r), "Only " + HL + " available in `getTransform`."), Oi.el[r];
  },
  setShape: function(r, t) {
    process.env.NODE_ENV !== "production" && _u(r);
    var e = Oi.el, n = e.shape || (e.shape = {});
    return n[r] = t, e.dirtyShape && e.dirtyShape(), this;
  },
  getShape: function(r) {
    process.env.NODE_ENV !== "production" && _u(r);
    var t = Oi.el.shape;
    if (t)
      return t[r];
  },
  setStyle: function(r, t) {
    process.env.NODE_ENV !== "production" && _u(r);
    var e = Oi.el, n = e.style;
    return n && (process.env.NODE_ENV !== "production" && Or(t) && Xe("style." + r + " must not be assigned with NaN."), n[r] = t, e.dirtyStyle && e.dirtyStyle()), this;
  },
  getStyle: function(r) {
    process.env.NODE_ENV !== "production" && _u(r);
    var t = Oi.el.style;
    if (t)
      return t[r];
  },
  setExtra: function(r, t) {
    process.env.NODE_ENV !== "production" && _u(r);
    var e = Oi.el.extra || (Oi.el.extra = {});
    return e[r] = t, this;
  },
  getExtra: function(r) {
    process.env.NODE_ENV !== "production" && _u(r);
    var t = Oi.el.extra;
    if (t)
      return t[r];
  }
};
function _u(r) {
  if (process.env.NODE_ENV !== "production" && (r === "transition" || r === "enterFrom" || r === "leaveTo"))
    throw new Error('key must not be "' + r + '"');
}
function Ant() {
  var r = this, t = r.el;
  if (t) {
    var e = dc(t).userDuring, n = r.userDuring;
    if (e !== n) {
      r.el = r.userDuring = null;
      return;
    }
    Oi.el = t, n(Tnt);
  }
}
function WL(r, t, e, n) {
  var i = e[r];
  if (i) {
    var a = t[r], o;
    if (a) {
      var s = e.transition, l = i.transition;
      if (l)
        if (!o && (o = n[r] = {}), ul(l))
          J(o, a);
        else
          for (var u = Ie(l), c = 0; c < u.length; c++) {
            var f = u[c], h = a[f];
            o[f] = h;
          }
      else if (ul(s) || Zt(s, r) >= 0) {
        !o && (o = n[r] = {});
        for (var d = se(a), c = 0; c < d.length; c++) {
          var f = d[c], h = a[f];
          Lnt(i[f], h) && (o[f] = h);
        }
      }
    }
  }
}
function h_(r, t, e) {
  var n = t[r];
  if (n)
    for (var i = e[r] = {}, a = se(n), o = 0; o < a.length; o++) {
      var s = a[o];
      i[s] = Hf(n[s]);
    }
}
function Ent(r, t, e) {
  for (var n = t.transition, i = ul(n) ? na : Ie(n || []), a = 0; a < i.length; a++) {
    var o = i[a];
    if (!(o === "style" || o === "shape" || o === "extra")) {
      var s = r[o];
      process.env.NODE_ENV !== "production" && eV(o, "el.transition"), e[o] = s;
    }
  }
}
function Cnt(r, t, e) {
  for (var n = 0; n < GL.length; n++) {
    var i = GL[n], a = QB[i], o = t[i];
    o && (e[a[0]] = o[0], e[a[1]] = o[1]);
  }
  for (var n = 0; n < na.length; n++) {
    var s = na[n];
    t[s] != null && (e[s] = t[s]);
  }
}
function Dnt(r, t, e, n) {
  if (e) {
    var i = r.style, a;
    if (i) {
      var o = e.transition, s = t.transition;
      if (o && !ul(o)) {
        var l = Ie(o);
        !a && (a = n.style = {});
        for (var u = 0; u < l.length; u++) {
          var c = l[u], f = i[c];
          a[c] = f;
        }
      } else if (r.getAnimationStyleProps && (ul(s) || ul(o) || Zt(s, "style") >= 0)) {
        var h = r.getAnimationStyleProps(), d = h ? h.style : null;
        if (d) {
          !a && (a = n.style = {});
          for (var p = se(e), u = 0; u < p.length; u++) {
            var c = p[u];
            if (d[c]) {
              var f = i[c];
              a[c] = f;
            }
          }
        }
      }
    }
  }
}
function Lnt(r, t) {
  return qr(r) ? r !== t : r != null && isFinite(r);
}
var eV;
process.env.NODE_ENV !== "production" && (eV = function(r, t) {
  _t(dg, r) || Xe("Prop `" + r + "` is not a permitted in `" + t + "`. Only `" + se(dg).join("`, `") + "` are permitted.");
});
var rV = ee(), Rnt = ["percent", "easing", "shape", "style", "extra"];
function nV(r) {
  r.stopAnimation("keyframe"), r.attr(rV(r));
}
function vg(r, t, e) {
  if (!(!e.isAnimationEnabled() || !t)) {
    if (et(t)) {
      L(t, function(s) {
        vg(r, s, e);
      });
      return;
    }
    var n = t.keyframes, i = t.duration;
    if (e && i == null) {
      var a = Mc("enter", e, 0);
      i = a && a.duration;
    }
    if (!(!n || !i)) {
      var o = rV(r);
      L(pg, function(s) {
        if (!(s && !r[s])) {
          var l, u = !1;
          n.sort(function(c, f) {
            return c.percent - f.percent;
          }), L(n, function(c) {
            var f = r.animators, h = s ? c[s] : c;
            if (process.env.NODE_ENV !== "production" && c.percent >= 1 && (u = !0), !!h) {
              var d = se(h);
              if (s || (d = Te(d, function(v) {
                return Zt(Rnt, v) < 0;
              })), !!d.length) {
                l || (l = r.animate(s, t.loop, !0), l.scope = "keyframe");
                for (var p = 0; p < f.length; p++)
                  f[p] !== l && f[p].targetName === l.targetName && f[p].stopTracks(d);
                s && (o[s] = o[s] || {});
                var g = s ? o[s] : o;
                L(d, function(v) {
                  g[v] = ((s ? r[s] : r) || {})[v];
                }), l.whenWithKeys(i * c.percent, h, d, c.easing);
              }
            }
          }), l && (process.env.NODE_ENV !== "production" && (u || Xe("End frame with percent: 1 is missing in the keyframeAnimation.", !0)), l.delay(t.delay || 0).duration(i).start(t.easing));
        }
      });
    }
  }
}
var ka = "emphasis", Eo = "normal", sw = "blur", lw = "select", $o = [Eo, ka, sw, lw], d_ = {
  normal: ["itemStyle"],
  emphasis: [ka, "itemStyle"],
  blur: [sw, "itemStyle"],
  select: [lw, "itemStyle"]
}, p_ = {
  normal: ["label"],
  emphasis: [ka, "label"],
  blur: [sw, "label"],
  select: [lw, "label"]
}, Int = ["x", "y"], Pnt = "e\0\0", Wn = {
  normal: {},
  emphasis: {},
  blur: {},
  select: {}
}, XL = {
  cartesian2d: dnt,
  geo: vnt,
  single: mnt,
  polar: _nt,
  calendar: xnt,
  matrix: Snt
};
function gg(r) {
  return r instanceof ne;
}
function FS(r) {
  return r instanceof ii;
}
function Nnt(r, t) {
  t.copyTransform(r), FS(t) && FS(r) && (t.setStyle(r.style), t.z = r.z, t.z2 = r.z2, t.zlevel = r.zlevel, t.invisible = r.invisible, t.ignore = r.ignore, gg(t) && gg(r) && t.setShape(r.shape));
}
var Ont = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n, i, a) {
      this._progressiveEls = null;
      var o = this._data, s = e.getData(), l = this.group, u = YL(e, s, n, i);
      o || l.removeAll(), s.diff(o).add(function(f) {
        v_(i, null, f, u(f, a), e, l, s);
      }).remove(function(f) {
        var h = o.getItemGraphicEl(f);
        h && Mm(h, Oa(h).option, e);
      }).update(function(f, h) {
        var d = o.getItemGraphicEl(h);
        v_(i, d, f, u(f, a), e, l, s);
      }).execute();
      var c = e.get("clip", !0) ? Yh(e.coordinateSystem, !1, e) : null;
      c ? l.setClipPath(c) : l.removeClipPath(), this._data = s;
    }, t.prototype.incrementalPrepareRender = function(e, n, i) {
      this.group.removeAll(), this._data = null;
    }, t.prototype.incrementalRender = function(e, n, i, a, o) {
      var s = n.getData(), l = YL(n, s, i, a), u = this._progressiveEls = [];
      function c(d) {
        d.isGroup || (d.incremental = !0, d.ensureState("emphasis").hoverLayer = !0);
      }
      for (var f = e.start; f < e.end; f++) {
        var h = v_(null, null, f, l(f, o), n, this.group, s);
        h && (h.traverse(c), u.push(h));
      }
    }, t.prototype.eachRendered = function(e) {
      Ko(this._progressiveEls || this.group, e);
    }, t.prototype.filterForExposedEvent = function(e, n, i, a) {
      var o = n.element;
      if (o == null || i.name === o)
        return !0;
      for (; (i = i.__hostTarget || i.parent) && i !== this.group; )
        if (i.name === o)
          return !0;
      return !1;
    }, t.type = "custom", t;
  }(Re)
);
function uw(r) {
  var t = r.type, e;
  if (t === "path") {
    var n = r.shape, i = n.width != null && n.height != null ? {
      x: n.x || 0,
      y: n.y || 0,
      width: n.width,
      height: n.height
    } : null, a = oV(n);
    e = oh(a, null, i, n.layout || "center"), Oa(e).customPathData = a;
  } else if (t === "image")
    e = new Vr({}), Oa(e).customImagePath = r.style.image;
  else if (t === "text")
    e = new pe({});
  else if (t === "group")
    e = new Et();
  else if (t === "compoundPath") {
    var n = r.shape;
    if (!n || !n.paths) {
      var o = "";
      process.env.NODE_ENV !== "production" && (o = "shape.paths must be specified in compoundPath"), we(o);
    }
    var s = rt(n.paths, function(c) {
      if (c.type === "path")
        return oh(c.shape.pathData, c, null);
      var f = Nv(c.type);
      if (!f) {
        var h = "";
        process.env.NODE_ENV !== "production" && (h = 'graphic type "' + t + '" can not be found.'), we(h);
      }
      return new f();
    });
    e = new im({
      shape: {
        paths: s
      }
    });
  } else {
    var l = Nv(t);
    if (!l) {
      var o = "";
      process.env.NODE_ENV !== "production" && (o = 'graphic type "' + t + '" can not be found.'), we(o);
    }
    e = new l();
  }
  return Oa(e).customGraphicType = t, e.name = r.name, e.z2EmphasisLift = 1, e.z2SelectLift = 1, e;
}
function cw(r, t, e, n, i, a, o) {
  nV(t);
  var s = i && i.normal.cfg;
  s && t.setTextConfig(s), n && n.transition == null && (n.transition = Int);
  var l = n && n.style;
  if (l) {
    if (t.type === "text") {
      var u = l;
      _t(u, "textFill") && (u.fill = u.textFill), _t(u, "textStroke") && (u.stroke = u.textStroke);
    }
    var c = void 0, f = gg(t) ? l.decal : null;
    r && f && (f.dirty = !0, c = ac(f, r)), l.__decalPattern = c;
  }
  if (FS(t) && l) {
    var c = l.__decalPattern;
    c && (l.decal = c);
  }
  nv(t, n, a, {
    dataIndex: e,
    isInit: o,
    clearStyle: !0
  }), vg(t, n.keyframeAnimation, a);
}
function iV(r, t, e, n, i) {
  var a = t.isGroup ? null : t, o = i && i[r].cfg;
  if (a) {
    var s = a.ensureState(r);
    if (n === !1) {
      var l = a.getState(r);
      l && (l.style = null);
    } else
      s.style = n || null;
    o && (s.textConfig = o), vl(a);
  }
}
function knt(r, t, e) {
  if (!r.isGroup) {
    var n = r, i = e.currentZ, a = e.currentZLevel;
    n.z = i, n.zlevel = a;
    var o = t.z2;
    o != null && (n.z2 = o || 0);
    for (var s = 0; s < $o.length; s++)
      Bnt(n, t, $o[s]);
  }
}
function Bnt(r, t, e) {
  var n = e === Eo, i = n ? t : mg(t, e), a = i ? i.z2 : null, o;
  a != null && (o = n ? r : r.ensureState(e), o.z2 = a || 0);
}
function YL(r, t, e, n) {
  var i = r.get("renderItem");
  if (typeof i == "string") {
    var a = YY(i);
    a ? i = a : process.env.NODE_ENV !== "production" && console.warn("Custom series renderItem '" + i + `' not found.
                Call 'echarts.registerCustomSeries' to register it.`);
  }
  var o = r.coordinateSystem, s = {};
  o && (process.env.NODE_ENV !== "production" && (St(i, "series.render is required."), St(o.prepareCustoms || XL[o.type], "This coordSys does not support custom series.")), s = o.prepareCustoms ? o.prepareCustoms(o) : XL[o.type](o));
  for (var l = kt({
    getWidth: n.getWidth,
    getHeight: n.getHeight,
    getZr: n.getZr,
    getDevicePixelRatio: n.getDevicePixelRatio,
    value: b,
    style: w,
    ordinalRawValue: S,
    styleEmphasis: A,
    visual: E,
    barLayout: R,
    currentSeriesIndices: C,
    font: D
  }, s.api || {}), u = {
    // The life cycle of context: current round of rendering.
    // The global life cycle is probably not necessary, because
    // user can store global status by themselves.
    context: {},
    seriesId: r.id,
    seriesName: r.name,
    seriesIndex: r.seriesIndex,
    coordSys: s.coordSys,
    dataInsideLength: t.count(),
    encode: Vnt(r.getData()),
    itemPayload: r.get("itemPayload") || {}
  }, c, f, h = {}, d = {}, p = {}, g = {}, v = 0; v < $o.length; v++) {
    var m = $o[v];
    p[m] = r.getModel(d_[m]), g[m] = r.getModel(p_[m]);
  }
  function y(I) {
    return I === c ? f || (f = t.getItemModel(I)) : t.getItemModel(I);
  }
  function _(I, P) {
    return t.hasItemOption ? I === c ? h[P] || (h[P] = y(I).getModel(d_[P])) : y(I).getModel(d_[P]) : p[P];
  }
  function x(I, P) {
    return t.hasItemOption ? I === c ? d[P] || (d[P] = y(I).getModel(p_[P])) : y(I).getModel(p_[P]) : g[P];
  }
  return function(I, P) {
    return c = I, f = null, h = {}, d = {}, i && i(kt({
      dataIndexInside: I,
      dataIndex: t.getRawIndex(I),
      // Can be used for optimization when zoom or roam.
      actionType: P ? P.type : null
    }, u), l);
  };
  function b(I, P) {
    return P == null && (P = c), t.getStore().get(t.getDimensionIndex(I || 0), P);
  }
  function S(I, P) {
    P == null && (P = c), I = I || 0;
    var O = t.getDimensionInfo(I);
    if (!O) {
      var N = t.getDimensionIndex(I);
      return N >= 0 ? t.getStore().get(N, P) : void 0;
    }
    var B = t.get(O.name, P), F = O && O.ordinalMeta;
    return F ? F.categories[B] : B;
  }
  function w(I, P) {
    process.env.NODE_ENV !== "production" && UL("api.style", "Please write literal style directly instead."), P == null && (P = c);
    var O = t.getItemVisual(P, "style"), N = O && O.fill, B = O && O.opacity, F = _(P, Eo).getItemStyle();
    N != null && (F.fill = N), B != null && (F.opacity = B);
    var G = {
      inheritColor: pt(N) ? N : Y.color.neutral99
    }, X = x(P, Eo), K = Oe(X, null, G, !1, !0);
    K.text = X.getShallow("show") ? bt(r.getFormattedLabel(P, Eo), uc(t, P)) : null;
    var U = Ov(X, G, !1);
    return M(I, F), F = FL(F, K, U), I && T(F, I), F.legacy = !0, F;
  }
  function A(I, P) {
    process.env.NODE_ENV !== "production" && UL("api.styleEmphasis", "Please write literal style directly instead."), P == null && (P = c);
    var O = _(P, ka).getItemStyle(), N = x(P, ka), B = Oe(N, null, null, !0, !0);
    B.text = N.getShallow("show") ? ln(r.getFormattedLabel(P, ka), r.getFormattedLabel(P, Eo), uc(t, P)) : null;
    var F = Ov(N, null, !0);
    return M(I, O), O = FL(O, B, F), I && T(O, I), O.legacy = !0, O;
  }
  function T(I, P) {
    for (var O in P)
      _t(P, O) && (I[O] = P[O]);
  }
  function M(I, P) {
    I && (I.textFill && (P.textFill = I.textFill), I.textPosition && (P.textPosition = I.textPosition));
  }
  function E(I, P) {
    if (P == null && (P = c), _t(kL, I)) {
      var O = t.getItemVisual(P, "style");
      return O ? O[kL[I]] : null;
    }
    if (_t(cnt, I))
      return t.getItemVisual(P, I);
  }
  function R(I) {
    if (o.type === "cartesian2d") {
      var P = o.getBaseAxis();
      return Y$(kt({
        axis: P
      }, I));
    }
  }
  function C() {
    return e.getCurrentSeriesIndices();
  }
  function D(I) {
    return W1(I, e);
  }
}
function Vnt(r) {
  var t = {};
  return L(r.dimensions, function(e) {
    var n = r.getDimensionInfo(e);
    if (!n.isExtraCoord) {
      var i = n.coordDim, a = t[i] = t[i] || [];
      a[n.coordDimIndex] = r.getDimensionIndex(e);
    }
  }), t;
}
function v_(r, t, e, n, i, a, o) {
  if (!n) {
    a.remove(t);
    return;
  }
  var s = fw(r, t, e, n, i, a);
  return s && o.setItemGraphicEl(e, s), s && Ge(s, n.focus, n.blurScope, n.emphasisDisabled), s;
}
function fw(r, t, e, n, i, a) {
  process.env.NODE_ENV !== "production" && St(n, "should not have an null/undefined element setting");
  var o = -1, s = t;
  t && aV(t, n, i) && (o = Zt(a.childrenRef(), t), t = null);
  var l = !t, u = t;
  u ? u.clearStates() : (u = uw(n), s && Nnt(s, u)), n.morph === !1 ? u.disableMorphing = !0 : u.disableMorphing && (u.disableMorphing = !1), n.tooltipDisabled && (u.tooltipDisabled = !0), Wn.normal.cfg = Wn.normal.conOpt = Wn.emphasis.cfg = Wn.emphasis.conOpt = Wn.blur.cfg = Wn.blur.conOpt = Wn.select.cfg = Wn.select.conOpt = null, Wn.isLegacy = !1, znt(u, e, n, i, l, Wn), Fnt(u, e, n, i, l), cw(r, u, e, n, Wn, i, l), _t(n, "info") && (Oa(u).info = n.info);
  for (var c = 0; c < $o.length; c++) {
    var f = $o[c];
    if (f !== Eo) {
      var h = mg(n, f), d = hw(n, h, f);
      iV(f, u, h, d, Wn);
    }
  }
  return knt(u, n, i), n.type === "group" && Unt(r, u, e, n, i), o >= 0 ? a.replaceAt(u, o) : a.add(u), u;
}
function aV(r, t, e) {
  var n = Oa(r), i = t.type, a = t.shape, o = t.style;
  return (
    // Always create new if universal transition is enabled.
    // Because we do transition after render. It needs to know what old element is. Replacement will loose it.
    e.isUniversalTransitionEnabled() || i != null && i !== n.customGraphicType || i === "path" && Xnt(a) && oV(a) !== n.customPathData || i === "image" && _t(o, "image") && o.image !== n.customImagePath
  );
}
function Fnt(r, t, e, n, i) {
  var a = e.clipPath;
  if (a === !1)
    r && r.getClipPath() && r.removeClipPath();
  else if (a) {
    var o = r.getClipPath();
    o && aV(o, a, n) && (o = null), o || (o = uw(a), process.env.NODE_ENV !== "production" && St(gg(o), "Only any type of `path` can be used in `clipPath`, rather than " + o.type + "."), r.setClipPath(o)), cw(null, o, t, a, null, n, i);
  }
}
function znt(r, t, e, n, i, a) {
  if (!(r.isGroup || r.type === "compoundPath")) {
    $L(e, null, a), $L(e, ka, a);
    var o = a.normal.conOpt, s = a.emphasis.conOpt, l = a.blur.conOpt, u = a.select.conOpt;
    if (o != null || s != null || u != null || l != null) {
      var c = r.getTextContent();
      if (o === !1)
        c && r.removeTextContent();
      else {
        o = a.normal.conOpt = o || {
          type: "text"
        }, c ? c.clearStates() : (c = uw(o), r.setTextContent(c)), cw(null, c, t, o, null, n, i);
        for (var f = o && o.style, h = 0; h < $o.length; h++) {
          var d = $o[h];
          if (d !== Eo) {
            var p = a[d].conOpt;
            iV(d, c, p, hw(o, p, d), null);
          }
        }
        f ? c.dirty() : c.markRedraw();
      }
    }
  }
}
function $L(r, t, e) {
  var n = t ? mg(r, t) : r, i = t ? hw(r, n, ka) : r.style, a = r.type, o = n ? n.textConfig : null, s = r.textContent, l = s ? t ? mg(s, t) : s : null;
  if (i && // Because emphasis style has little info to detect legacy,
  // if normal is legacy, emphasis is trade as legacy.
  (e.isLegacy || jB(i, a, !!o, !!l))) {
    e.isLegacy = !0;
    var u = JB(i, a, !t);
    !o && u.textConfig && (o = u.textConfig), !l && u.textContent && (l = u.textContent);
  }
  if (!t && l) {
    var c = l;
    !c.type && (c.type = "text"), process.env.NODE_ENV !== "production" && St(c.type === "text", 'textContent.type must be "text"');
  }
  var f = t ? e[t] : e.normal;
  f.cfg = o, f.conOpt = l;
}
function mg(r, t) {
  return t ? r ? r[t] : null : r;
}
function hw(r, t, e) {
  var n = t && t.style;
  return n == null && e === ka && r && (n = r.styleEmphasis), n;
}
function Unt(r, t, e, n, i) {
  var a = n.children, o = a ? a.length : 0, s = n.$mergeChildren, l = s === "byName" || n.diffChildrenByName, u = s === !1;
  if (!(!o && !l && !u)) {
    if (l) {
      Hnt({
        api: r,
        oldChildren: t.children() || [],
        newChildren: a || [],
        dataIndex: e,
        seriesModel: i,
        group: t
      });
      return;
    }
    u && t.removeAll();
    for (var c = 0; c < o; c++) {
      var f = a[c], h = t.childAt(c);
      f ? (f.ignore == null && (f.ignore = !1), fw(r, h, e, f, i, t)) : (process.env.NODE_ENV !== "production" && St(h, "renderItem should not return a group containing elements as null/undefined/{} if they do not exist before."), h.ignore = !0);
    }
    for (var d = t.childCount() - 1; d >= c; d--) {
      var p = t.childAt(d);
      Gnt(t, p, i);
    }
  }
}
function Gnt(r, t, e) {
  t && Mm(t, Oa(r).option, e);
}
function Hnt(r) {
  new Xa(r.oldChildren, r.newChildren, ZL, ZL, r).add(qL).update(qL).remove(Wnt).execute();
}
function ZL(r, t) {
  var e = r && r.name;
  return e ?? Pnt + t;
}
function qL(r, t) {
  var e = this.context, n = r != null ? e.newChildren[r] : null, i = t != null ? e.oldChildren[t] : null;
  fw(e.api, i, e.dataIndex, n, e.seriesModel, e.group);
}
function Wnt(r) {
  var t = this.context, e = t.oldChildren[r];
  e && Mm(e, Oa(e).option, t.seriesModel);
}
function oV(r) {
  return r && (r.pathData || r.d);
}
function Xnt(r) {
  return r && (_t(r, "pathData") || _t(r, "d"));
}
function Ynt(r) {
  r.registerChartView(Ont), r.registerSeriesModel(fnt);
}
var Ws = ee(), KL = Ct, g_ = mt, dw = (
  /** @class */
  function() {
    function r() {
      this._dragging = !1, this.animationThreshold = 15;
    }
    return r.prototype.render = function(t, e, n, i) {
      var a = e.get("value"), o = e.get("status");
      if (this._axisModel = t, this._axisPointerModel = e, this._api = n, !(!i && this._lastValue === a && this._lastStatus === o)) {
        this._lastValue = a, this._lastStatus = o;
        var s = this._group, l = this._handle;
        if (!o || o === "hide") {
          s && s.hide(), l && l.hide();
          return;
        }
        s && s.show(), l && l.show();
        var u = {};
        this.makeElOption(u, a, t, e, n);
        var c = u.graphicKey;
        c !== this._lastGraphicKey && this.clear(n), this._lastGraphicKey = c;
        var f = this._moveAnimation = this.determineAnimation(t, e);
        if (!s)
          s = this._group = new Et(), this.createPointerEl(s, u, t, e), this.createLabelEl(s, u, t, e), n.getZr().add(s);
        else {
          var h = Yt(jL, e, f);
          this.updatePointerEl(s, u, h), this.updateLabelEl(s, u, h, e);
        }
        QL(s, e, !0), this._renderHandle(a);
      }
    }, r.prototype.remove = function(t) {
      this.clear(t);
    }, r.prototype.dispose = function(t) {
      this.clear(t);
    }, r.prototype.determineAnimation = function(t, e) {
      var n = e.get("animation"), i = t.axis, a = i.type === "category", o = e.get("snap");
      if (!o && !a)
        return !1;
      if (n === "auto" || n == null) {
        var s = this.animationThreshold;
        if (a && i.getBandWidth() > s)
          return !0;
        if (o) {
          var l = Nb(t).seriesDataCount, u = i.getExtent();
          return Math.abs(u[0] - u[1]) / l > s;
        }
        return !1;
      }
      return n === !0;
    }, r.prototype.makeElOption = function(t, e, n, i, a) {
    }, r.prototype.createPointerEl = function(t, e, n, i) {
      var a = e.pointer;
      if (a) {
        var o = Ws(t).pointerEl = new Al[a.type](KL(e.pointer));
        t.add(o);
      }
    }, r.prototype.createLabelEl = function(t, e, n, i) {
      if (e.label) {
        var a = Ws(t).labelEl = new pe(KL(e.label));
        t.add(a), JL(a, i);
      }
    }, r.prototype.updatePointerEl = function(t, e, n) {
      var i = Ws(t).pointerEl;
      i && e.pointer && (i.setStyle(e.pointer.style), n(i, {
        shape: e.pointer.shape
      }));
    }, r.prototype.updateLabelEl = function(t, e, n, i) {
      var a = Ws(t).labelEl;
      a && (a.setStyle(e.label.style), n(a, {
        // Consider text length change in vertical axis, animation should
        // be used on shape, otherwise the effect will be weird.
        // TODOTODO
        // shape: elOption.label.shape,
        x: e.label.x,
        y: e.label.y
      }), JL(a, i));
    }, r.prototype._renderHandle = function(t) {
      if (!(this._dragging || !this.updateHandleTransform)) {
        var e = this._axisPointerModel, n = this._api.getZr(), i = this._handle, a = e.getModel("handle"), o = e.get("status");
        if (!a.get("show") || !o || o === "hide") {
          i && n.remove(i), this._handle = null;
          return;
        }
        var s;
        this._handle || (s = !0, i = this._handle = Vh(a.get("icon"), {
          cursor: "move",
          draggable: !0,
          onmousemove: function(u) {
            Ua(u.event);
          },
          onmousedown: g_(this._onHandleDragMove, this, 0, 0),
          drift: g_(this._onHandleDragMove, this),
          ondragend: g_(this._onHandleDragEnd, this)
        }), n.add(i)), QL(i, e, !1), i.setStyle(a.getItemStyle(null, ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"]));
        var l = a.get("size");
        et(l) || (l = [l, l]), i.scaleX = l[0] / 2, i.scaleY = l[1] / 2, Dc(this, "_doDispatchAxisPointer", a.get("throttle") || 0, "fixRate"), this._moveHandleToValue(t, s);
      }
    }, r.prototype._moveHandleToValue = function(t, e) {
      jL(this._axisPointerModel, !e && this._moveAnimation, this._handle, m_(this.getHandleTransform(t, this._axisModel, this._axisPointerModel)));
    }, r.prototype._onHandleDragMove = function(t, e) {
      var n = this._handle;
      if (n) {
        this._dragging = !0;
        var i = this.updateHandleTransform(m_(n), [t, e], this._axisModel, this._axisPointerModel);
        this._payloadInfo = i, n.stopAnimation(), n.attr(m_(i)), Ws(n).lastProp = null, this._doDispatchAxisPointer();
      }
    }, r.prototype._doDispatchAxisPointer = function() {
      var t = this._handle;
      if (t) {
        var e = this._payloadInfo, n = this._axisModel;
        this._api.dispatchAction({
          type: "updateAxisPointer",
          x: e.cursorPoint[0],
          y: e.cursorPoint[1],
          tooltipOption: e.tooltipOption,
          axesInfo: [{
            axisDim: n.axis.dim,
            axisIndex: n.componentIndex
          }]
        });
      }
    }, r.prototype._onHandleDragEnd = function() {
      this._dragging = !1;
      var t = this._handle;
      if (t) {
        var e = this._axisPointerModel.get("value");
        this._moveHandleToValue(e), this._api.dispatchAction({
          type: "hideTip"
        });
      }
    }, r.prototype.clear = function(t) {
      this._lastValue = null, this._lastStatus = null;
      var e = t.getZr(), n = this._group, i = this._handle;
      e && n && (this._lastGraphicKey = null, n && e.remove(n), i && e.remove(i), this._group = null, this._handle = null, this._payloadInfo = null), ch(this, "_doDispatchAxisPointer");
    }, r.prototype.doClear = function() {
    }, r.prototype.buildLabel = function(t, e, n) {
      return n = n || 0, {
        x: t[n],
        y: t[1 - n],
        width: e[n],
        height: e[1 - n]
      };
    }, r;
  }()
);
function jL(r, t, e, n) {
  sV(Ws(e).lastProp, n) || (Ws(e).lastProp = n, t ? ve(e, n, r) : (e.stopAnimation(), e.attr(n)));
}
function sV(r, t) {
  if (Dt(r) && Dt(t)) {
    var e = !0;
    return L(t, function(n, i) {
      e = e && sV(r[i], n);
    }), !!e;
  } else
    return r === t;
}
function JL(r, t) {
  r[t.get(["label", "show"]) ? "show" : "hide"]();
}
function m_(r) {
  return {
    x: r.x || 0,
    y: r.y || 0,
    rotation: r.rotation || 0
  };
}
function QL(r, t, e) {
  var n = t.get("z"), i = t.get("zlevel");
  r && r.traverse(function(a) {
    a.type !== "group" && (n != null && (a.z = n), i != null && (a.zlevel = i), a.silent = e);
  });
}
function pw(r) {
  var t = r.get("type"), e = r.getModel(t + "Style"), n;
  return t === "line" ? (n = e.getLineStyle(), n.fill = null) : t === "shadow" && (n = e.getAreaStyle(), n.stroke = null), n;
}
function lV(r, t, e, n, i) {
  var a = e.get("value"), o = uV(a, t.axis, t.ecModel, e.get("seriesDataIndices"), {
    precision: e.get(["label", "precision"]),
    formatter: e.get(["label", "formatter"])
  }), s = e.getModel("label"), l = Fh(s.get("padding") || 0), u = s.getFont(), c = Wg(o, u), f = i.position, h = c.width + l[1] + l[3], d = c.height + l[0] + l[2], p = i.align;
  p === "right" && (f[0] -= h), p === "center" && (f[0] -= h / 2);
  var g = i.verticalAlign;
  g === "bottom" && (f[1] -= d), g === "middle" && (f[1] -= d / 2), $nt(f, h, d, n);
  var v = s.get("backgroundColor");
  (!v || v === "auto") && (v = t.get(["axisLine", "lineStyle", "color"])), r.label = {
    // shape: {x: 0, y: 0, width: width, height: height, r: labelModel.get('borderRadius')},
    x: f[0],
    y: f[1],
    style: Oe(s, {
      text: o,
      font: u,
      fill: s.getTextColor(),
      padding: l,
      backgroundColor: v
    }),
    // Label should be over axisPointer.
    z2: 10
  };
}
function $nt(r, t, e, n) {
  var i = n.getWidth(), a = n.getHeight();
  r[0] = Math.min(r[0] + t, i) - t, r[1] = Math.min(r[1] + e, a) - e, r[0] = Math.max(r[0], 0), r[1] = Math.max(r[1], 0);
}
function uV(r, t, e, n, i) {
  r = t.scale.parse(r);
  var a = t.scale.getLabel({
    value: r
  }, {
    // If `precision` is set, width can be fixed (like '12.00500'), which
    // helps to debounce when when moving label.
    precision: i.precision
  }), o = i.formatter;
  if (o) {
    var s = {
      value: Kv(t, {
        value: r
      }),
      axisDimension: t.dim,
      axisIndex: t.index,
      seriesData: []
    };
    L(n, function(l) {
      var u = e.getSeriesByIndex(l.seriesIndex), c = l.dataIndexInside, f = u && u.getDataParams(c);
      f && s.seriesData.push(f);
    }), pt(o) ? a = o.replace("{value}", a) : Tt(o) && (a = o(s));
  }
  return a;
}
function vw(r, t, e) {
  var n = kr();
  return qo(n, n, e.rotation), ra(n, n, e.position), yi([r.dataToCoord(t), (e.labelOffset || 0) + (e.labelDirection || 1) * (e.labelMargin || 0)], n);
}
function cV(r, t, e, n, i, a) {
  var o = cn.innerTextLayout(e.rotation, 0, e.labelDirection);
  e.labelMargin = i.get(["label", "margin"]), lV(t, n, i, a, {
    position: vw(n.axis, r, e),
    align: o.textAlign,
    verticalAlign: o.textVerticalAlign
  });
}
function gw(r, t, e) {
  return e = e || 0, {
    x1: r[e],
    y1: r[1 - e],
    x2: t[e],
    y2: t[1 - e]
  };
}
function fV(r, t, e) {
  return e = e || 0, {
    x: r[e],
    y: r[1 - e],
    width: t[e],
    height: t[1 - e]
  };
}
function t2(r, t, e, n, i, a) {
  return {
    cx: r,
    cy: t,
    r0: e,
    r: n,
    startAngle: i,
    endAngle: a,
    clockwise: !0
  };
}
var Znt = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t.prototype.makeElOption = function(e, n, i, a, o) {
      var s = i.axis, l = s.grid, u = a.get("type"), c = e2(l, s).getOtherAxis(s).getGlobalExtent(), f = s.toGlobalCoord(s.dataToCoord(n, !0));
      if (u && u !== "none") {
        var h = pw(a), d = qnt[u](s, f, c);
        d.style = h, e.graphicKey = d.type, e.pointer = d;
      }
      var p = og(l.getRect(), i);
      cV(n, e, p, i, a, o);
    }, t.prototype.getHandleTransform = function(e, n, i) {
      var a = og(n.axis.grid.getRect(), n, {
        labelInside: !1
      });
      a.labelMargin = i.get(["handle", "margin"]);
      var o = vw(n.axis, e, a);
      return {
        x: o[0],
        y: o[1],
        rotation: a.rotation + (a.labelDirection < 0 ? Math.PI : 0)
      };
    }, t.prototype.updateHandleTransform = function(e, n, i, a) {
      var o = i.axis, s = o.grid, l = o.getGlobalExtent(!0), u = e2(s, o).getOtherAxis(o).getGlobalExtent(), c = o.dim === "x" ? 0 : 1, f = [e.x, e.y];
      f[c] += n[c], f[c] = Math.min(l[1], f[c]), f[c] = Math.max(l[0], f[c]);
      var h = (u[1] + u[0]) / 2, d = [h, h];
      d[c] = f[c];
      var p = [{
        verticalAlign: "middle"
      }, {
        align: "center"
      }];
      return {
        x: f[0],
        y: f[1],
        rotation: e.rotation,
        cursorPoint: d,
        tooltipOption: p[c]
      };
    }, t;
  }(dw)
);
function e2(r, t) {
  var e = {};
  return e[t.dim + "AxisIndex"] = t.index, r.getCartesian(e);
}
var qnt = {
  line: function(r, t, e) {
    var n = gw([t, e[0]], [t, e[1]], r2(r));
    return {
      type: "Line",
      subPixelOptimize: !0,
      shape: n
    };
  },
  shadow: function(r, t, e) {
    var n = Math.max(1, r.getBandWidth()), i = e[1] - e[0];
    return {
      type: "Rect",
      shape: fV([t - n / 2, e[0]], [n, i], r2(r))
    };
  }
};
function r2(r) {
  return r.dim === "x" ? 0 : 1;
}
var Knt = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.type = "axisPointer", t.defaultOption = {
      // 'auto' means that show when triggered by tooltip or handle.
      show: "auto",
      // zlevel: 0,
      z: 50,
      type: "line",
      // axispointer triggered by tootip determine snap automatically,
      // see `modelHelper`.
      snap: !1,
      triggerTooltip: !0,
      triggerEmphasis: !0,
      value: null,
      status: null,
      link: [],
      // Do not set 'auto' here, otherwise global animation: false
      // will not effect at this axispointer.
      animation: null,
      animationDurationUpdate: 200,
      lineStyle: {
        color: Y.color.border,
        width: 1,
        type: "dashed"
      },
      shadowStyle: {
        color: Y.color.shadowTint
      },
      label: {
        show: !0,
        formatter: null,
        precision: "auto",
        margin: 3,
        color: Y.color.neutral00,
        padding: [5, 7, 5, 7],
        backgroundColor: Y.color.accent60,
        borderColor: null,
        borderWidth: 0,
        borderRadius: 3
      },
      handle: {
        show: !1,
        // eslint-disable-next-line
        icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
        size: 45,
        // handle margin is from symbol center to axis, which is stable when circular move.
        margin: 50,
        // color: '#1b8bbd'
        // color: '#2f4554'
        color: Y.color.accent40,
        // For mobile performance
        throttle: 40
      }
    }, t;
  }(re)
), La = ee(), jnt = L;
function hV(r, t, e) {
  if (!oe.node) {
    var n = t.getZr();
    La(n).records || (La(n).records = {}), Jnt(n, t);
    var i = La(n).records[r] || (La(n).records[r] = {});
    i.handler = e;
  }
}
function Jnt(r, t) {
  if (La(r).initialized)
    return;
  La(r).initialized = !0, e("click", Yt(n2, "click")), e("mousemove", Yt(n2, "mousemove")), e("globalout", tit);
  function e(n, i) {
    r.on(n, function(a) {
      var o = eit(t);
      jnt(La(r).records, function(s) {
        s && i(s, a, o.dispatchAction);
      }), Qnt(o.pendings, t);
    });
  }
}
function Qnt(r, t) {
  var e = r.showTip.length, n = r.hideTip.length, i;
  e ? i = r.showTip[e - 1] : n && (i = r.hideTip[n - 1]), i && (i.dispatchAction = null, t.dispatchAction(i));
}
function tit(r, t, e) {
  r.handler("leave", null, e);
}
function n2(r, t, e, n) {
  t.handler(r, e, n);
}
function eit(r) {
  var t = {
    showTip: [],
    hideTip: []
  }, e = function(n) {
    var i = t[n.type];
    i ? i.push(n) : (n.dispatchAction = e, r.dispatchAction(n));
  };
  return {
    dispatchAction: e,
    pendings: t
  };
}
function zS(r, t) {
  if (!oe.node) {
    var e = t.getZr(), n = (La(e).records || {})[r];
    n && (La(e).records[r] = null);
  }
}
var rit = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n, i) {
      var a = n.getComponent("tooltip"), o = e.get("triggerOn") || a && a.get("triggerOn") || "mousemove|click";
      hV("axisPointer", i, function(s, l, u) {
        o !== "none" && (s === "leave" || o.indexOf(s) >= 0) && u({
          type: "updateAxisPointer",
          currTrigger: s,
          x: l && l.offsetX,
          y: l && l.offsetY
        });
      });
    }, t.prototype.remove = function(e, n) {
      zS("axisPointer", n);
    }, t.prototype.dispose = function(e, n) {
      zS("axisPointer", n);
    }, t.type = "axisPointer", t;
  }(Ue)
);
function dV(r, t) {
  var e = [], n = r.seriesIndex, i;
  if (n == null || !(i = t.getSeriesByIndex(n)))
    return {
      point: []
    };
  var a = i.getData(), o = dl(a, r);
  if (o == null || o < 0 || et(o))
    return {
      point: []
    };
  var s = a.getItemGraphicEl(o), l = i.coordinateSystem;
  if (i.getTooltipPosition)
    e = i.getTooltipPosition(o) || [];
  else if (l && l.dataToPoint)
    if (r.isStacked) {
      var u = l.getBaseAxis(), c = l.getOtherAxis(u), f = c.dim, h = u.dim, d = f === "x" || f === "radius" ? 1 : 0, p = a.mapDimension(h), g = [];
      g[d] = a.get(p, o), g[1 - d] = a.get(a.getCalculationInfo("stackResultDimension"), o), e = l.dataToPoint(g) || [];
    } else
      e = l.dataToPoint(a.getValues(rt(l.dimensions, function(m) {
        return a.mapDimension(m);
      }), o)) || [];
  else if (s) {
    var v = s.getBoundingRect().clone();
    v.applyTransform(s.transform), e = [v.x + v.width / 2, v.y + v.height / 2];
  }
  return {
    point: e,
    el: s
  };
}
var i2 = ee();
function nit(r, t, e) {
  var n = r.currTrigger, i = [r.x, r.y], a = r, o = r.dispatchAction || mt(e.dispatchAction, e), s = t.getComponent("axisPointer").coordSysAxesInfo;
  if (s) {
    iv(i) && (i = dV({
      seriesIndex: a.seriesIndex,
      // Do not use dataIndexInside from other ec instance.
      // FIXME: auto detect it?
      dataIndex: a.dataIndex
    }, t).point);
    var l = iv(i), u = a.axesInfo, c = s.axesInfo, f = n === "leave" || iv(i), h = {}, d = {}, p = {
      list: [],
      map: {}
    }, g = {
      showPointer: Yt(ait, d),
      showTooltip: Yt(oit, p)
    };
    L(s.coordSysMap, function(m, y) {
      var _ = l || m.containPoint(i);
      L(s.coordSysAxesInfo[y], function(x, b) {
        var S = x.axis, w = cit(u, x);
        if (!f && _ && (!u || w)) {
          var A = w && w.value;
          A == null && !l && (A = S.pointToData(i)), A != null && a2(x, A, g, !1, h);
        }
      });
    });
    var v = {};
    return L(c, function(m, y) {
      var _ = m.linkGroup;
      _ && !d[y] && L(_.axesInfo, function(x, b) {
        var S = d[b];
        if (x !== m && S) {
          var w = S.value;
          _.mapper && (w = m.axis.scale.parse(_.mapper(w, o2(x), o2(m)))), v[m.key] = w;
        }
      });
    }), L(v, function(m, y) {
      a2(c[y], m, g, !0, h);
    }), sit(d, c, h), lit(p, i, r, o), uit(c, o, e), h;
  }
}
function a2(r, t, e, n, i) {
  var a = r.axis;
  if (!(a.scale.isBlank() || !a.containData(t))) {
    if (!r.involveSeries) {
      e.showPointer(r, t);
      return;
    }
    var o = iit(t, r), s = o.payloadBatch, l = o.snapToValue;
    s[0] && i.seriesIndex == null && J(i, s[0]), !n && r.snap && a.containData(l) && l != null && (t = l), e.showPointer(r, t, s), e.showTooltip(r, o, l);
  }
}
function iit(r, t) {
  var e = t.axis, n = e.dim, i = r, a = [], o = Number.MAX_VALUE, s = -1;
  return L(t.seriesModels, function(l, u) {
    var c = l.getData().mapDimensionsAll(n), f, h;
    if (l.getAxisTooltipData) {
      var d = l.getAxisTooltipData(c, r, e);
      h = d.dataIndices, f = d.nestestValue;
    } else {
      if (h = l.indicesOfNearest(
        n,
        c[0],
        r,
        // Add a threshold to avoid find the wrong dataIndex
        // when data length is not same.
        // false,
        e.type === "category" ? 0.5 : null
      ), !h.length)
        return;
      f = l.getData().get(c[0], h[0]);
    }
    if (!(f == null || !isFinite(f))) {
      var p = r - f, g = Math.abs(p);
      g <= o && ((g < o || p >= 0 && s < 0) && (o = g, s = p, i = f, a.length = 0), L(h, function(v) {
        a.push({
          seriesIndex: l.seriesIndex,
          dataIndexInside: v,
          dataIndex: l.getData().getRawIndex(v)
        });
      }));
    }
  }), {
    payloadBatch: a,
    snapToValue: i
  };
}
function ait(r, t, e, n) {
  r[t.key] = {
    value: e,
    payloadBatch: n
  };
}
function oit(r, t, e, n) {
  var i = e.payloadBatch, a = t.axis, o = a.model, s = t.axisPointerModel;
  if (!(!t.triggerTooltip || !i.length)) {
    var l = t.coordSys.model, u = _h(l), c = r.map[u];
    c || (c = r.map[u] = {
      coordSysId: l.id,
      coordSysIndex: l.componentIndex,
      coordSysType: l.type,
      coordSysMainType: l.mainType,
      dataByAxis: []
    }, r.list.push(c)), c.dataByAxis.push({
      axisDim: a.dim,
      axisIndex: o.componentIndex,
      axisType: o.type,
      axisId: o.id,
      value: n,
      // Caustion: viewHelper.getValueLabel is actually on "view stage", which
      // depends that all models have been updated. So it should not be performed
      // here. Considering axisPointerModel used here is volatile, which is hard
      // to be retrieve in TooltipView, we prepare parameters here.
      valueLabelOpt: {
        precision: s.get(["label", "precision"]),
        formatter: s.get(["label", "formatter"])
      },
      seriesDataIndices: i.slice()
    });
  }
}
function sit(r, t, e) {
  var n = e.axesInfo = [];
  L(t, function(i, a) {
    var o = i.axisPointerModel.option, s = r[a];
    s ? (!i.useHandle && (o.status = "show"), o.value = s.value, o.seriesDataIndices = (s.payloadBatch || []).slice()) : !i.useHandle && (o.status = "hide"), o.status === "show" && n.push({
      axisDim: i.axis.dim,
      axisIndex: i.axis.model.componentIndex,
      value: o.value
    });
  });
}
function lit(r, t, e, n) {
  if (iv(t) || !r.list.length) {
    n({
      type: "hideTip"
    });
    return;
  }
  var i = ((r.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
  n({
    type: "showTip",
    escapeConnect: !0,
    x: t[0],
    y: t[1],
    tooltipOption: e.tooltipOption,
    position: e.position,
    dataIndexInside: i.dataIndexInside,
    dataIndex: i.dataIndex,
    seriesIndex: i.seriesIndex,
    dataByCoordSys: r.list
  });
}
function uit(r, t, e) {
  var n = e.getZr(), i = "axisPointerLastHighlights", a = i2(n)[i] || {}, o = i2(n)[i] = {};
  L(r, function(u, c) {
    var f = u.axisPointerModel.option;
    f.status === "show" && u.triggerEmphasis && L(f.seriesDataIndices, function(h) {
      var d = h.seriesIndex + " | " + h.dataIndex;
      o[d] = h;
    });
  });
  var s = [], l = [];
  L(a, function(u, c) {
    !o[c] && l.push(u);
  }), L(o, function(u, c) {
    !a[c] && s.push(u);
  }), l.length && e.dispatchAction({
    type: "downplay",
    escapeConnect: !0,
    // Not blur others when highlight in axisPointer.
    notBlur: !0,
    batch: l
  }), s.length && e.dispatchAction({
    type: "highlight",
    escapeConnect: !0,
    // Not blur others when highlight in axisPointer.
    notBlur: !0,
    batch: s
  });
}
function cit(r, t) {
  for (var e = 0; e < (r || []).length; e++) {
    var n = r[e];
    if (t.axis.dim === n.axisDim && t.axis.model.componentIndex === n.axisIndex)
      return n;
  }
}
function o2(r) {
  var t = r.axis.model, e = {}, n = e.axisDim = r.axis.dim;
  return e.axisIndex = e[n + "AxisIndex"] = t.componentIndex, e.axisName = e[n + "AxisName"] = t.name, e.axisId = e[n + "AxisId"] = t.id, e;
}
function iv(r) {
  return !r || r[0] == null || isNaN(r[0]) || r[1] == null || isNaN(r[1]);
}
function qh(r) {
  Rl.registerAxisPointerClass("CartesianAxisPointer", Znt), r.registerComponentModel(Knt), r.registerComponentView(rit), r.registerPreprocessor(function(t) {
    if (t) {
      (!t.axisPointer || t.axisPointer.length === 0) && (t.axisPointer = {});
      var e = t.axisPointer.link;
      e && !et(e) && (t.axisPointer.link = [e]);
    }
  }), r.registerProcessor(r.PRIORITY.PROCESSOR.STATISTIC, function(t, e) {
    t.getComponent("axisPointer").coordSysAxesInfo = cj(t, e);
  }), r.registerAction({
    type: "updateAxisPointer",
    event: "updateAxisPointer",
    update: ":updateAxisPointer"
  }, nit);
}
function fit(r) {
  jt(k3), jt(qh);
}
var hit = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t.prototype.makeElOption = function(e, n, i, a, o) {
      var s = i.axis;
      s.dim === "angle" && (this.animationThreshold = Math.PI / 18);
      var l = s.polar, u = l.getOtherAxis(s), c = u.getExtent(), f = s.dataToCoord(n), h = a.get("type");
      if (h && h !== "none") {
        var d = pw(a), p = pit[h](s, l, f, c);
        p.style = d, e.graphicKey = p.type, e.pointer = p;
      }
      var g = a.get(["label", "margin"]), v = dit(n, i, a, l, g);
      lV(e, i, a, o, v);
    }, t;
  }(dw)
);
function dit(r, t, e, n, i) {
  var a = t.axis, o = a.dataToCoord(r), s = n.getAngleAxis().getExtent()[0];
  s = s / 180 * Math.PI;
  var l = n.getRadiusAxis().getExtent(), u, c, f;
  if (a.dim === "radius") {
    var h = kr();
    qo(h, h, s), ra(h, h, [n.cx, n.cy]), u = yi([o, -i], h);
    var d = t.getModel("axisLabel").get("rotate") || 0, p = cn.innerTextLayout(s, d * Math.PI / 180, -1);
    c = p.textAlign, f = p.textVerticalAlign;
  } else {
    var g = l[1];
    u = n.coordToPoint([g + i, o]);
    var v = n.cx, m = n.cy;
    c = Math.abs(u[0] - v) / g < 0.3 ? "center" : u[0] > v ? "left" : "right", f = Math.abs(u[1] - m) / g < 0.3 ? "middle" : u[1] > m ? "top" : "bottom";
  }
  return {
    position: u,
    align: c,
    verticalAlign: f
  };
}
var pit = {
  line: function(r, t, e, n) {
    return r.dim === "angle" ? {
      type: "Line",
      shape: gw(t.coordToPoint([n[0], e]), t.coordToPoint([n[1], e]))
    } : {
      type: "Circle",
      shape: {
        cx: t.cx,
        cy: t.cy,
        r: e
      }
    };
  },
  shadow: function(r, t, e, n) {
    var i = Math.max(1, r.getBandWidth()), a = Math.PI / 180;
    return r.dim === "angle" ? {
      type: "Sector",
      shape: t2(
        t.cx,
        t.cy,
        n[0],
        n[1],
        // In ECharts y is negative if angle is positive
        (-e - i / 2) * a,
        (-e + i / 2) * a
      )
    } : {
      type: "Sector",
      shape: t2(t.cx, t.cy, e - i / 2, e + i / 2, 0, Math.PI * 2)
    };
  }
}, vit = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.findAxisModel = function(e) {
      var n, i = this.ecModel;
      return i.eachComponent(e, function(a) {
        a.getCoordSysModel() === this && (n = a);
      }, this), n;
    }, t.type = "polar", t.dependencies = ["radiusAxis", "angleAxis"], t.defaultOption = {
      // zlevel: 0,
      z: 0,
      center: ["50%", "50%"],
      radius: "80%"
    }, t;
  }(re)
), mw = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t.prototype.getCoordSysModel = function() {
      return this.getReferringComponents("polar", Ke).models[0];
    }, t.type = "polarAxis", t;
  }(re)
);
hr(mw, Hh);
var git = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.type = "angleAxis", t;
  }(mw)
), mit = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.type = "radiusAxis", t;
  }(mw)
), yw = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e, n) {
      return r.call(this, "radius", e, n) || this;
    }
    return t.prototype.pointToData = function(e, n) {
      return this.polar.pointToData(e, n)[this.dim === "radius" ? 0 : 1];
    }, t;
  }(Ai)
);
yw.prototype.dataToRadius = Ai.prototype.dataToCoord;
yw.prototype.radiusToData = Ai.prototype.coordToData;
var yit = ee(), _w = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e, n) {
      return r.call(this, "angle", e, n || [0, 360]) || this;
    }
    return t.prototype.pointToData = function(e, n) {
      return this.polar.pointToData(e, n)[this.dim === "radius" ? 0 : 1];
    }, t.prototype.calculateCategoryInterval = function() {
      var e = this, n = e.getLabelModel(), i = e.scale, a = i.getExtent(), o = i.count();
      if (a[1] - a[0] < 1)
        return 0;
      var s = a[0], l = e.dataToCoord(s + 1) - e.dataToCoord(s), u = Math.abs(l), c = Wg(s == null ? "" : s + "", n.getFont(), "center", "top"), f = Math.max(c.height, 7), h = f / u;
      isNaN(h) && (h = 1 / 0);
      var d = Math.max(0, Math.floor(h)), p = yit(e.model), g = p.lastAutoInterval, v = p.lastTickCount;
      return g != null && v != null && Math.abs(g - d) <= 1 && Math.abs(v - o) <= 1 && g > d ? d = g : (p.lastTickCount = o, p.lastAutoInterval = d), d;
    }, t;
  }(Ai)
);
_w.prototype.dataToAngle = Ai.prototype.dataToCoord;
_w.prototype.angleToData = Ai.prototype.coordToData;
var pV = ["radius", "angle"], _it = (
  /** @class */
  function() {
    function r(t) {
      this.dimensions = pV, this.type = "polar", this.cx = 0, this.cy = 0, this._radiusAxis = new yw(), this._angleAxis = new _w(), this.axisPointerEnabled = !0, this.name = t || "", this._radiusAxis.polar = this._angleAxis.polar = this;
    }
    return r.prototype.containPoint = function(t) {
      var e = this.pointToCoord(t);
      return this._radiusAxis.contain(e[0]) && this._angleAxis.contain(e[1]);
    }, r.prototype.containData = function(t) {
      return this._radiusAxis.containData(t[0]) && this._angleAxis.containData(t[1]);
    }, r.prototype.getAxis = function(t) {
      var e = "_" + t + "Axis";
      return this[e];
    }, r.prototype.getAxes = function() {
      return [this._radiusAxis, this._angleAxis];
    }, r.prototype.getAxesByScale = function(t) {
      var e = [], n = this._angleAxis, i = this._radiusAxis;
      return n.scale.type === t && e.push(n), i.scale.type === t && e.push(i), e;
    }, r.prototype.getAngleAxis = function() {
      return this._angleAxis;
    }, r.prototype.getRadiusAxis = function() {
      return this._radiusAxis;
    }, r.prototype.getOtherAxis = function(t) {
      var e = this._angleAxis;
      return t === e ? this._radiusAxis : e;
    }, r.prototype.getBaseAxis = function() {
      return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAngleAxis();
    }, r.prototype.getTooltipAxes = function(t) {
      var e = t != null && t !== "auto" ? this.getAxis(t) : this.getBaseAxis();
      return {
        baseAxes: [e],
        otherAxes: [this.getOtherAxis(e)]
      };
    }, r.prototype.dataToPoint = function(t, e, n) {
      return this.coordToPoint([this._radiusAxis.dataToRadius(t[0], e), this._angleAxis.dataToAngle(t[1], e)], n);
    }, r.prototype.pointToData = function(t, e, n) {
      n = n || [];
      var i = this.pointToCoord(t);
      return n[0] = this._radiusAxis.radiusToData(i[0], e), n[1] = this._angleAxis.angleToData(i[1], e), n;
    }, r.prototype.pointToCoord = function(t) {
      var e = t[0] - this.cx, n = t[1] - this.cy, i = this.getAngleAxis(), a = i.getExtent(), o = Math.min(a[0], a[1]), s = Math.max(a[0], a[1]);
      i.inverse ? o = s - 360 : s = o + 360;
      var l = Math.sqrt(e * e + n * n);
      e /= l, n /= l;
      for (var u = Math.atan2(-n, e) / Math.PI * 180, c = u < o ? 1 : -1; u < o || u > s; )
        u += c * 360;
      return [l, u];
    }, r.prototype.coordToPoint = function(t, e) {
      e = e || [];
      var n = t[0], i = t[1] / 180 * Math.PI;
      return e[0] = Math.cos(i) * n + this.cx, e[1] = -Math.sin(i) * n + this.cy, e;
    }, r.prototype.getArea = function() {
      var t = this.getAngleAxis(), e = this.getRadiusAxis(), n = e.getExtent().slice();
      n[0] > n[1] && n.reverse();
      var i = t.getExtent(), a = Math.PI / 180, o = 1e-4;
      return {
        cx: this.cx,
        cy: this.cy,
        r0: n[0],
        r: n[1],
        startAngle: -i[0] * a,
        endAngle: -i[1] * a,
        clockwise: t.inverse,
        contain: function(s, l) {
          var u = s - this.cx, c = l - this.cy, f = u * u + c * c, h = this.r, d = this.r0;
          return h !== d && f - o <= h * h && f + o >= d * d;
        },
        // As the bounding box
        x: this.cx - n[1],
        y: this.cy - n[1],
        width: n[1] * 2,
        height: n[1] * 2
      };
    }, r.prototype.convertToPixel = function(t, e, n) {
      var i = s2(e);
      return i === this ? this.dataToPoint(n) : null;
    }, r.prototype.convertFromPixel = function(t, e, n) {
      var i = s2(e);
      return i === this ? this.pointToData(n) : null;
    }, r;
  }()
);
function s2(r) {
  var t = r.seriesModel, e = r.polarModel;
  return e && e.coordinateSystem || t && t.coordinateSystem;
}
function xit(r, t, e) {
  var n = t.get("center"), i = xr(t, e).refContainer;
  r.cx = dt(n[0], i.width) + i.x, r.cy = dt(n[1], i.height) + i.y;
  var a = r.getRadiusAxis(), o = Math.min(i.width, i.height) / 2, s = t.get("radius");
  s == null ? s = [0, "100%"] : et(s) || (s = [0, s]);
  var l = [dt(s[0], o), dt(s[1], o)];
  a.inverse ? a.setExtent(l[1], l[0]) : a.setExtent(l[0], l[1]);
}
function Sit(r, t) {
  var e = this, n = e.getAngleAxis(), i = e.getRadiusAxis();
  if (n.scale.setExtent(1 / 0, -1 / 0), i.scale.setExtent(1 / 0, -1 / 0), r.eachSeries(function(s) {
    if (s.coordinateSystem === e) {
      var l = s.getData();
      L(jv(l, "radius"), function(u) {
        i.scale.unionExtentFromData(l, u);
      }), L(jv(l, "angle"), function(u) {
        n.scale.unionExtentFromData(l, u);
      });
    }
  }), sc(n.scale, n.model), sc(i.scale, i.model), n.type === "category" && !n.onBand) {
    var a = n.getExtent(), o = 360 / n.scale.count();
    n.inverse ? a[1] += o : a[1] -= o, n.setExtent(a[0], a[1]);
  }
}
function bit(r) {
  return r.mainType === "angleAxis";
}
function l2(r, t) {
  var e;
  if (r.type = t.get("type"), r.scale = pm(t), r.onBand = t.get("boundaryGap") && r.type === "category", r.inverse = t.get("inverse"), bit(t)) {
    r.inverse = r.inverse !== t.get("clockwise");
    var n = t.get("startAngle"), i = (e = t.get("endAngle")) !== null && e !== void 0 ? e : n + (r.inverse ? -360 : 360);
    r.setExtent(n, i);
  }
  t.axis = r, r.model = t;
}
var wit = {
  dimensions: pV,
  create: function(r, t) {
    var e = [];
    return r.eachComponent("polar", function(n, i) {
      var a = new _it(i + "");
      a.update = Sit;
      var o = a.getRadiusAxis(), s = a.getAngleAxis(), l = n.findAxisModel("radiusAxis"), u = n.findAxisModel("angleAxis");
      l2(o, l), l2(s, u), xit(a, n, t), e.push(a), n.coordinateSystem = a, a.model = n;
    }), r.eachSeries(function(n) {
      if (n.get("coordinateSystem") === "polar") {
        var i = n.getReferringComponents("polar", Ke).models[0];
        if (process.env.NODE_ENV !== "production" && !i)
          throw new Error('Polar "' + gr(n.get("polarIndex"), n.get("polarId"), 0) + '" not found');
        n.coordinateSystem = i.coordinateSystem;
      }
    }), e;
  }
}, Mit = ["axisLine", "axisLabel", "axisTick", "minorTick", "splitLine", "minorSplitLine", "splitArea"];
function bp(r, t, e) {
  t[1] > t[0] && (t = t.slice().reverse());
  var n = r.coordToPoint([t[0], e]), i = r.coordToPoint([t[1], e]);
  return {
    x1: n[0],
    y1: n[1],
    x2: i[0],
    y2: i[1]
  };
}
function wp(r) {
  var t = r.getRadiusAxis();
  return t.inverse ? 0 : 1;
}
function u2(r) {
  var t = r[0], e = r[r.length - 1];
  t && e && Math.abs(Math.abs(t.coord - e.coord) - 360) < 1e-4 && r.pop();
}
var Tit = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.axisPointerClass = "PolarAxisPointer", e;
    }
    return t.prototype.render = function(e, n) {
      if (this.group.removeAll(), !!e.get("show")) {
        var i = e.axis, a = i.polar, o = a.getRadiusAxis().getExtent(), s = i.getTicksCoords({
          breakTicks: "none"
        }), l = i.getMinorTicksCoords(), u = rt(i.getViewLabels(), function(c) {
          c = Ct(c);
          var f = i.scale, h = f.type === "ordinal" ? f.getRawOrdinalNumber(c.tickValue) : c.tickValue;
          return c.coord = i.dataToCoord(h), c;
        });
        u2(u), u2(s), L(Mit, function(c) {
          e.get([c, "show"]) && (!i.scale.isBlank() || c === "axisLine") && Ait[c](this.group, e, a, s, l, o, u);
        }, this);
      }
    }, t.type = "angleAxis", t;
  }(Rl)
), Ait = {
  axisLine: function(r, t, e, n, i, a) {
    var o = t.getModel(["axisLine", "lineStyle"]), s = e.getAngleAxis(), l = Math.PI / 180, u = s.getExtent(), c = wp(e), f = c ? 0 : 1, h, d = Math.abs(u[1] - u[0]) === 360 ? "Circle" : "Arc";
    a[f] === 0 ? h = new Al[d]({
      shape: {
        cx: e.cx,
        cy: e.cy,
        r: a[c],
        startAngle: -u[0] * l,
        endAngle: -u[1] * l,
        clockwise: s.inverse
      },
      style: o.getLineStyle(),
      z2: 1,
      silent: !0
    }) : h = new Oh({
      shape: {
        cx: e.cx,
        cy: e.cy,
        r: a[c],
        r0: a[f]
      },
      style: o.getLineStyle(),
      z2: 1,
      silent: !0
    }), h.style.fill = null, r.add(h);
  },
  axisTick: function(r, t, e, n, i, a) {
    var o = t.getModel("axisTick"), s = (o.get("inside") ? -1 : 1) * o.get("length"), l = a[wp(e)], u = rt(n, function(c) {
      return new sr({
        shape: bp(e, [l, l + s], c.coord)
      });
    });
    r.add(Jn(u, {
      style: kt(o.getModel("lineStyle").getLineStyle(), {
        stroke: t.get(["axisLine", "lineStyle", "color"])
      })
    }));
  },
  minorTick: function(r, t, e, n, i, a) {
    if (i.length) {
      for (var o = t.getModel("axisTick"), s = t.getModel("minorTick"), l = (o.get("inside") ? -1 : 1) * s.get("length"), u = a[wp(e)], c = [], f = 0; f < i.length; f++)
        for (var h = 0; h < i[f].length; h++)
          c.push(new sr({
            shape: bp(e, [u, u + l], i[f][h].coord)
          }));
      r.add(Jn(c, {
        style: kt(s.getModel("lineStyle").getLineStyle(), kt(o.getLineStyle(), {
          stroke: t.get(["axisLine", "lineStyle", "color"])
        }))
      }));
    }
  },
  axisLabel: function(r, t, e, n, i, a, o) {
    var s = t.getCategories(!0), l = t.getModel("axisLabel"), u = l.get("margin"), c = t.get("triggerEvent");
    L(o, function(f, h) {
      var d = l, p = f.tickValue, g = a[wp(e)], v = e.coordToPoint([g + u, f.coord]), m = e.cx, y = e.cy, _ = Math.abs(v[0] - m) / g < 0.3 ? "center" : v[0] > m ? "left" : "right", x = Math.abs(v[1] - y) / g < 0.3 ? "middle" : v[1] > y ? "top" : "bottom";
      if (s && s[p]) {
        var b = s[p];
        Dt(b) && b.textStyle && (d = new ue(b.textStyle, l, l.ecModel));
      }
      var S = new pe({
        silent: cn.isLabelSilent(t),
        style: Oe(d, {
          x: v[0],
          y: v[1],
          fill: d.getTextColor() || t.get(["axisLine", "lineStyle", "color"]),
          text: f.formattedLabel,
          align: _,
          verticalAlign: x
        })
      });
      if (r.add(S), Ka({
        el: S,
        componentModel: t,
        itemName: f.formattedLabel,
        formatterParamsExtra: {
          isTruncated: function() {
            return S.isTruncated;
          },
          value: f.rawLabel,
          tickIndex: h
        }
      }), c) {
        var w = cn.makeAxisEventDataBase(t);
        w.targetType = "axisLabel", w.value = f.rawLabel, zt(S).eventData = w;
      }
    }, this);
  },
  splitLine: function(r, t, e, n, i, a) {
    var o = t.getModel("splitLine"), s = o.getModel("lineStyle"), l = s.get("color"), u = 0;
    l = l instanceof Array ? l : [l];
    for (var c = [], f = 0; f < n.length; f++) {
      var h = u++ % l.length;
      c[h] = c[h] || [], c[h].push(new sr({
        shape: bp(e, a, n[f].coord)
      }));
    }
    for (var f = 0; f < c.length; f++)
      r.add(Jn(c[f], {
        style: kt({
          stroke: l[f % l.length]
        }, s.getLineStyle()),
        silent: !0,
        z: t.get("z")
      }));
  },
  minorSplitLine: function(r, t, e, n, i, a) {
    if (i.length) {
      for (var o = t.getModel("minorSplitLine"), s = o.getModel("lineStyle"), l = [], u = 0; u < i.length; u++)
        for (var c = 0; c < i[u].length; c++)
          l.push(new sr({
            shape: bp(e, a, i[u][c].coord)
          }));
      r.add(Jn(l, {
        style: s.getLineStyle(),
        silent: !0,
        z: t.get("z")
      }));
    }
  },
  splitArea: function(r, t, e, n, i, a) {
    if (n.length) {
      var o = t.getModel("splitArea"), s = o.getModel("areaStyle"), l = s.get("color"), u = 0;
      l = l instanceof Array ? l : [l];
      for (var c = [], f = Math.PI / 180, h = -n[0].coord * f, d = Math.min(a[0], a[1]), p = Math.max(a[0], a[1]), g = t.get("clockwise"), v = 1, m = n.length; v <= m; v++) {
        var y = v === m ? n[0].coord : n[v].coord, _ = u++ % l.length;
        c[_] = c[_] || [], c[_].push(new Kr({
          shape: {
            cx: e.cx,
            cy: e.cy,
            r0: d,
            r: p,
            startAngle: h,
            endAngle: -y * f,
            clockwise: g
          },
          silent: !0
        })), h = -y * f;
      }
      for (var v = 0; v < c.length; v++)
        r.add(Jn(c[v], {
          style: kt({
            fill: l[v % l.length]
          }, s.getAreaStyle()),
          silent: !0
        }));
    }
  }
}, Eit = ["splitLine", "splitArea", "minorSplitLine"], Cit = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.axisPointerClass = "PolarAxisPointer", e;
    }
    return t.prototype.render = function(e, n, i) {
      if (this.group.removeAll(), !!e.get("show")) {
        var a = this._axisGroup, o = this._axisGroup = new Et();
        this.group.add(o);
        var s = e.axis, l = s.polar, u = l.getAngleAxis(), c = s.getTicksCoords(), f = s.getMinorTicksCoords(), h = u.getExtent()[0], d = s.getExtent(), p = Lit(l, e, h), g = new cn(e, i, p);
        g.build(), o.add(g.group), Bh(a, o, e), L(Eit, function(v) {
          e.get([v, "show"]) && !s.scale.isBlank() && Dit[v](this.group, e, l, h, d, c, f);
        }, this);
      }
    }, t.type = "radiusAxis", t;
  }(Rl)
), Dit = {
  splitLine: function(r, t, e, n, i, a) {
    var o = t.getModel("splitLine"), s = o.getModel("lineStyle"), l = s.get("color"), u = 0, c = e.getAngleAxis(), f = Math.PI / 180, h = c.getExtent(), d = Math.abs(h[1] - h[0]) === 360 ? "Circle" : "Arc";
    l = l instanceof Array ? l : [l];
    for (var p = [], g = 0; g < a.length; g++) {
      var v = u++ % l.length;
      p[v] = p[v] || [], p[v].push(new Al[d]({
        shape: {
          cx: e.cx,
          cy: e.cy,
          // ensure circle radius >= 0
          r: Math.max(a[g].coord, 0),
          startAngle: -h[0] * f,
          endAngle: -h[1] * f,
          clockwise: c.inverse
        }
      }));
    }
    for (var g = 0; g < p.length; g++)
      r.add(Jn(p[g], {
        style: kt({
          stroke: l[g % l.length],
          fill: null
        }, s.getLineStyle()),
        silent: !0
      }));
  },
  minorSplitLine: function(r, t, e, n, i, a, o) {
    if (o.length) {
      for (var s = t.getModel("minorSplitLine"), l = s.getModel("lineStyle"), u = [], c = 0; c < o.length; c++)
        for (var f = 0; f < o[c].length; f++)
          u.push(new qa({
            shape: {
              cx: e.cx,
              cy: e.cy,
              r: o[c][f].coord
            }
          }));
      r.add(Jn(u, {
        style: kt({
          fill: null
        }, l.getLineStyle()),
        silent: !0
      }));
    }
  },
  splitArea: function(r, t, e, n, i, a) {
    if (a.length) {
      var o = t.getModel("splitArea"), s = o.getModel("areaStyle"), l = s.get("color"), u = 0;
      l = l instanceof Array ? l : [l];
      for (var c = [], f = a[0].coord, h = 1; h < a.length; h++) {
        var d = u++ % l.length;
        c[d] = c[d] || [], c[d].push(new Kr({
          shape: {
            cx: e.cx,
            cy: e.cy,
            r0: f,
            r: a[h].coord,
            startAngle: 0,
            endAngle: Math.PI * 2
          },
          silent: !0
        })), f = a[h].coord;
      }
      for (var h = 0; h < c.length; h++)
        r.add(Jn(c[h], {
          style: kt({
            fill: l[h % l.length]
          }, s.getAreaStyle()),
          silent: !0
        }));
    }
  }
};
function Lit(r, t, e) {
  return {
    position: [r.cx, r.cy],
    rotation: e / 180 * Math.PI,
    labelDirection: -1,
    tickDirection: -1,
    nameDirection: 1,
    labelRotate: t.getModel("axisLabel").get("rotate"),
    // Over splitLine and splitArea
    z2: 1
  };
}
function vV(r) {
  return r.get("stack") || "__ec_stack_" + r.seriesIndex;
}
function gV(r, t) {
  return t.dim + r.model.componentIndex;
}
function Rit(r, t, e) {
  var n = {}, i = Iit(Te(t.getSeriesByType(r), function(a) {
    return !t.isSeriesFiltered(a) && a.coordinateSystem && a.coordinateSystem.type === "polar";
  }));
  t.eachSeriesByType(r, function(a) {
    if (a.coordinateSystem.type === "polar") {
      var o = a.getData(), s = a.coordinateSystem, l = s.getBaseAxis(), u = gV(s, l), c = vV(a), f = i[u][c], h = f.offset, d = f.width, p = s.getOtherAxis(l), g = a.coordinateSystem.cx, v = a.coordinateSystem.cy, m = a.get("barMinHeight") || 0, y = a.get("barMinAngle") || 0;
      n[c] = n[c] || [];
      for (var _ = o.mapDimension(p.dim), x = o.mapDimension(l.dim), b = Ho(
        o,
        _
        /* , baseDim */
      ), S = l.dim !== "radius" || !a.get("roundCap", !0), w = p.model, A = w.get("startValue"), T = p.dataToCoord(A || 0), M = 0, E = o.count(); M < E; M++) {
        var R = o.get(_, M), C = o.get(x, M), D = R >= 0 ? "p" : "n", I = T;
        b && (n[c][C] || (n[c][C] = {
          p: T,
          n: T
          // Negative stack
        }), I = n[c][C][D]);
        var P = void 0, O = void 0, N = void 0, B = void 0;
        if (p.dim === "radius") {
          var F = p.dataToCoord(R) - T, G = l.dataToCoord(C);
          Math.abs(F) < m && (F = (F < 0 ? -1 : 1) * m), P = I, O = I + F, N = G - h, B = N - d, b && (n[c][C][D] = O);
        } else {
          var X = p.dataToCoord(R, S) - T, K = l.dataToCoord(C);
          Math.abs(X) < y && (X = (X < 0 ? -1 : 1) * y), P = K + h, O = P + d, N = I, B = I + X, b && (n[c][C][D] = B);
        }
        o.setItemLayout(M, {
          cx: g,
          cy: v,
          r0: P,
          r: O,
          // Consider that positive angle is anti-clockwise,
          // while positive radian of sector is clockwise
          startAngle: -N * Math.PI / 180,
          endAngle: -B * Math.PI / 180,
          /**
           * Keep the same logic with bar in catesion: use end value to
           * control direction. Notice that if clockwise is true (by
           * default), the sector will always draw clockwisely, no matter
           * whether endAngle is greater or less than startAngle.
           */
          clockwise: N >= B
        });
      }
    }
  });
}
function Iit(r) {
  var t = {};
  L(r, function(n, i) {
    var a = n.getData(), o = n.coordinateSystem, s = o.getBaseAxis(), l = gV(o, s), u = s.getExtent(), c = s.type === "category" ? s.getBandWidth() : Math.abs(u[1] - u[0]) / a.count(), f = t[l] || {
      bandWidth: c,
      remainedWidth: c,
      autoWidthCount: 0,
      categoryGap: "20%",
      gap: "30%",
      stacks: {}
    }, h = f.stacks;
    t[l] = f;
    var d = vV(n);
    h[d] || f.autoWidthCount++, h[d] = h[d] || {
      width: 0,
      maxWidth: 0
    };
    var p = dt(n.get("barWidth"), c), g = dt(n.get("barMaxWidth"), c), v = n.get("barGap"), m = n.get("barCategoryGap");
    p && !h[d].width && (p = Math.min(f.remainedWidth, p), h[d].width = p, f.remainedWidth -= p), g && (h[d].maxWidth = g), v != null && (f.gap = v), m != null && (f.categoryGap = m);
  });
  var e = {};
  return L(t, function(n, i) {
    e[i] = {};
    var a = n.stacks, o = n.bandWidth, s = dt(n.categoryGap, o), l = dt(n.gap, 1), u = n.remainedWidth, c = n.autoWidthCount, f = (u - s) / (c + (c - 1) * l);
    f = Math.max(f, 0), L(a, function(g, v) {
      var m = g.maxWidth;
      m && m < f && (m = Math.min(m, u), g.width && (m = Math.min(m, g.width)), u -= m, g.width = m, c--);
    }), f = (u - s) / (c + (c - 1) * l), f = Math.max(f, 0);
    var h = 0, d;
    L(a, function(g, v) {
      g.width || (g.width = f), d = g, h += g.width * (1 + l);
    }), d && (h -= d.width * l);
    var p = -h / 2;
    L(a, function(g, v) {
      e[i][v] = e[i][v] || {
        offset: p,
        width: g.width
      }, p += g.width * (1 + l);
    });
  }), e;
}
var Pit = {
  startAngle: 90,
  clockwise: !0,
  splitNumber: 12,
  axisLabel: {
    rotate: 0
  }
}, Nit = {
  splitNumber: 5
}, Oit = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.type = "polar", t;
  }(Ue)
);
function kit(r) {
  jt(qh), Rl.registerAxisPointerClass("PolarAxisPointer", hit), r.registerCoordinateSystem("polar", wit), r.registerComponentModel(vit), r.registerComponentView(Oit), cc(r, "angle", git, Pit), cc(r, "radius", mit, Nit), r.registerComponentView(Tit), r.registerComponentView(Cit), r.registerLayout(Yt(Rit, "bar"));
}
function US(r, t) {
  t = t || {};
  var e = r.coordinateSystem, n = r.axis, i = {}, a = n.position, o = n.orient, s = e.getRect(), l = [s.x, s.x + s.width, s.y, s.y + s.height], u = {
    horizontal: {
      top: l[2],
      bottom: l[3]
    },
    vertical: {
      left: l[0],
      right: l[1]
    }
  };
  i.position = [o === "vertical" ? u.vertical[a] : l[0], o === "horizontal" ? u.horizontal[a] : l[3]];
  var c = {
    horizontal: 0,
    vertical: 1
  };
  i.rotation = Math.PI / 2 * c[o];
  var f = {
    top: -1,
    bottom: 1,
    right: 1,
    left: -1
  };
  i.labelDirection = i.tickDirection = i.nameDirection = f[a], r.get(["axisTick", "inside"]) && (i.tickDirection = -i.tickDirection), gr(t.labelInside, r.get(["axisLabel", "inside"])) && (i.labelDirection = -i.labelDirection);
  var h = r.get(["axisLabel", "rotate"]);
  return i.labelRotate = a === "top" ? -h : h, i.z2 = 1, i;
}
var Bit = ["splitArea", "splitLine", "breakArea"], Vit = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.axisPointerClass = "SingleAxisPointer", e;
    }
    return t.prototype.render = function(e, n, i, a) {
      var o = this.group;
      o.removeAll();
      var s = this._axisGroup;
      this._axisGroup = new Et();
      var l = US(e), u = new cn(e, i, l);
      u.build(), o.add(this._axisGroup), o.add(u.group), L(Bit, function(c) {
        e.get([c, "show"]) && Fit[c](this, this.group, this._axisGroup, e, i);
      }, this), Bh(s, this._axisGroup, e), r.prototype.render.call(this, e, n, i, a);
    }, t.prototype.remove = function() {
      P3(this);
    }, t.type = "singleAxis", t;
  }(Rl)
), Fit = {
  splitLine: function(r, t, e, n, i) {
    var a = n.axis;
    if (!a.scale.isBlank()) {
      var o = n.getModel("splitLine"), s = o.getModel("lineStyle"), l = s.get("color");
      l = l instanceof Array ? l : [l];
      for (var u = s.get("width"), c = n.coordinateSystem.getRect(), f = a.isHorizontal(), h = [], d = 0, p = a.getTicksCoords({
        tickModel: o,
        breakTicks: "none",
        pruneByBreak: "preserve_extent_bound"
      }), g = [], v = [], m = 0; m < p.length; ++m) {
        var y = a.toGlobalCoord(p[m].coord);
        f ? (g[0] = y, g[1] = c.y, v[0] = y, v[1] = c.y + c.height) : (g[0] = c.x, g[1] = y, v[0] = c.x + c.width, v[1] = y);
        var _ = new sr({
          shape: {
            x1: g[0],
            y1: g[1],
            x2: v[0],
            y2: v[1]
          },
          silent: !0
        });
        nc(_.shape, u);
        var x = d++ % l.length;
        h[x] = h[x] || [], h[x].push(_);
      }
      for (var b = s.getLineStyle(["color"]), m = 0; m < h.length; ++m)
        t.add(Jn(h[m], {
          style: kt({
            stroke: l[m % l.length]
          }, b),
          silent: !0
        }));
    }
  },
  splitArea: function(r, t, e, n, i) {
    I3(r, e, n, n);
  },
  breakArea: function(r, t, e, n, i) {
    var a = Zh(), o = n.axis.scale;
    a && o.type !== "ordinal" && a.rectCoordBuildBreakAxis(t, r, n, n.coordinateSystem.getRect(), i);
  }
}, av = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.getCoordSysModel = function() {
      return this;
    }, t.type = "singleAxis", t.layoutMode = "box", t.defaultOption = {
      left: "5%",
      top: "5%",
      right: "5%",
      bottom: "5%",
      type: "value",
      position: "bottom",
      orient: "horizontal",
      axisLine: {
        show: !0,
        lineStyle: {
          width: 1,
          type: "solid"
        }
      },
      // Single coordinate system and single axis is the,
      // which is used as the parent tooltip model.
      // same model, so we set default tooltip show as true.
      tooltip: {
        show: !0
      },
      axisTick: {
        show: !0,
        length: 6,
        lineStyle: {
          width: 1
        }
      },
      axisLabel: {
        show: !0,
        interval: "auto"
      },
      splitLine: {
        show: !0,
        lineStyle: {
          type: "dashed",
          opacity: 0.2
        }
      },
      jitter: 0,
      jitterOverlap: !0,
      jitterMargin: 2
    }, t;
  }(re)
);
hr(av, Hh.prototype);
var zit = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e, n, i, a, o) {
      var s = r.call(this, e, n, i) || this;
      return s.type = a || "value", s.position = o || "bottom", s;
    }
    return t.prototype.isHorizontal = function() {
      var e = this.position;
      return e === "top" || e === "bottom";
    }, t.prototype.pointToData = function(e, n) {
      return this.coordinateSystem.pointToData(e)[0];
    }, t;
  }(Ai)
), mV = ["single"], Uit = (
  /** @class */
  function() {
    function r(t, e, n) {
      this.type = "single", this.dimension = "single", this.dimensions = mV, this.axisPointerEnabled = !0, this.model = t, this._init(t, e, n);
    }
    return r.prototype._init = function(t, e, n) {
      var i = this.dimension, a = new zit(i, pm(t), [0, 0], t.get("type"), t.get("position")), o = a.type === "category";
      a.onBand = o && t.get("boundaryGap"), a.inverse = t.get("inverse"), a.orient = t.get("orient"), t.axis = a, a.model = t, a.coordinateSystem = this, this._axis = a;
    }, r.prototype.update = function(t, e) {
      t.eachSeries(function(n) {
        if (n.coordinateSystem === this) {
          var i = n.getData();
          L(i.mapDimensionsAll(this.dimension), function(a) {
            this._axis.scale.unionExtentFromData(i, a);
          }, this), sc(this._axis.scale, this._axis.model);
        }
      }, this);
    }, r.prototype.resize = function(t, e) {
      var n = xr(t, e).refContainer;
      this._rect = He(t.getBoxLayoutParams(), n), this._adjustAxis();
    }, r.prototype.getRect = function() {
      return this._rect;
    }, r.prototype._adjustAxis = function() {
      var t = this._rect, e = this._axis, n = e.isHorizontal(), i = n ? [0, t.width] : [0, t.height], a = e.inverse ? 1 : 0;
      e.setExtent(i[a], i[1 - a]), this._updateAxisTransform(e, n ? t.x : t.y);
    }, r.prototype._updateAxisTransform = function(t, e) {
      var n = t.getExtent(), i = n[0] + n[1], a = t.isHorizontal();
      t.toGlobalCoord = a ? function(o) {
        return o + e;
      } : function(o) {
        return i - o + e;
      }, t.toLocalCoord = a ? function(o) {
        return o - e;
      } : function(o) {
        return i - o + e;
      };
    }, r.prototype.getAxis = function() {
      return this._axis;
    }, r.prototype.getBaseAxis = function() {
      return this._axis;
    }, r.prototype.getAxes = function() {
      return [this._axis];
    }, r.prototype.getTooltipAxes = function() {
      return {
        baseAxes: [this.getAxis()],
        // Empty otherAxes
        otherAxes: []
      };
    }, r.prototype.containPoint = function(t) {
      var e = this.getRect(), n = this.getAxis(), i = n.orient;
      return i === "horizontal" ? n.contain(n.toLocalCoord(t[0])) && t[1] >= e.y && t[1] <= e.y + e.height : n.contain(n.toLocalCoord(t[1])) && t[0] >= e.y && t[0] <= e.y + e.height;
    }, r.prototype.pointToData = function(t, e, n) {
      n = n || [];
      var i = this.getAxis();
      return n[0] = i.coordToData(i.toLocalCoord(t[i.orient === "horizontal" ? 0 : 1])), n;
    }, r.prototype.dataToPoint = function(t, e, n) {
      var i = this.getAxis(), a = this.getRect();
      n = n || [];
      var o = i.orient === "horizontal" ? 0 : 1;
      return t instanceof Array && (t = t[0]), n[o] = i.toGlobalCoord(i.dataToCoord(+t)), n[1 - o] = o === 0 ? a.y + a.height / 2 : a.x + a.width / 2, n;
    }, r.prototype.convertToPixel = function(t, e, n) {
      var i = c2(e);
      return i === this ? this.dataToPoint(n) : null;
    }, r.prototype.convertFromPixel = function(t, e, n) {
      var i = c2(e);
      return i === this ? this.pointToData(n) : null;
    }, r;
  }()
);
function c2(r) {
  var t = r.seriesModel, e = r.singleAxisModel;
  return e && e.coordinateSystem || t && t.coordinateSystem;
}
function Git(r, t) {
  var e = [];
  return r.eachComponent("singleAxis", function(n, i) {
    var a = new Uit(n, r, t);
    a.name = "single_" + i, a.resize(n, t), n.coordinateSystem = a, e.push(a);
  }), r.eachSeries(function(n) {
    if (n.get("coordinateSystem") === "singleAxis") {
      var i = n.getReferringComponents("singleAxis", Ke).models[0];
      n.coordinateSystem = i && i.coordinateSystem;
    }
  }), e;
}
var Hit = {
  create: Git,
  dimensions: mV
}, f2 = ["x", "y"], Wit = ["width", "height"], Xit = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t.prototype.makeElOption = function(e, n, i, a, o) {
      var s = i.axis, l = s.coordinateSystem, u = y_(l, 1 - yg(s)), c = l.dataToPoint(n)[0], f = a.get("type");
      if (f && f !== "none") {
        var h = pw(a), d = Yit[f](s, c, u);
        d.style = h, e.graphicKey = d.type, e.pointer = d;
      }
      var p = US(i);
      cV(n, e, p, i, a, o);
    }, t.prototype.getHandleTransform = function(e, n, i) {
      var a = US(n, {
        labelInside: !1
      });
      a.labelMargin = i.get(["handle", "margin"]);
      var o = vw(n.axis, e, a);
      return {
        x: o[0],
        y: o[1],
        rotation: a.rotation + (a.labelDirection < 0 ? Math.PI : 0)
      };
    }, t.prototype.updateHandleTransform = function(e, n, i, a) {
      var o = i.axis, s = o.coordinateSystem, l = yg(o), u = y_(s, l), c = [e.x, e.y];
      c[l] += n[l], c[l] = Math.min(u[1], c[l]), c[l] = Math.max(u[0], c[l]);
      var f = y_(s, 1 - l), h = (f[1] + f[0]) / 2, d = [h, h];
      return d[l] = c[l], {
        x: c[0],
        y: c[1],
        rotation: e.rotation,
        cursorPoint: d,
        tooltipOption: {
          verticalAlign: "middle"
        }
      };
    }, t;
  }(dw)
), Yit = {
  line: function(r, t, e) {
    var n = gw([t, e[0]], [t, e[1]], yg(r));
    return {
      type: "Line",
      subPixelOptimize: !0,
      shape: n
    };
  },
  shadow: function(r, t, e) {
    var n = r.getBandWidth(), i = e[1] - e[0];
    return {
      type: "Rect",
      shape: fV([t - n / 2, e[0]], [n, i], yg(r))
    };
  }
};
function yg(r) {
  return r.isHorizontal() ? 0 : 1;
}
function y_(r, t) {
  var e = r.getRect();
  return [e[f2[t]], e[f2[t]] + e[Wit[t]]];
}
var $it = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.type = "single", t;
  }(Ue)
);
function Zit(r) {
  jt(qh), Rl.registerAxisPointerClass("SingleAxisPointer", Xit), r.registerComponentView($it), r.registerComponentView(Vit), r.registerComponentModel(av), cc(r, "single", av, av.defaultOption), r.registerCoordinateSystem("single", Hit);
}
var qit = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function(e, n, i) {
      var a = El(e);
      r.prototype.init.apply(this, arguments), h2(e, a);
    }, t.prototype.mergeOption = function(e) {
      r.prototype.mergeOption.apply(this, arguments), h2(this.option, e);
    }, t.prototype.getCellSize = function() {
      return this.option.cellSize;
    }, t.type = "calendar", t.layoutMode = "box", t.defaultOption = {
      // zlevel: 0,
      // TODO: theoretically, the z of the calendar should be lower
      // than series, but we don't want the series to be displayed
      // on top of the borders like month split line. To align with
      // the effect of previous versions, we set the z to 2 for now
      // until better solution is found.
      z: 2,
      left: 80,
      top: 60,
      cellSize: 20,
      // horizontal vertical
      orient: "horizontal",
      // month separate line style
      splitLine: {
        show: !0,
        lineStyle: {
          color: Y.color.axisLine,
          width: 1,
          type: "solid"
        }
      },
      // rect style  temporarily unused emphasis
      itemStyle: {
        color: Y.color.neutral00,
        borderWidth: 1,
        borderColor: Y.color.neutral10
      },
      // week text style
      dayLabel: {
        show: !0,
        firstDay: 0,
        // start end
        position: "start",
        margin: Y.size.s,
        color: Y.color.secondary
      },
      // month text style
      monthLabel: {
        show: !0,
        // start end
        position: "start",
        margin: Y.size.s,
        // center or left
        align: "center",
        formatter: null,
        color: Y.color.secondary
      },
      // year text style
      yearLabel: {
        show: !0,
        // top bottom left right
        position: null,
        margin: Y.size.xl,
        formatter: null,
        color: Y.color.quaternary,
        fontFamily: "sans-serif",
        fontWeight: "bolder",
        fontSize: 20
      }
    }, t;
  }(re)
);
function h2(r, t) {
  var e = r.cellSize, n;
  et(e) ? n = e : n = r.cellSize = [e, e], n.length === 1 && (n[1] = n[0]);
  var i = rt([0, 1], function(a) {
    return C9(t, a) && (n[a] = "auto"), n[a] != null && n[a] !== "auto";
  });
  oa(r, t, {
    type: "box",
    ignoreSize: i
  });
}
var Kit = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n, i) {
      var a = this.group;
      a.removeAll();
      var o = e.coordinateSystem, s = o.getRangeInfo(), l = o.getOrient(), u = n.getLocaleModel();
      this._renderDayRect(e, s, a), this._renderLines(e, s, l, a), this._renderYearText(e, s, l, a), this._renderMonthText(e, u, l, a), this._renderWeekText(e, u, s, l, a);
    }, t.prototype._renderDayRect = function(e, n, i) {
      for (var a = e.coordinateSystem, o = e.getModel("itemStyle").getItemStyle(), s = a.getCellWidth(), l = a.getCellHeight(), u = n.start.time; u <= n.end.time; u = a.getNextNDay(u, 1).time) {
        var c = a.dataToCalendarLayout([u], !1).tl, f = new te({
          shape: {
            x: c[0],
            y: c[1],
            width: s,
            height: l
          },
          cursor: "default",
          style: o
        });
        i.add(f);
      }
    }, t.prototype._renderLines = function(e, n, i, a) {
      var o = this, s = e.coordinateSystem, l = e.getModel(["splitLine", "lineStyle"]).getLineStyle(), u = e.get(["splitLine", "show"]), c = l.lineWidth;
      this._tlpoints = [], this._blpoints = [], this._firstDayOfMonth = [], this._firstDayPoints = [];
      for (var f = n.start, h = 0; f.time <= n.end.time; h++) {
        p(f.formatedDate), h === 0 && (f = s.getDateInfo(n.start.y + "-" + n.start.m));
        var d = f.date;
        d.setMonth(d.getMonth() + 1), f = s.getDateInfo(d);
      }
      p(s.getNextNDay(n.end.time, 1).formatedDate);
      function p(g) {
        o._firstDayOfMonth.push(s.getDateInfo(g)), o._firstDayPoints.push(s.dataToCalendarLayout([g], !1).tl);
        var v = o._getLinePointsOfOneWeek(e, g, i);
        o._tlpoints.push(v[0]), o._blpoints.push(v[v.length - 1]), u && o._drawSplitline(v, l, a);
      }
      u && this._drawSplitline(o._getEdgesPoints(o._tlpoints, c, i), l, a), u && this._drawSplitline(o._getEdgesPoints(o._blpoints, c, i), l, a);
    }, t.prototype._getEdgesPoints = function(e, n, i) {
      var a = [e[0].slice(), e[e.length - 1].slice()], o = i === "horizontal" ? 0 : 1;
      return a[0][o] = a[0][o] - n / 2, a[1][o] = a[1][o] + n / 2, a;
    }, t.prototype._drawSplitline = function(e, n, i) {
      var a = new Ur({
        z2: 20,
        shape: {
          points: e
        },
        style: n
      });
      i.add(a);
    }, t.prototype._getLinePointsOfOneWeek = function(e, n, i) {
      for (var a = e.coordinateSystem, o = a.getDateInfo(n), s = [], l = 0; l < 7; l++) {
        var u = a.getNextNDay(o.time, l), c = a.dataToCalendarLayout([u.time], !1);
        s[2 * u.day] = c.tl, s[2 * u.day + 1] = c[i === "horizontal" ? "bl" : "tr"];
      }
      return s;
    }, t.prototype._formatterLabel = function(e, n) {
      return pt(e) && e ? b9(e, n) : Tt(e) ? e(n) : n.nameMap;
    }, t.prototype._yearTextPositionControl = function(e, n, i, a, o) {
      var s = n[0], l = n[1], u = ["center", "bottom"];
      a === "bottom" ? (l += o, u = ["center", "top"]) : a === "left" ? s -= o : a === "right" ? (s += o, u = ["center", "top"]) : l -= o;
      var c = 0;
      return (a === "left" || a === "right") && (c = Math.PI / 2), {
        rotation: c,
        x: s,
        y: l,
        style: {
          align: u[0],
          verticalAlign: u[1]
        }
      };
    }, t.prototype._renderYearText = function(e, n, i, a) {
      var o = e.getModel("yearLabel");
      if (o.get("show")) {
        var s = o.get("margin"), l = o.get("position");
        l || (l = i !== "horizontal" ? "top" : "left");
        var u = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]], c = (u[0][0] + u[1][0]) / 2, f = (u[0][1] + u[1][1]) / 2, h = i === "horizontal" ? 0 : 1, d = {
          top: [c, u[h][1]],
          bottom: [c, u[1 - h][1]],
          left: [u[1 - h][0], f],
          right: [u[h][0], f]
        }, p = n.start.y;
        +n.end.y > +n.start.y && (p = p + "-" + n.end.y);
        var g = o.get("formatter"), v = {
          start: n.start.y,
          end: n.end.y,
          nameMap: p
        }, m = this._formatterLabel(g, v), y = new pe({
          z2: 30,
          style: Oe(o, {
            text: m
          }),
          silent: o.get("silent")
        });
        y.attr(this._yearTextPositionControl(y, d[l], i, l, s)), a.add(y);
      }
    }, t.prototype._monthTextPositionControl = function(e, n, i, a, o) {
      var s = "left", l = "top", u = e[0], c = e[1];
      return i === "horizontal" ? (c = c + o, n && (s = "center"), a === "start" && (l = "bottom")) : (u = u + o, n && (l = "middle"), a === "start" && (s = "right")), {
        x: u,
        y: c,
        align: s,
        verticalAlign: l
      };
    }, t.prototype._renderMonthText = function(e, n, i, a) {
      var o = e.getModel("monthLabel");
      if (o.get("show")) {
        var s = o.get("nameMap"), l = o.get("margin"), u = o.get("position"), c = o.get("align"), f = [this._tlpoints, this._blpoints];
        (!s || pt(s)) && (s && (n = kx(s) || n), s = n.get(["time", "monthAbbr"]) || []);
        var h = u === "start" ? 0 : 1, d = i === "horizontal" ? 0 : 1;
        l = u === "start" ? -l : l;
        for (var p = c === "center", g = o.get("silent"), v = 0; v < f[h].length - 1; v++) {
          var m = f[h][v].slice(), y = this._firstDayOfMonth[v];
          if (p) {
            var _ = this._firstDayPoints[v];
            m[d] = (_[d] + f[0][v + 1][d]) / 2;
          }
          var x = o.get("formatter"), b = s[+y.m - 1], S = {
            yyyy: y.y,
            yy: (y.y + "").slice(2),
            MM: y.m,
            M: +y.m,
            nameMap: b
          }, w = this._formatterLabel(x, S), A = new pe({
            z2: 30,
            style: J(Oe(o, {
              text: w
            }), this._monthTextPositionControl(m, p, i, u, l)),
            silent: g
          });
          a.add(A);
        }
      }
    }, t.prototype._weekTextPositionControl = function(e, n, i, a, o) {
      var s = "center", l = "middle", u = e[0], c = e[1], f = i === "start";
      return n === "horizontal" ? (u = u + a + (f ? 1 : -1) * o[0] / 2, s = f ? "right" : "left") : (c = c + a + (f ? 1 : -1) * o[1] / 2, l = f ? "bottom" : "top"), {
        x: u,
        y: c,
        align: s,
        verticalAlign: l
      };
    }, t.prototype._renderWeekText = function(e, n, i, a, o) {
      var s = e.getModel("dayLabel");
      if (s.get("show")) {
        var l = e.coordinateSystem, u = s.get("position"), c = s.get("nameMap"), f = s.get("margin"), h = l.getFirstDayOfWeek();
        if (!c || pt(c)) {
          c && (n = kx(c) || n);
          var d = n.get(["time", "dayOfWeekShort"]);
          c = d || rt(n.get(["time", "dayOfWeekAbbr"]), function(S) {
            return S[0];
          });
        }
        var p = l.getNextNDay(i.end.time, 7 - i.lweek).time, g = [l.getCellWidth(), l.getCellHeight()];
        f = dt(f, Math.min(g[1], g[0])), u === "start" && (p = l.getNextNDay(i.start.time, -(7 + i.fweek)).time, f = -f);
        for (var v = s.get("silent"), m = 0; m < 7; m++) {
          var y = l.getNextNDay(p, m), _ = l.dataToCalendarLayout([y.time], !1).center, x = m;
          x = Math.abs((m + h) % 7);
          var b = new pe({
            z2: 30,
            style: J(Oe(s, {
              text: c[x]
            }), this._weekTextPositionControl(_, a, u, f, g)),
            silent: v
          });
          o.add(b);
        }
      }
    }, t.type = "calendar", t;
  }(Ue)
), __ = 864e5, jit = (
  /** @class */
  function() {
    function r(t, e, n) {
      this.type = "calendar", this.dimensions = r.dimensions, this.getDimensionsInfo = r.getDimensionsInfo, this._model = t, this._update(e, n);
    }
    return r.getDimensionsInfo = function() {
      return [{
        name: "time",
        type: "time"
      }, "value"];
    }, r.prototype.getRangeInfo = function() {
      return this._rangeInfo;
    }, r.prototype.getModel = function() {
      return this._model;
    }, r.prototype.getRect = function() {
      return this._rect;
    }, r.prototype.getCellWidth = function() {
      return this._sw;
    }, r.prototype.getCellHeight = function() {
      return this._sh;
    }, r.prototype.getOrient = function() {
      return this._orient;
    }, r.prototype.getFirstDayOfWeek = function() {
      return this._firstDayOfWeek;
    }, r.prototype.getDateInfo = function(t) {
      t = Tl(t);
      var e = t.getFullYear(), n = t.getMonth() + 1, i = n < 10 ? "0" + n : "" + n, a = t.getDate(), o = a < 10 ? "0" + a : "" + a, s = t.getDay();
      return s = Math.abs((s + 7 - this.getFirstDayOfWeek()) % 7), {
        y: e + "",
        m: i,
        d: o,
        day: s,
        time: t.getTime(),
        formatedDate: e + "-" + i + "-" + o,
        date: t
      };
    }, r.prototype.getNextNDay = function(t, e) {
      return e = e || 0, e === 0 ? this.getDateInfo(t) : (t = new Date(this.getDateInfo(t).time), t.setDate(t.getDate() + e), this.getDateInfo(t));
    }, r.prototype._update = function(t, e) {
      this._firstDayOfWeek = +this._model.getModel("dayLabel").get("firstDay"), this._orient = this._model.get("orient"), this._lineWidth = this._model.getModel("itemStyle").getItemStyle().lineWidth || 0, this._rangeInfo = this._getRangeInfo(this._initRangeOption());
      var n = this._rangeInfo.weeks || 1, i = ["width", "height"], a = this._model.getCellSize().slice(), o = this._model.getBoxLayoutParams(), s = this._orient === "horizontal" ? [n, 7] : [7, n];
      L([0, 1], function(f) {
        c(a, f) && (o[i[f]] = a[f] * s[f]);
      });
      var l = {
        width: e.getWidth(),
        height: e.getHeight()
      }, u = this._rect = He(o, l);
      L([0, 1], function(f) {
        c(a, f) || (a[f] = u[i[f]] / s[f]);
      });
      function c(f, h) {
        return f[h] != null && f[h] !== "auto";
      }
      this._sw = a[0], this._sh = a[1];
    }, r.prototype.dataToPoint = function(t, e, n) {
      n = n || [], et(t) && (t = t[0]), e == null && (e = !0);
      var i = this.getDateInfo(t), a = this._rangeInfo, o = i.formatedDate;
      if (e && !(i.time >= a.start.time && i.time < a.end.time + __))
        return n[0] = n[1] = NaN, n;
      var s = i.day, l = this._getRangeInfo([a.start.time, o]).nthWeek;
      return this._orient === "vertical" ? (n[0] = this._rect.x + s * this._sw + this._sw / 2, n[1] = this._rect.y + l * this._sh + this._sh / 2) : (n[0] = this._rect.x + l * this._sw + this._sw / 2, n[1] = this._rect.y + s * this._sh + this._sh / 2), n;
    }, r.prototype.pointToData = function(t) {
      var e = this.pointToDate(t);
      return e && e.time;
    }, r.prototype.dataToLayout = function(t, e, n) {
      n = n || {};
      var i = n.rect = n.rect || {}, a = n.contentRect = n.contentRect || {}, o = this.dataToPoint(t, e);
      return i.x = o[0] - this._sw / 2, i.y = o[1] - this._sh / 2, i.width = this._sw, i.height = this._sh, Bt.copy(a, i), gl(a, this._lineWidth / 2, !0, !0), n;
    }, r.prototype.dataToCalendarLayout = function(t, e) {
      var n = this.dataToPoint(t, e);
      return {
        center: n,
        tl: [n[0] - this._sw / 2, n[1] - this._sh / 2],
        tr: [n[0] + this._sw / 2, n[1] - this._sh / 2],
        br: [n[0] + this._sw / 2, n[1] + this._sh / 2],
        bl: [n[0] - this._sw / 2, n[1] + this._sh / 2]
      };
    }, r.prototype.pointToDate = function(t) {
      var e = Math.floor((t[0] - this._rect.x) / this._sw) + 1, n = Math.floor((t[1] - this._rect.y) / this._sh) + 1, i = this._rangeInfo.range;
      return this._orient === "vertical" ? this._getDateByWeeksAndDay(n, e - 1, i) : this._getDateByWeeksAndDay(e, n - 1, i);
    }, r.prototype.convertToPixel = function(t, e, n) {
      var i = x_(e);
      return i === this ? i.dataToPoint(n) : null;
    }, r.prototype.convertToLayout = function(t, e, n) {
      var i = x_(e);
      return i === this ? i.dataToLayout(n) : null;
    }, r.prototype.convertFromPixel = function(t, e, n) {
      var i = x_(e);
      return i === this ? i.pointToData(n) : null;
    }, r.prototype.containPoint = function(t) {
      return console.warn("Not implemented."), !1;
    }, r.prototype._initRangeOption = function() {
      var t = this._model.get("range"), e;
      if (et(t) && t.length === 1 && (t = t[0]), et(t))
        e = t;
      else {
        var n = t.toString();
        if (/^\d{4}$/.test(n) && (e = [n + "-01-01", n + "-12-31"]), /^\d{4}[\/|-]\d{1,2}$/.test(n)) {
          var i = this.getDateInfo(n), a = i.date;
          a.setMonth(a.getMonth() + 1);
          var o = this.getNextNDay(a, -1);
          e = [i.formatedDate, o.formatedDate];
        }
        /^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(n) && (e = [n, n]);
      }
      if (!e)
        return process.env.NODE_ENV !== "production" && gi("Invalid date range."), t;
      var s = this._getRangeInfo(e);
      return s.start.time > s.end.time && e.reverse(), e;
    }, r.prototype._getRangeInfo = function(t) {
      var e = [this.getDateInfo(t[0]), this.getDateInfo(t[1])], n;
      e[0].time > e[1].time && (n = !0, e.reverse());
      var i = Math.floor(e[1].time / __) - Math.floor(e[0].time / __) + 1, a = new Date(e[0].time), o = a.getDate(), s = e[1].date.getDate();
      a.setDate(o + i - 1);
      var l = a.getDate();
      if (l !== s)
        for (var u = a.getTime() - e[1].time > 0 ? 1 : -1; (l = a.getDate()) !== s && (a.getTime() - e[1].time) * u > 0; )
          i -= u, a.setDate(l - u);
      var c = Math.floor((i + e[0].day + 6) / 7), f = n ? -c + 1 : c - 1;
      return n && e.reverse(), {
        range: [e[0].formatedDate, e[1].formatedDate],
        start: e[0],
        end: e[1],
        allDay: i,
        weeks: c,
        // From 0.
        nthWeek: f,
        fweek: e[0].day,
        lweek: e[1].day
      };
    }, r.prototype._getDateByWeeksAndDay = function(t, e, n) {
      var i = this._getRangeInfo(n);
      if (t > i.weeks || t === 0 && e < i.fweek || t === i.weeks && e > i.lweek)
        return null;
      var a = (t - 1) * 7 - i.fweek + e, o = new Date(i.start.time);
      return o.setDate(+i.start.d + a), this.getDateInfo(o);
    }, r.create = function(t, e) {
      var n = [];
      return t.eachComponent("calendar", function(i) {
        var a = new r(i, t, e);
        n.push(a), i.coordinateSystem = a;
      }), t.eachComponent(function(i, a) {
        zh({
          targetModel: a,
          coordSysType: "calendar",
          coordSysProvider: UN
        });
      }), n;
    }, r.dimensions = ["time", "value"], r;
  }()
);
function x_(r) {
  var t = r.calendarModel, e = r.seriesModel, n = t ? t.coordinateSystem : e ? e.coordinateSystem : null;
  return n;
}
function Jit(r) {
  r.registerComponentModel(qit), r.registerComponentView(Kit), r.registerCoordinateSystem("calendar", jit);
}
var Aa = {
  level: 1,
  leaf: 2,
  nonLeaf: 3
}, Ba = {
  // No clamp, be falsy, equals to null/undefined. It means if the input part is
  // null/undefined/NaN/outOfBoundary, the result part is NaN, rather than clamp to
  // the boundary of the matrix.
  none: 0,
  // Clamp, where null/undefined/NaN/outOfBoundary can be used to cover the entire row/column.
  all: 1,
  body: 2,
  corner: 3
};
function GS(r, t, e) {
  var n = t[Wt[e]].getCell(r);
  return !n && fe(r) && r < 0 && (n = t[Wt[1 - e]].getUnitLayoutInfo(e, Math.round(r))), n;
}
function yV(r) {
  var t = r || [];
  return t[0] = t[0] || [], t[1] = t[1] || [], t[0][0] = t[0][1] = t[1][0] = t[1][1] = NaN, t;
}
function _V(r, t, e, n, i) {
  d2(r[0], t, i, e, n, 0), d2(r[1], t, i, e, n, 1);
}
function d2(r, t, e, n, i, a) {
  r[0] = 1 / 0, r[1] = -1 / 0;
  var o = n[a], s = et(o) ? o : [o], l = s.length, u = !!e;
  if (l >= 1 ? (p2(r, t, s, u, i, a, 0), l > 1 && p2(r, t, s, u, i, a, l - 1)) : (process.env.NODE_ENV !== "production" && t && t.push('Should be like [["x1", "x2"], ["y1", "y2"]], or ["x1", "y1"], rather than empty.'), r[0] = r[1] = NaN), u) {
    var c = -i[Wt[1 - a]].getLocatorCount(a), f = i[Wt[a]].getLocatorCount(a) - 1;
    e === Ba.body ? c = tr(0, c) : e === Ba.corner && (f = kn(-1, f)), f < c && (c = f = NaN), Or(r[0]) && (r[0] = c), Or(r[1]) && (r[1] = f), r[0] = tr(kn(r[0], f), c), r[1] = tr(kn(r[1], f), c);
  }
}
function p2(r, t, e, n, i, a, o) {
  var s = GS(e[o], i, a);
  if (!s) {
    process.env.NODE_ENV !== "production" && !n && t && t.push("Can not find cell by coord[" + a + "][" + o + "]."), r[0] = r[1] = NaN;
    return;
  }
  var l = s.id[Wt[a]], u = l, c = rat(s);
  c && (u += c.span[Wt[a]] - 1), r[0] = kn(r[0], l, u), r[1] = tr(r[1], l, u);
}
function Mp(r, t) {
  return Or(r[t][0]) || Or(r[t][1]);
}
function v2(r, t, e, n) {
  t = t || Qit;
  for (var i = 0; i < n; i++)
    t[i] = !1;
  for (; ; ) {
    for (var a = !1, i = 0; i < n; i++) {
      var o = e[i];
      !t[i] && o.cellMergeOwner && tat(r, o.locatorRange) && (t[i] = !0, a = !0);
    }
    if (!a)
      break;
  }
}
var Qit = [];
function tat(r, t) {
  return !g2(r[0], t[0]) || !g2(r[1], t[1]) ? !1 : (r[0][0] = kn(r[0][0], t[0][0]), r[0][1] = tr(r[0][1], t[0][1]), r[1][0] = kn(r[1][0], t[1][0]), r[1][1] = tr(r[1][1], t[1][1]), !0);
}
function g2(r, t) {
  return r[1] >= t[0] && r[0] <= t[1];
}
function m2(r, t) {
  r.id.set(t[0][0], t[1][0]), r.span.set(t[0][1] - r.id.x + 1, t[1][1] - r.id.y + 1);
}
function eat(r, t) {
  r[0][0] = t[0][0], r[0][1] = t[0][1], r[1][0] = t[1][0], r[1][1] = t[1][1];
}
function y2(r, t, e, n) {
  var i = GS(t[n][0], e, n), a = GS(t[n][1], e, n);
  r[Wt[n]] = r[ur[n]] = NaN, i && a && (r[Wt[n]] = i.xy, r[ur[n]] = a.xy + a.wh - i.xy);
}
function mf(r, t, e, n) {
  return r[Wt[t]] = e, r[Wt[1 - t]] = n, r;
}
function rat(r) {
  return r && (r.type === Aa.leaf || r.type === Aa.nonLeaf) ? r : null;
}
function _g() {
  return {
    x: NaN,
    y: NaN,
    width: NaN,
    height: NaN
  };
}
var _2 = (
  /** @class */
  function() {
    function r(t, e) {
      this._cells = [], this._levels = [], this.dim = t, this.dimIdx = t === "x" ? 0 : 1, this._model = e, this._uniqueValueGen = nat(t);
      var n = e.get("data", !0);
      n != null && !et(n) && (process.env.NODE_ENV !== "production" && ce("Illegal echarts option - matrix." + this.dim + ".data must be an array if specified."), n = []), n ? this._initByDimModelData(n) : this._initBySeriesData();
    }
    return r.prototype._initByDimModelData = function(t) {
      var e = this, n = e._cells, i = e._levels, a = [], o = 0;
      e._leavesCount = s(t, 0, 0), l();
      return;
      function s(u, c, f) {
        var h = 0;
        return u && L(u, function(d, p) {
          var g = !1, v;
          pt(d) ? v = {
            value: d
          } : Dt(d) ? (v = d, d.value != null && !pt(d.value) && (g = !0, v = {
            value: null
          })) : (v = {
            value: null
          }, d != null && (g = !0)), g && process.env.NODE_ENV !== "production" && ce("Illegal echarts option - matrix." + e.dim + ".data[" + p + "] must be `string | {value: string}`.");
          var m = {
            type: Aa.nonLeaf,
            ordinal: NaN,
            level: f,
            firstLeafLocator: c,
            id: new Nt(),
            span: mf(new Nt(), e.dimIdx, 1, 1),
            option: v,
            xy: NaN,
            wh: NaN,
            dim: e,
            rect: _g()
          };
          o++, (a[c] || (a[c] = [])).push(m), i[f] || (i[f] = {
            type: Aa.level,
            xy: NaN,
            wh: NaN,
            option: null,
            id: new Nt(),
            dim: e
          });
          var y = s(v.children, c, f + 1), _ = Math.max(1, y);
          m.span[Wt[e.dimIdx]] = _, h += _, c += _;
        }), h;
      }
      function l() {
        for (var u = []; n.length < o; )
          for (var c = 0; c < a.length; c++) {
            var f = a[c].pop();
            if (f) {
              f.ordinal = u.length;
              var h = f.option.value;
              u.push(h), n.push(f), e._uniqueValueGen.calcDupBase(h);
            }
          }
        e._uniqueValueGen.ensureValueUnique(u, n);
        var d = e._ordinalMeta = new ph({
          categories: u,
          needCollect: !1,
          deduplication: !1
        });
        e._scale = new oc({
          ordinalMeta: d
        });
        for (var p = 0; p < e._leavesCount; p++) {
          var g = e._cells[p];
          g.type = Aa.leaf, g.span[Wt[1 - e.dimIdx]] = e._levels.length - g.level;
        }
        e._initCellsId(), e._initLevelIdOptions();
      }
    }, r.prototype._initBySeriesData = function() {
      var t = this;
      t._leavesCount = 0, t._levels = [{
        type: Aa.level,
        xy: NaN,
        wh: NaN,
        option: null,
        id: new Nt(),
        dim: t
      }], t._initLevelIdOptions();
      var e = t._ordinalMeta = new ph({
        needCollect: !0,
        deduplication: !0,
        onCollect: function(n, i) {
          var a = t._cells[i] = {
            type: Aa.leaf,
            ordinal: i,
            level: 0,
            firstLeafLocator: i,
            id: new Nt(),
            span: mf(new Nt(), t.dimIdx, 1, 1),
            // Theoretically `value` is from `dataset` or `series.data`, so it may be any type.
            // Do not restrict this case for user's convenience, and here simply convert it to
            // string for display.
            option: {
              value: n + ""
            },
            xy: NaN,
            wh: NaN,
            dim: t,
            rect: _g()
          };
          t._leavesCount++, t._setCellId(a);
        }
      });
      t._scale = new oc({
        ordinalMeta: e
      });
    }, r.prototype._setCellId = function(t) {
      var e = this._levels.length, n = this.dimIdx;
      mf(t.id, n, t.firstLeafLocator, t.level - e);
    }, r.prototype._initCellsId = function() {
      var t = this._levels.length, e = this.dimIdx;
      L(this._cells, function(n) {
        mf(n.id, e, n.firstLeafLocator, n.level - t);
      });
    }, r.prototype._initLevelIdOptions = function() {
      var t = this._levels.length, e = this.dimIdx, n = this._model.get("levels", !0);
      n = et(n) ? n : [], L(this._levels, function(i, a) {
        mf(i.id, e, 0, a - t), i.option = n[a];
      });
    }, r.prototype.shouldShow = function() {
      return !!this._model.getShallow("show", !0);
    }, r.prototype.resetLayoutIterator = function(t, e, n, i) {
      if (t = t || new Oo(), e === this.dimIdx) {
        var a = this._leavesCount, o = n != null ? Math.max(0, n) : 0;
        i = i != null ? Math.min(i, a) : a, t.reset(this._cells, o, o + i);
      } else {
        var a = this._levels.length, o = n != null ? Math.max(0, n + a) : 0;
        i = i != null ? Math.min(i, a) : a, t.reset(this._levels, o, o + i);
      }
      return t;
    }, r.prototype.resetCellIterator = function(t) {
      return (t || new Oo()).reset(this._cells, 0);
    }, r.prototype.resetLevelIterator = function(t) {
      return (t || new Oo()).reset(this._levels, 0);
    }, r.prototype.getLayout = function(t, e, n) {
      var i = this.getUnitLayoutInfo(e, n);
      t[Wt[e]] = i ? i.xy : NaN, t[ur[e]] = i ? i.wh : NaN;
    }, r.prototype.getUnitLayoutInfo = function(t, e) {
      return t === this.dimIdx ? e < this._leavesCount ? this._cells[e] : void 0 : this._levels[e + this._levels.length];
    }, r.prototype.getCell = function(t) {
      var e = this._scale.parse(t);
      return Or(e) ? void 0 : this._cells[e];
    }, r.prototype.getLocatorCount = function(t) {
      return t === this.dimIdx ? this._leavesCount : this._levels.length;
    }, r.prototype.getOrdinalMeta = function() {
      return this._ordinalMeta;
    }, r;
  }()
);
function nat(r) {
  var t = r.toUpperCase(), e = new RegExp("^" + t + "([0-9]+)$"), n = 0;
  function i(s) {
    var l;
    s != null && (l = s.match(e)) && (n = tr(n, +l[1] + 1));
  }
  function a() {
    return "" + t + n++;
  }
  function o(s, l) {
    for (var u = wt(), c = 0; c < s.length; c++) {
      var f = s[c];
      (f == null || u.get(f) != null) && (s[c] = f = a(), l[c].option = kt({
        value: f
      }, l[c].option)), u.set(f, !0);
    }
  }
  return {
    calcDupBase: i,
    ensureValueUnique: o
  };
}
var x2 = (
  /** @class */
  function() {
    function r(t, e, n) {
      this._model = e, this._dims = n, this._kind = t, this._cellMergeOwnerList = [];
    }
    return r.prototype._ensureCellMap = function() {
      var t = this, e = t._cellMap;
      return e || (e = t._cellMap = wt(), n()), e;
      function n() {
        var a = [], o = t._model.getShallow("data");
        o && !et(o) && (process.env.NODE_ENV !== "production" && ce("matrix." + o + ".data must be an array if specified."), o = null), L(o, function(p, g) {
          if (!Dt(p) || !et(p.coord)) {
            process.env.NODE_ENV !== "production" && ce("Illegal matrix." + t._kind + ".data[" + g + "], must be a {coord: [...], ...}");
            return;
          }
          var v = yV([]), m = null;
          if (process.env.NODE_ENV !== "production" && (m = []), _V(v, m, p.coord, t._dims, p.coordClamp ? Ba[t._kind] : Ba.none), Mp(v, 0) || Mp(v, 1)) {
            process.env.NODE_ENV !== "production" && ce("Can not determine cells by option matrix." + t._kind + ".data[" + g + "]: " + ("" + m.join(" ")));
            return;
          }
          var y = p && p.mergeCells, _ = {
            id: new Nt(),
            span: new Nt(),
            locatorRange: v,
            option: p,
            cellMergeOwner: y
          };
          m2(_, v), a.push(_);
        });
        for (var s = [], l = 0; l < a.length; l++) {
          var u = a[l];
          if (u.cellMergeOwner) {
            var c = u.locatorRange;
            v2(c, s, a, l);
            for (var f = 0; f < l; f++)
              s[f] && (a[f].cellMergeOwner = !1);
            if (c[0][0] !== u.id.x || c[1][0] !== u.id.y) {
              u.cellMergeOwner = !1;
              var h = J({}, u.option);
              h.coord = null;
              var d = {
                id: new Nt(),
                span: new Nt(),
                locatorRange: c,
                option: h,
                cellMergeOwner: !0
              };
              m2(d, c), a.push(d);
            }
          }
        }
        L(a, function(p) {
          var g = i(p.id.x, p.id.y);
          if (p.cellMergeOwner && (g.cellMergeOwner = !0, g.span = p.span, g.locatorRange = p.locatorRange, g.spanRect = _g(), t._cellMergeOwnerList.push(g)), !(!p.cellMergeOwner && !p.option))
            for (var v = 0; v < p.span.y; v++)
              for (var m = 0; m < p.span.x; m++) {
                var y = i(p.id.x + m, p.id.y + v);
                y.option = p.option, p.cellMergeOwner && (y.inSpanOf = g);
              }
        });
      }
      function i(a, o) {
        var s = S2(a, o), l = e.get(s);
        return l || (l = e.set(s, {
          id: new Nt(a, o),
          option: null,
          inSpanOf: null,
          span: null,
          spanRect: null,
          locatorRange: null,
          cellMergeOwner: !1
        })), l;
      }
    }, r.prototype.getCell = function(t) {
      return this._ensureCellMap().get(S2(t[0], t[1]));
    }, r.prototype.travelExistingCells = function(t) {
      this._ensureCellMap().each(t);
    }, r.prototype.expandRangeByCellMerge = function(t) {
      if (!Mp(t, 0) && !Mp(t, 1) && t[0][0] === t[0][1] && t[1][0] === t[1][1]) {
        S_[0] = t[0][0], S_[1] = t[1][0];
        var e = this.getCell(S_), n = e && e.inSpanOf;
        if (n) {
          eat(t, n.locatorRange);
          return;
        }
      }
      var i = this._cellMergeOwnerList;
      v2(t, null, i, i.length);
    }, r;
  }()
), S_ = [];
function S2(r, t) {
  return r + "|" + t;
}
var xw = {
  show: !0,
  color: Y.color.secondary,
  // overflow: 'truncate',
  overflow: "break",
  lineOverflow: "truncate",
  padding: [2, 3, 2, 3],
  // Prefer to use `padding`, rather than distance.
  distance: 0
};
function Sw(r) {
  return {
    color: "none",
    borderWidth: 1,
    borderColor: r ? "none" : Y.color.borderTint
  };
}
var b2 = {
  show: !0,
  label: xw,
  itemStyle: Sw(!1),
  silent: void 0,
  dividerLineStyle: {
    width: 1,
    color: Y.color.border
  }
}, iat = {
  label: xw,
  itemStyle: Sw(!1),
  silent: void 0
}, aat = {
  label: xw,
  itemStyle: Sw(!0),
  silent: void 0
}, oat = {
  // As a most basic coord sys, `z` should be lower than
  // other series and coord sys, such as, grid.
  z: -50,
  left: "10%",
  top: "10%",
  right: "10%",
  bottom: "10%",
  x: b2,
  y: b2,
  body: iat,
  corner: aat,
  backgroundStyle: {
    color: "none",
    borderColor: Y.color.axisLine,
    borderWidth: 1
  }
}, sat = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.optionUpdated = function() {
      var e = this._dimModels = {
        // Do not use matrixModel as the parent model, for preventing from cascade-fetching options to it.
        x: new w2(this.get("x", !0) || {}),
        y: new w2(this.get("y", !0) || {})
      };
      e.x.option.type = e.y.option.type = "category";
      var n = e.x.dim = new _2("x", e.x), i = e.y.dim = new _2("y", e.y), a = {
        x: n,
        y: i
      };
      this._body = new x2("body", new ue(this.getShallow("body")), a), this._corner = new x2("corner", new ue(this.getShallow("corner")), a);
    }, t.prototype.getDimensionModel = function(e) {
      return this._dimModels[e];
    }, t.prototype.getBody = function() {
      return this._body;
    }, t.prototype.getCorner = function() {
      return this._corner;
    }, t.type = "matrix", t.layoutMode = "box", t.defaultOption = oat, t;
  }(re)
), w2 = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t.prototype.getOrdinalMeta = function() {
      return this.dim.getOrdinalMeta();
    }, t;
  }(ue)
), Tp = Math.round, lat = 0, uat = 99, cat = {
  normal: 25,
  special: 100
}, fat = {
  normal: 50,
  special: 125
}, hat = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n) {
      this.group.removeAll();
      var i = this.group, a = e.coordinateSystem, o = a.getRect(), s = e.getDimensionModel("x"), l = e.getDimensionModel("y"), u = s.dim, c = l.dim;
      dat(i, e, n), pat(i, e, u, c, n);
      var f = e.getShallow("borderZ2", !0), h = bt(f, uat), d = h - 1, p = e.getModel("backgroundStyle").getItemStyle(["borderWidth"]);
      p.lineWidth = 0;
      var g = e.getModel("backgroundStyle").getItemStyle(["color", "decal", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"]);
      g.fill = "none";
      var v = HS(o.clone(), p, lat), m = HS(o.clone(), g, h);
      v.silent = !0, m.silent = !0, i.add(v), i.add(m);
      var y = u.getUnitLayoutInfo(0, 0), _ = c.getUnitLayoutInfo(1, 0);
      y && _ && (u.shouldShow() && i.add(M2({
        x1: o.x,
        y1: _.xy,
        x2: o.x + o.width,
        y2: _.xy
      }, s.getModel("dividerLineStyle").getLineStyle(), d)), c.shouldShow() && i.add(M2({
        x1: y.xy,
        y1: o.y,
        x2: y.xy,
        y2: o.y + o.height
      }, l.getModel("dividerLineStyle").getLineStyle(), d)));
    }, t.type = "matrix", t;
  }(Ue)
);
function dat(r, t, e) {
  n(0), n(1);
  function n(i) {
    var a = t.getDimensionModel(Wt[i]), o = a.dim;
    if (o.shouldShow())
      for (var s = a.getModel("itemStyle"), l = a.getModel("label"), u = t.getShallow("tooltip", !0), c = [], f = o.resetCellIterator(); f.next(); ) {
        var h = f.item, d = {};
        Bt.copy(d, h.rect), b1(c, h.id.x, h.id.y), xV(c, t, r, e, h.option, s, l, a, d, h.option.value, fat, u);
      }
  }
}
function pat(r, t, e, n, i) {
  a("body", t.getBody(), e, n), e.shouldShow() && n.shouldShow() && a("corner", t.getCorner(), n, e);
  function a(o, s, l, u) {
    var c = new ue(t.getShallow(o, !0)), f = c.getModel("itemStyle"), h = c.getModel("label"), d = new Oo(), p = new Oo(), g = [], v = t.getShallow("tooltip", !0);
    for (u.resetLayoutIterator(p, 1); p.next(); )
      for (l.resetLayoutIterator(d, 0); d.next(); ) {
        var m = d.item, y = p.item;
        b1(g, m.id.x, y.id.y);
        var _ = s.getCell(g);
        if (!(_ && _.inSpanOf && _.inSpanOf !== _)) {
          var x = {};
          _ && _.span ? Bt.copy(x, _.spanRect) : (m.dim.getLayout(x, 0, g[0]), y.dim.getLayout(x, 1, g[1]));
          var b = _ ? _.option : null;
          xV(g, t, r, i, b, f, h, c, x, b ? b.value : null, cat, v);
        }
      }
  }
}
function xV(r, t, e, n, i, a, o, s, l, u, c, f) {
  var h;
  Ap.option = i ? i.itemStyle : null, Ap.parentModel = a, xu.option = i, xu.parentModel = s;
  var d = bt(xu.getShallow("z2"), i && i.itemStyle ? c.special : c.normal), p = f && f.show, g = HS(l, Ap.getItemStyle(), d);
  e.add(g);
  var v = xu.get("cursor");
  v != null && g.attr("cursor", v);
  var m;
  if (u != null) {
    var y = u + "";
    if (Su.option = i ? i.label : null, Su.parentModel = o, Su.ecModel = n, Er(
      g,
      // Currently do not support other states (`emphasis`, `select`, `blur`)
      {
        normal: Su
      },
      {
        defaultText: y,
        autoOverflowArea: !0,
        // By default based on boundingRect. But boundingRect contains borderWidth,
        // and borderWidth is half outside the cell. Thus specific `layoutRect` explicitly.
        layoutRect: Ct(g.shape)
      }
    ), m = g.getTextContent(), m) {
      m.z2 = d + 1;
      var _ = m.style;
      if (_ && _.overflow && _.overflow !== "none" && _.lineOverflow) {
        var x = {};
        Bt.copy(x, l), gl(x, (((h = g.style) === null || h === void 0 ? void 0 : h.lineWidth) || 0) / 2, !0, !0), g.updateInnerText(), m.getLocalTransform(Ep), Si(Ep, Ep), Bt.applyTransform(x, x, Ep), m.setClipPath(new te({
          shape: x
        }));
      }
    }
    Ka({
      el: g,
      componentModel: t,
      itemName: y,
      itemTooltipOption: f,
      formatterParamsExtra: {
        xyLocator: r.slice()
      }
    });
  }
  if (m) {
    var b = Su.get("silent");
    b == null && (b = !p), m.silent = b, m.ignoreHostSilent = !0;
  }
  var S = xu.get("silent");
  S == null && (S = // If no background color in cell, set `rect.silent: false` will cause that only
  // the border response to mouse hovering, which is probably weird.
  !g.style || g.style.fill === "none" || !g.style.fill), g.silent = S, Iy(xu), Iy(Ap), Iy(Su);
}
var xu = new ue(), Ap = new ue(), Su = new ue(), Ep = [];
function HS(r, t, e) {
  var n = t.lineWidth;
  if (n) {
    var i = r.x + r.width, a = r.y + r.height;
    r.x = Nn(r.x, n, !0), r.y = Nn(r.y, n, !0), r.width = Nn(i, n, !0) - r.x, r.height = Nn(a, n, !0) - r.y;
  }
  return new te({
    shape: r,
    style: t,
    z2: e
  });
}
function M2(r, t, e) {
  var n = t.lineWidth;
  return n && (Tp(r.x1 * 2) === Tp(r.x2 * 2) && (r.x1 = r.x2 = Nn(r.x1, n, !0)), Tp(r.y1 * 2) === Tp(r.y2 * 2) && (r.y1 = r.y2 = Nn(r.y1, n, !0))), new sr({
    shape: r,
    style: t,
    silent: !0,
    z2: e
  });
}
var vat = (
  /** @class */
  function() {
    function r(t, e, n) {
      this.dimensions = r.dimensions, this.type = "matrix", this._model = t;
      var i = this._dimModels = {
        x: t.getDimensionModel("x"),
        y: t.getDimensionModel("y")
      };
      this._dims = {
        x: i.x.dim,
        y: i.y.dim
      }, this._resize(t, n);
    }
    return r.getDimensionsInfo = function() {
      return [{
        name: "x",
        type: "ordinal"
      }, {
        name: "y",
        type: "ordinal"
      }, {
        name: "value"
      }];
    }, r.create = function(t, e) {
      var n = [];
      return t.eachComponent("matrix", function(i) {
        var a = new r(i, t, e);
        n.push(a), i.coordinateSystem = a;
      }), t.eachComponent(function(i, a) {
        zh({
          targetModel: a,
          coordSysType: "matrix",
          coordSysProvider: UN
        });
      }), n;
    }, r.prototype.getRect = function() {
      return this._rect;
    }, r.prototype._resize = function(t, e) {
      var n = this._dims, i = this._dimModels, a = this._rect = He(t.getBoxLayoutParams(), {
        width: e.getWidth(),
        height: e.getHeight()
      });
      T2(i, n, a, 0), T2(i, n, a, 1), A2(0, n), A2(1, n), E2(this._model.getBody(), n), E2(this._model.getCorner(), n);
    }, r.prototype.dataToPoint = function(t, e, n) {
      return n = n || [], this.dataToLayout(t, e, yf), n[0] = yf.rect.x + yf.rect.width / 2, n[1] = yf.rect.y + yf.rect.height / 2, n;
    }, r.prototype.dataToLayout = function(t, e, n) {
      var i = this._dims;
      n = n || {};
      var a = n.rect = n.rect || {};
      a.x = a.y = a.width = a.height = NaN;
      var o = n.matrixXYLocatorRange = yV(n.matrixXYLocatorRange);
      return et(t) ? (_V(o, null, t, i, bt(e && e.clamp, Ba.none)), (!e || !e.ignoreMergeCells) && ((!e || e.clamp !== Ba.corner) && this._model.getBody().expandRangeByCellMerge(o), (!e || e.clamp !== Ba.body) && this._model.getCorner().expandRangeByCellMerge(o)), y2(a, o, i, 0), y2(a, o, i, 1), n) : (process.env.NODE_ENV !== "production" && ce("Input data must be an array in `convertToLayout`, `convertToPixel`"), n);
    }, r.prototype.pointToData = function(t, e, n) {
      var i = this._dims;
      return C2(Pi, 0, i, t, e && e.clamp), C2(Pi, 1, i, t, e && e.clamp), n = n || [], n[0] = n[1] = NaN, Pi.y === zr.inCorner && Pi.x === zr.inBody ? D2(Pi, n, 0, i) : Pi.x === zr.inCorner && Pi.y === zr.inBody ? D2(Pi, n, 1, i) : (L2(Pi, n, 0, i), L2(Pi, n, 1, i)), n;
    }, r.prototype.convertToPixel = function(t, e, n, i) {
      var a = w_(e);
      return a === this ? a.dataToPoint(n, i) : void 0;
    }, r.prototype.convertToLayout = function(t, e, n, i) {
      var a = w_(e);
      return a === this ? a.dataToLayout(n, i) : void 0;
    }, r.prototype.convertFromPixel = function(t, e, n, i) {
      var a = w_(e);
      return a === this ? a.pointToData(n, i) : void 0;
    }, r.prototype.containPoint = function(t) {
      return this._rect.contain(t[0], t[1]);
    }, r.dimensions = ["x", "y", "value"], r;
  }()
), yf = {
  rect: _g()
}, Cp = new Oo(), b_ = new Oo();
function T2(r, t, e, n) {
  for (var i = 1 - n, a = t[Wt[n]], o = t[Wt[i]], s = o.shouldShow(), l = a.resetCellIterator(); l.next(); )
    l.item.wh = l.item.xy = NaN;
  for (var u = o.resetLayoutIterator(null, n); u.next(); )
    u.item.wh = u.item.xy = NaN;
  for (var c = e[ur[n]], f = a.getLocatorCount(n) + o.getLocatorCount(n), h = new ue(), d = o.resetLevelIterator(); d.next(); )
    h.option = d.item.option, h.parentModel = r[Wt[i]], v(d.item, s ? h.get("levelSize") : 0);
  for (var p = new ue(), g = a.resetCellIterator(); g.next(); )
    g.item.type === Aa.leaf && (p.option = g.item.option, p.parentModel = void 0, v(g.item, p.get("size")));
  function v(w, A) {
    var T = gat(A, n, e);
    Or(T) || (w.wh = WS(T, c), c = WS(c - w.wh), f--);
  }
  var m = f ? c / f : 0, y = !f && c >= 1, _ = e[Wt[n]], x = a.getLocatorCount(n) - 1, b = new Oo();
  for (o.resetLayoutIterator(b, n); b.next(); )
    S(b.item);
  for (a.resetLayoutIterator(b, n); b.next(); )
    S(b.item);
  function S(w) {
    Or(w.wh) && (w.wh = m), w.xy = _, w.id[Wt[n]] === x && !y && (w.wh = e[Wt[n]] + e[ur[n]] - w.xy), _ += w.wh;
  }
}
function A2(r, t) {
  for (var e = t[Wt[r]].resetCellIterator(); e.next(); ) {
    var n = e.item;
    xg(n.rect, r, n.id, n.span, t), xg(n.rect, 1 - r, n.id, n.span, t), n.type === Aa.nonLeaf && (n.xy = n.rect[Wt[r]], n.wh = n.rect[ur[r]]);
  }
}
function E2(r, t) {
  r.travelExistingCells(function(e) {
    var n = e.span;
    if (n) {
      var i = e.spanRect, a = e.id;
      xg(i, 0, a, n, t), xg(i, 1, a, n, t);
    }
  });
}
function xg(r, t, e, n, i) {
  r[ur[t]] = 0;
  var a = e[Wt[t]], o = a < 0 ? i[Wt[1 - t]] : i[Wt[t]], s = o.getUnitLayoutInfo(t, e[Wt[t]]);
  if (r[Wt[t]] = s.xy, r[ur[t]] = s.wh, n[Wt[t]] > 1) {
    var l = o.getUnitLayoutInfo(t, e[Wt[t]] + n[Wt[t]] - 1);
    r[ur[t]] = l.xy + l.wh - s.xy;
  }
}
function gat(r, t, e) {
  var n = Dv(r, e[ur[t]]);
  return WS(n, e[ur[t]]);
}
function WS(r, t) {
  return Math.max(Math.min(r, bt(t, 1 / 0)), 0);
}
function w_(r) {
  var t = r.matrixModel, e = r.seriesModel, n = t ? t.coordinateSystem : e ? e.coordinateSystem : null;
  return n;
}
var zr = {
  inBody: 1,
  inCorner: 2,
  outside: 3
}, Pi = {
  x: null,
  y: null,
  point: []
};
function C2(r, t, e, n, i) {
  var a = e[Wt[t]], o = e[Wt[1 - t]], s = a.getUnitLayoutInfo(t, a.getLocatorCount(t) - 1), l = a.getUnitLayoutInfo(t, 0), u = o.getUnitLayoutInfo(t, -o.getLocatorCount(t)), c = o.shouldShow() ? o.getUnitLayoutInfo(t, -1) : null, f = r.point[t] = n[t];
  if (!l && !c) {
    r[Wt[t]] = zr.outside;
    return;
  }
  if (i === Ba.body) {
    l ? (r[Wt[t]] = zr.inBody, f = kn(s.xy + s.wh, tr(l.xy, f)), r.point[t] = f) : r[Wt[t]] = zr.outside;
    return;
  } else if (i === Ba.corner) {
    c ? (r[Wt[t]] = zr.inCorner, f = kn(c.xy + c.wh, tr(u.xy, f)), r.point[t] = f) : r[Wt[t]] = zr.outside;
    return;
  }
  var h = l ? l.xy : c ? c.xy + c.wh : NaN, d = u ? u.xy : h, p = s ? s.xy + s.wh : h;
  if (f < d) {
    if (!i) {
      r[Wt[t]] = zr.outside;
      return;
    }
    f = d;
  } else if (f > p) {
    if (!i) {
      r[Wt[t]] = zr.outside;
      return;
    }
    f = p;
  }
  r.point[t] = f, r[Wt[t]] = h <= f && f <= p ? zr.inBody : d <= f && f <= h ? zr.inCorner : zr.outside;
}
function D2(r, t, e, n) {
  var i = 1 - e;
  if (r[Wt[e]] !== zr.outside)
    for (n[Wt[e]].resetCellIterator(b_); b_.next(); ) {
      var a = b_.item;
      if (R2(r.point[e], a.rect, e) && R2(r.point[i], a.rect, i)) {
        t[e] = a.ordinal, t[i] = a.id[Wt[i]];
        return;
      }
    }
}
function L2(r, t, e, n) {
  if (r[Wt[e]] !== zr.outside) {
    var i = r[Wt[e]] === zr.inCorner ? n[Wt[1 - e]] : n[Wt[e]];
    for (i.resetLayoutIterator(Cp, e); Cp.next(); )
      if (mat(r.point[e], Cp.item)) {
        t[e] = Cp.item.id[Wt[e]];
        return;
      }
  }
}
function mat(r, t) {
  return t.xy <= r && r <= t.xy + t.wh;
}
function R2(r, t, e) {
  return t[Wt[e]] <= r && r <= t[Wt[e]] + t[ur[e]];
}
function yat(r) {
  r.registerComponentModel(sat), r.registerComponentView(hat), r.registerCoordinateSystem("matrix", vat);
}
function _at(r, t) {
  var e = r.existing;
  if (t.id = r.keyInfo.id, !t.type && e && (t.type = e.type), t.parentId == null) {
    var n = t.parentOption;
    n ? t.parentId = n.id : e && (t.parentId = e.parentId);
  }
  t.parentOption = null;
}
function I2(r, t) {
  var e;
  return L(t, function(n) {
    r[n] != null && r[n] !== "auto" && (e = !0);
  }), e;
}
function xat(r, t, e) {
  var n = J({}, e), i = r[t], a = e.$action || "merge";
  if (a === "merge")
    if (i) {
      if (process.env.NODE_ENV !== "production") {
        var o = e.type;
        St(!o || i.type === o, 'Please set $action: "replace" to change `type`');
      }
      qt(i, n, !0), oa(i, n, {
        ignoreSize: !0
      }), YN(e, i), Dp(e, i), Dp(e, i, "shape"), Dp(e, i, "style"), Dp(e, i, "extra"), e.clipPath = i.clipPath;
    } else
      r[t] = n;
  else
    a === "replace" ? r[t] = n : a === "remove" && i && (r[t] = null);
}
var SV = ["transition", "enterFrom", "leaveTo"], Sat = SV.concat(["enterAnimation", "updateAnimation", "leaveAnimation"]);
function Dp(r, t, e) {
  if (e && (!r[e] && t[e] && (r[e] = {}), r = r[e], t = t[e]), !(!r || !t))
    for (var n = e ? SV : Sat, i = 0; i < n.length; i++) {
      var a = n[i];
      r[a] == null && t[a] != null && (r[a] = t[a]);
    }
}
function bat(r, t) {
  if (r && (r.hv = t.hv = [
    // Rigid body, don't care about `width`.
    I2(t, ["left", "right"]),
    // Rigid body, don't care about `height`.
    I2(t, ["top", "bottom"])
  ], r.type === "group")) {
    var e = r, n = t;
    e.width == null && (e.width = n.width = 0), e.height == null && (e.height = n.height = 0);
  }
}
var wat = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.preventAutoZ = !0, e;
    }
    return t.prototype.mergeOption = function(e, n) {
      var i = this.option.elements;
      this.option.elements = null, r.prototype.mergeOption.call(this, e, n), this.option.elements = i;
    }, t.prototype.optionUpdated = function(e, n) {
      var i = this.option, a = (n ? i : e).elements, o = i.elements = n ? [] : i.elements, s = [];
      this._flatten(a, s, null);
      var l = OP(o, s, "normalMerge"), u = this._elOptionsToUpdate = [];
      L(l, function(c, f) {
        var h = c.newOption;
        process.env.NODE_ENV !== "production" && St(Dt(h) || c.existing, "Empty graphic option definition"), h && (u.push(h), _at(c, h), xat(o, f, h), bat(o[f], h));
      }, this), i.elements = Te(o, function(c) {
        return c && delete c.$action, c != null;
      });
    }, t.prototype._flatten = function(e, n, i) {
      L(e, function(a) {
        if (a) {
          i && (a.parentOption = i), n.push(a);
          var o = a.children;
          o && o.length && this._flatten(o, n, a), delete a.children;
        }
      }, this);
    }, t.prototype.useElOptionsToUpdate = function() {
      var e = this._elOptionsToUpdate;
      return this._elOptionsToUpdate = null, e;
    }, t.type = "graphic", t.defaultOption = {
      elements: []
      // parentId: null
    }, t;
  }(re)
), P2 = {
  // Reserved but not supported in graphic component.
  path: null,
  compoundPath: null,
  // Supported in graphic component.
  group: Et,
  image: Vr,
  text: pe
}, qn = ee(), Mat = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function() {
      this._elMap = wt();
    }, t.prototype.render = function(e, n, i) {
      e !== this._lastGraphicModel && this._clear(), this._lastGraphicModel = e, this._updateElements(e), this._relocate(e, i);
    }, t.prototype._updateElements = function(e) {
      var n = e.useElOptionsToUpdate();
      if (n) {
        var i = this._elMap, a = this.group, o = e.get("z"), s = e.get("zlevel");
        L(n, function(l) {
          var u = mr(l.id, null), c = u != null ? i.get(u) : null, f = mr(l.parentId, null), h = f != null ? i.get(f) : a, d = l.type, p = l.style;
          d === "text" && p && l.hv && l.hv[1] && (p.textVerticalAlign = p.textBaseline = p.verticalAlign = p.align = null);
          var g = l.textContent, v = l.textConfig;
          if (p && jB(p, d, !!v, !!g)) {
            var m = JB(p, d, !0);
            !v && m.textConfig && (v = l.textConfig = m.textConfig), !g && m.textContent && (g = m.textContent);
          }
          var y = Tat(l);
          process.env.NODE_ENV !== "production" && c && St(h === c.parent, "Changing parent is not supported.");
          var _ = l.$action || "merge", x = _ === "merge", b = _ === "replace";
          if (x) {
            var S = !c, w = c;
            S ? w = N2(u, h, l.type, i) : (w && (qn(w).isNew = !1), nV(w)), w && (nv(w, y, e, {
              isInit: S
            }), O2(w, l, o, s));
          } else if (b) {
            ov(c, l, i, e);
            var A = N2(u, h, l.type, i);
            A && (nv(A, y, e, {
              isInit: !0
            }), O2(A, l, o, s));
          } else
            _ === "remove" && (tV(c, l), ov(c, l, i, e));
          var T = i.get(u);
          if (T && g)
            if (x) {
              var M = T.getTextContent();
              M ? M.attr(g) : T.setTextContent(new pe(g));
            } else
              b && T.setTextContent(new pe(g));
          if (T) {
            var E = l.clipPath;
            if (E) {
              var R = E.type, C = void 0, S = !1;
              if (x) {
                var D = T.getClipPath();
                S = !D || qn(D).type !== R, C = S ? XS(R) : D;
              } else
                b && (S = !0, C = XS(R));
              T.setClipPath(C), nv(C, E, e, {
                isInit: S
              }), vg(C, E.keyframeAnimation, e);
            }
            var I = qn(T);
            T.setTextConfig(v), I.option = l, Aat(T, e, l), Ka({
              el: T,
              componentModel: e,
              itemName: T.name,
              itemTooltipOption: l.tooltip
            }), vg(T, l.keyframeAnimation, e);
          }
        });
      }
    }, t.prototype._relocate = function(e, n) {
      for (var i = e.option.elements, a = this.group, o = this._elMap, s = n.getWidth(), l = n.getHeight(), u = ["x", "y"], c = 0; c < i.length; c++) {
        var f = i[c], h = mr(f.id, null), d = h != null ? o.get(h) : null;
        if (!(!d || !d.isGroup)) {
          var p = d.parent, g = p === a, v = qn(d), m = qn(p);
          v.width = dt(v.option.width, g ? s : m.width) || 0, v.height = dt(v.option.height, g ? l : m.height) || 0;
        }
      }
      for (var c = i.length - 1; c >= 0; c--) {
        var f = i[c], h = mr(f.id, null), d = h != null ? o.get(h) : null;
        if (d) {
          var p = d.parent, m = qn(p), y = p === a ? {
            width: s,
            height: l
          } : {
            width: m.width,
            height: m.height
          }, _ = {}, x = um(d, f, y, null, {
            hv: f.hv,
            boundingMode: f.bounding
          }, _);
          if (!qn(d).isNew && x) {
            for (var b = f.transition, S = {}, w = 0; w < u.length; w++) {
              var A = u[w], T = _[A];
              b && (ul(b) || Zt(b, A) >= 0) ? S[A] = T : d[A] = T;
            }
            ve(d, S, e, 0);
          } else
            d.attr(_);
        }
      }
    }, t.prototype._clear = function() {
      var e = this, n = this._elMap;
      n.each(function(i) {
        ov(i, qn(i).option, n, e._lastGraphicModel);
      }), this._elMap = wt();
    }, t.prototype.dispose = function() {
      this._clear();
    }, t.type = "graphic", t;
  }(Ue)
);
function XS(r) {
  process.env.NODE_ENV !== "production" && St(r, "graphic type MUST be set");
  var t = _t(P2, r) ? P2[r] : Nv(r);
  process.env.NODE_ENV !== "production" && St(t, "graphic type " + r + " can not be found");
  var e = new t({});
  return qn(e).type = r, e;
}
function N2(r, t, e, n) {
  var i = XS(e);
  return t.add(i), n.set(r, i), qn(i).id = r, qn(i).isNew = !0, i;
}
function ov(r, t, e, n) {
  var i = r && r.parent;
  i && (r.type === "group" && r.traverse(function(a) {
    ov(a, t, e, n);
  }), Mm(r, t, n), e.removeKey(qn(r).id));
}
function O2(r, t, e, n) {
  r.isGroup || L([
    ["cursor", ii.prototype.cursor],
    // We should not support configure z and zlevel in the element level.
    // But seems we didn't limit it previously. So here still use it to avoid breaking.
    ["zlevel", n || 0],
    ["z", e || 0],
    // z2 must not be null/undefined, otherwise sort error may occur.
    ["z2", 0]
  ], function(i) {
    var a = i[0];
    _t(t, a) ? r[a] = bt(t[a], i[1]) : r[a] == null && (r[a] = i[1]);
  }), L(se(t), function(i) {
    if (i.indexOf("on") === 0) {
      var a = t[i];
      r[i] = Tt(a) ? a : null;
    }
  }), _t(t, "draggable") && (r.draggable = t.draggable), t.name != null && (r.name = t.name), t.id != null && (r.id = t.id);
}
function Tat(r) {
  return r = J({}, r), L(["id", "parentId", "$action", "hv", "bounding", "textContent", "clipPath"].concat(GN), function(t) {
    delete r[t];
  }), r;
}
function Aat(r, t, e) {
  var n = zt(r).eventData;
  !r.silent && !r.ignore && !n && (n = zt(r).eventData = {
    componentType: "graphic",
    componentIndex: t.componentIndex,
    name: r.name
  }), n && (n.info = e.info);
}
function Eat(r) {
  r.registerComponentModel(wat), r.registerComponentView(Mat), r.registerPreprocessor(function(t) {
    var e = t.graphic;
    et(e) ? !e[0] || !e[0].elements ? t.graphic = [{
      elements: e
    }] : t.graphic = [t.graphic[0]] : e && !e.elements && (t.graphic = [{
      elements: [e]
    }]);
  });
}
var k2 = ["x", "y", "radius", "angle", "single"], Cat = ["cartesian2d", "polar", "singleAxis"];
function Dat(r) {
  var t = r.get("coordinateSystem");
  return Zt(Cat, t) >= 0;
}
function Co(r) {
  return process.env.NODE_ENV !== "production" && St(r), r + "Axis";
}
function Lat(r, t) {
  var e = wt(), n = [], i = wt();
  r.eachComponent({
    mainType: "dataZoom",
    query: t
  }, function(c) {
    i.get(c.uid) || s(c);
  });
  var a;
  do
    a = !1, r.eachComponent("dataZoom", o);
  while (a);
  function o(c) {
    !i.get(c.uid) && l(c) && (s(c), a = !0);
  }
  function s(c) {
    i.set(c.uid, !0), n.push(c), u(c);
  }
  function l(c) {
    var f = !1;
    return c.eachTargetAxis(function(h, d) {
      var p = e.get(h);
      p && p[d] && (f = !0);
    }), f;
  }
  function u(c) {
    c.eachTargetAxis(function(f, h) {
      (e.get(f) || e.set(f, []))[h] = !0;
    });
  }
  return n;
}
function bV(r) {
  var t = r.ecModel, e = {
    infoList: [],
    infoMap: wt()
  };
  return r.eachTargetAxis(function(n, i) {
    var a = t.getComponent(Co(n), i);
    if (a) {
      var o = a.getCoordSysModel();
      if (o) {
        var s = o.uid, l = e.infoMap.get(s);
        l || (l = {
          model: o,
          axisModels: []
        }, e.infoList.push(l), e.infoMap.set(s, l)), l.axisModels.push(a);
      }
    }
  }), e;
}
var M_ = (
  /** @class */
  function() {
    function r() {
      this.indexList = [], this.indexMap = [];
    }
    return r.prototype.add = function(t) {
      this.indexMap[t] || (this.indexList.push(t), this.indexMap[t] = !0);
    }, r;
  }()
), Th = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e._autoThrottle = !0, e._noTarget = !0, e._rangePropMode = ["percent", "percent"], e;
    }
    return t.prototype.init = function(e, n, i) {
      var a = B2(e);
      this.settledOption = a, this.mergeDefaultAndTheme(e, i), this._doInit(a);
    }, t.prototype.mergeOption = function(e) {
      var n = B2(e);
      qt(this.option, e, !0), qt(this.settledOption, n, !0), this._doInit(n);
    }, t.prototype._doInit = function(e) {
      var n = this.option;
      this._setDefaultThrottle(e), this._updateRangeUse(e);
      var i = this.settledOption;
      L([["start", "startValue"], ["end", "endValue"]], function(a, o) {
        this._rangePropMode[o] === "value" && (n[a[0]] = i[a[0]] = null);
      }, this), this._resetTarget();
    }, t.prototype._resetTarget = function() {
      var e = this.get("orient", !0), n = this._targetAxisInfoMap = wt(), i = this._fillSpecifiedTargetAxis(n);
      i ? this._orient = e || this._makeAutoOrientByTargetAxis() : (this._orient = e || "horizontal", this._fillAutoTargetAxisByOrient(n, this._orient)), this._noTarget = !0, n.each(function(a) {
        a.indexList.length && (this._noTarget = !1);
      }, this);
    }, t.prototype._fillSpecifiedTargetAxis = function(e) {
      var n = !1;
      return L(k2, function(i) {
        var a = this.getReferringComponents(Co(i), n6);
        if (a.specified) {
          n = !0;
          var o = new M_();
          L(a.models, function(s) {
            o.add(s.componentIndex);
          }), e.set(i, o);
        }
      }, this), n;
    }, t.prototype._fillAutoTargetAxisByOrient = function(e, n) {
      var i = this.ecModel, a = !0;
      if (a) {
        var o = n === "vertical" ? "y" : "x", s = i.findComponents({
          mainType: o + "Axis"
        });
        l(s, o);
      }
      if (a) {
        var s = i.findComponents({
          mainType: "singleAxis",
          filter: function(c) {
            return c.get("orient", !0) === n;
          }
        });
        l(s, "single");
      }
      function l(u, c) {
        var f = u[0];
        if (f) {
          var h = new M_();
          if (h.add(f.componentIndex), e.set(c, h), a = !1, c === "x" || c === "y") {
            var d = f.getReferringComponents("grid", Ke).models[0];
            d && L(u, function(p) {
              f.componentIndex !== p.componentIndex && d === p.getReferringComponents("grid", Ke).models[0] && h.add(p.componentIndex);
            });
          }
        }
      }
      a && L(k2, function(u) {
        if (a) {
          var c = i.findComponents({
            mainType: Co(u),
            filter: function(h) {
              return h.get("type", !0) === "category";
            }
          });
          if (c[0]) {
            var f = new M_();
            f.add(c[0].componentIndex), e.set(u, f), a = !1;
          }
        }
      }, this);
    }, t.prototype._makeAutoOrientByTargetAxis = function() {
      var e;
      return this.eachTargetAxis(function(n) {
        !e && (e = n);
      }, this), e === "y" ? "vertical" : "horizontal";
    }, t.prototype._setDefaultThrottle = function(e) {
      if (e.hasOwnProperty("throttle") && (this._autoThrottle = !1), this._autoThrottle) {
        var n = this.ecModel.option;
        this.option.throttle = n.animation && n.animationDurationUpdate > 0 ? 100 : 20;
      }
    }, t.prototype._updateRangeUse = function(e) {
      var n = this._rangePropMode, i = this.get("rangeMode");
      L([["start", "startValue"], ["end", "endValue"]], function(a, o) {
        var s = e[a[0]] != null, l = e[a[1]] != null;
        s && !l ? n[o] = "percent" : !s && l ? n[o] = "value" : i ? n[o] = i[o] : s && (n[o] = "percent");
      });
    }, t.prototype.noTarget = function() {
      return this._noTarget;
    }, t.prototype.getFirstTargetAxisModel = function() {
      var e;
      return this.eachTargetAxis(function(n, i) {
        e == null && (e = this.ecModel.getComponent(Co(n), i));
      }, this), e;
    }, t.prototype.eachTargetAxis = function(e, n) {
      this._targetAxisInfoMap.each(function(i, a) {
        L(i.indexList, function(o) {
          e.call(n, a, o);
        });
      });
    }, t.prototype.getAxisProxy = function(e, n) {
      var i = this.getAxisModel(e, n);
      if (i)
        return i.__dzAxisProxy;
    }, t.prototype.getAxisModel = function(e, n) {
      process.env.NODE_ENV !== "production" && St(e && n != null);
      var i = this._targetAxisInfoMap.get(e);
      if (i && i.indexMap[n])
        return this.ecModel.getComponent(Co(e), n);
    }, t.prototype.setRawRange = function(e) {
      var n = this.option, i = this.settledOption;
      L([["start", "startValue"], ["end", "endValue"]], function(a) {
        (e[a[0]] != null || e[a[1]] != null) && (n[a[0]] = i[a[0]] = e[a[0]], n[a[1]] = i[a[1]] = e[a[1]]);
      }, this), this._updateRangeUse(e);
    }, t.prototype.setCalculatedRange = function(e) {
      var n = this.option;
      L(["start", "startValue", "end", "endValue"], function(i) {
        n[i] = e[i];
      });
    }, t.prototype.getPercentRange = function() {
      var e = this.findRepresentativeAxisProxy();
      if (e)
        return e.getDataPercentWindow();
    }, t.prototype.getValueRange = function(e, n) {
      if (e == null && n == null) {
        var i = this.findRepresentativeAxisProxy();
        if (i)
          return i.getDataValueWindow();
      } else
        return this.getAxisProxy(e, n).getDataValueWindow();
    }, t.prototype.findRepresentativeAxisProxy = function(e) {
      if (e)
        return e.__dzAxisProxy;
      for (var n, i = this._targetAxisInfoMap.keys(), a = 0; a < i.length; a++)
        for (var o = i[a], s = this._targetAxisInfoMap.get(o), l = 0; l < s.indexList.length; l++) {
          var u = this.getAxisProxy(o, s.indexList[l]);
          if (u.hostedBy(this))
            return u;
          n || (n = u);
        }
      return n;
    }, t.prototype.getRangePropMode = function() {
      return this._rangePropMode.slice();
    }, t.prototype.getOrient = function() {
      return process.env.NODE_ENV !== "production" && St(this._orient), this._orient;
    }, t.type = "dataZoom", t.dependencies = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "series", "toolbox"], t.defaultOption = {
      // zlevel: 0,
      z: 4,
      filterMode: "filter",
      start: 0,
      end: 100
    }, t;
  }(re)
);
function B2(r) {
  var t = {};
  return L(["start", "end", "startValue", "endValue", "throttle"], function(e) {
    r.hasOwnProperty(e) && (t[e] = r[e]);
  }), t;
}
var Rat = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.type = "dataZoom.select", t;
  }(Th)
), bw = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n, i, a) {
      this.dataZoomModel = e, this.ecModel = n, this.api = i;
    }, t.type = "dataZoom", t;
  }(Ue)
), Iat = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.type = "dataZoom.select", t;
  }(bw)
), Du = L, V2 = ei, Pat = (
  /** @class */
  function() {
    function r(t, e, n, i) {
      this._dimName = t, this._axisIndex = e, this.ecModel = i, this._dataZoomModel = n;
    }
    return r.prototype.hostedBy = function(t) {
      return this._dataZoomModel === t;
    }, r.prototype.getDataValueWindow = function() {
      return this._valueWindow.slice();
    }, r.prototype.getDataPercentWindow = function() {
      return this._percentWindow.slice();
    }, r.prototype.getTargetSeriesModels = function() {
      var t = [];
      return this.ecModel.eachSeries(function(e) {
        if (Dat(e)) {
          var n = Co(this._dimName), i = e.getReferringComponents(n, Ke).models[0];
          i && this._axisIndex === i.componentIndex && t.push(e);
        }
      }, this), t;
    }, r.prototype.getAxisModel = function() {
      return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex);
    }, r.prototype.getMinMaxSpan = function() {
      return Ct(this._minMaxSpan);
    }, r.prototype.calculateDataWindow = function(t) {
      var e = this._dataExtent, n = this.getAxisModel(), i = n.axis.scale, a = this._dataZoomModel.getRangePropMode(), o = [0, 100], s = [], l = [], u;
      Du(["start", "end"], function(h, d) {
        var p = t[h], g = t[h + "Value"];
        a[d] === "percent" ? (p == null && (p = o[d]), g = i.parse(Me(p, o, e))) : (u = !0, g = g == null ? e[d] : i.parse(g), p = Me(g, e, o)), l[d] = g == null || isNaN(g) ? e[d] : g, s[d] = p == null || isNaN(p) ? o[d] : p;
      }), V2(l), V2(s);
      var c = this._minMaxSpan;
      u ? f(l, s, e, o, !1) : f(s, l, o, e, !0);
      function f(h, d, p, g, v) {
        var m = v ? "Span" : "ValueSpan";
        Xo(0, h, p, "all", c["min" + m], c["max" + m]);
        for (var y = 0; y < 2; y++)
          d[y] = Me(h[y], p, g, !0), v && (d[y] = i.parse(d[y]));
      }
      return {
        valueWindow: l,
        percentWindow: s
      };
    }, r.prototype.reset = function(t) {
      if (t === this._dataZoomModel) {
        var e = this.getTargetSeriesModels();
        this._dataExtent = Nat(this, this._dimName, e), this._updateMinMaxSpan();
        var n = this.calculateDataWindow(t.settledOption);
        this._valueWindow = n.valueWindow, this._percentWindow = n.percentWindow, this._setAxisModel();
      }
    }, r.prototype.filterData = function(t, e) {
      if (t !== this._dataZoomModel)
        return;
      var n = this._dimName, i = this.getTargetSeriesModels(), a = t.get("filterMode"), o = this._valueWindow;
      if (a === "none")
        return;
      Du(i, function(l) {
        var u = l.getData(), c = u.mapDimensionsAll(n);
        if (c.length) {
          if (a === "weakFilter") {
            var f = u.getStore(), h = rt(c, function(d) {
              return u.getDimensionIndex(d);
            }, u);
            u.filterSelf(function(d) {
              for (var p, g, v, m = 0; m < c.length; m++) {
                var y = f.get(h[m], d), _ = !isNaN(y), x = y < o[0], b = y > o[1];
                if (_ && !x && !b)
                  return !0;
                _ && (v = !0), x && (p = !0), b && (g = !0);
              }
              return v && p && g;
            });
          } else
            Du(c, function(d) {
              if (a === "empty")
                l.setData(u = u.map(d, function(g) {
                  return s(g) ? g : NaN;
                }));
              else {
                var p = {};
                p[d] = o, u.selectRange(p);
              }
            });
          Du(c, function(d) {
            u.setApproximateExtent(o, d);
          });
        }
      });
      function s(l) {
        return l >= o[0] && l <= o[1];
      }
    }, r.prototype._updateMinMaxSpan = function() {
      var t = this._minMaxSpan = {}, e = this._dataZoomModel, n = this._dataExtent;
      Du(["min", "max"], function(i) {
        var a = e.get(i + "Span"), o = e.get(i + "ValueSpan");
        o != null && (o = this.getAxisModel().axis.scale.parse(o)), o != null ? a = Me(n[0] + o, n, [0, 100], !0) : a != null && (o = Me(a, [0, 100], n, !0) - n[0]), t[i + "Span"] = a, t[i + "ValueSpan"] = o;
      }, this);
    }, r.prototype._setAxisModel = function() {
      var t = this.getAxisModel(), e = this._percentWindow, n = this._valueWindow;
      if (e) {
        var i = EP(n, [0, 500]);
        i = Math.min(i, 20);
        var a = t.axis.scale.rawExtentInfo;
        e[0] !== 0 && a.setDeterminedMinMax("min", +n[0].toFixed(i)), e[1] !== 100 && a.setDeterminedMinMax("max", +n[1].toFixed(i)), a.freeze();
      }
    }, r;
  }()
);
function Nat(r, t, e) {
  var n = [1 / 0, -1 / 0];
  Du(e, function(o) {
    fZ(n, o.getData(), t);
  });
  var i = r.getAxisModel(), a = xk(i.axis.scale, i, n).calculate();
  return [a.min, a.max];
}
var Oat = {
  // `dataZoomProcessor` will only be performed in needed series. Consider if
  // there is a line series and a pie series, it is better not to update the
  // line series if only pie series is needed to be updated.
  getTargetSeries: function(r) {
    function t(i) {
      r.eachComponent("dataZoom", function(a) {
        a.eachTargetAxis(function(o, s) {
          var l = r.getComponent(Co(o), s);
          i(o, s, l, a);
        });
      });
    }
    t(function(i, a, o, s) {
      o.__dzAxisProxy = null;
    });
    var e = [];
    t(function(i, a, o, s) {
      o.__dzAxisProxy || (o.__dzAxisProxy = new Pat(i, a, s, r), e.push(o.__dzAxisProxy));
    });
    var n = wt();
    return L(e, function(i) {
      L(i.getTargetSeriesModels(), function(a) {
        n.set(a.uid, a);
      });
    }), n;
  },
  // Consider appendData, where filter should be performed. Because data process is
  // in block mode currently, it is not need to worry about that the overallProgress
  // execute every frame.
  overallReset: function(r, t) {
    r.eachComponent("dataZoom", function(e) {
      e.eachTargetAxis(function(n, i) {
        e.getAxisProxy(n, i).reset(e);
      }), e.eachTargetAxis(function(n, i) {
        e.getAxisProxy(n, i).filterData(e, t);
      });
    }), r.eachComponent("dataZoom", function(e) {
      var n = e.findRepresentativeAxisProxy();
      if (n) {
        var i = n.getDataPercentWindow(), a = n.getDataValueWindow();
        e.setCalculatedRange({
          start: i[0],
          end: i[1],
          startValue: a[0],
          endValue: a[1]
        });
      }
    });
  }
};
function kat(r) {
  r.registerAction("dataZoom", function(t, e) {
    var n = Lat(e, t);
    L(n, function(i) {
      i.setRawRange({
        start: t.start,
        end: t.end,
        startValue: t.startValue,
        endValue: t.endValue
      });
    });
  });
}
var F2 = !1;
function ww(r) {
  F2 || (F2 = !0, r.registerProcessor(r.PRIORITY.PROCESSOR.FILTER, Oat), kat(r), r.registerSubTypeDefaulter("dataZoom", function() {
    return "slider";
  }));
}
function Bat(r) {
  r.registerComponentModel(Rat), r.registerComponentView(Iat), ww(r);
}
var jn = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
    }
    return r;
  }()
), wV = {};
function Lu(r, t) {
  wV[r] = t;
}
function MV(r) {
  return wV[r];
}
var Vat = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.optionUpdated = function() {
      r.prototype.optionUpdated.apply(this, arguments);
      var e = this.ecModel;
      L(this.option.feature, function(n, i) {
        var a = MV(i);
        a && (a.getDefaultOption && (a.defaultOption = a.getDefaultOption(e)), qt(n, a.defaultOption));
      });
    }, t.type = "toolbox", t.layoutMode = {
      type: "box",
      ignoreSize: !0
    }, t.defaultOption = {
      show: !0,
      z: 6,
      // zlevel: 0,
      orient: "horizontal",
      left: "right",
      top: "top",
      // right
      // bottom
      backgroundColor: "transparent",
      borderColor: Y.color.border,
      borderRadius: 0,
      borderWidth: 0,
      padding: Y.size.m,
      itemSize: 15,
      itemGap: Y.size.s,
      showTitle: !0,
      iconStyle: {
        borderColor: Y.color.accent50,
        color: "none"
      },
      emphasis: {
        iconStyle: {
          borderColor: Y.color.accent50
        }
      },
      // textStyle: {},
      // feature
      tooltip: {
        show: !1,
        position: "bottom"
      }
    }, t;
  }(re)
);
function TV(r, t) {
  var e = Fh(t.get("padding")), n = t.getItemStyle(["color", "opacity"]);
  n.fill = t.get("backgroundColor");
  var i = new te({
    shape: {
      x: r.x - e[3],
      y: r.y - e[0],
      width: r.width + e[1] + e[3],
      height: r.height + e[0] + e[2],
      r: t.get("borderRadius")
    },
    style: n,
    silent: !0,
    z2: -1
  });
  return i;
}
var Fat = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t.prototype.render = function(e, n, i, a) {
      var o = this.group;
      if (o.removeAll(), !e.get("show"))
        return;
      var s = +e.get("itemSize"), l = e.get("orient") === "vertical", u = e.get("feature") || {}, c = this._features || (this._features = {}), f = [];
      L(u, function(y, _) {
        f.push(_);
      }), new Xa(this._featureNames || [], f).add(h).update(h).remove(Yt(h, null)).execute(), this._featureNames = f;
      function h(y, _) {
        var x = f[y], b = f[_], S = u[x], w = new ue(S, e, e.ecModel), A;
        if (a && a.newTitle != null && a.featureName === x && (S.title = a.newTitle), x && !b) {
          if (zat(x))
            A = {
              onclick: w.option.onclick,
              featureName: x
            };
          else {
            var T = MV(x);
            if (!T)
              return;
            A = new T();
          }
          c[x] = A;
        } else if (A = c[b], !A)
          return;
        A.uid = Ac("toolbox-feature"), A.model = w, A.ecModel = n, A.api = i;
        var M = A instanceof jn;
        if (!x && b) {
          M && A.dispose && A.dispose(n, i);
          return;
        }
        if (!w.get("show") || M && A.unusable) {
          M && A.remove && A.remove(n, i);
          return;
        }
        d(w, A, x), w.setIconStatus = function(E, R) {
          var C = this.option, D = this.iconPaths;
          C.iconStatus = C.iconStatus || {}, C.iconStatus[E] = R, D[E] && (R === "emphasis" ? Ha : Wa)(D[E]);
        }, A instanceof jn && A.render && A.render(w, n, i, a);
      }
      function d(y, _, x) {
        var b = y.getModel("iconStyle"), S = y.getModel(["emphasis", "iconStyle"]), w = _ instanceof jn && _.getIcons ? _.getIcons() : y.get("icon"), A = y.get("title") || {}, T, M;
        pt(w) ? (T = {}, T[x] = w) : T = w, pt(A) ? (M = {}, M[x] = A) : M = A;
        var E = y.iconPaths = {};
        L(T, function(R, C) {
          var D = Vh(R, {}, {
            x: -s / 2,
            y: -s / 2,
            width: s,
            height: s
          });
          D.setStyle(b.getItemStyle());
          var I = D.ensureState("emphasis");
          I.style = S.getItemStyle();
          var P = new pe({
            style: {
              text: M[C],
              align: S.get("textAlign"),
              borderRadius: S.get("textBorderRadius"),
              padding: S.get("textPadding"),
              fill: null,
              font: W1({
                fontStyle: S.get("textFontStyle"),
                fontFamily: S.get("textFontFamily"),
                fontSize: S.get("textFontSize"),
                fontWeight: S.get("textFontWeight")
              }, n)
            },
            ignore: !0
          });
          D.setTextContent(P), Ka({
            el: D,
            componentModel: e,
            itemName: C,
            formatterParamsExtra: {
              title: M[C]
            }
          }), D.__title = M[C], D.on("mouseover", function() {
            var O = S.getItemStyle(), N = l ? e.get("right") == null && e.get("left") !== "right" ? "right" : "left" : e.get("bottom") == null && e.get("top") !== "bottom" ? "bottom" : "top";
            P.setStyle({
              fill: S.get("textFill") || O.fill || O.stroke || Y.color.neutral99,
              backgroundColor: S.get("textBackgroundColor")
            }), D.setTextConfig({
              position: S.get("textPosition") || N
            }), P.ignore = !e.get("showTitle"), i.enterEmphasis(this);
          }).on("mouseout", function() {
            y.get(["iconStatus", C]) !== "emphasis" && i.leaveEmphasis(this), P.hide();
          }), (y.get(["iconStatus", C]) === "emphasis" ? Ha : Wa)(D), o.add(D), D.on("click", mt(_.onclick, _, n, i, C)), E[C] = D;
        });
      }
      var p = xr(e, i).refContainer, g = e.getBoxLayoutParams(), v = e.get("padding"), m = He(g, p, v);
      sl(e.get("orient"), o, e.get("itemGap"), m.width, m.height), um(o, g, p, v), o.add(TV(o.getBoundingRect(), e)), l || o.eachChild(function(y) {
        var _ = y.__title, x = y.ensureState("emphasis"), b = x.textConfig || (x.textConfig = {}), S = y.getTextContent(), w = S && S.ensureState("emphasis");
        if (w && !Tt(w) && _) {
          var A = w.style || (w.style = {}), T = Wg(_, pe.makeFont(A)), M = y.x + o.x, E = y.y + o.y + s, R = !1;
          E + T.height > i.getHeight() && (b.position = "top", R = !0);
          var C = R ? -5 - T.height : s + 10;
          M + T.width / 2 > i.getWidth() ? (b.position = ["100%", C], A.align = "right") : M - T.width / 2 < 0 && (b.position = [0, C], A.align = "left");
        }
      });
    }, t.prototype.updateView = function(e, n, i, a) {
      L(this._features, function(o) {
        o instanceof jn && o.updateView && o.updateView(o.model, n, i, a);
      });
    }, t.prototype.remove = function(e, n) {
      L(this._features, function(i) {
        i instanceof jn && i.remove && i.remove(e, n);
      }), this.group.removeAll();
    }, t.prototype.dispose = function(e, n) {
      L(this._features, function(i) {
        i instanceof jn && i.dispose && i.dispose(e, n);
      });
    }, t.type = "toolbox", t;
  }(Ue)
);
function zat(r) {
  return r.indexOf("my") === 0;
}
var Uat = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t.prototype.onclick = function(e, n) {
      var i = this.model, a = i.get("name") || e.get("title.0.text") || "echarts", o = n.getZr().painter.getType() === "svg", s = o ? "svg" : i.get("type", !0) || "png", l = n.getConnectedDataURL({
        type: s,
        backgroundColor: i.get("backgroundColor", !0) || e.get("backgroundColor") || Y.color.neutral00,
        connectedBackgroundColor: i.get("connectedBackgroundColor"),
        excludeComponents: i.get("excludeComponents"),
        pixelRatio: i.get("pixelRatio")
      }), u = oe.browser;
      if (typeof MouseEvent == "function" && (u.newEdge || !u.ie && !u.edge)) {
        var c = document.createElement("a");
        c.download = a + "." + s, c.target = "_blank", c.href = l;
        var f = new MouseEvent("click", {
          // some micro front-end framework window maybe is a Proxy
          view: document.defaultView,
          bubbles: !0,
          cancelable: !1
        });
        c.dispatchEvent(f);
      } else if (window.navigator.msSaveOrOpenBlob || o) {
        var h = l.split(","), d = h[0].indexOf("base64") > -1, p = o ? decodeURIComponent(h[1]) : h[1];
        d && (p = window.atob(p));
        var g = a + "." + s;
        if (window.navigator.msSaveOrOpenBlob) {
          for (var v = p.length, m = new Uint8Array(v); v--; )
            m[v] = p.charCodeAt(v);
          var y = new Blob([m]);
          window.navigator.msSaveOrOpenBlob(y, g);
        } else {
          var _ = document.createElement("iframe");
          document.body.appendChild(_);
          var x = _.contentWindow, b = x.document;
          b.open("image/svg+xml", "replace"), b.write(p), b.close(), x.focus(), b.execCommand("SaveAs", !0, g), document.body.removeChild(_);
        }
      } else {
        var S = i.get("lang"), w = '<body style="margin:0;"><img src="' + l + '" style="max-width:100%;" title="' + (S && S[0] || "") + '" /></body>', A = window.open();
        A.document.write(w), A.document.title = a;
      }
    }, t.getDefaultOption = function(e) {
      var n = {
        show: !0,
        icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0",
        title: e.getLocaleModel().get(["toolbox", "saveAsImage", "title"]),
        type: "png",
        // Default use option.backgroundColor
        // backgroundColor: '#fff',
        connectedBackgroundColor: Y.color.neutral00,
        name: "",
        excludeComponents: ["toolbox"],
        // use current pixel ratio of device by default
        // pixelRatio: 1,
        lang: e.getLocaleModel().get(["toolbox", "saveAsImage", "lang"])
      };
      return n;
    }, t;
  }(jn)
), z2 = "__ec_magicType_stack__", Gat = [["line", "bar"], ["stack"]], Hat = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t.prototype.getIcons = function() {
      var e = this.model, n = e.get("icon"), i = {};
      return L(e.get("type"), function(a) {
        n[a] && (i[a] = n[a]);
      }), i;
    }, t.getDefaultOption = function(e) {
      var n = {
        show: !0,
        type: [],
        // Icon group
        icon: {
          line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4",
          bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7",
          // eslint-disable-next-line
          stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z"
          // jshint ignore:line
        },
        // `line`, `bar`, `stack`, `tiled`
        title: e.getLocaleModel().get(["toolbox", "magicType", "title"]),
        option: {},
        seriesIndex: {}
      };
      return n;
    }, t.prototype.onclick = function(e, n, i) {
      var a = this.model, o = a.get(["seriesIndex", i]);
      if (U2[i]) {
        var s = {
          series: []
        }, l = function(f) {
          var h = f.subType, d = f.id, p = U2[i](h, d, f, a);
          p && (kt(p, f.option), s.series.push(p));
          var g = f.coordinateSystem;
          if (g && g.type === "cartesian2d" && (i === "line" || i === "bar")) {
            var v = g.getAxesByScale("ordinal")[0];
            if (v) {
              var m = v.dim, y = m + "Axis", _ = f.getReferringComponents(y, Ke).models[0], x = _.componentIndex;
              s[y] = s[y] || [];
              for (var b = 0; b <= x; b++)
                s[y][x] = s[y][x] || {};
              s[y][x].boundaryGap = i === "bar";
            }
          }
        };
        L(Gat, function(f) {
          Zt(f, i) >= 0 && L(f, function(h) {
            a.setIconStatus(h, "normal");
          });
        }), a.setIconStatus(i, "emphasis"), e.eachComponent({
          mainType: "series",
          query: o == null ? null : {
            seriesIndex: o
          }
        }, l);
        var u, c = i;
        i === "stack" && (u = qt({
          stack: a.option.title.tiled,
          tiled: a.option.title.stack
        }, a.option.title), a.get(["iconStatus", i]) !== "emphasis" && (c = "tiled")), n.dispatchAction({
          type: "changeMagicType",
          currentType: c,
          newOption: s,
          newTitle: u,
          featureName: "magicType"
        });
      }
    }, t;
  }(jn)
), U2 = {
  line: function(r, t, e, n) {
    if (r === "bar")
      return qt({
        id: t,
        type: "line",
        // Preserve data related option
        data: e.get("data"),
        stack: e.get("stack"),
        markPoint: e.get("markPoint"),
        markLine: e.get("markLine")
      }, n.get(["option", "line"]) || {}, !0);
  },
  bar: function(r, t, e, n) {
    if (r === "line")
      return qt({
        id: t,
        type: "bar",
        // Preserve data related option
        data: e.get("data"),
        stack: e.get("stack"),
        markPoint: e.get("markPoint"),
        markLine: e.get("markLine")
      }, n.get(["option", "bar"]) || {}, !0);
  },
  stack: function(r, t, e, n) {
    var i = e.get("stack") === z2;
    if (r === "line" || r === "bar")
      return n.setIconStatus("stack", i ? "normal" : "emphasis"), qt({
        id: t,
        stack: i ? "" : z2
      }, n.get(["option", "stack"]) || {}, !0);
  }
};
ca({
  type: "changeMagicType",
  event: "magicTypeChanged",
  update: "prepareAndUpdate"
}, function(r, t) {
  t.mergeOption(r.newOption);
});
var Tm = new Array(60).join("-"), pc = "	";
function Wat(r) {
  var t = {}, e = [], n = [];
  return r.eachRawSeries(function(i) {
    var a = i.coordinateSystem;
    if (a && (a.type === "cartesian2d" || a.type === "polar")) {
      var o = a.getBaseAxis();
      if (o.type === "category") {
        var s = o.dim + "_" + o.index;
        t[s] || (t[s] = {
          categoryAxis: o,
          valueAxis: a.getOtherAxis(o),
          series: []
        }, n.push({
          axisDim: o.dim,
          axisIndex: o.index
        })), t[s].series.push(i);
      } else
        e.push(i);
    } else
      e.push(i);
  }), {
    seriesGroupByCategoryAxis: t,
    other: e,
    meta: n
  };
}
function Xat(r) {
  var t = [];
  return L(r, function(e, n) {
    var i = e.categoryAxis, a = e.valueAxis, o = a.dim, s = [" "].concat(rt(e.series, function(d) {
      return d.name;
    })), l = [i.model.getCategories()];
    L(e.series, function(d) {
      var p = d.getRawData();
      l.push(d.getRawData().mapArray(p.mapDimension(o), function(g) {
        return g;
      }));
    });
    for (var u = [s.join(pc)], c = 0; c < l[0].length; c++) {
      for (var f = [], h = 0; h < l.length; h++)
        f.push(l[h][c]);
      u.push(f.join(pc));
    }
    t.push(u.join(`
`));
  }), t.join(`

` + Tm + `

`);
}
function Yat(r) {
  return rt(r, function(t) {
    var e = t.getRawData(), n = [t.name], i = [];
    return e.each(e.dimensions, function() {
      for (var a = arguments.length, o = arguments[a - 1], s = e.getName(o), l = 0; l < a - 1; l++)
        i[l] = arguments[l];
      n.push((s ? s + pc : "") + i.join(pc));
    }), n.join(`
`);
  }).join(`

` + Tm + `

`);
}
function $at(r) {
  var t = Wat(r);
  return {
    value: Te([Xat(t.seriesGroupByCategoryAxis), Yat(t.other)], function(e) {
      return !!e.replace(/[\n\t\s]/g, "");
    }).join(`

` + Tm + `

`),
    meta: t.meta
  };
}
function Sg(r) {
  return r.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function Zat(r) {
  var t = r.slice(0, r.indexOf(`
`));
  if (t.indexOf(pc) >= 0)
    return !0;
}
var YS = new RegExp("[" + pc + "]+", "g");
function qat(r) {
  for (var t = r.split(/\n+/g), e = Sg(t.shift()).split(YS), n = [], i = rt(e, function(l) {
    return {
      name: l,
      data: []
    };
  }), a = 0; a < t.length; a++) {
    var o = Sg(t[a]).split(YS);
    n.push(o.shift());
    for (var s = 0; s < o.length; s++)
      i[s] && (i[s].data[a] = o[s]);
  }
  return {
    series: i,
    categories: n
  };
}
function Kat(r) {
  for (var t = r.split(/\n+/g), e = Sg(t.shift()), n = [], i = 0; i < t.length; i++) {
    var a = Sg(t[i]);
    if (a) {
      var o = a.split(YS), s = "", l = void 0, u = !1;
      isNaN(o[0]) ? (u = !0, s = o[0], o = o.slice(1), n[i] = {
        name: s,
        value: []
      }, l = n[i].value) : l = n[i] = [];
      for (var c = 0; c < o.length; c++)
        l.push(+o[c]);
      l.length === 1 && (u ? n[i].value = l[0] : n[i] = l[0]);
    }
  }
  return {
    name: e,
    data: n
  };
}
function jat(r, t) {
  var e = r.split(new RegExp(`
*` + Tm + `
*`, "g")), n = {
    series: []
  };
  return L(e, function(i, a) {
    if (Zat(i)) {
      var o = qat(i), s = t[a], l = s.axisDim + "Axis";
      s && (n[l] = n[l] || [], n[l][s.axisIndex] = {
        data: o.categories
      }, n.series = n.series.concat(o.series));
    } else {
      var o = Kat(i);
      n.series.push(o);
    }
  }), n;
}
var Jat = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t.prototype.onclick = function(e, n) {
      setTimeout(function() {
        n.dispatchAction({
          type: "hideTip"
        });
      });
      var i = n.getDom(), a = this.model;
      this._dom && i.removeChild(this._dom);
      var o = document.createElement("div");
      o.style.cssText = "position:absolute;top:0;bottom:0;left:0;right:0;padding:5px", o.style.backgroundColor = a.get("backgroundColor") || Y.color.neutral00;
      var s = document.createElement("h4"), l = a.get("lang") || [];
      s.innerHTML = l[0] || a.get("title"), s.style.cssText = "margin:10px 20px", s.style.color = a.get("textColor");
      var u = document.createElement("div"), c = document.createElement("textarea");
      u.style.cssText = "overflow:auto";
      var f = a.get("optionToContent"), h = a.get("contentToOption"), d = $at(e);
      if (Tt(f)) {
        var p = f(n.getOption());
        pt(p) ? u.innerHTML = p : fl(p) && u.appendChild(p);
      } else {
        c.readOnly = a.get("readOnly");
        var g = c.style;
        g.cssText = "display:block;width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;resize:none;box-sizing:border-box;outline:none", g.color = a.get("textColor"), g.borderColor = a.get("textareaBorderColor"), g.backgroundColor = a.get("textareaColor"), c.value = d.value, u.appendChild(c);
      }
      var v = d.meta, m = document.createElement("div");
      m.style.cssText = "position:absolute;bottom:5px;left:0;right:0";
      var y = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px", _ = document.createElement("div"), x = document.createElement("div");
      y += ";background-color:" + a.get("buttonColor"), y += ";color:" + a.get("buttonTextColor");
      var b = this;
      function S() {
        i.removeChild(o), b._dom = null;
      }
      ex(_, "click", S), ex(x, "click", function() {
        if (h == null && f != null || h != null && f == null) {
          process.env.NODE_ENV !== "production" && Xe("It seems you have just provided one of `contentToOption` and `optionToContent` functions but missed the other one. Data change is ignored."), S();
          return;
        }
        var w;
        try {
          Tt(h) ? w = h(u, n.getOption()) : w = jat(c.value, v);
        } catch (A) {
          throw S(), new Error("Data view format error " + A);
        }
        w && n.dispatchAction({
          type: "changeDataView",
          newOption: w
        }), S();
      }), _.innerHTML = l[1], x.innerHTML = l[2], x.style.cssText = _.style.cssText = y, !a.get("readOnly") && m.appendChild(x), m.appendChild(_), o.appendChild(s), o.appendChild(u), o.appendChild(m), u.style.height = i.clientHeight - 80 + "px", i.appendChild(o), this._dom = o;
    }, t.prototype.remove = function(e, n) {
      this._dom && n.getDom().removeChild(this._dom);
    }, t.prototype.dispose = function(e, n) {
      this.remove(e, n);
    }, t.getDefaultOption = function(e) {
      var n = {
        show: !0,
        readOnly: !1,
        optionToContent: null,
        contentToOption: null,
        // eslint-disable-next-line
        icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28",
        title: e.getLocaleModel().get(["toolbox", "dataView", "title"]),
        lang: e.getLocaleModel().get(["toolbox", "dataView", "lang"]),
        backgroundColor: Y.color.background,
        textColor: Y.color.primary,
        textareaColor: Y.color.background,
        textareaBorderColor: Y.color.border,
        buttonColor: Y.color.accent50,
        buttonTextColor: Y.color.neutral00
      };
      return n;
    }, t;
  }(jn)
);
function Qat(r, t) {
  return rt(r, function(e, n) {
    var i = t && t[n];
    if (Dt(i) && !et(i)) {
      var a = Dt(e) && !et(e);
      a || (e = {
        value: e
      });
      var o = i.name != null && e.name == null;
      return e = kt(e, i), o && delete e.name, e;
    } else
      return e;
  });
}
ca({
  type: "changeDataView",
  event: "dataViewChanged",
  update: "prepareAndUpdate"
}, function(r, t) {
  var e = [];
  L(r.newOption.series, function(n) {
    var i = t.getSeriesByName(n.name)[0];
    if (!i)
      e.push(J({
        // Default is scatter
        type: "scatter"
      }, n));
    else {
      var a = i.get("data");
      e.push({
        name: n.name,
        data: Qat(n.data, a)
      });
    }
  }), t.mergeOption(kt({
    series: e
  }, r.newOption));
});
var AV = L, EV = ee();
function tot(r, t) {
  var e = Mw(r);
  AV(t, function(n, i) {
    for (var a = e.length - 1; a >= 0; a--) {
      var o = e[a];
      if (o[i])
        break;
    }
    if (a < 0) {
      var s = r.queryComponents({
        mainType: "dataZoom",
        subType: "select",
        id: i
      })[0];
      if (s) {
        var l = s.getPercentRange();
        e[0][i] = {
          dataZoomId: i,
          start: l[0],
          end: l[1]
        };
      }
    }
  }), e.push(t);
}
function eot(r) {
  var t = Mw(r), e = t[t.length - 1];
  t.length > 1 && t.pop();
  var n = {};
  return AV(e, function(i, a) {
    for (var o = t.length - 1; o >= 0; o--)
      if (i = t[o][a], i) {
        n[a] = i;
        break;
      }
  }), n;
}
function rot(r) {
  EV(r).snapshots = null;
}
function not(r) {
  return Mw(r).length;
}
function Mw(r) {
  var t = EV(r);
  return t.snapshots || (t.snapshots = [{}]), t.snapshots;
}
var iot = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t.prototype.onclick = function(e, n) {
      rot(e), n.dispatchAction({
        type: "restore",
        from: this.uid
      });
    }, t.getDefaultOption = function(e) {
      var n = {
        show: !0,
        // eslint-disable-next-line
        icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5",
        title: e.getLocaleModel().get(["toolbox", "restore", "title"])
      };
      return n;
    }, t;
  }(jn)
);
ca({
  type: "restore",
  event: "restore",
  update: "prepareAndUpdate"
}, function(r, t) {
  t.resetOption("recreate");
});
var aot = ["grid", "xAxis", "yAxis", "geo", "graph", "polar", "radiusAxis", "angleAxis", "bmap"], Tw = (
  /** @class */
  function() {
    function r(t, e, n) {
      var i = this;
      this._targetInfoList = [];
      var a = G2(e, t);
      L(oot, function(o, s) {
        (!n || !n.include || Zt(n.include, s) >= 0) && o(a, i._targetInfoList);
      });
    }
    return r.prototype.setOutputRanges = function(t, e) {
      return this.matchOutputRanges(t, e, function(n, i, a) {
        if ((n.coordRanges || (n.coordRanges = [])).push(i), !n.coordRange) {
          n.coordRange = i;
          var o = T_[n.brushType](0, a, i);
          n.__rangeOffset = {
            offset: Y2[n.brushType](o.values, n.range, [1, 1]),
            xyMinMax: o.xyMinMax
          };
        }
      }), t;
    }, r.prototype.matchOutputRanges = function(t, e, n) {
      L(t, function(i) {
        var a = this.findTargetInfo(i, e);
        a && a !== !0 && L(a.coordSyses, function(o) {
          var s = T_[i.brushType](1, o, i.range, !0);
          n(i, s.values, o, e);
        });
      }, this);
    }, r.prototype.setInputRanges = function(t, e) {
      L(t, function(n) {
        var i = this.findTargetInfo(n, e);
        if (process.env.NODE_ENV !== "production" && (St(!i || i === !0 || n.coordRange, "coordRange must be specified when coord index specified."), St(!i || i !== !0 || n.range, "range must be specified in global brush.")), n.range = n.range || [], i && i !== !0) {
          n.panelId = i.panelId;
          var a = T_[n.brushType](0, i.coordSys, n.coordRange), o = n.__rangeOffset;
          n.range = o ? Y2[n.brushType](a.values, o.offset, sot(a.xyMinMax, o.xyMinMax)) : a.values;
        }
      }, this);
    }, r.prototype.makePanelOpts = function(t, e) {
      return rt(this._targetInfoList, function(n) {
        var i = n.getPanelRect();
        return {
          panelId: n.panelId,
          defaultBrushType: e ? e(n) : null,
          clipPath: RB(i),
          isTargetByCursor: PB(i, t, n.coordSysModel),
          getLinearBrushOtherExtent: IB(i)
        };
      });
    }, r.prototype.controlSeries = function(t, e, n) {
      var i = this.findTargetInfo(t, n);
      return i === !0 || i && Zt(i.coordSyses, e.coordinateSystem) >= 0;
    }, r.prototype.findTargetInfo = function(t, e) {
      for (var n = this._targetInfoList, i = G2(e, t), a = 0; a < n.length; a++) {
        var o = n[a], s = t.panelId;
        if (s) {
          if (o.panelId === s)
            return o;
        } else
          for (var l = 0; l < H2.length; l++)
            if (H2[l](i, o))
              return o;
      }
      return !0;
    }, r;
  }()
);
function $S(r) {
  return r[0] > r[1] && r.reverse(), r;
}
function G2(r, t) {
  return Wu(r, t, {
    includeMainTypes: aot
  });
}
var oot = {
  grid: function(r, t) {
    var e = r.xAxisModels, n = r.yAxisModels, i = r.gridModels, a = wt(), o = {}, s = {};
    !e && !n && !i || (L(e, function(l) {
      var u = l.axis.grid.model;
      a.set(u.id, u), o[u.id] = !0;
    }), L(n, function(l) {
      var u = l.axis.grid.model;
      a.set(u.id, u), s[u.id] = !0;
    }), L(i, function(l) {
      a.set(l.id, l), o[l.id] = !0, s[l.id] = !0;
    }), a.each(function(l) {
      var u = l.coordinateSystem, c = [];
      L(u.getCartesians(), function(f, h) {
        (Zt(e, f.getAxis("x").model) >= 0 || Zt(n, f.getAxis("y").model) >= 0) && c.push(f);
      }), t.push({
        panelId: "grid--" + l.id,
        gridModel: l,
        coordSysModel: l,
        // Use the first one as the representitive coordSys.
        coordSys: c[0],
        coordSyses: c,
        getPanelRect: W2.grid,
        xAxisDeclared: o[l.id],
        yAxisDeclared: s[l.id]
      });
    }));
  },
  geo: function(r, t) {
    L(r.geoModels, function(e) {
      var n = e.coordinateSystem;
      t.push({
        panelId: "geo--" + e.id,
        geoModel: e,
        coordSysModel: e,
        coordSys: n,
        coordSyses: [n],
        getPanelRect: W2.geo
      });
    });
  }
}, H2 = [
  // grid
  function(r, t) {
    var e = r.xAxisModel, n = r.yAxisModel, i = r.gridModel;
    return !i && e && (i = e.axis.grid.model), !i && n && (i = n.axis.grid.model), i && i === t.gridModel;
  },
  // geo
  function(r, t) {
    var e = r.geoModel;
    return e && e === t.geoModel;
  }
], W2 = {
  grid: function() {
    return this.coordSys.master.getRect().clone();
  },
  geo: function() {
    var r = this.coordSys, t = r.getBoundingRect().clone();
    return t.applyTransform(ol(r)), t;
  }
}, T_ = {
  lineX: Yt(X2, 0),
  lineY: Yt(X2, 1),
  rect: function(r, t, e, n) {
    var i = r ? t.pointToData([e[0][0], e[1][0]], n) : t.dataToPoint([e[0][0], e[1][0]], n), a = r ? t.pointToData([e[0][1], e[1][1]], n) : t.dataToPoint([e[0][1], e[1][1]], n), o = [$S([i[0], a[0]]), $S([i[1], a[1]])];
    return {
      values: o,
      xyMinMax: o
    };
  },
  polygon: function(r, t, e, n) {
    var i = [[1 / 0, -1 / 0], [1 / 0, -1 / 0]], a = rt(e, function(o) {
      var s = r ? t.pointToData(o, n) : t.dataToPoint(o, n);
      return i[0][0] = Math.min(i[0][0], s[0]), i[1][0] = Math.min(i[1][0], s[1]), i[0][1] = Math.max(i[0][1], s[0]), i[1][1] = Math.max(i[1][1], s[1]), s;
    });
    return {
      values: a,
      xyMinMax: i
    };
  }
};
function X2(r, t, e, n) {
  process.env.NODE_ENV !== "production" && St(e.type === "cartesian2d", "lineX/lineY brush is available only in cartesian2d.");
  var i = e.getAxis(["x", "y"][r]), a = $S(rt([0, 1], function(s) {
    return t ? i.coordToData(i.toLocalCoord(n[s]), !0) : i.toGlobalCoord(i.dataToCoord(n[s]));
  })), o = [];
  return o[r] = a, o[1 - r] = [NaN, NaN], {
    values: a,
    xyMinMax: o
  };
}
var Y2 = {
  lineX: Yt($2, 0),
  lineY: Yt($2, 1),
  rect: function(r, t, e) {
    return [[r[0][0] - e[0] * t[0][0], r[0][1] - e[0] * t[0][1]], [r[1][0] - e[1] * t[1][0], r[1][1] - e[1] * t[1][1]]];
  },
  polygon: function(r, t, e) {
    return rt(r, function(n, i) {
      return [n[0] - e[0] * t[i][0], n[1] - e[1] * t[i][1]];
    });
  }
};
function $2(r, t, e, n) {
  return [t[0] - n[r] * e[0], t[1] - n[r] * e[1]];
}
function sot(r, t) {
  var e = Z2(r), n = Z2(t), i = [e[0] / n[0], e[1] / n[1]];
  return isNaN(i[0]) && (i[0] = 1), isNaN(i[1]) && (i[1] = 1), i;
}
function Z2(r) {
  return r ? [r[0][1] - r[0][0], r[1][1] - r[1][0]] : [NaN, NaN];
}
var ZS = L, lot = J8("toolbox-dataZoom_"), uot = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t.prototype.render = function(e, n, i, a) {
      this._brushController || (this._brushController = new Kb(i.getZr()), this._brushController.on("brush", mt(this._onBrush, this)).mount()), hot(e, n, this, a, i), fot(e, n);
    }, t.prototype.onclick = function(e, n, i) {
      cot[i].call(this);
    }, t.prototype.remove = function(e, n) {
      this._brushController && this._brushController.unmount();
    }, t.prototype.dispose = function(e, n) {
      this._brushController && this._brushController.dispose();
    }, t.prototype._onBrush = function(e) {
      var n = e.areas;
      if (!e.isEnd || !n.length)
        return;
      var i = {}, a = this.ecModel;
      this._brushController.updateCovers([]);
      var o = new Tw(Aw(this.model), a, {
        include: ["grid"]
      });
      o.matchOutputRanges(n, a, function(u, c, f) {
        if (f.type === "cartesian2d") {
          var h = u.brushType;
          h === "rect" ? (s("x", f, c[0]), s("y", f, c[1])) : s({
            lineX: "x",
            lineY: "y"
          }[h], f, c);
        }
      }), tot(a, i), this._dispatchZoomAction(i);
      function s(u, c, f) {
        var h = c.getAxis(u), d = h.model, p = l(u, d, a), g = p.findRepresentativeAxisProxy(d).getMinMaxSpan();
        (g.minValueSpan != null || g.maxValueSpan != null) && (f = Xo(0, f.slice(), h.scale.getExtent(), 0, g.minValueSpan, g.maxValueSpan)), p && (i[p.id] = {
          dataZoomId: p.id,
          startValue: f[0],
          endValue: f[1]
        });
      }
      function l(u, c, f) {
        var h;
        return f.eachComponent({
          mainType: "dataZoom",
          subType: "select"
        }, function(d) {
          var p = d.getAxisModel(u, c.componentIndex);
          p && (h = d);
        }), h;
      }
    }, t.prototype._dispatchZoomAction = function(e) {
      var n = [];
      ZS(e, function(i, a) {
        n.push(Ct(i));
      }), n.length && this.api.dispatchAction({
        type: "dataZoom",
        from: this.uid,
        batch: n
      });
    }, t.getDefaultOption = function(e) {
      var n = {
        show: !0,
        filterMode: "filter",
        // Icon group
        icon: {
          zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1",
          back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26"
        },
        // `zoom`, `back`
        title: e.getLocaleModel().get(["toolbox", "dataZoom", "title"]),
        brushStyle: {
          borderWidth: 0,
          color: Y.color.backgroundTint
        }
      };
      return n;
    }, t;
  }(jn)
), cot = {
  zoom: function() {
    var r = !this._isZoomActive;
    this.api.dispatchAction({
      type: "takeGlobalCursor",
      key: "dataZoomSelect",
      dataZoomSelectActive: r
    });
  },
  back: function() {
    this._dispatchZoomAction(eot(this.ecModel));
  }
};
function Aw(r) {
  var t = {
    xAxisIndex: r.get("xAxisIndex", !0),
    yAxisIndex: r.get("yAxisIndex", !0),
    xAxisId: r.get("xAxisId", !0),
    yAxisId: r.get("yAxisId", !0)
  };
  return t.xAxisIndex == null && t.xAxisId == null && (t.xAxisIndex = "all"), t.yAxisIndex == null && t.yAxisId == null && (t.yAxisIndex = "all"), t;
}
function fot(r, t) {
  r.setIconStatus("back", not(t) > 1 ? "emphasis" : "normal");
}
function hot(r, t, e, n, i) {
  var a = e._isZoomActive;
  n && n.type === "takeGlobalCursor" && (a = n.key === "dataZoomSelect" ? n.dataZoomSelectActive : !1), e._isZoomActive = a, r.setIconStatus("zoom", a ? "emphasis" : "normal");
  var o = new Tw(Aw(r), t, {
    include: ["grid"]
  }), s = o.makePanelOpts(i, function(l) {
    return l.xAxisDeclared && !l.yAxisDeclared ? "lineX" : !l.xAxisDeclared && l.yAxisDeclared ? "lineY" : "rect";
  });
  e._brushController.setPanels(s).enableBrush(a && s.length ? {
    brushType: "auto",
    brushStyle: r.getModel("brushStyle").getItemStyle()
  } : !1);
}
O9("dataZoom", function(r) {
  var t = r.getComponent("toolbox", 0), e = ["feature", "dataZoom"];
  if (!t || t.get(e) == null)
    return;
  var n = t.getModel(e), i = [], a = Aw(n), o = Wu(r, a);
  ZS(o.xAxisModels, function(l) {
    return s(l, "xAxis", "xAxisIndex");
  }), ZS(o.yAxisModels, function(l) {
    return s(l, "yAxis", "yAxisIndex");
  });
  function s(l, u, c) {
    var f = l.componentIndex, h = {
      type: "select",
      $fromToolbox: !0,
      // Default to be filter
      filterMode: n.get("filterMode", !0) || "filter",
      // Id for merge mapping.
      id: lot + u + f
    };
    h[c] = f, i.push(h);
  }
  return i;
});
function dot(r) {
  r.registerComponentModel(Vat), r.registerComponentView(Fat), Lu("saveAsImage", Uat), Lu("magicType", Hat), Lu("dataView", Jat), Lu("dataZoom", uot), Lu("restore", iot), jt(Bat);
}
var pot = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.type = "tooltip", t.dependencies = ["axisPointer"], t.defaultOption = {
      // zlevel: 0,
      z: 60,
      show: !0,
      // tooltip main content
      showContent: !0,
      // 'trigger' only works on coordinate system.
      // 'item' | 'axis' | 'none'
      trigger: "item",
      // 'click' | 'mousemove' | 'none'
      triggerOn: "mousemove|click",
      alwaysShowContent: !1,
      renderMode: "auto",
      // whether restraint content inside viewRect.
      // If renderMode: 'richText', default true.
      // If renderMode: 'html', defaults to `false` (for backward compat).
      confine: null,
      showDelay: 0,
      hideDelay: 100,
      // Animation transition time, unit is second
      transitionDuration: 0.4,
      displayTransition: !0,
      enterable: !1,
      backgroundColor: Y.color.neutral00,
      // box shadow
      shadowBlur: 10,
      shadowColor: "rgba(0, 0, 0, .2)",
      shadowOffsetX: 1,
      shadowOffsetY: 2,
      // tooltip border radius, unit is px, default is 4
      borderRadius: 4,
      // tooltip border width, unit is px, default is 0 (no border)
      borderWidth: 1,
      defaultBorderColor: Y.color.border,
      // Tooltip inside padding, default is 5 for all direction
      // Array is allowed to set up, right, bottom, left, same with css
      // The default value: See `tooltip/tooltipMarkup.ts#getPaddingFromTooltipModel`.
      padding: null,
      // Extra css text
      extraCssText: "",
      // axis indicator, trigger by axis
      axisPointer: {
        // default is line
        // legal values: 'line' | 'shadow' | 'cross'
        type: "line",
        // Valid when type is line, appoint tooltip line locate on which line. Optional
        // legal values: 'x' | 'y' | 'angle' | 'radius' | 'auto'
        // default is 'auto', chose the axis which type is category.
        // for multiply y axis, cartesian coord chose x axis, polar chose angle axis
        axis: "auto",
        animation: "auto",
        animationDurationUpdate: 200,
        animationEasingUpdate: "exponentialOut",
        crossStyle: {
          color: Y.color.borderShade,
          width: 1,
          type: "dashed",
          // TODO formatter
          textStyle: {}
        }
        // lineStyle and shadowStyle should not be specified here,
        // otherwise it will always override those styles on option.axisPointer.
      },
      textStyle: {
        color: Y.color.tertiary,
        fontSize: 14
      }
    }, t;
  }(re)
);
function CV(r) {
  var t = r.get("confine");
  return t != null ? !!t : r.get("renderMode") === "richText";
}
function DV(r) {
  if (oe.domSupported) {
    for (var t = document.documentElement.style, e = 0, n = r.length; e < n; e++)
      if (r[e] in t)
        return r[e];
  }
}
var LV = DV(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]), vot = DV(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]);
function RV(r, t) {
  if (!r)
    return t;
  t = VN(t, !0);
  var e = r.indexOf(t);
  return r = e === -1 ? t : "-" + r.slice(0, e) + "-" + t, r.toLowerCase();
}
function got(r, t) {
  var e = r.currentStyle || document.defaultView && document.defaultView.getComputedStyle(r);
  return e ? e[t] : null;
}
var mot = RV(vot, "transition"), Ew = RV(LV, "transform"), yot = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;" + (oe.transform3dSupported ? "will-change:transform;" : "");
function _ot(r) {
  return r = r === "left" ? "right" : r === "right" ? "left" : r === "top" ? "bottom" : "top", r;
}
function xot(r, t, e) {
  if (!pt(e) || e === "inside")
    return "";
  var n = r.get("backgroundColor"), i = r.get("borderWidth");
  t = yl(t);
  var a = _ot(e), o = Math.max(Math.round(i) * 1.5, 6), s = "", l = Ew + ":", u;
  Zt(["left", "right"], a) > -1 ? (s += "top:50%", l += "translateY(-50%) rotate(" + (u = a === "left" ? -225 : -45) + "deg)") : (s += "left:50%", l += "translateX(-50%) rotate(" + (u = a === "top" ? 225 : 45) + "deg)");
  var c = u * Math.PI / 180, f = o + i, h = f * Math.abs(Math.cos(c)) + f * Math.abs(Math.sin(c)), d = Math.round(((h - Math.SQRT2 * i) / 2 + Math.SQRT2 * i - (h - f) / 2) * 100) / 100;
  s += ";" + a + ":-" + d + "px";
  var p = t + " solid " + i + "px;", g = ["position:absolute;width:" + o + "px;height:" + o + "px;z-index:-1;", s + ";" + l + ";", "border-bottom:" + p, "border-right:" + p, "background-color:" + n + ";"];
  return '<div style="' + g.join("") + '"></div>';
}
function Sot(r, t, e) {
  var n = "cubic-bezier(0.23,1,0.32,1)", i = "", a = "";
  return e && (i = " " + r / 2 + "s " + n, a = "opacity" + i + ",visibility" + i), t || (i = " " + r + "s " + n, a += (a.length ? "," : "") + (oe.transformSupported ? "" + Ew + i : ",left" + i + ",top" + i)), mot + ":" + a;
}
function q2(r, t, e) {
  var n = r.toFixed(0) + "px", i = t.toFixed(0) + "px";
  if (!oe.transformSupported)
    return e ? "top:" + i + ";left:" + n + ";" : [["top", i], ["left", n]];
  var a = oe.transform3dSupported, o = "translate" + (a ? "3d" : "") + "(" + n + "," + i + (a ? ",0" : "") + ")";
  return e ? "top:0;left:0;" + Ew + ":" + o + ";" : [["top", 0], ["left", 0], [LV, o]];
}
function bot(r) {
  var t = [], e = r.get("fontSize"), n = r.getTextColor();
  n && t.push("color:" + n), t.push("font:" + r.getFont());
  var i = bt(r.get("lineHeight"), Math.round(e * 3 / 2));
  e && t.push("line-height:" + i + "px");
  var a = r.get("textShadowColor"), o = r.get("textShadowBlur") || 0, s = r.get("textShadowOffsetX") || 0, l = r.get("textShadowOffsetY") || 0;
  return a && o && t.push("text-shadow:" + s + "px " + l + "px " + o + "px " + a), L(["decoration", "align"], function(u) {
    var c = r.get(u);
    c && t.push("text-" + u + ":" + c);
  }), t.join(";");
}
function wot(r, t, e, n) {
  var i = [], a = r.get("transitionDuration"), o = r.get("backgroundColor"), s = r.get("shadowBlur"), l = r.get("shadowColor"), u = r.get("shadowOffsetX"), c = r.get("shadowOffsetY"), f = r.getModel("textStyle"), h = wO(r, "html"), d = u + "px " + c + "px " + s + "px " + l;
  return i.push("box-shadow:" + d), t && a > 0 && i.push(Sot(a, e, n)), o && i.push("background-color:" + o), L(["width", "color", "radius"], function(p) {
    var g = "border-" + p, v = VN(g), m = r.get(v);
    m != null && i.push(g + ":" + m + (p === "color" ? "" : "px"));
  }), i.push(bot(f)), h != null && i.push("padding:" + Fh(h).join("px ") + "px"), i.join(";") + ";";
}
function K2(r, t, e, n, i) {
  var a = t && t.painter;
  if (e) {
    var o = a && a.getViewportRoot();
    o && wW(r, o, e, n, i);
  } else {
    r[0] = n, r[1] = i;
    var s = a && a.getViewportRootOffset();
    s && (r[0] += s.offsetLeft, r[1] += s.offsetTop);
  }
  r[2] = r[0] / t.getWidth(), r[3] = r[1] / t.getHeight();
}
var Mot = (
  /** @class */
  function() {
    function r(t, e) {
      if (this._show = !1, this._styleCoord = [0, 0, 0, 0], this._enterable = !0, this._alwaysShowContent = !1, this._firstShow = !0, this._longHide = !0, oe.wxa)
        return null;
      var n = document.createElement("div");
      n.domBelongToZr = !0, this.el = n;
      var i = this._zr = t.getZr(), a = e.appendTo, o = a && (pt(a) ? document.querySelector(a) : fl(a) ? a : Tt(a) && a(t.getDom()));
      K2(this._styleCoord, i, o, t.getWidth() / 2, t.getHeight() / 2), (o || t.getDom()).appendChild(n), this._api = t, this._container = o;
      var s = this;
      n.onmouseenter = function() {
        s._enterable && (clearTimeout(s._hideTimeout), s._show = !0), s._inContent = !0;
      }, n.onmousemove = function(l) {
        if (l = l || window.event, !s._enterable) {
          var u = i.handler, c = i.painter.getViewportRoot();
          Yn(c, l, !0), u.dispatch("mousemove", l);
        }
      }, n.onmouseleave = function() {
        s._inContent = !1, s._enterable && s._show && s.hideLater(s._hideDelay);
      };
    }
    return r.prototype.update = function(t) {
      if (!this._container) {
        var e = this._api.getDom(), n = got(e, "position"), i = e.style;
        i.position !== "absolute" && n !== "absolute" && (i.position = "relative");
      }
      var a = t.get("alwaysShowContent");
      a && this._moveIfResized(), this._alwaysShowContent = a, this._enableDisplayTransition = t.get("displayTransition") && t.get("transitionDuration") > 0, this.el.className = t.get("className") || "";
    }, r.prototype.show = function(t, e) {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
      var n = this.el, i = n.style, a = this._styleCoord;
      n.innerHTML ? i.cssText = yot + wot(t, !this._firstShow, this._longHide, this._enableDisplayTransition) + q2(a[0], a[1], !0) + ("border-color:" + yl(e) + ";") + (t.get("extraCssText") || "") + (";pointer-events:" + (this._enterable ? "auto" : "none")) : i.display = "none", this._show = !0, this._firstShow = !1, this._longHide = !1;
    }, r.prototype.setContent = function(t, e, n, i, a) {
      var o = this.el;
      if (t == null) {
        o.innerHTML = "";
        return;
      }
      var s = "";
      if (pt(a) && n.get("trigger") === "item" && !CV(n) && (s = xot(n, i, a)), pt(t))
        o.innerHTML = t + s;
      else if (t) {
        o.innerHTML = "", et(t) || (t = [t]);
        for (var l = 0; l < t.length; l++)
          fl(t[l]) && t[l].parentNode !== o && o.appendChild(t[l]);
        if (s && o.childNodes.length) {
          var u = document.createElement("div");
          u.innerHTML = s, o.appendChild(u);
        }
      }
    }, r.prototype.setEnterable = function(t) {
      this._enterable = t;
    }, r.prototype.getSize = function() {
      var t = this.el;
      return t ? [t.offsetWidth, t.offsetHeight] : [0, 0];
    }, r.prototype.moveTo = function(t, e) {
      if (this.el) {
        var n = this._styleCoord;
        if (K2(n, this._zr, this._container, t, e), n[0] != null && n[1] != null) {
          var i = this.el.style, a = q2(n[0], n[1]);
          L(a, function(o) {
            i[o[0]] = o[1];
          });
        }
      }
    }, r.prototype._moveIfResized = function() {
      var t = this._styleCoord[2], e = this._styleCoord[3];
      this.moveTo(t * this._zr.getWidth(), e * this._zr.getHeight());
    }, r.prototype.hide = function() {
      var t = this, e = this.el.style;
      this._enableDisplayTransition ? (e.visibility = "hidden", e.opacity = "0") : e.display = "none", oe.transform3dSupported && (e.willChange = ""), this._show = !1, this._longHideTimeout = setTimeout(function() {
        return t._longHide = !0;
      }, 500);
    }, r.prototype.hideLater = function(t) {
      this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(mt(this.hide, this), t)) : this.hide());
    }, r.prototype.isShow = function() {
      return this._show;
    }, r.prototype.dispose = function() {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
      var t = this._zr;
      MW(t && t.painter && t.painter.getViewportRoot(), this._container);
      var e = this.el;
      if (e) {
        e.onmouseenter = e.onmousemove = e.onmouseleave = null;
        var n = e.parentNode;
        n && n.removeChild(e);
      }
      this.el = this._container = null;
    }, r;
  }()
), Tot = (
  /** @class */
  function() {
    function r(t) {
      this._show = !1, this._styleCoord = [0, 0, 0, 0], this._alwaysShowContent = !1, this._enterable = !0, this._zr = t.getZr(), J2(this._styleCoord, this._zr, t.getWidth() / 2, t.getHeight() / 2);
    }
    return r.prototype.update = function(t) {
      var e = t.get("alwaysShowContent");
      e && this._moveIfResized(), this._alwaysShowContent = e;
    }, r.prototype.show = function() {
      this._hideTimeout && clearTimeout(this._hideTimeout), this.el.show(), this._show = !0;
    }, r.prototype.setContent = function(t, e, n, i, a) {
      var o = this;
      Dt(t) && we(process.env.NODE_ENV !== "production" ? "Passing DOM nodes as content is not supported in richText tooltip!" : ""), this.el && this._zr.remove(this.el);
      var s = n.getModel("textStyle");
      this.el = new pe({
        style: {
          rich: e.richTextStyles,
          text: t,
          lineHeight: 22,
          borderWidth: 1,
          borderColor: i,
          textShadowColor: s.get("textShadowColor"),
          fill: n.get(["textStyle", "color"]),
          padding: wO(n, "richText"),
          verticalAlign: "top",
          align: "left"
        },
        z: n.get("z")
      }), L(["backgroundColor", "borderRadius", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"], function(u) {
        o.el.style[u] = n.get(u);
      }), L(["textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], function(u) {
        o.el.style[u] = s.get(u) || 0;
      }), this._zr.add(this.el);
      var l = this;
      this.el.on("mouseover", function() {
        l._enterable && (clearTimeout(l._hideTimeout), l._show = !0), l._inContent = !0;
      }), this.el.on("mouseout", function() {
        l._enterable && l._show && l.hideLater(l._hideDelay), l._inContent = !1;
      });
    }, r.prototype.setEnterable = function(t) {
      this._enterable = t;
    }, r.prototype.getSize = function() {
      var t = this.el, e = this.el.getBoundingRect(), n = j2(t.style);
      return [e.width + n.left + n.right, e.height + n.top + n.bottom];
    }, r.prototype.moveTo = function(t, e) {
      var n = this.el;
      if (n) {
        var i = this._styleCoord;
        J2(i, this._zr, t, e), t = i[0], e = i[1];
        var a = n.style, o = go(a.borderWidth || 0), s = j2(a);
        n.x = t + o + s.left, n.y = e + o + s.top, n.markRedraw();
      }
    }, r.prototype._moveIfResized = function() {
      var t = this._styleCoord[2], e = this._styleCoord[3];
      this.moveTo(t * this._zr.getWidth(), e * this._zr.getHeight());
    }, r.prototype.hide = function() {
      this.el && this.el.hide(), this._show = !1;
    }, r.prototype.hideLater = function(t) {
      this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(mt(this.hide, this), t)) : this.hide());
    }, r.prototype.isShow = function() {
      return this._show;
    }, r.prototype.dispose = function() {
      this._zr.remove(this.el);
    }, r;
  }()
);
function go(r) {
  return Math.max(0, r);
}
function j2(r) {
  var t = go(r.shadowBlur || 0), e = go(r.shadowOffsetX || 0), n = go(r.shadowOffsetY || 0);
  return {
    left: go(t - e),
    right: go(t + e),
    top: go(t - n),
    bottom: go(t + n)
  };
}
function J2(r, t, e, n) {
  r[0] = e, r[1] = n, r[2] = r[0] / t.getWidth(), r[3] = r[1] / t.getHeight();
}
var Aot = new te({
  shape: {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }
}), Eot = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function(e, n) {
      if (!(oe.node || !n.getDom())) {
        var i = e.getComponent("tooltip"), a = this._renderMode = a6(i.get("renderMode"));
        this._tooltipContent = a === "richText" ? new Tot(n) : new Mot(n, {
          appendTo: i.get("appendToBody", !0) ? "body" : i.get("appendTo", !0)
        });
      }
    }, t.prototype.render = function(e, n, i) {
      if (!(oe.node || !i.getDom())) {
        this.group.removeAll(), this._tooltipModel = e, this._ecModel = n, this._api = i;
        var a = this._tooltipContent;
        a.update(e), a.setEnterable(e.get("enterable")), this._initGlobalListener(), this._keepShow(), this._renderMode !== "richText" && e.get("transitionDuration") ? Dc(this, "_updatePosition", 50, "fixRate") : ch(this, "_updatePosition");
      }
    }, t.prototype._initGlobalListener = function() {
      var e = this._tooltipModel, n = e.get("triggerOn");
      hV("itemTooltip", this._api, mt(function(i, a, o) {
        n !== "none" && (n.indexOf(i) >= 0 ? this._tryShow(a, o) : i === "leave" && this._hide(o));
      }, this));
    }, t.prototype._keepShow = function() {
      var e = this._tooltipModel, n = this._ecModel, i = this._api, a = e.get("triggerOn");
      if (this._lastX != null && this._lastY != null && a !== "none" && a !== "click") {
        var o = this;
        clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function() {
          !i.isDisposed() && o.manuallyShowTip(e, n, i, {
            x: o._lastX,
            y: o._lastY,
            dataByCoordSys: o._lastDataByCoordSys
          });
        });
      }
    }, t.prototype.manuallyShowTip = function(e, n, i, a) {
      if (!(a.from === this.uid || oe.node || !i.getDom())) {
        var o = Q2(a, i);
        this._ticket = "";
        var s = a.dataByCoordSys, l = Rot(a, n, i);
        if (l) {
          var u = l.el.getBoundingRect().clone();
          u.applyTransform(l.el.transform), this._tryShow({
            offsetX: u.x + u.width / 2,
            offsetY: u.y + u.height / 2,
            target: l.el,
            position: a.position,
            // When manully trigger, the mouse is not on the el, so we'd better to
            // position tooltip on the bottom of the el and display arrow is possible.
            positionDefault: "bottom"
          }, o);
        } else if (a.tooltip && a.x != null && a.y != null) {
          var c = Aot;
          c.x = a.x, c.y = a.y, c.update(), zt(c).tooltipConfig = {
            name: null,
            option: a.tooltip
          }, this._tryShow({
            offsetX: a.x,
            offsetY: a.y,
            target: c
          }, o);
        } else if (s)
          this._tryShow({
            offsetX: a.x,
            offsetY: a.y,
            position: a.position,
            dataByCoordSys: s,
            tooltipOption: a.tooltipOption
          }, o);
        else if (a.seriesIndex != null) {
          if (this._manuallyAxisShowTip(e, n, i, a))
            return;
          var f = dV(a, n), h = f.point[0], d = f.point[1];
          h != null && d != null && this._tryShow({
            offsetX: h,
            offsetY: d,
            target: f.el,
            position: a.position,
            // When manully trigger, the mouse is not on the el, so we'd better to
            // position tooltip on the bottom of the el and display arrow is possible.
            positionDefault: "bottom"
          }, o);
        } else
          a.x != null && a.y != null && (i.dispatchAction({
            type: "updateAxisPointer",
            x: a.x,
            y: a.y
          }), this._tryShow({
            offsetX: a.x,
            offsetY: a.y,
            position: a.position,
            target: i.getZr().findHover(a.x, a.y).target
          }, o));
      }
    }, t.prototype.manuallyHideTip = function(e, n, i, a) {
      var o = this._tooltipContent;
      this._tooltipModel && o.hideLater(this._tooltipModel.get("hideDelay")), this._lastX = this._lastY = this._lastDataByCoordSys = null, a.from !== this.uid && this._hide(Q2(a, i));
    }, t.prototype._manuallyAxisShowTip = function(e, n, i, a) {
      var o = a.seriesIndex, s = a.dataIndex, l = n.getComponent("axisPointer").coordSysAxesInfo;
      if (!(o == null || s == null || l == null)) {
        var u = n.getSeriesByIndex(o);
        if (u) {
          var c = u.getData(), f = _f([c.getItemModel(s), u, (u.coordinateSystem || {}).model], this._tooltipModel);
          if (f.get("trigger") === "axis")
            return i.dispatchAction({
              type: "updateAxisPointer",
              seriesIndex: o,
              dataIndex: s,
              position: a.position
            }), !0;
        }
      }
    }, t.prototype._tryShow = function(e, n) {
      var i = e.target, a = this._tooltipModel;
      if (a) {
        this._lastX = e.offsetX, this._lastY = e.offsetY;
        var o = e.dataByCoordSys;
        if (o && o.length)
          this._showAxisTooltip(o, e);
        else if (i) {
          var s = zt(i);
          if (s.ssrType === "legend")
            return;
          this._lastDataByCoordSys = null;
          var l, u;
          Js(i, function(c) {
            if (c.tooltipDisabled)
              return l = u = null, !0;
            l || u || (zt(c).dataIndex != null ? l = c : zt(c).tooltipConfig != null && (u = c));
          }, !0), l ? this._showSeriesItemTooltip(e, l, n) : u ? this._showComponentItemTooltip(e, u, n) : this._hide(n);
        } else
          this._lastDataByCoordSys = null, this._hide(n);
      }
    }, t.prototype._showOrMove = function(e, n) {
      var i = e.get("showDelay");
      n = mt(n, this), clearTimeout(this._showTimout), i > 0 ? this._showTimout = setTimeout(n, i) : n();
    }, t.prototype._showAxisTooltip = function(e, n) {
      var i = this._ecModel, a = this._tooltipModel, o = [n.offsetX, n.offsetY], s = _f([n.tooltipOption], a), l = this._renderMode, u = [], c = cr("section", {
        blocks: [],
        noHeader: !0
      }), f = [], h = new a0();
      L(e, function(y) {
        L(y.dataByAxis, function(_) {
          var x = i.getComponent(_.axisDim + "Axis", _.axisIndex), b = _.value;
          if (!(!x || b == null)) {
            var S = uV(b, x.axis, i, _.seriesDataIndices, _.valueLabelOpt), w = cr("section", {
              header: S,
              noHeader: !ti(S),
              sortBlocks: !0,
              blocks: []
            });
            c.blocks.push(w), L(_.seriesDataIndices, function(A) {
              var T = i.getSeriesByIndex(A.seriesIndex), M = A.dataIndexInside, E = T.getDataParams(M);
              if (!(E.dataIndex < 0)) {
                E.axisDim = _.axisDim, E.axisIndex = _.axisIndex, E.axisType = _.axisType, E.axisId = _.axisId, E.axisValue = Kv(x.axis, {
                  value: b
                }), E.axisValueLabel = S, E.marker = h.makeTooltipMarker("item", yl(E.color), l);
                var R = fE(T.formatTooltip(M, !0, null)), C = R.frag;
                if (C) {
                  var D = _f([T], a).get("valueFormatter");
                  w.blocks.push(D ? J({
                    valueFormatter: D
                  }, C) : C);
                }
                R.text && f.push(R.text), u.push(E);
              }
            });
          }
        });
      }), c.blocks.reverse(), f.reverse();
      var d = n.position, p = s.get("order"), g = mE(c, h, l, p, i.get("useUTC"), s.get("textStyle"));
      g && f.unshift(g);
      var v = l === "richText" ? `

` : "<br/>", m = f.join(v);
      this._showOrMove(s, function() {
        this._updateContentNotChangedOnAxis(e, u) ? this._updatePosition(s, d, o[0], o[1], this._tooltipContent, u) : this._showTooltipContent(s, m, u, Math.random() + "", o[0], o[1], d, null, h);
      });
    }, t.prototype._showSeriesItemTooltip = function(e, n, i) {
      var a = this._ecModel, o = zt(n), s = o.seriesIndex, l = a.getSeriesByIndex(s), u = o.dataModel || l, c = o.dataIndex, f = o.dataType, h = u.getData(f), d = this._renderMode, p = e.positionDefault, g = _f([h.getItemModel(c), u, l && (l.coordinateSystem || {}).model], this._tooltipModel, p ? {
        position: p
      } : null), v = g.get("trigger");
      if (!(v != null && v !== "item")) {
        var m = u.getDataParams(c, f), y = new a0();
        m.marker = y.makeTooltipMarker("item", yl(m.color), d);
        var _ = fE(u.formatTooltip(c, !1, f)), x = g.get("order"), b = g.get("valueFormatter"), S = _.frag, w = S ? mE(b ? J({
          valueFormatter: b
        }, S) : S, y, d, x, a.get("useUTC"), g.get("textStyle")) : _.text, A = "item_" + u.name + "_" + c;
        this._showOrMove(g, function() {
          this._showTooltipContent(g, w, m, A, e.offsetX, e.offsetY, e.position, e.target, y);
        }), i({
          type: "showTip",
          dataIndexInside: c,
          dataIndex: h.getRawIndex(c),
          seriesIndex: s,
          from: this.uid
        });
      }
    }, t.prototype._showComponentItemTooltip = function(e, n, i) {
      var a = this._renderMode === "html", o = zt(n), s = o.tooltipConfig, l = s.option || {}, u = l.encodeHTMLContent;
      if (pt(l)) {
        var c = l;
        l = {
          content: c,
          // Fixed formatter
          formatter: c
        }, u = !0;
      }
      u && a && l.content && (l = Ct(l), l.content = on(l.content));
      var f = [l], h = this._ecModel.getComponent(o.componentMainType, o.componentIndex);
      h && f.push(h), f.push({
        formatter: l.content
      });
      var d = e.positionDefault, p = _f(f, this._tooltipModel, d ? {
        position: d
      } : null), g = p.get("content"), v = Math.random() + "", m = new a0();
      this._showOrMove(p, function() {
        var y = Ct(p.get("formatterParams") || {});
        this._showTooltipContent(p, g, y, v, e.offsetX, e.offsetY, e.position, n, m);
      }), i({
        type: "showTip",
        from: this.uid
      });
    }, t.prototype._showTooltipContent = function(e, n, i, a, o, s, l, u, c) {
      if (this._ticket = "", !(!e.get("showContent") || !e.get("show"))) {
        var f = this._tooltipContent;
        f.setEnterable(e.get("enterable"));
        var h = e.get("formatter");
        l = l || e.get("position");
        var d = n, p = this._getNearestPoint([o, s], i, e.get("trigger"), e.get("borderColor"), e.get("defaultBorderColor", !0)), g = p.color;
        if (h)
          if (pt(h)) {
            var v = e.ecModel.get("useUTC"), m = et(i) ? i[0] : i, y = m && m.axisType && m.axisType.indexOf("time") >= 0;
            d = h, y && (d = lm(m.axisValue, d, v)), d = FN(d, i, !0);
          } else if (Tt(h)) {
            var _ = mt(function(x, b) {
              x === this._ticket && (f.setContent(b, c, e, g, l), this._updatePosition(e, l, o, s, f, i, u));
            }, this);
            this._ticket = a, d = h(i, a, _);
          } else
            d = h;
        f.setContent(d, c, e, g, l), f.show(e, g), this._updatePosition(e, l, o, s, f, i, u);
      }
    }, t.prototype._getNearestPoint = function(e, n, i, a, o) {
      if (i === "axis" || et(n))
        return {
          color: a || o
        };
      if (!et(n))
        return {
          color: a || n.color || n.borderColor
        };
    }, t.prototype._updatePosition = function(e, n, i, a, o, s, l) {
      var u = this._api.getWidth(), c = this._api.getHeight();
      n = n || e.get("position");
      var f = o.getSize(), h = e.get("align"), d = e.get("verticalAlign"), p = l && l.getBoundingRect().clone();
      if (l && p.applyTransform(l.transform), Tt(n) && (n = n([i, a], s, o.el, p, {
        viewSize: [u, c],
        contentSize: f.slice()
      })), et(n))
        i = dt(n[0], u), a = dt(n[1], c);
      else if (Dt(n)) {
        var g = n;
        g.width = f[0], g.height = f[1];
        var v = He(g, {
          width: u,
          height: c
        });
        i = v.x, a = v.y, h = null, d = null;
      } else if (pt(n) && l) {
        var m = Lot(n, p, f, e.get("borderWidth"));
        i = m[0], a = m[1];
      } else {
        var m = Cot(i, a, o, u, c, h ? null : 20, d ? null : 20);
        i = m[0], a = m[1];
      }
      if (h && (i -= tR(h) ? f[0] / 2 : h === "right" ? f[0] : 0), d && (a -= tR(d) ? f[1] / 2 : d === "bottom" ? f[1] : 0), CV(e)) {
        var m = Dot(i, a, o, u, c);
        i = m[0], a = m[1];
      }
      o.moveTo(i, a);
    }, t.prototype._updateContentNotChangedOnAxis = function(e, n) {
      var i = this._lastDataByCoordSys, a = this._cbParamsList, o = !!i && i.length === e.length;
      return o && L(i, function(s, l) {
        var u = s.dataByAxis || [], c = e[l] || {}, f = c.dataByAxis || [];
        o = o && u.length === f.length, o && L(u, function(h, d) {
          var p = f[d] || {}, g = h.seriesDataIndices || [], v = p.seriesDataIndices || [];
          o = o && h.value === p.value && h.axisType === p.axisType && h.axisId === p.axisId && g.length === v.length, o && L(g, function(m, y) {
            var _ = v[y];
            o = o && m.seriesIndex === _.seriesIndex && m.dataIndex === _.dataIndex;
          }), a && L(h.seriesDataIndices, function(m) {
            var y = m.seriesIndex, _ = n[y], x = a[y];
            _ && x && x.data !== _.data && (o = !1);
          });
        });
      }), this._lastDataByCoordSys = e, this._cbParamsList = n, !!o;
    }, t.prototype._hide = function(e) {
      this._lastDataByCoordSys = null, e({
        type: "hideTip",
        from: this.uid
      });
    }, t.prototype.dispose = function(e, n) {
      oe.node || !n.getDom() || (ch(this, "_updatePosition"), this._tooltipContent.dispose(), zS("itemTooltip", n));
    }, t.type = "tooltip", t;
  }(Ue)
);
function _f(r, t, e) {
  var n = t.ecModel, i;
  e ? (i = new ue(e, n, n), i = new ue(t.option, i, n)) : i = t;
  for (var a = r.length - 1; a >= 0; a--) {
    var o = r[a];
    o && (o instanceof ue && (o = o.get("tooltip", !0)), pt(o) && (o = {
      formatter: o
    }), o && (i = new ue(o, i, n)));
  }
  return i;
}
function Q2(r, t) {
  return r.dispatchAction || mt(t.dispatchAction, t);
}
function Cot(r, t, e, n, i, a, o) {
  var s = e.getSize(), l = s[0], u = s[1];
  return a != null && (r + l + a + 2 > n ? r -= l + a : r += a), o != null && (t + u + o > i ? t -= u + o : t += o), [r, t];
}
function Dot(r, t, e, n, i) {
  var a = e.getSize(), o = a[0], s = a[1];
  return r = Math.min(r + o, n) - o, t = Math.min(t + s, i) - s, r = Math.max(r, 0), t = Math.max(t, 0), [r, t];
}
function Lot(r, t, e, n) {
  var i = e[0], a = e[1], o = Math.ceil(Math.SQRT2 * n) + 8, s = 0, l = 0, u = t.width, c = t.height;
  switch (r) {
    case "inside":
      s = t.x + u / 2 - i / 2, l = t.y + c / 2 - a / 2;
      break;
    case "top":
      s = t.x + u / 2 - i / 2, l = t.y - a - o;
      break;
    case "bottom":
      s = t.x + u / 2 - i / 2, l = t.y + c + o;
      break;
    case "left":
      s = t.x - i - o, l = t.y + c / 2 - a / 2;
      break;
    case "right":
      s = t.x + u + o, l = t.y + c / 2 - a / 2;
  }
  return [s, l];
}
function tR(r) {
  return r === "center" || r === "middle";
}
function Rot(r, t, e) {
  var n = L1(r).queryOptionMap, i = n.keys()[0];
  if (!(!i || i === "series")) {
    var a = Sc(t, i, n.get(i), {
      useDefault: !1,
      enableAll: !1,
      enableNone: !1
    }), o = a.models[0];
    if (o) {
      var s = e.getViewOfComponentModel(o), l;
      if (s.group.traverse(function(u) {
        var c = zt(u).tooltipConfig;
        if (c && c.name === r.name)
          return l = u, !0;
      }), l)
        return {
          componentMainType: i,
          componentIndex: o.componentIndex,
          el: l
        };
    }
  }
}
function Iot(r) {
  jt(qh), r.registerComponentModel(pot), r.registerComponentView(Eot), r.registerAction({
    type: "showTip",
    event: "showTip",
    update: "tooltip:manuallyShowTip"
  }, er), r.registerAction({
    type: "hideTip",
    event: "hideTip",
    update: "tooltip:manuallyHideTip"
  }, er);
}
var Pot = ["rect", "polygon", "keep", "clear"];
function Not(r, t) {
  var e = Ie(r ? r.brush : []);
  if (e.length) {
    var n = [];
    L(e, function(l) {
      var u = l.hasOwnProperty("toolbox") ? l.toolbox : [];
      u instanceof Array && (n = n.concat(u));
    });
    var i = r && r.toolbox;
    et(i) && (i = i[0]), i || (i = {
      feature: {}
    }, r.toolbox = [i]);
    var a = i.feature || (i.feature = {}), o = a.brush || (a.brush = {}), s = o.type || (o.type = []);
    s.push.apply(s, n), Oot(s), t && !s.length && s.push.apply(s, Pot);
  }
}
function Oot(r) {
  var t = {};
  L(r, function(e) {
    t[e] = 1;
  }), r.length = 0, L(t, function(e, n) {
    r.push(n);
  });
}
var eR = L;
function rR(r) {
  if (r) {
    for (var t in r)
      if (r.hasOwnProperty(t))
        return !0;
  }
}
function qS(r, t, e) {
  var n = {};
  return eR(t, function(a) {
    var o = n[a] = i();
    eR(r[a], function(s, l) {
      if (Mr.isValidType(l)) {
        var u = {
          type: l,
          visual: s
        };
        e && e(u, a), o[l] = new Mr(u), l === "opacity" && (u = Ct(u), u.type = "colorAlpha", o.__hidden.__alphaForOpacity = new Mr(u));
      }
    });
  }), n;
  function i() {
    var a = function() {
    };
    a.prototype.__hidden = a.prototype;
    var o = new a();
    return o;
  }
}
function IV(r, t, e) {
  var n;
  L(e, function(i) {
    t.hasOwnProperty(i) && rR(t[i]) && (n = !0);
  }), n && L(e, function(i) {
    t.hasOwnProperty(i) && rR(t[i]) ? r[i] = Ct(t[i]) : delete r[i];
  });
}
function kot(r, t, e, n, i, a) {
  var o = {};
  L(r, function(f) {
    var h = Mr.prepareVisualTypes(t[f]);
    o[f] = h;
  });
  var s;
  function l(f) {
    return cb(e, s, f);
  }
  function u(f, h) {
    PO(e, s, f, h);
  }
  e.each(c);
  function c(f, h) {
    s = f;
    var d = e.getRawDataItem(s);
    if (!(d && d.visualMap === !1))
      for (var p = n.call(i, f), g = t[p], v = o[p], m = 0, y = v.length; m < y; m++) {
        var _ = v[m];
        g[_] && g[_].applyVisual(f, l, u);
      }
  }
}
function Bot(r, t, e, n) {
  var i = {};
  return L(r, function(a) {
    var o = Mr.prepareVisualTypes(t[a]);
    i[a] = o;
  }), {
    progress: function(o, s) {
      var l;
      n != null && (l = s.getDimensionIndex(n));
      function u(b) {
        return cb(s, f, b);
      }
      function c(b, S) {
        PO(s, f, b, S);
      }
      for (var f, h = s.getStore(); (f = o.next()) != null; ) {
        var d = s.getRawDataItem(f);
        if (!(d && d.visualMap === !1))
          for (var p = n != null ? h.get(l, f) : f, g = e(p), v = t[g], m = i[g], y = 0, _ = m.length; y < _; y++) {
            var x = m[y];
            v[x] && v[x].applyVisual(p, u, c);
          }
      }
    }
  };
}
function Vot(r) {
  var t = r.brushType, e = {
    point: function(n) {
      return nR[t].point(n, e, r);
    },
    rect: function(n) {
      return nR[t].rect(n, e, r);
    }
  };
  return e;
}
var nR = {
  lineX: iR(0),
  lineY: iR(1),
  rect: {
    point: function(r, t, e) {
      return r && e.boundingRect.contain(r[0], r[1]);
    },
    rect: function(r, t, e) {
      return r && e.boundingRect.intersect(r);
    }
  },
  polygon: {
    point: function(r, t, e) {
      return r && e.boundingRect.contain(r[0], r[1]) && Gs(e.range, r[0], r[1]);
    },
    rect: function(r, t, e) {
      var n = e.range;
      if (!r || n.length <= 1)
        return !1;
      var i = r.x, a = r.y, o = r.width, s = r.height, l = n[0];
      if (Gs(n, i, a) || Gs(n, i + o, a) || Gs(n, i, a + s) || Gs(n, i + o, a + s) || Bt.create(r).contain(l[0], l[1]) || Lf(i, a, i + o, a, n) || Lf(i, a, i, a + s, n) || Lf(i + o, a, i + o, a + s, n) || Lf(i, a + s, i + o, a + s, n))
        return !0;
    }
  }
};
function iR(r) {
  var t = ["x", "y"], e = ["width", "height"];
  return {
    point: function(n, i, a) {
      if (n) {
        var o = a.range, s = n[r];
        return xf(s, o);
      }
    },
    rect: function(n, i, a) {
      if (n) {
        var o = a.range, s = [n[t[r]], n[t[r]] + n[e[r]]];
        return s[1] < s[0] && s.reverse(), xf(s[0], o) || xf(s[1], o) || xf(o[0], s) || xf(o[1], s);
      }
    }
  };
}
function xf(r, t) {
  return t[0] <= r && r <= t[1];
}
var aR = ["inBrush", "outOfBrush"], A_ = "__ecBrushSelect", KS = "__ecInBrushSelectEvent";
function PV(r) {
  r.eachComponent({
    mainType: "brush"
  }, function(t) {
    var e = t.brushTargetManager = new Tw(t.option, r);
    e.setInputRanges(t.areas, r);
  });
}
function Fot(r, t, e) {
  var n = [], i, a;
  r.eachComponent({
    mainType: "brush"
  }, function(o) {
    e && e.type === "takeGlobalCursor" && o.setBrushOption(e.key === "brush" ? e.brushOption : {
      brushType: !1
    });
  }), PV(r), r.eachComponent({
    mainType: "brush"
  }, function(o, s) {
    var l = {
      brushId: o.id,
      brushIndex: s,
      brushName: o.name,
      areas: Ct(o.areas),
      selected: []
    };
    n.push(l);
    var u = o.option, c = u.brushLink, f = [], h = [], d = [], p = !1;
    s || (i = u.throttleType, a = u.throttleDelay);
    var g = rt(o.areas, function(b) {
      var S = Hot[b.brushType], w = kt({
        boundingRect: S ? S(b) : void 0
      }, b);
      return w.selectors = Vot(w), w;
    }), v = qS(o.option, aR, function(b) {
      b.mappingMethod = "fixed";
    });
    et(c) && L(c, function(b) {
      f[b] = 1;
    });
    function m(b) {
      return c === "all" || !!f[b];
    }
    function y(b) {
      return !!b.length;
    }
    r.eachSeries(function(b, S) {
      var w = d[S] = [];
      b.subType === "parallel" ? _(b, S) : x(b, S, w);
    });
    function _(b, S) {
      var w = b.coordinateSystem;
      p = p || w.hasAxisBrushed(), m(S) && w.eachActiveState(b.getData(), function(A, T) {
        A === "active" && (h[T] = 1);
      });
    }
    function x(b, S, w) {
      if (!(!b.brushSelector || Got(o, S)) && (L(g, function(T) {
        o.brushTargetManager.controlSeries(T, b, r) && w.push(T), p = p || y(w);
      }), m(S) && y(w))) {
        var A = b.getData();
        A.each(function(T) {
          oR(b, w, A, T) && (h[T] = 1);
        });
      }
    }
    r.eachSeries(function(b, S) {
      var w = {
        seriesId: b.id,
        seriesIndex: S,
        seriesName: b.name,
        dataIndex: []
      };
      l.selected.push(w);
      var A = d[S], T = b.getData(), M = m(S) ? function(E) {
        return h[E] ? (w.dataIndex.push(T.getRawIndex(E)), "inBrush") : "outOfBrush";
      } : function(E) {
        return oR(b, A, T, E) ? (w.dataIndex.push(T.getRawIndex(E)), "inBrush") : "outOfBrush";
      };
      (m(S) ? p : y(A)) && kot(aR, v, T, M);
    });
  }), zot(t, i, a, n, e);
}
function zot(r, t, e, n, i) {
  if (i) {
    var a = r.getZr();
    if (!a[KS]) {
      a[A_] || (a[A_] = Uot);
      var o = Dc(a, A_, e, t);
      o(r, n);
    }
  }
}
function Uot(r, t) {
  if (!r.isDisposed()) {
    var e = r.getZr();
    e[KS] = !0, r.dispatchAction({
      type: "brushSelect",
      batch: t
    }), e[KS] = !1;
  }
}
function oR(r, t, e, n) {
  for (var i = 0, a = t.length; i < a; i++) {
    var o = t[i];
    if (r.brushSelector(n, e, o.selectors, o))
      return !0;
  }
}
function Got(r, t) {
  var e = r.option.seriesIndex;
  return e != null && e !== "all" && (et(e) ? Zt(e, t) < 0 : t !== e);
}
var Hot = {
  rect: function(r) {
    return sR(r.range);
  },
  polygon: function(r) {
    for (var t, e = r.range, n = 0, i = e.length; n < i; n++) {
      t = t || [[1 / 0, -1 / 0], [1 / 0, -1 / 0]];
      var a = e[n];
      a[0] < t[0][0] && (t[0][0] = a[0]), a[0] > t[0][1] && (t[0][1] = a[0]), a[1] < t[1][0] && (t[1][0] = a[1]), a[1] > t[1][1] && (t[1][1] = a[1]);
    }
    return t && sR(t);
  }
};
function sR(r) {
  return new Bt(r[0][0], r[1][0], r[0][1] - r[0][0], r[1][1] - r[1][0]);
}
var Wot = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function(e, n) {
      this.ecModel = e, this.api = n, this.model, (this._brushController = new Kb(n.getZr())).on("brush", mt(this._onBrush, this)).mount();
    }, t.prototype.render = function(e, n, i, a) {
      this.model = e, this._updateController(e, n, i, a);
    }, t.prototype.updateTransform = function(e, n, i, a) {
      PV(n), this._updateController(e, n, i, a);
    }, t.prototype.updateVisual = function(e, n, i, a) {
      this.updateTransform(e, n, i, a);
    }, t.prototype.updateView = function(e, n, i, a) {
      this._updateController(e, n, i, a);
    }, t.prototype._updateController = function(e, n, i, a) {
      (!a || a.$from !== e.id) && this._brushController.setPanels(e.brushTargetManager.makePanelOpts(i)).enableBrush(e.brushOption).updateCovers(e.areas.slice());
    }, t.prototype.dispose = function() {
      this._brushController.dispose();
    }, t.prototype._onBrush = function(e) {
      var n = this.model.id, i = this.model.brushTargetManager.setOutputRanges(e.areas, this.ecModel);
      (!e.isEnd || e.removeOnClick) && this.api.dispatchAction({
        type: "brush",
        brushId: n,
        areas: Ct(i),
        $from: n
      }), e.isEnd && this.api.dispatchAction({
        type: "brushEnd",
        brushId: n,
        areas: Ct(i),
        $from: n
      });
    }, t.type = "brush", t;
  }(Ue)
), Xot = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.areas = [], e.brushOption = {}, e;
    }
    return t.prototype.optionUpdated = function(e, n) {
      var i = this.option;
      !n && IV(i, e, ["inBrush", "outOfBrush"]);
      var a = i.inBrush = i.inBrush || {};
      i.outOfBrush = i.outOfBrush || {
        color: this.option.defaultOutOfBrushColor
      }, a.hasOwnProperty("liftZ") || (a.liftZ = 5);
    }, t.prototype.setAreas = function(e) {
      process.env.NODE_ENV !== "production" && (St(et(e)), L(e, function(n) {
        St(n.brushType, "Illegal areas");
      })), e && (this.areas = rt(e, function(n) {
        return lR(this.option, n);
      }, this));
    }, t.prototype.setBrushOption = function(e) {
      this.brushOption = lR(this.option, e), this.brushType = this.brushOption.brushType;
    }, t.type = "brush", t.dependencies = ["geo", "grid", "xAxis", "yAxis", "parallel", "series"], t.defaultOption = {
      seriesIndex: "all",
      brushType: "rect",
      brushMode: "single",
      transformable: !0,
      brushStyle: {
        borderWidth: 1,
        color: Y.color.backgroundTint,
        borderColor: Y.color.borderTint
      },
      throttleType: "fixRate",
      throttleDelay: 0,
      removeOnClick: !0,
      z: 1e4,
      defaultOutOfBrushColor: Y.color.disabled
    }, t;
  }(re)
);
function lR(r, t) {
  return qt({
    brushType: r.brushType,
    brushMode: r.brushMode,
    transformable: r.transformable,
    brushStyle: new ue(r.brushStyle).getItemStyle(),
    removeOnClick: r.removeOnClick,
    z: r.z
  }, t, !0);
}
var Yot = ["rect", "polygon", "lineX", "lineY", "keep", "clear"], $ot = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return t.prototype.render = function(e, n, i) {
      var a, o, s;
      n.eachComponent({
        mainType: "brush"
      }, function(l) {
        a = l.brushType, o = l.brushOption.brushMode || "single", s = s || !!l.areas.length;
      }), this._brushType = a, this._brushMode = o, L(e.get("type", !0), function(l) {
        e.setIconStatus(l, (l === "keep" ? o === "multiple" : l === "clear" ? s : l === a) ? "emphasis" : "normal");
      });
    }, t.prototype.updateView = function(e, n, i) {
      this.render(e, n, i);
    }, t.prototype.getIcons = function() {
      var e = this.model, n = e.get("icon", !0), i = {};
      return L(e.get("type", !0), function(a) {
        n[a] && (i[a] = n[a]);
      }), i;
    }, t.prototype.onclick = function(e, n, i) {
      var a = this._brushType, o = this._brushMode;
      i === "clear" ? (n.dispatchAction({
        type: "axisAreaSelect",
        intervals: []
      }), n.dispatchAction({
        type: "brush",
        command: "clear",
        // Clear all areas of all brush components.
        areas: []
      })) : n.dispatchAction({
        type: "takeGlobalCursor",
        key: "brush",
        brushOption: {
          brushType: i === "keep" ? a : a === i ? !1 : i,
          brushMode: i === "keep" ? o === "multiple" ? "single" : "multiple" : o
        }
      });
    }, t.getDefaultOption = function(e) {
      var n = {
        show: !0,
        type: Yot.slice(),
        icon: {
          /* eslint-disable */
          rect: "M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13",
          polygon: "M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2",
          lineX: "M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4",
          lineY: "M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4",
          keep: "M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z",
          clear: "M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2"
          // jshint ignore:line
          /* eslint-enable */
        },
        // `rect`, `polygon`, `lineX`, `lineY`, `keep`, `clear`
        title: e.getLocaleModel().get(["toolbox", "brush", "title"])
      };
      return n;
    }, t;
  }(jn)
);
function Zot(r) {
  r.registerComponentView(Wot), r.registerComponentModel(Xot), r.registerPreprocessor(Not), r.registerVisual(r.PRIORITY.VISUAL.BRUSH, Fot), r.registerAction({
    type: "brush",
    event: "brush",
    update: "updateVisual"
  }, function(t, e) {
    e.eachComponent({
      mainType: "brush",
      query: t
    }, function(n) {
      n.setAreas(t.areas);
    });
  }), r.registerAction({
    type: "brushSelect",
    event: "brushSelected",
    update: "none"
  }, er), r.registerAction({
    type: "brushEnd",
    event: "brushEnd",
    update: "none"
  }, er), Lu("brush", $ot);
}
var qot = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.layoutMode = {
        type: "box",
        ignoreSize: !0
      }, e;
    }
    return t.type = "title", t.defaultOption = {
      // zlevel: 0,
      z: 6,
      show: !0,
      text: "",
      target: "blank",
      subtext: "",
      subtarget: "blank",
      left: "center",
      top: Y.size.m,
      backgroundColor: Y.color.transparent,
      borderColor: Y.color.primary,
      borderWidth: 0,
      padding: 5,
      itemGap: 10,
      textStyle: {
        fontSize: 18,
        fontWeight: "bold",
        color: Y.color.primary
      },
      subtextStyle: {
        fontSize: 12,
        color: Y.color.quaternary
      }
    }, t;
  }(re)
), Kot = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n, i) {
      if (this.group.removeAll(), !!e.get("show")) {
        var a = this.group, o = e.getModel("textStyle"), s = e.getModel("subtextStyle"), l = e.get("textAlign"), u = bt(e.get("textBaseline"), e.get("textVerticalAlign")), c = new pe({
          style: Oe(o, {
            text: e.get("text"),
            fill: o.getTextColor()
          }, {
            disableBox: !0
          }),
          z2: 10
        }), f = c.getBoundingRect(), h = e.get("subtext"), d = new pe({
          style: Oe(s, {
            text: h,
            fill: s.getTextColor(),
            y: f.height + e.get("itemGap"),
            verticalAlign: "top"
          }, {
            disableBox: !0
          }),
          z2: 10
        }), p = e.get("link"), g = e.get("sublink"), v = e.get("triggerEvent", !0);
        c.silent = !p && !v, d.silent = !g && !v, p && c.on("click", function() {
          Bv(p, "_" + e.get("target"));
        }), g && d.on("click", function() {
          Bv(g, "_" + e.get("subtarget"));
        }), zt(c).eventData = zt(d).eventData = v ? {
          componentType: "title",
          componentIndex: e.componentIndex
        } : null, a.add(c), h && a.add(d);
        var m = a.getBoundingRect(), y = e.getBoxLayoutParams();
        y.width = m.width, y.height = m.height;
        var _ = xr(e, i), x = He(y, _.refContainer, e.get("padding"));
        l || (l = e.get("left") || e.get("right"), l === "middle" && (l = "center"), l === "right" ? x.x += x.width : l === "center" && (x.x += x.width / 2)), u || (u = e.get("top") || e.get("bottom"), u === "center" && (u = "middle"), u === "bottom" ? x.y += x.height : u === "middle" && (x.y += x.height / 2), u = u || "top"), a.x = x.x, a.y = x.y, a.markRedraw();
        var b = {
          align: l,
          verticalAlign: u
        };
        c.setStyle(b), d.setStyle(b), m = a.getBoundingRect();
        var S = x.margin, w = e.getItemStyle(["color", "opacity"]);
        w.fill = e.get("backgroundColor");
        var A = new te({
          shape: {
            x: m.x - S[3],
            y: m.y - S[0],
            width: m.width + S[1] + S[3],
            height: m.height + S[0] + S[2],
            r: e.get("borderRadius")
          },
          style: w,
          subPixelOptimize: !0,
          silent: !0
        });
        a.add(A);
      }
    }, t.type = "title", t;
  }(Ue)
);
function jot(r) {
  r.registerComponentModel(qot), r.registerComponentView(Kot);
}
var uR = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.layoutMode = "box", e;
    }
    return t.prototype.init = function(e, n, i) {
      this.mergeDefaultAndTheme(e, i), this._initData();
    }, t.prototype.mergeOption = function(e) {
      r.prototype.mergeOption.apply(this, arguments), this._initData();
    }, t.prototype.setCurrentIndex = function(e) {
      e == null && (e = this.option.currentIndex);
      var n = this._data.count();
      this.option.loop ? e = (e % n + n) % n : (e >= n && (e = n - 1), e < 0 && (e = 0)), this.option.currentIndex = e;
    }, t.prototype.getCurrentIndex = function() {
      return this.option.currentIndex;
    }, t.prototype.isIndexMax = function() {
      return this.getCurrentIndex() >= this._data.count() - 1;
    }, t.prototype.setPlayState = function(e) {
      this.option.autoPlay = !!e;
    }, t.prototype.getPlayState = function() {
      return !!this.option.autoPlay;
    }, t.prototype._initData = function() {
      var e = this.option, n = e.data || [], i = e.axisType, a = this._names = [], o;
      i === "category" ? (o = [], L(n, function(u, c) {
        var f = mr(xc(u), ""), h;
        Dt(u) ? (h = Ct(u), h.value = c) : h = c, o.push(h), a.push(f);
      })) : o = n;
      var s = {
        category: "ordinal",
        time: "time",
        value: "number"
      }[i] || "number", l = this._data = new un([{
        name: "value",
        type: s
      }], this);
      l.initData(o, a);
    }, t.prototype.getData = function() {
      return this._data;
    }, t.prototype.getCategories = function() {
      if (this.get("axisType") === "category")
        return this._names.slice();
    }, t.type = "timeline", t.defaultOption = {
      // zlevel: 0,                  // 
      z: 4,
      show: !0,
      axisType: "time",
      realtime: !0,
      left: "20%",
      top: null,
      right: "20%",
      bottom: 0,
      width: null,
      height: 40,
      padding: Y.size.m,
      controlPosition: "left",
      autoPlay: !1,
      rewind: !1,
      loop: !0,
      playInterval: 2e3,
      currentIndex: 0,
      itemStyle: {},
      label: {
        color: Y.color.secondary
      },
      data: []
    }, t;
  }(re)
), NV = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.type = "timeline.slider", t.defaultOption = jo(uR.defaultOption, {
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: Y.color.border,
      borderWidth: 0,
      orient: "horizontal",
      inverse: !1,
      tooltip: {
        trigger: "item"
        // data item may also have tootip attr.
      },
      symbol: "circle",
      symbolSize: 12,
      lineStyle: {
        show: !0,
        width: 2,
        color: Y.color.accent10
      },
      label: {
        position: "auto",
        // When using number, label position is not
        // restricted by viewRect.
        // positive: right/bottom, negative: left/top
        show: !0,
        interval: "auto",
        rotate: 0,
        // formatter: null,
        // TEXTSTYLE
        color: Y.color.tertiary
      },
      itemStyle: {
        color: Y.color.accent20,
        borderWidth: 0
      },
      checkpointStyle: {
        symbol: "circle",
        symbolSize: 15,
        color: Y.color.accent50,
        borderColor: Y.color.accent50,
        borderWidth: 0,
        shadowBlur: 0,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        shadowColor: "rgba(0, 0, 0, 0)",
        // borderColor: 'rgba(194,53,49, 0.5)',
        animation: !0,
        animationDuration: 300,
        animationEasing: "quinticInOut"
      },
      controlStyle: {
        show: !0,
        showPlayBtn: !0,
        showPrevBtn: !0,
        showNextBtn: !0,
        itemSize: 24,
        itemGap: 12,
        position: "left",
        playIcon: "path://M15 0C23.2843 0 30 6.71573 30 15C30 23.2843 23.2843 30 15 30C6.71573 30 0 23.2843 0 15C0 6.71573 6.71573 0 15 0ZM15 3C8.37258 3 3 8.37258 3 15C3 21.6274 8.37258 27 15 27C21.6274 27 27 21.6274 27 15C27 8.37258 21.6274 3 15 3ZM11.5 10.6699C11.5 9.90014 12.3333 9.41887 13 9.80371L20.5 14.1338C21.1667 14.5187 21.1667 15.4813 20.5 15.8662L13 20.1963C12.3333 20.5811 11.5 20.0999 11.5 19.3301V10.6699Z",
        stopIcon: "path://M15 0C23.2843 0 30 6.71573 30 15C30 23.2843 23.2843 30 15 30C6.71573 30 0 23.2843 0 15C0 6.71573 6.71573 0 15 0ZM15 3C8.37258 3 3 8.37258 3 15C3 21.6274 8.37258 27 15 27C21.6274 27 27 21.6274 27 15C27 8.37258 21.6274 3 15 3ZM11.5 10C12.3284 10 13 10.6716 13 11.5V18.5C13 19.3284 12.3284 20 11.5 20C10.6716 20 10 19.3284 10 18.5V11.5C10 10.6716 10.6716 10 11.5 10ZM18.5 10C19.3284 10 20 10.6716 20 11.5V18.5C20 19.3284 19.3284 20 18.5 20C17.6716 20 17 19.3284 17 18.5V11.5C17 10.6716 17.6716 10 18.5 10Z",
        // eslint-disable-next-line max-len
        nextIcon: "path://M0.838834 18.7383C0.253048 18.1525 0.253048 17.2028 0.838834 16.617L7.55635 9.89949L0.838834 3.18198C0.253048 2.59619 0.253048 1.64645 0.838834 1.06066C1.42462 0.474874 2.37437 0.474874 2.96015 1.06066L10.7383 8.83883L10.8412 8.95277C11.2897 9.50267 11.2897 10.2963 10.8412 10.8462L10.7383 10.9602L2.96015 18.7383C2.37437 19.3241 1.42462 19.3241 0.838834 18.7383Z",
        // eslint-disable-next-line max-len
        prevIcon: "path://M10.9602 1.06066C11.5459 1.64645 11.5459 2.59619 10.9602 3.18198L4.24264 9.89949L10.9602 16.617C11.5459 17.2028 11.5459 18.1525 10.9602 18.7383C10.3744 19.3241 9.42462 19.3241 8.83883 18.7383L1.06066 10.9602L0.957771 10.8462C0.509245 10.2963 0.509245 9.50267 0.957771 8.95277L1.06066 8.83883L8.83883 1.06066C9.42462 0.474874 10.3744 0.474874 10.9602 1.06066Z",
        prevBtnSize: 18,
        nextBtnSize: 18,
        color: Y.color.accent50,
        borderColor: Y.color.accent50,
        borderWidth: 0
      },
      emphasis: {
        label: {
          show: !0,
          // TEXTSTYLE
          color: Y.color.accent60
        },
        itemStyle: {
          color: Y.color.accent60,
          borderColor: Y.color.accent60
        },
        controlStyle: {
          color: Y.color.accent70,
          borderColor: Y.color.accent70
        }
      },
      progress: {
        lineStyle: {
          color: Y.color.accent30
        },
        itemStyle: {
          color: Y.color.accent40
        }
      },
      data: []
    }), t;
  }(uR)
);
hr(NV, fm.prototype);
var Jot = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.type = "timeline", t;
  }(Ue)
), Qot = (
  /** @class */
  function(r) {
    W(t, r);
    function t(e, n, i, a) {
      var o = r.call(this, e, n, i) || this;
      return o.type = a || "value", o;
    }
    return t.prototype.getLabelModel = function() {
      return this.model.getModel("label");
    }, t.prototype.isHorizontal = function() {
      return this.model.get("orient") === "horizontal";
    }, t;
  }(Ai)
), E_ = Math.PI, cR = ee(), tst = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function(e, n) {
      this.api = n;
    }, t.prototype.render = function(e, n, i) {
      if (this.model = e, this.api = i, this.ecModel = n, this.group.removeAll(), e.get("show", !0)) {
        var a = this._layout(e, i), o = this._createGroup("_mainGroup"), s = this._createGroup("_labelGroup"), l = this._axis = this._createAxis(a, e);
        e.formatTooltip = function(u) {
          var c = l.scale.getLabel({
            value: u
          });
          return cr("nameValue", {
            noName: !0,
            value: c
          });
        }, L(["AxisLine", "AxisTick", "Control", "CurrentPointer"], function(u) {
          this["_render" + u](a, o, l, e);
        }, this), this._renderAxisLabel(a, s, l, e), this._position(a, e);
      }
      this._doPlayStop(), this._updateTicksStatus();
    }, t.prototype.remove = function() {
      this._clearTimer(), this.group.removeAll();
    }, t.prototype.dispose = function() {
      this._clearTimer();
    }, t.prototype._layout = function(e, n) {
      var i = e.get(["label", "position"]), a = e.get("orient"), o = rst(e, n), s;
      i == null || i === "auto" ? s = a === "horizontal" ? o.y + o.height / 2 < n.getHeight() / 2 ? "-" : "+" : o.x + o.width / 2 < n.getWidth() / 2 ? "+" : "-" : pt(i) ? s = {
        horizontal: {
          top: "-",
          bottom: "+"
        },
        vertical: {
          left: "-",
          right: "+"
        }
      }[a][i] : s = i;
      var l = {
        horizontal: "center",
        vertical: s >= 0 || s === "+" ? "left" : "right"
      }, u = {
        horizontal: s >= 0 || s === "+" ? "top" : "bottom",
        vertical: "middle"
      }, c = {
        horizontal: 0,
        vertical: E_ / 2
      }, f = a === "vertical" ? o.height : o.width, h = e.getModel("controlStyle"), d = h.get("show", !0), p = d ? h.get("itemSize") : 0, g = d ? h.get("itemGap") : 0, v = p + g, m = e.get(["label", "rotate"]) || 0;
      m = m * E_ / 180;
      var y, _, x, b = h.get("position", !0), S = d && h.get("showPlayBtn", !0), w = d && h.get("showPrevBtn", !0), A = d && h.get("showNextBtn", !0), T = 0, M = f;
      b === "left" || b === "bottom" ? (S && (y = [0, 0], T += v), w && (_ = [T, 0], T += v), A && (x = [M - p, 0], M -= v)) : (S && (y = [M - p, 0], M -= v), w && (_ = [0, 0], T += v), A && (x = [M - p, 0], M -= v));
      var E = [T, M];
      return e.get("inverse") && E.reverse(), {
        viewRect: o,
        mainLength: f,
        orient: a,
        rotation: c[a],
        labelRotation: m,
        labelPosOpt: s,
        labelAlign: e.get(["label", "align"]) || l[a],
        labelBaseline: e.get(["label", "verticalAlign"]) || e.get(["label", "baseline"]) || u[a],
        // Based on mainGroup.
        playPosition: y,
        prevBtnPosition: _,
        nextBtnPosition: x,
        axisExtent: E,
        controlSize: p,
        controlGap: g
      };
    }, t.prototype._position = function(e, n) {
      var i = this._mainGroup, a = this._labelGroup, o = e.viewRect;
      if (e.orient === "vertical") {
        var s = kr(), l = o.x, u = o.y + o.height;
        ra(s, s, [-l, -u]), qo(s, s, -E_ / 2), ra(s, s, [l, u]), o = o.clone(), o.applyTransform(s);
      }
      var c = y(o), f = y(i.getBoundingRect()), h = y(a.getBoundingRect()), d = [i.x, i.y], p = [a.x, a.y];
      p[0] = d[0] = c[0][0];
      var g = e.labelPosOpt;
      if (g == null || pt(g)) {
        var v = g === "+" ? 0 : 1;
        _(d, f, c, 1, v), _(p, h, c, 1, 1 - v);
      } else {
        var v = g >= 0 ? 0 : 1;
        _(d, f, c, 1, v), p[1] = d[1] + g;
      }
      i.setPosition(d), a.setPosition(p), i.rotation = a.rotation = e.rotation, m(i), m(a);
      function m(x) {
        x.originX = c[0][0] - x.x, x.originY = c[1][0] - x.y;
      }
      function y(x) {
        return [[x.x, x.x + x.width], [x.y, x.y + x.height]];
      }
      function _(x, b, S, w, A) {
        x[w] += S[w][A] - b[w][A];
      }
    }, t.prototype._createAxis = function(e, n) {
      var i = n.getData(), a = n.get("axisType"), o = est(n, a);
      o.getTicks = function() {
        return i.mapArray(["value"], function(u) {
          return {
            value: u
          };
        });
      };
      var s = i.getDataExtent("value");
      o.setExtent(s[0], s[1]), o.calcNiceTicks();
      var l = new Qot("value", o, e.axisExtent, a);
      return l.model = n, l;
    }, t.prototype._createGroup = function(e) {
      var n = this[e] = new Et();
      return this.group.add(n), n;
    }, t.prototype._renderAxisLine = function(e, n, i, a) {
      var o = i.getExtent();
      if (a.get(["lineStyle", "show"])) {
        var s = new sr({
          shape: {
            x1: o[0],
            y1: 0,
            x2: o[1],
            y2: 0
          },
          style: J({
            lineCap: "round"
          }, a.getModel("lineStyle").getLineStyle()),
          silent: !0,
          z2: 1
        });
        n.add(s);
        var l = this._progressLine = new sr({
          shape: {
            x1: o[0],
            x2: this._currentPointer ? this._currentPointer.x : o[0],
            y1: 0,
            y2: 0
          },
          style: kt({
            lineCap: "round",
            lineWidth: s.style.lineWidth
          }, a.getModel(["progress", "lineStyle"]).getLineStyle()),
          silent: !0,
          z2: 1
        });
        n.add(l);
      }
    }, t.prototype._renderAxisTick = function(e, n, i, a) {
      var o = this, s = a.getData(), l = i.scale.getTicks();
      this._tickSymbols = [], L(l, function(u) {
        var c = i.dataToCoord(u.value), f = s.getItemModel(u.value), h = f.getModel("itemStyle"), d = f.getModel(["emphasis", "itemStyle"]), p = f.getModel(["progress", "itemStyle"]), g = {
          x: c,
          y: 0,
          onclick: mt(o._changeTimeline, o, u.value)
        }, v = fR(f, h, n, g);
        v.ensureState("emphasis").style = d.getItemStyle(), v.ensureState("progress").style = p.getItemStyle(), al(v);
        var m = zt(v);
        f.get("tooltip") ? (m.dataIndex = u.value, m.dataModel = a) : m.dataIndex = m.dataModel = null, o._tickSymbols.push(v);
      });
    }, t.prototype._renderAxisLabel = function(e, n, i, a) {
      var o = this, s = i.getLabelModel();
      if (s.get("show")) {
        var l = a.getData(), u = i.getViewLabels();
        this._tickLabels = [], L(u, function(c) {
          var f = c.tickValue, h = l.getItemModel(f), d = h.getModel("label"), p = h.getModel(["emphasis", "label"]), g = h.getModel(["progress", "label"]), v = i.dataToCoord(c.tickValue), m = new pe({
            x: v,
            y: 0,
            rotation: e.labelRotation - e.rotation,
            onclick: mt(o._changeTimeline, o, f),
            silent: !1,
            style: Oe(d, {
              text: c.formattedLabel,
              align: e.labelAlign,
              verticalAlign: e.labelBaseline
            })
          });
          m.ensureState("emphasis").style = Oe(p), m.ensureState("progress").style = Oe(g), n.add(m), al(m), cR(m).dataIndex = f, o._tickLabels.push(m);
        });
      }
    }, t.prototype._renderControl = function(e, n, i, a) {
      var o = e.controlSize, s = e.rotation, l = a.getModel("controlStyle").getItemStyle(), u = a.getModel(["emphasis", "controlStyle"]).getItemStyle(), c = a.getPlayState(), f = a.get("inverse", !0);
      h(e.nextBtnPosition, "next", mt(this._changeTimeline, this, f ? "-" : "+")), h(e.prevBtnPosition, "prev", mt(this._changeTimeline, this, f ? "+" : "-")), h(e.playPosition, c ? "stop" : "play", mt(this._handlePlayClick, this, !c), !0);
      function h(d, p, g, v) {
        if (d) {
          var m = bi(bt(a.get(["controlStyle", p + "BtnSize"]), o), o), y = [0, -m / 2, m, m], _ = nst(a, p + "Icon", y, {
            x: d[0],
            y: d[1],
            originX: o / 2,
            originY: 0,
            rotation: v ? -s : 0,
            rectHover: !0,
            style: l,
            onclick: g
          });
          _.ensureState("emphasis").style = u, n.add(_), al(_);
        }
      }
    }, t.prototype._renderCurrentPointer = function(e, n, i, a) {
      var o = a.getData(), s = a.getCurrentIndex(), l = o.getItemModel(s).getModel("checkpointStyle"), u = this, c = {
        onCreate: function(f) {
          f.draggable = !0, f.drift = mt(u._handlePointerDrag, u), f.ondragend = mt(u._handlePointerDragend, u), hR(f, u._progressLine, s, i, a, !0);
        },
        onUpdate: function(f) {
          hR(f, u._progressLine, s, i, a);
        }
      };
      this._currentPointer = fR(l, l, this._mainGroup, {}, this._currentPointer, c);
    }, t.prototype._handlePlayClick = function(e) {
      this._clearTimer(), this.api.dispatchAction({
        type: "timelinePlayChange",
        playState: e,
        from: this.uid
      });
    }, t.prototype._handlePointerDrag = function(e, n, i) {
      this._clearTimer(), this._pointerChangeTimeline([i.offsetX, i.offsetY]);
    }, t.prototype._handlePointerDragend = function(e) {
      this._pointerChangeTimeline([e.offsetX, e.offsetY], !0);
    }, t.prototype._pointerChangeTimeline = function(e, n) {
      var i = this._toAxisCoord(e)[0], a = this._axis, o = ei(a.getExtent().slice());
      i > o[1] && (i = o[1]), i < o[0] && (i = o[0]), this._currentPointer.x = i, this._currentPointer.markRedraw();
      var s = this._progressLine;
      s && (s.shape.x2 = i, s.dirty());
      var l = this._findNearestTick(i), u = this.model;
      (n || l !== u.getCurrentIndex() && u.get("realtime")) && this._changeTimeline(l);
    }, t.prototype._doPlayStop = function() {
      var e = this;
      this._clearTimer(), this.model.getPlayState() && (this._timer = setTimeout(function() {
        var n = e.model;
        e._changeTimeline(n.getCurrentIndex() + (n.get("rewind", !0) ? -1 : 1));
      }, this.model.get("playInterval")));
    }, t.prototype._toAxisCoord = function(e) {
      var n = this._mainGroup.getLocalTransform();
      return yi(e, n, !0);
    }, t.prototype._findNearestTick = function(e) {
      var n = this.model.getData(), i = 1 / 0, a, o = this._axis;
      return n.each(["value"], function(s, l) {
        var u = o.dataToCoord(s), c = Math.abs(u - e);
        c < i && (i = c, a = l);
      }), a;
    }, t.prototype._clearTimer = function() {
      this._timer && (clearTimeout(this._timer), this._timer = null);
    }, t.prototype._changeTimeline = function(e) {
      var n = this.model.getCurrentIndex();
      e === "+" ? e = n + 1 : e === "-" && (e = n - 1), this.api.dispatchAction({
        type: "timelineChange",
        currentIndex: e,
        from: this.uid
      });
    }, t.prototype._updateTicksStatus = function() {
      var e = this.model.getCurrentIndex(), n = this._tickSymbols, i = this._tickLabels;
      if (n)
        for (var a = 0; a < n.length; a++)
          n && n[a] && n[a].toggleState("progress", a < e);
      if (i)
        for (var a = 0; a < i.length; a++)
          i && i[a] && i[a].toggleState("progress", cR(i[a]).dataIndex <= e);
    }, t.type = "timeline.slider", t;
  }(Jot)
);
function est(r, t) {
  if (t = t || r.get("type"), t)
    switch (t) {
      case "category":
        return new oc({
          ordinalMeta: r.getCategories(),
          extent: [1 / 0, -1 / 0]
        });
      case "time":
        return new xb({
          locale: r.ecModel.getLocaleModel(),
          useUTC: r.ecModel.get("useUTC")
        });
      default:
        return new Ya();
    }
}
function rst(r, t) {
  return He(r.getBoxLayoutParams(), xr(r, t).refContainer, r.get("padding"));
}
function nst(r, t, e, n) {
  var i = n.style, a = Vh(r.get(["controlStyle", t]), n || {}, new Bt(e[0], e[1], e[2], e[3]));
  return i && a.setStyle(i), a;
}
function fR(r, t, e, n, i, a) {
  var o = t.get("color");
  if (i)
    i.setColor(o), e.add(i), a && a.onUpdate(i);
  else {
    var s = r.get("symbol");
    i = fr(s, -1, -1, 2, 2, o), i.setStyle("strokeNoScale", !0), e.add(i), a && a.onCreate(i);
  }
  var l = t.getItemStyle(["color"]);
  i.setStyle(l), n = qt({
    rectHover: !0,
    z2: 100
  }, n, !0);
  var u = Lc(r.get("symbolSize"));
  n.scaleX = u[0] / 2, n.scaleY = u[1] / 2;
  var c = Dl(r.get("symbolOffset"), u);
  c && (n.x = (n.x || 0) + c[0], n.y = (n.y || 0) + c[1]);
  var f = r.get("symbolRotate");
  return n.rotation = (f || 0) * Math.PI / 180 || 0, i.attr(n), i.updateTransform(), i;
}
function hR(r, t, e, n, i, a) {
  if (!r.dragging) {
    var o = i.getModel("checkpointStyle"), s = n.dataToCoord(i.getData().get("value", e));
    if (a || !o.get("animation", !0))
      r.attr({
        x: s,
        y: 0
      }), t && t.attr({
        shape: {
          x2: s
        }
      });
    else {
      var l = {
        duration: o.get("animationDuration", !0),
        easing: o.get("animationEasing", !0)
      };
      r.stopAnimation(null, !0), r.animateTo({
        x: s,
        y: 0
      }, l), t && t.animateTo({
        shape: {
          x2: s
        }
      }, l);
    }
  }
}
function ist(r) {
  r.registerAction({
    type: "timelineChange",
    event: "timelineChanged",
    update: "prepareAndUpdate"
  }, function(t, e, n) {
    var i = e.getComponent("timeline");
    return i && t.currentIndex != null && (i.setCurrentIndex(t.currentIndex), !i.get("loop", !0) && i.isIndexMax() && i.getPlayState() && (i.setPlayState(!1), n.dispatchAction({
      type: "timelinePlayChange",
      playState: !1,
      from: t.from
    }))), e.resetOption("timeline", {
      replaceMerge: i.get("replaceMerge", !0)
    }), kt({
      currentIndex: i.option.currentIndex
    }, t);
  }), r.registerAction({
    type: "timelinePlayChange",
    event: "timelinePlayChanged",
    update: "update"
  }, function(t, e) {
    var n = e.getComponent("timeline");
    n && t.playState != null && n.setPlayState(t.playState);
  });
}
function ast(r) {
  var t = r && r.timeline;
  et(t) || (t = t ? [t] : []), L(t, function(e) {
    e && ost(e);
  });
}
function ost(r) {
  var t = r.type, e = {
    number: "value",
    time: "time"
  };
  if (e[t] && (r.axisType = e[t], delete r.type), dR(r), Xs(r, "controlPosition")) {
    var n = r.controlStyle || (r.controlStyle = {});
    Xs(n, "position") || (n.position = r.controlPosition), n.position === "none" && !Xs(n, "show") && (n.show = !1, delete n.position), delete r.controlPosition;
  }
  L(r.data || [], function(i) {
    Dt(i) && !et(i) && (!Xs(i, "value") && Xs(i, "name") && (i.value = i.name), dR(i));
  });
}
function dR(r) {
  var t = r.itemStyle || (r.itemStyle = {}), e = t.emphasis || (t.emphasis = {}), n = r.label || r.label || {}, i = n.normal || (n.normal = {}), a = {
    normal: 1,
    emphasis: 1
  };
  L(n, function(o, s) {
    !a[s] && !Xs(i, s) && (i[s] = o);
  }), e.label && !Xs(n, "emphasis") && (n.emphasis = e.label, delete e.label);
}
function Xs(r, t) {
  return r.hasOwnProperty(t);
}
function sst(r) {
  r.registerComponentModel(NV), r.registerComponentView(tst), r.registerSubTypeDefaulter("timeline", function() {
    return "slider";
  }), ist(r), r.registerPreprocessor(ast);
}
function Cw(r, t) {
  if (!r)
    return !1;
  for (var e = et(r) ? r : [r], n = 0; n < e.length; n++)
    if (e[n] && e[n][t])
      return !0;
  return !1;
}
function Lp(r) {
  hl(r, "label", ["show"]);
}
var Rp = ee(), la = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.createdBySelf = !1, e.preventAutoZ = !0, e;
    }
    return t.prototype.init = function(e, n, i) {
      if (process.env.NODE_ENV !== "production" && this.type === "marker")
        throw new Error("Marker component is abstract component. Use markLine, markPoint, markArea instead.");
      this.mergeDefaultAndTheme(e, i), this._mergeOption(e, i, !1, !0);
    }, t.prototype.isAnimationEnabled = function() {
      if (oe.node)
        return !1;
      var e = this.__hostSeries;
      return this.getShallow("animation") && e && e.isAnimationEnabled();
    }, t.prototype.mergeOption = function(e, n) {
      this._mergeOption(e, n, !1, !1);
    }, t.prototype._mergeOption = function(e, n, i, a) {
      var o = this.mainType;
      i || n.eachSeries(function(s) {
        var l = s.get(this.mainType, !0), u = Rp(s)[o];
        if (!l || !l.data) {
          Rp(s)[o] = null;
          return;
        }
        u ? u._mergeOption(l, n, !0) : (a && Lp(l), L(l.data, function(c) {
          c instanceof Array ? (Lp(c[0]), Lp(c[1])) : Lp(c);
        }), u = this.createMarkerModelFromSeries(l, this, n), J(u, {
          mainType: this.mainType,
          // Use the same series index and name
          seriesIndex: s.seriesIndex,
          name: s.name,
          createdBySelf: !0
        }), u.__hostSeries = s), Rp(s)[o] = u;
      }, this);
    }, t.prototype.formatTooltip = function(e, n, i) {
      var a = this.getData(), o = this.getRawValue(e), s = a.getName(e);
      return cr("section", {
        header: this.name,
        blocks: [cr("nameValue", {
          name: s,
          value: o,
          noName: !s,
          noValue: o == null
        })]
      });
    }, t.prototype.getData = function() {
      return this._data;
    }, t.prototype.setData = function(e) {
      this._data = e;
    }, t.prototype.getDataParams = function(e, n) {
      var i = fm.prototype.getDataParams.call(this, e, n), a = this.__hostSeries;
      return a && (i.seriesId = a.id, i.seriesName = a.name, i.seriesType = a.subType), i;
    }, t.getMarkerModelFromSeries = function(e, n) {
      return Rp(e)[n];
    }, t.type = "marker", t.dependencies = ["series", "grid", "polar", "geo"], t;
  }(re)
);
hr(la, fm.prototype);
var lst = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.createMarkerModelFromSeries = function(e, n, i) {
      return new t(e, n, i);
    }, t.type = "markPoint", t.defaultOption = {
      // zlevel: 0,
      z: 5,
      symbol: "pin",
      symbolSize: 50,
      // symbolRotate: 0,
      // symbolOffset: [0, 0]
      tooltip: {
        trigger: "item"
      },
      label: {
        show: !0,
        position: "inside"
      },
      itemStyle: {
        borderWidth: 2
      },
      emphasis: {
        label: {
          show: !0
        }
      }
    }, t;
  }(la)
);
function jS(r) {
  return !(isNaN(parseFloat(r.x)) && isNaN(parseFloat(r.y)));
}
function ust(r) {
  return !isNaN(parseFloat(r.x)) && !isNaN(parseFloat(r.y));
}
function Ip(r, t, e, n, i, a, o) {
  var s = [], l = Ho(
    t,
    i
    /* , otherDataDim */
  ), u = l ? t.getCalculationInfo("stackResultDimension") : i, c = bg(t, u, r), f = t.hostModel, h = f.indicesOfNearest(e, u, c)[0];
  s[a] = t.get(n, h), s[o] = t.get(u, h);
  var d = t.get(i, h), p = Yi(t.get(i, h));
  return p = Math.min(p, 20), p >= 0 && (s[o] = +s[o].toFixed(p)), [s, d];
}
var Pp = {
  min: Yt(Ip, "min"),
  max: Yt(Ip, "max"),
  average: Yt(Ip, "average"),
  median: Yt(Ip, "median")
};
function Ah(r, t) {
  if (t) {
    var e = r.getData(), n = r.coordinateSystem, i = n && n.dimensions;
    if (!ust(t) && !et(t.coord) && et(i)) {
      var a = OV(t, e, n, r);
      if (t = Ct(t), t.type && Pp[t.type] && a.baseAxis && a.valueAxis) {
        var o = Zt(i, a.baseAxis.dim), s = Zt(i, a.valueAxis.dim), l = Pp[t.type](e, a.valueAxis.dim, a.baseDataDim, a.valueDataDim, o, s);
        t.coord = l[0], t.value = l[1];
      } else
        t.coord = [t.xAxis != null ? t.xAxis : t.radiusAxis, t.yAxis != null ? t.yAxis : t.angleAxis];
    }
    if (t.coord == null || !et(i)) {
      t.coord = [];
      var u = r.getBaseAxis();
      if (u && t.type && Pp[t.type]) {
        var c = n.getOtherAxis(u);
        c && (t.value = bg(e, e.mapDimension(c.dim), t.type));
      }
    } else
      for (var f = t.coord, h = 0; h < 2; h++)
        Pp[f[h]] && (f[h] = bg(e, e.mapDimension(i[h]), f[h]));
    return t;
  }
}
function OV(r, t, e, n) {
  var i = {};
  return r.valueIndex != null || r.valueDim != null ? (i.valueDataDim = r.valueIndex != null ? t.getDimension(r.valueIndex) : r.valueDim, i.valueAxis = e.getAxis(cst(n, i.valueDataDim)), i.baseAxis = e.getOtherAxis(i.valueAxis), i.baseDataDim = t.mapDimension(i.baseAxis.dim)) : (i.baseAxis = n.getBaseAxis(), i.valueAxis = e.getOtherAxis(i.baseAxis), i.baseDataDim = t.mapDimension(i.baseAxis.dim), i.valueDataDim = t.mapDimension(i.valueAxis.dim)), i;
}
function cst(r, t) {
  var e = r.getData().getDimensionInfo(t);
  return e && e.coordDim;
}
function Eh(r, t) {
  return r && r.containData && t.coord && !jS(t) ? r.containData(t.coord) : !0;
}
function fst(r, t, e) {
  return r && r.containZone && t.coord && e.coord && !jS(t) && !jS(e) ? r.containZone(t.coord, e.coord) : !0;
}
function kV(r, t) {
  return r ? function(e, n, i, a) {
    var o = a < 2 ? e.coord && e.coord[a] : e.value;
    return ko(o, t[a]);
  } : function(e, n, i, a) {
    return ko(e.value, t[a]);
  };
}
function bg(r, t, e) {
  if (e === "average") {
    var n = 0, i = 0;
    return r.each(t, function(a, o) {
      isNaN(a) || (n += a, i++);
    }), n / i;
  } else
    return e === "median" ? r.getMedian(t) : r.getDataExtent(t)[e === "max" ? 1 : 0];
}
var C_ = ee(), Dw = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.init = function() {
      this.markerGroupMap = wt();
    }, t.prototype.render = function(e, n, i) {
      var a = this, o = this.markerGroupMap;
      o.each(function(s) {
        C_(s).keep = !1;
      }), n.eachSeries(function(s) {
        var l = la.getMarkerModelFromSeries(s, a.type);
        l && a.renderSeries(s, l, n, i);
      }), o.each(function(s) {
        !C_(s).keep && a.group.remove(s.group);
      }), hst(n, o, this.type);
    }, t.prototype.markKeep = function(e) {
      C_(e).keep = !0;
    }, t.prototype.toggleBlurSeries = function(e, n) {
      var i = this;
      L(e, function(a) {
        var o = la.getMarkerModelFromSeries(a, i.type);
        if (o) {
          var s = o.getData();
          s.eachItemGraphicEl(function(l) {
            l && (n ? tN(l) : V1(l));
          });
        }
      });
    }, t.type = "marker", t;
  }(Ue)
);
function hst(r, t, e) {
  r.eachSeries(function(n) {
    var i = la.getMarkerModelFromSeries(n, e), a = t.get(n.id);
    if (i && a && a.group) {
      var o = ml(i), s = o.z, l = o.zlevel;
      om(a.group, s, l);
    }
  });
}
function pR(r, t, e) {
  var n = t.coordinateSystem, i = e.getWidth(), a = e.getHeight(), o = n && n.getArea && n.getArea();
  r.each(function(s) {
    var l = r.getItemModel(s), u = l.get("relativeTo") === "coordinate", c = u ? o ? o.width : 0 : i, f = u ? o ? o.height : 0 : a, h = u && o ? o.x : 0, d = u && o ? o.y : 0, p, g = dt(l.get("x"), c) + h, v = dt(l.get("y"), f) + d;
    if (!isNaN(g) && !isNaN(v))
      p = [g, v];
    else if (t.getMarkerPosition)
      p = t.getMarkerPosition(r.getValues(r.dimensions, s));
    else if (n) {
      var m = r.get(n.dimensions[0], s), y = r.get(n.dimensions[1], s);
      p = n.dataToPoint([m, y]);
    }
    isNaN(g) || (p[0] = g), isNaN(v) || (p[1] = v), r.setItemLayout(s, p);
  });
}
var dst = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.updateTransform = function(e, n, i) {
      n.eachSeries(function(a) {
        var o = la.getMarkerModelFromSeries(a, "markPoint");
        o && (pR(o.getData(), a, i), this.markerGroupMap.get(a.id).updateLayout());
      }, this);
    }, t.prototype.renderSeries = function(e, n, i, a) {
      var o = e.coordinateSystem, s = e.id, l = e.getData(), u = this.markerGroupMap, c = u.get(s) || u.set(s, new Xh()), f = pst(o, e, n);
      n.setData(f), pR(n.getData(), e, a), f.each(function(h) {
        var d = f.getItemModel(h), p = d.getShallow("symbol"), g = d.getShallow("symbolSize"), v = d.getShallow("symbolRotate"), m = d.getShallow("symbolOffset"), y = d.getShallow("symbolKeepAspect");
        if (Tt(p) || Tt(g) || Tt(v) || Tt(m)) {
          var _ = n.getRawValue(h), x = n.getDataParams(h);
          Tt(p) && (p = p(_, x)), Tt(g) && (g = g(_, x)), Tt(v) && (v = v(_, x)), Tt(m) && (m = m(_, x));
        }
        var b = d.getModel("itemStyle").getItemStyle(), S = d.get("z2"), w = Uh(l, "color");
        b.fill || (b.fill = w), f.setItemVisual(h, {
          z2: bt(S, 0),
          symbol: p,
          symbolSize: g,
          symbolRotate: v,
          symbolOffset: m,
          symbolKeepAspect: y,
          style: b
        });
      }), c.updateData(f), this.group.add(c.group), f.eachItemGraphicEl(function(h) {
        h.traverse(function(d) {
          zt(d).dataModel = n;
        });
      }), this.markKeep(c), c.group.silent = n.get("silent") || e.get("silent");
    }, t.type = "markPoint", t;
  }(Dw)
);
function pst(r, t, e) {
  var n;
  r ? n = rt(r && r.dimensions, function(s) {
    var l = t.getData().getDimensionInfo(t.getData().mapDimension(s)) || {};
    return J(J({}, l), {
      name: s,
      // DON'T use ordinalMeta to parse and collect ordinal.
      ordinalMeta: null
    });
  }) : n = [{
    name: "value",
    type: "float"
  }];
  var i = new un(n, e), a = rt(e.get("data"), Yt(Ah, t));
  r && (a = Te(a, Yt(Eh, r)));
  var o = kV(!!r, n);
  return i.initData(a, null, o), i;
}
function vst(r) {
  r.registerComponentModel(lst), r.registerComponentView(dst), r.registerPreprocessor(function(t) {
    Cw(t.series, "markPoint") && (t.markPoint = t.markPoint || {});
  });
}
var gst = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.createMarkerModelFromSeries = function(e, n, i) {
      return new t(e, n, i);
    }, t.type = "markLine", t.defaultOption = {
      // zlevel: 0,
      z: 5,
      symbol: ["circle", "arrow"],
      symbolSize: [8, 16],
      // symbolRotate: 0,
      symbolOffset: 0,
      precision: 2,
      tooltip: {
        trigger: "item"
      },
      label: {
        show: !0,
        position: "end",
        distance: 5
      },
      lineStyle: {
        type: "dashed"
      },
      emphasis: {
        label: {
          show: !0
        },
        lineStyle: {
          width: 3
        }
      },
      animationEasing: "linear"
    }, t;
  }(la)
), Np = ee(), mst = function(r, t, e, n) {
  var i = r.getData(), a;
  if (et(n))
    a = n;
  else {
    var o = n.type;
    if (o === "min" || o === "max" || o === "average" || o === "median" || n.xAxis != null || n.yAxis != null) {
      var s = void 0, l = void 0;
      if (n.yAxis != null || n.xAxis != null)
        s = t.getAxis(n.yAxis != null ? "y" : "x"), l = gr(n.yAxis, n.xAxis);
      else {
        var u = OV(n, i, t, r);
        s = u.valueAxis;
        var c = lk(i, u.valueDataDim);
        l = bg(i, c, o);
      }
      var f = s.dim === "x" ? 0 : 1, h = 1 - f, d = Ct(n), p = {
        coord: []
      };
      d.type = null, d.coord = [], d.coord[h] = -1 / 0, p.coord[h] = 1 / 0;
      var g = e.get("precision");
      g >= 0 && fe(l) && (l = +l.toFixed(Math.min(g, 20))), d.coord[f] = p.coord[f] = l, a = [d, p, {
        type: o,
        valueIndex: n.valueIndex,
        // Force to use the value of calculated value.
        value: l
      }];
    } else
      process.env.NODE_ENV !== "production" && gi("Invalid markLine data."), a = [];
  }
  var v = [Ah(r, a[0]), Ah(r, a[1]), J({}, a[2])];
  return v[2].type = v[2].type || null, qt(v[2], v[0]), qt(v[2], v[1]), v;
};
function wg(r) {
  return !isNaN(r) && !isFinite(r);
}
function vR(r, t, e, n) {
  var i = 1 - r, a = n.dimensions[r];
  return wg(t[i]) && wg(e[i]) && t[r] === e[r] && n.getAxis(a).containData(t[r]);
}
function yst(r, t) {
  if (r.type === "cartesian2d") {
    var e = t[0].coord, n = t[1].coord;
    if (e && n && (vR(1, e, n, r) || vR(0, e, n, r)))
      return !0;
  }
  return Eh(r, t[0]) && Eh(r, t[1]);
}
function D_(r, t, e, n, i) {
  var a = n.coordinateSystem, o = r.getItemModel(t), s, l = dt(o.get("x"), i.getWidth()), u = dt(o.get("y"), i.getHeight());
  if (!isNaN(l) && !isNaN(u))
    s = [l, u];
  else {
    if (n.getMarkerPosition)
      s = n.getMarkerPosition(r.getValues(r.dimensions, t));
    else {
      var c = a.dimensions, f = r.get(c[0], t), h = r.get(c[1], t);
      s = a.dataToPoint([f, h]);
    }
    if (Wo(a, "cartesian2d")) {
      var d = a.getAxis("x"), p = a.getAxis("y"), c = a.dimensions;
      wg(r.get(c[0], t)) ? s[0] = d.toGlobalCoord(d.getExtent()[e ? 0 : 1]) : wg(r.get(c[1], t)) && (s[1] = p.toGlobalCoord(p.getExtent()[e ? 0 : 1]));
    }
    isNaN(l) || (s[0] = l), isNaN(u) || (s[1] = u);
  }
  r.setItemLayout(t, s);
}
var _st = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.updateTransform = function(e, n, i) {
      n.eachSeries(function(a) {
        var o = la.getMarkerModelFromSeries(a, "markLine");
        if (o) {
          var s = o.getData(), l = Np(o).from, u = Np(o).to;
          l.each(function(c) {
            D_(l, c, !0, a, i), D_(u, c, !1, a, i);
          }), s.each(function(c) {
            s.setItemLayout(c, [l.getItemLayout(c), u.getItemLayout(c)]);
          }), this.markerGroupMap.get(a.id).updateLayout();
        }
      }, this);
    }, t.prototype.renderSeries = function(e, n, i, a) {
      var o = e.coordinateSystem, s = e.id, l = e.getData(), u = this.markerGroupMap, c = u.get(s) || u.set(s, new Zb());
      this.group.add(c.group);
      var f = xst(o, e, n), h = f.from, d = f.to, p = f.line;
      Np(n).from = h, Np(n).to = d, n.setData(p);
      var g = n.get("symbol"), v = n.get("symbolSize"), m = n.get("symbolRotate"), y = n.get("symbolOffset");
      et(g) || (g = [g, g]), et(v) || (v = [v, v]), et(m) || (m = [m, m]), et(y) || (y = [y, y]), f.from.each(function(x) {
        _(h, x, !0), _(d, x, !1);
      }), p.each(function(x) {
        var b = p.getItemModel(x), S = b.getModel("lineStyle").getLineStyle();
        p.setItemLayout(x, [h.getItemLayout(x), d.getItemLayout(x)]);
        var w = b.get("z2");
        S.stroke == null && (S.stroke = h.getItemVisual(x, "style").fill), p.setItemVisual(x, {
          z2: bt(w, 0),
          fromSymbolKeepAspect: h.getItemVisual(x, "symbolKeepAspect"),
          fromSymbolOffset: h.getItemVisual(x, "symbolOffset"),
          fromSymbolRotate: h.getItemVisual(x, "symbolRotate"),
          fromSymbolSize: h.getItemVisual(x, "symbolSize"),
          fromSymbol: h.getItemVisual(x, "symbol"),
          toSymbolKeepAspect: d.getItemVisual(x, "symbolKeepAspect"),
          toSymbolOffset: d.getItemVisual(x, "symbolOffset"),
          toSymbolRotate: d.getItemVisual(x, "symbolRotate"),
          toSymbolSize: d.getItemVisual(x, "symbolSize"),
          toSymbol: d.getItemVisual(x, "symbol"),
          style: S
        });
      }), c.updateData(p), f.line.eachItemGraphicEl(function(x) {
        zt(x).dataModel = n, x.traverse(function(b) {
          zt(b).dataModel = n;
        });
      });
      function _(x, b, S) {
        var w = x.getItemModel(b);
        D_(x, b, S, e, a);
        var A = w.getModel("itemStyle").getItemStyle();
        A.fill == null && (A.fill = Uh(l, "color")), x.setItemVisual(b, {
          symbolKeepAspect: w.get("symbolKeepAspect"),
          // `0` should be considered as a valid value, so use `retrieve2` instead of `||`
          symbolOffset: bt(w.get("symbolOffset", !0), y[S ? 0 : 1]),
          symbolRotate: bt(w.get("symbolRotate", !0), m[S ? 0 : 1]),
          // TODO: when 2d array is supported, it should ignore parent
          symbolSize: bt(w.get("symbolSize"), v[S ? 0 : 1]),
          symbol: bt(w.get("symbol", !0), g[S ? 0 : 1]),
          style: A
        });
      }
      this.markKeep(c), c.group.silent = n.get("silent") || e.get("silent");
    }, t.type = "markLine", t;
  }(Dw)
);
function xst(r, t, e) {
  var n;
  r ? n = rt(r && r.dimensions, function(u) {
    var c = t.getData().getDimensionInfo(t.getData().mapDimension(u)) || {};
    return J(J({}, c), {
      name: u,
      // DON'T use ordinalMeta to parse and collect ordinal.
      ordinalMeta: null
    });
  }) : n = [{
    name: "value",
    type: "float"
  }];
  var i = new un(n, e), a = new un(n, e), o = new un([], e), s = rt(e.get("data"), Yt(mst, t, r, e));
  r && (s = Te(s, Yt(yst, r)));
  var l = kV(!!r, n);
  return i.initData(rt(s, function(u) {
    return u[0];
  }), null, l), a.initData(rt(s, function(u) {
    return u[1];
  }), null, l), o.initData(rt(s, function(u) {
    return u[2];
  })), o.hasItemOption = !0, {
    from: i,
    to: a,
    line: o
  };
}
function Sst(r) {
  r.registerComponentModel(gst), r.registerComponentView(_st), r.registerPreprocessor(function(t) {
    Cw(t.series, "markLine") && (t.markLine = t.markLine || {});
  });
}
var bst = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.createMarkerModelFromSeries = function(e, n, i) {
      return new t(e, n, i);
    }, t.type = "markArea", t.defaultOption = {
      // zlevel: 0,
      // PENDING
      z: 1,
      tooltip: {
        trigger: "item"
      },
      // markArea should fixed on the coordinate system
      animation: !1,
      label: {
        show: !0,
        position: "top"
      },
      itemStyle: {
        // color and borderColor default to use color from series
        // color: 'auto'
        // borderColor: 'auto'
        borderWidth: 0
      },
      emphasis: {
        label: {
          show: !0,
          position: "top"
        }
      }
    }, t;
  }(la)
), Op = ee(), wst = function(r, t, e, n) {
  var i = n[0], a = n[1];
  if (!(!i || !a)) {
    var o = Ah(r, i), s = Ah(r, a), l = o.coord, u = s.coord;
    l[0] = gr(l[0], -1 / 0), l[1] = gr(l[1], -1 / 0), u[0] = gr(u[0], 1 / 0), u[1] = gr(u[1], 1 / 0);
    var c = x1([{}, o, s]);
    return c.coord = [o.coord, s.coord], c.x0 = o.x, c.y0 = o.y, c.x1 = s.x, c.y1 = s.y, c;
  }
};
function Mg(r) {
  return !isNaN(r) && !isFinite(r);
}
function gR(r, t, e, n) {
  var i = 1 - r;
  return Mg(t[i]) && Mg(e[i]);
}
function Mst(r, t) {
  var e = t.coord[0], n = t.coord[1], i = {
    coord: e,
    x: t.x0,
    y: t.y0
  }, a = {
    coord: n,
    x: t.x1,
    y: t.y1
  };
  return Wo(r, "cartesian2d") ? e && n && (gR(1, e, n) || gR(0, e, n)) ? !0 : fst(r, i, a) : Eh(r, i) || Eh(r, a);
}
function mR(r, t, e, n, i) {
  var a = n.coordinateSystem, o = r.getItemModel(t), s, l = dt(o.get(e[0]), i.getWidth()), u = dt(o.get(e[1]), i.getHeight());
  if (!isNaN(l) && !isNaN(u))
    s = [l, u];
  else {
    if (n.getMarkerPosition) {
      var c = r.getValues(["x0", "y0"], t), f = r.getValues(["x1", "y1"], t), h = a.clampData(c), d = a.clampData(f), p = [];
      e[0] === "x0" ? p[0] = h[0] > d[0] ? f[0] : c[0] : p[0] = h[0] > d[0] ? c[0] : f[0], e[1] === "y0" ? p[1] = h[1] > d[1] ? f[1] : c[1] : p[1] = h[1] > d[1] ? c[1] : f[1], s = n.getMarkerPosition(p, e, !0);
    } else {
      var g = r.get(e[0], t), v = r.get(e[1], t), m = [g, v];
      a.clampData && a.clampData(m, m), s = a.dataToPoint(m, !0);
    }
    if (Wo(a, "cartesian2d")) {
      var y = a.getAxis("x"), _ = a.getAxis("y"), g = r.get(e[0], t), v = r.get(e[1], t);
      Mg(g) ? s[0] = y.toGlobalCoord(y.getExtent()[e[0] === "x0" ? 0 : 1]) : Mg(v) && (s[1] = _.toGlobalCoord(_.getExtent()[e[1] === "y0" ? 0 : 1]));
    }
    isNaN(l) || (s[0] = l), isNaN(u) || (s[1] = u);
  }
  return s;
}
var yR = [["x0", "y0"], ["x1", "y0"], ["x1", "y1"], ["x0", "y1"]], Tst = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.updateTransform = function(e, n, i) {
      n.eachSeries(function(a) {
        var o = la.getMarkerModelFromSeries(a, "markArea");
        if (o) {
          var s = o.getData();
          s.each(function(l) {
            var u = rt(yR, function(f) {
              return mR(s, l, f, a, i);
            });
            s.setItemLayout(l, u);
            var c = s.getItemGraphicEl(l);
            c.setShape("points", u);
          });
        }
      }, this);
    }, t.prototype.renderSeries = function(e, n, i, a) {
      var o = e.coordinateSystem, s = e.id, l = e.getData(), u = this.markerGroupMap, c = u.get(s) || u.set(s, {
        group: new Et()
      });
      this.group.add(c.group), this.markKeep(c);
      var f = Ast(o, e, n);
      n.setData(f), f.each(function(h) {
        var d = rt(yR, function(M) {
          return mR(f, h, M, e, a);
        }), p = o.getAxis("x").scale, g = o.getAxis("y").scale, v = p.getExtent(), m = g.getExtent(), y = [p.parse(f.get("x0", h)), p.parse(f.get("x1", h))], _ = [g.parse(f.get("y0", h)), g.parse(f.get("y1", h))];
        ei(y), ei(_);
        var x = !(v[0] > y[1] || v[1] < y[0] || m[0] > _[1] || m[1] < _[0]), b = !x;
        f.setItemLayout(h, {
          points: d,
          allClipped: b
        });
        var S = f.getItemModel(h), w = S.getModel("itemStyle").getItemStyle(), A = S.get("z2"), T = Uh(l, "color");
        w.fill || (w.fill = T, pt(w.fill) && (w.fill = wv(w.fill, 0.4))), w.stroke || (w.stroke = T), f.setItemVisual(h, "style", w), f.setItemVisual(h, "z2", bt(A, 0));
      }), f.diff(Op(c).data).add(function(h) {
        var d = f.getItemLayout(h), p = f.getItemVisual(h, "z2");
        if (!d.allClipped) {
          var g = new jr({
            z2: bt(p, 0),
            shape: {
              points: d.points
            }
          });
          f.setItemGraphicEl(h, g), c.group.add(g);
        }
      }).update(function(h, d) {
        var p = Op(c).data.getItemGraphicEl(d), g = f.getItemLayout(h), v = f.getItemVisual(h, "z2");
        g.allClipped ? p && c.group.remove(p) : (p ? ve(p, {
          z2: bt(v, 0),
          shape: {
            points: g.points
          }
        }, n, h) : p = new jr({
          shape: {
            points: g.points
          }
        }), f.setItemGraphicEl(h, p), c.group.add(p));
      }).remove(function(h) {
        var d = Op(c).data.getItemGraphicEl(h);
        c.group.remove(d);
      }).execute(), f.eachItemGraphicEl(function(h, d) {
        var p = f.getItemModel(d), g = f.getItemVisual(d, "style");
        h.useStyle(f.getItemVisual(d, "style")), Er(h, _r(p), {
          labelFetcher: n,
          labelDataIndex: d,
          defaultText: f.getName(d) || "",
          inheritColor: pt(g.fill) ? wv(g.fill, 1) : Y.color.neutral99
        }), yr(h, p), Ge(h, null, null, p.get(["emphasis", "disabled"])), zt(h).dataModel = n;
      }), Op(c).data = f, c.group.silent = n.get("silent") || e.get("silent");
    }, t.type = "markArea", t;
  }(Dw)
);
function Ast(r, t, e) {
  var n, i, a = ["x0", "y0", "x1", "y1"];
  if (r) {
    var o = rt(r && r.dimensions, function(u) {
      var c = t.getData(), f = c.getDimensionInfo(c.mapDimension(u)) || {};
      return J(J({}, f), {
        name: u,
        // DON'T use ordinalMeta to parse and collect ordinal.
        ordinalMeta: null
      });
    });
    i = rt(a, function(u, c) {
      return {
        name: u,
        type: o[c % 2].type
      };
    }), n = new un(i, e);
  } else
    i = [{
      name: "value",
      type: "float"
    }], n = new un(i, e);
  var s = rt(e.get("data"), Yt(wst, t, r, e));
  r && (s = Te(s, Yt(Mst, r)));
  var l = r ? function(u, c, f, h) {
    var d = u.coord[Math.floor(h / 2)][h % 2];
    return ko(d, i[h]);
  } : function(u, c, f, h) {
    return ko(u.value, i[h]);
  };
  return n.initData(s, null, l), n.hasItemOption = !0, n;
}
function Est(r) {
  r.registerComponentModel(bst), r.registerComponentView(Tst), r.registerPreprocessor(function(t) {
    Cw(t.series, "markArea") && (t.markArea = t.markArea || {});
  });
}
var Cst = function(r, t) {
  if (t === "all")
    return {
      type: "all",
      title: r.getLocaleModel().get(["legend", "selector", "all"])
    };
  if (t === "inverse")
    return {
      type: "inverse",
      title: r.getLocaleModel().get(["legend", "selector", "inverse"])
    };
}, JS = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.layoutMode = {
        type: "box",
        // legend.width/height are maxWidth/maxHeight actually,
        // whereas real width/height is calculated by its content.
        // (Setting {left: 10, right: 10} does not make sense).
        // So consider the case:
        // `setOption({legend: {left: 10});`
        // then `setOption({legend: {right: 10});`
        // The previous `left` should be cleared by setting `ignoreSize`.
        ignoreSize: !0
      }, e;
    }
    return t.prototype.init = function(e, n, i) {
      this.mergeDefaultAndTheme(e, i), e.selected = e.selected || {}, this._updateSelector(e);
    }, t.prototype.mergeOption = function(e, n) {
      r.prototype.mergeOption.call(this, e, n), this._updateSelector(e);
    }, t.prototype._updateSelector = function(e) {
      var n = e.selector, i = this.ecModel;
      n === !0 && (n = e.selector = ["all", "inverse"]), et(n) && L(n, function(a, o) {
        pt(a) && (a = {
          type: a
        }), n[o] = qt(a, Cst(i, a.type));
      });
    }, t.prototype.optionUpdated = function() {
      this._updateData(this.ecModel);
      var e = this._data;
      if (e[0] && this.get("selectedMode") === "single") {
        for (var n = !1, i = 0; i < e.length; i++) {
          var a = e[i].get("name");
          if (this.isSelected(a)) {
            this.select(a), n = !0;
            break;
          }
        }
        !n && this.select(e[0].get("name"));
      }
    }, t.prototype._updateData = function(e) {
      var n = [], i = [];
      e.eachRawSeries(function(l) {
        var u = l.name;
        i.push(u);
        var c;
        if (l.legendVisualProvider) {
          var f = l.legendVisualProvider, h = f.getAllNames();
          e.isSeriesFiltered(l) || (i = i.concat(h)), h.length ? n = n.concat(h) : c = !0;
        } else
          c = !0;
        c && D1(l) && n.push(l.name);
      }), this._availableNames = i;
      var a = this.get("data") || n, o = wt(), s = rt(a, function(l) {
        return (pt(l) || fe(l)) && (l = {
          name: l
        }), o.get(l.name) ? null : (o.set(l.name, !0), new ue(l, this, this.ecModel));
      }, this);
      this._data = Te(s, function(l) {
        return !!l;
      });
    }, t.prototype.getData = function() {
      return this._data;
    }, t.prototype.select = function(e) {
      var n = this.option.selected, i = this.get("selectedMode");
      if (i === "single") {
        var a = this._data;
        L(a, function(o) {
          n[o.get("name")] = !1;
        });
      }
      n[e] = !0;
    }, t.prototype.unSelect = function(e) {
      this.get("selectedMode") !== "single" && (this.option.selected[e] = !1);
    }, t.prototype.toggleSelected = function(e) {
      var n = this.option.selected;
      n.hasOwnProperty(e) || (n[e] = !0), this[n[e] ? "unSelect" : "select"](e);
    }, t.prototype.allSelect = function() {
      var e = this._data, n = this.option.selected;
      L(e, function(i) {
        n[i.get("name", !0)] = !0;
      });
    }, t.prototype.inverseSelect = function() {
      var e = this._data, n = this.option.selected;
      L(e, function(i) {
        var a = i.get("name", !0);
        n.hasOwnProperty(a) || (n[a] = !0), n[a] = !n[a];
      });
    }, t.prototype.isSelected = function(e) {
      var n = this.option.selected;
      return !(n.hasOwnProperty(e) && !n[e]) && Zt(this._availableNames, e) >= 0;
    }, t.prototype.getOrient = function() {
      return this.get("orient") === "vertical" ? {
        index: 1,
        name: "vertical"
      } : {
        index: 0,
        name: "horizontal"
      };
    }, t.type = "legend.plain", t.dependencies = ["series"], t.defaultOption = {
      // zlevel: 0,
      z: 4,
      show: !0,
      orient: "horizontal",
      left: "center",
      // right: 'center',
      // top: 0,
      bottom: Y.size.m,
      align: "auto",
      backgroundColor: Y.color.transparent,
      borderColor: Y.color.border,
      borderRadius: 0,
      borderWidth: 0,
      padding: 5,
      itemGap: 8,
      itemWidth: 25,
      itemHeight: 14,
      symbolRotate: "inherit",
      symbolKeepAspect: !0,
      inactiveColor: Y.color.disabled,
      inactiveBorderColor: Y.color.disabled,
      inactiveBorderWidth: "auto",
      itemStyle: {
        color: "inherit",
        opacity: "inherit",
        borderColor: "inherit",
        borderWidth: "auto",
        borderCap: "inherit",
        borderJoin: "inherit",
        borderDashOffset: "inherit",
        borderMiterLimit: "inherit"
      },
      lineStyle: {
        width: "auto",
        color: "inherit",
        inactiveColor: Y.color.disabled,
        inactiveWidth: 2,
        opacity: "inherit",
        type: "inherit",
        cap: "inherit",
        join: "inherit",
        dashOffset: "inherit",
        miterLimit: "inherit"
      },
      textStyle: {
        color: Y.color.secondary
      },
      selectedMode: !0,
      selector: !1,
      selectorLabel: {
        show: !0,
        borderRadius: 10,
        padding: [3, 5, 3, 5],
        fontSize: 12,
        fontFamily: "sans-serif",
        color: Y.color.tertiary,
        borderWidth: 1,
        borderColor: Y.color.border
      },
      emphasis: {
        selectorLabel: {
          show: !0,
          color: Y.color.quaternary
        }
      },
      selectorPosition: "auto",
      selectorItemGap: 7,
      selectorButtonGap: 10,
      tooltip: {
        show: !1
      },
      triggerEvent: !1
    }, t;
  }(re)
), bu = Yt, QS = L, kp = Et, BV = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.newlineDisabled = !1, e;
    }
    return t.prototype.init = function() {
      this.group.add(this._contentGroup = new kp()), this.group.add(this._selectorGroup = new kp()), this._isFirstRender = !0;
    }, t.prototype.getContentGroup = function() {
      return this._contentGroup;
    }, t.prototype.getSelectorGroup = function() {
      return this._selectorGroup;
    }, t.prototype.render = function(e, n, i) {
      var a = this._isFirstRender;
      if (this._isFirstRender = !1, this.resetInner(), !!e.get("show", !0)) {
        var o = e.get("align"), s = e.get("orient");
        (!o || o === "auto") && (o = e.get("left") === "right" && s === "vertical" ? "right" : "left");
        var l = e.get("selector", !0), u = e.get("selectorPosition", !0);
        l && (!u || u === "auto") && (u = s === "horizontal" ? "end" : "start"), this.renderInner(o, e, n, i, l, s, u);
        var c = xr(e, i).refContainer, f = e.getBoxLayoutParams(), h = e.get("padding"), d = He(f, c, h), p = this.layoutInner(e, o, d, a, l, u), g = He(kt({
          width: p.width,
          height: p.height
        }, f), c, h);
        this.group.x = g.x - p.x, this.group.y = g.y - p.y, this.group.markRedraw(), this.group.add(this._backgroundEl = TV(
          p,
          // FXIME: most itemStyle options does not work in background because inherit is not handled yet.
          e
        ));
      }
    }, t.prototype.resetInner = function() {
      this.getContentGroup().removeAll(), this._backgroundEl && this.group.remove(this._backgroundEl), this.getSelectorGroup().removeAll();
    }, t.prototype.renderInner = function(e, n, i, a, o, s, l) {
      var u = this.getContentGroup(), c = wt(), f = n.get("selectedMode"), h = n.get("triggerEvent"), d = [];
      i.eachRawSeries(function(p) {
        !p.get("legendHoverLink") && d.push(p.id);
      }), QS(n.getData(), function(p, g) {
        var v = this, m = p.get("name");
        if (!this.newlineDisabled && (m === "" || m === `
`)) {
          var y = new kp();
          y.newline = !0, u.add(y);
          return;
        }
        var _ = i.getSeriesByName(m)[0];
        if (!c.get(m)) {
          if (_) {
            var x = _.getData(), b = x.getVisual("legendLineStyle") || {}, S = x.getVisual("legendIcon"), w = x.getVisual("style"), A = this._createItem(_, m, g, p, n, e, b, w, S, f, a);
            A.on("click", bu(_R, m, null, a, d)).on("mouseover", bu(t1, _.name, null, a, d)).on("mouseout", bu(e1, _.name, null, a, d)), i.ssr && A.eachChild(function(T) {
              var M = zt(T);
              M.seriesIndex = _.seriesIndex, M.dataIndex = g, M.ssrType = "legend";
            }), h && A.eachChild(function(T) {
              v.packEventData(T, n, _, g, m);
            }), c.set(m, !0);
          } else
            i.eachRawSeries(function(T) {
              var M = this;
              if (!c.get(m) && T.legendVisualProvider) {
                var E = T.legendVisualProvider;
                if (!E.containName(m))
                  return;
                var R = E.indexOfName(m), C = E.getItemVisual(R, "style"), D = E.getItemVisual(R, "legendIcon"), I = bn(C.fill);
                I && I[3] === 0 && (I[3] = 0.2, C = J(J({}, C), {
                  fill: Ji(I, "rgba")
                }));
                var P = this._createItem(T, m, g, p, n, e, {}, C, D, f, a);
                P.on("click", bu(_R, null, m, a, d)).on("mouseover", bu(t1, null, m, a, d)).on("mouseout", bu(e1, null, m, a, d)), i.ssr && P.eachChild(function(O) {
                  var N = zt(O);
                  N.seriesIndex = T.seriesIndex, N.dataIndex = g, N.ssrType = "legend";
                }), h && P.eachChild(function(O) {
                  M.packEventData(O, n, T, g, m);
                }), c.set(m, !0);
              }
            }, this);
          process.env.NODE_ENV !== "production" && (c.get(m) || console.warn(m + " series not exists. Legend data should be same with series name or data name."));
        }
      }, this), o && this._createSelector(o, n, a, s, l);
    }, t.prototype.packEventData = function(e, n, i, a, o) {
      var s = {
        componentType: "legend",
        componentIndex: n.componentIndex,
        dataIndex: a,
        value: o,
        seriesIndex: i.seriesIndex
      };
      zt(e).eventData = s;
    }, t.prototype._createSelector = function(e, n, i, a, o) {
      var s = this.getSelectorGroup();
      QS(e, function(u) {
        var c = u.type, f = new pe({
          style: {
            x: 0,
            y: 0,
            align: "center",
            verticalAlign: "middle"
          },
          onclick: function() {
            i.dispatchAction({
              type: c === "all" ? "legendAllSelect" : "legendInverseSelect",
              legendId: n.id
            });
          }
        });
        s.add(f);
        var h = n.getModel("selectorLabel"), d = n.getModel(["emphasis", "selectorLabel"]);
        Er(f, {
          normal: h,
          emphasis: d
        }, {
          defaultText: u.title
        }), al(f);
      });
    }, t.prototype._createItem = function(e, n, i, a, o, s, l, u, c, f, h) {
      var d = e.visualDrawType, p = o.get("itemWidth"), g = o.get("itemHeight"), v = o.isSelected(n), m = a.get("symbolRotate"), y = a.get("symbolKeepAspect"), _ = a.get("icon");
      c = _ || c || "roundRect";
      var x = Dst(c, a, l, u, d, v, h), b = new kp(), S = a.getModel("textStyle");
      if (Tt(e.getLegendIcon) && (!_ || _ === "inherit"))
        b.add(e.getLegendIcon({
          itemWidth: p,
          itemHeight: g,
          icon: c,
          iconRotate: m,
          itemStyle: x.itemStyle,
          lineStyle: x.lineStyle,
          symbolKeepAspect: y
        }));
      else {
        var w = _ === "inherit" && e.getData().getVisual("symbol") ? m === "inherit" ? e.getData().getVisual("symbolRotate") : m : 0;
        b.add(Lst({
          itemWidth: p,
          itemHeight: g,
          icon: c,
          iconRotate: w,
          itemStyle: x.itemStyle,
          symbolKeepAspect: y
        }));
      }
      var A = s === "left" ? p + 5 : -5, T = s, M = o.get("formatter"), E = n;
      pt(M) && M ? E = M.replace("{name}", n ?? "") : Tt(M) && (E = M(n));
      var R = v ? S.getTextColor() : a.get("inactiveColor");
      b.add(new pe({
        style: Oe(S, {
          text: E,
          x: A,
          y: g / 2,
          fill: R,
          align: T,
          verticalAlign: "middle"
        }, {
          inheritColor: R
        })
      }));
      var C = new te({
        shape: b.getBoundingRect(),
        style: {
          // Cannot use 'invisible' because SVG SSR will miss the node
          fill: "transparent"
        }
      }), D = a.getModel("tooltip");
      return D.get("show") && Ka({
        el: C,
        componentModel: o,
        itemName: n,
        itemTooltipOption: D.option
      }), b.add(C), b.eachChild(function(I) {
        I.silent = !0;
      }), C.silent = !f, this.getContentGroup().add(b), al(b), b.__legendDataIndex = i, b;
    }, t.prototype.layoutInner = function(e, n, i, a, o, s) {
      var l = this.getContentGroup(), u = this.getSelectorGroup();
      sl(e.get("orient"), l, e.get("itemGap"), i.width, i.height);
      var c = l.getBoundingRect(), f = [-c.x, -c.y];
      if (u.markRedraw(), l.markRedraw(), o) {
        sl(
          // Buttons in selectorGroup always layout horizontally
          "horizontal",
          u,
          e.get("selectorItemGap", !0)
        );
        var h = u.getBoundingRect(), d = [-h.x, -h.y], p = e.get("selectorButtonGap", !0), g = e.getOrient().index, v = g === 0 ? "width" : "height", m = g === 0 ? "height" : "width", y = g === 0 ? "y" : "x";
        s === "end" ? d[g] += c[v] + p : f[g] += h[v] + p, d[1 - g] += c[m] / 2 - h[m] / 2, u.x = d[0], u.y = d[1], l.x = f[0], l.y = f[1];
        var _ = {
          x: 0,
          y: 0
        };
        return _[v] = c[v] + p + h[v], _[m] = Math.max(c[m], h[m]), _[y] = Math.min(0, h[y] + d[1 - g]), _;
      } else
        return l.x = f[0], l.y = f[1], this.group.getBoundingRect();
    }, t.prototype.remove = function() {
      this.getContentGroup().removeAll(), this._isFirstRender = !0;
    }, t.type = "legend.plain", t;
  }(Ue)
);
function Dst(r, t, e, n, i, a, o) {
  function s(v, m) {
    v.lineWidth === "auto" && (v.lineWidth = m.lineWidth > 0 ? 2 : 0), QS(v, function(y, _) {
      v[_] === "inherit" && (v[_] = m[_]);
    });
  }
  var l = t.getModel("itemStyle"), u = l.getItemStyle(), c = r.lastIndexOf("empty", 0) === 0 ? "fill" : "stroke", f = l.getShallow("decal");
  u.decal = !f || f === "inherit" ? n.decal : ac(f, o), u.fill === "inherit" && (u.fill = n[i]), u.stroke === "inherit" && (u.stroke = n[c]), u.opacity === "inherit" && (u.opacity = (i === "fill" ? n : e).opacity), s(u, n);
  var h = t.getModel("lineStyle"), d = h.getLineStyle();
  if (s(d, e), u.fill === "auto" && (u.fill = n.fill), u.stroke === "auto" && (u.stroke = n.fill), d.stroke === "auto" && (d.stroke = n.fill), !a) {
    var p = t.get("inactiveBorderWidth"), g = u[c];
    u.lineWidth = p === "auto" ? n.lineWidth > 0 && g ? 2 : 0 : u.lineWidth, u.fill = t.get("inactiveColor"), u.stroke = t.get("inactiveBorderColor"), d.stroke = h.get("inactiveColor"), d.lineWidth = h.get("inactiveWidth");
  }
  return {
    itemStyle: u,
    lineStyle: d
  };
}
function Lst(r) {
  var t = r.icon || "roundRect", e = fr(t, 0, 0, r.itemWidth, r.itemHeight, r.itemStyle.fill, r.symbolKeepAspect);
  return e.setStyle(r.itemStyle), e.rotation = (r.iconRotate || 0) * Math.PI / 180, e.setOrigin([r.itemWidth / 2, r.itemHeight / 2]), t.indexOf("empty") > -1 && (e.style.stroke = e.style.fill, e.style.fill = Y.color.neutral00, e.style.lineWidth = 2), e;
}
function _R(r, t, e, n) {
  e1(r, t, e, n), e.dispatchAction({
    type: "legendToggleSelect",
    name: r ?? t
  }), t1(r, t, e, n);
}
function VV(r) {
  for (var t = r.getZr().storage.getDisplayList(), e, n = 0, i = t.length; n < i && !(e = t[n].states.emphasis); )
    n++;
  return e && e.hoverLayer;
}
function t1(r, t, e, n) {
  VV(e) || e.dispatchAction({
    type: "highlight",
    seriesName: r,
    name: t,
    excludeSeriesId: n
  });
}
function e1(r, t, e, n) {
  VV(e) || e.dispatchAction({
    type: "downplay",
    seriesName: r,
    name: t,
    excludeSeriesId: n
  });
}
function Rst(r) {
  var t = r.findComponents({
    mainType: "legend"
  });
  t && t.length && r.filterSeries(function(e) {
    for (var n = 0; n < t.length; n++)
      if (!t[n].isSelected(e.name))
        return !1;
    return !0;
  });
}
function Sf(r, t, e) {
  var n = r === "allSelect" || r === "inverseSelect", i = {}, a = [];
  e.eachComponent({
    mainType: "legend",
    query: t
  }, function(s) {
    n ? s[r]() : s[r](t.name), xR(s, i), a.push(s.componentIndex);
  });
  var o = {};
  return e.eachComponent("legend", function(s) {
    L(i, function(l, u) {
      s[l ? "select" : "unSelect"](u);
    }), xR(s, o);
  }), n ? {
    selected: o,
    // return legendIndex array to tell the developers which legends are allSelect / inverseSelect
    legendIndex: a
  } : {
    name: t.name,
    selected: o
  };
}
function xR(r, t) {
  var e = t || {};
  return L(r.getData(), function(n) {
    var i = n.get("name");
    if (!(i === `
` || i === "")) {
      var a = r.isSelected(i);
      _t(e, i) ? e[i] = e[i] && a : e[i] = a;
    }
  }), e;
}
function Ist(r) {
  r.registerAction("legendToggleSelect", "legendselectchanged", Yt(Sf, "toggleSelected")), r.registerAction("legendAllSelect", "legendselectall", Yt(Sf, "allSelect")), r.registerAction("legendInverseSelect", "legendinverseselect", Yt(Sf, "inverseSelect")), r.registerAction("legendSelect", "legendselected", Yt(Sf, "select")), r.registerAction("legendUnSelect", "legendunselected", Yt(Sf, "unSelect"));
}
function FV(r) {
  r.registerComponentModel(JS), r.registerComponentView(BV), r.registerProcessor(r.PRIORITY.PROCESSOR.SERIES_FILTER, Rst), r.registerSubTypeDefaulter("legend", function() {
    return "plain";
  }), Ist(r);
}
var Pst = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.setScrollDataIndex = function(e) {
      this.option.scrollDataIndex = e;
    }, t.prototype.init = function(e, n, i) {
      var a = El(e);
      r.prototype.init.call(this, e, n, i), SR(this, e, a);
    }, t.prototype.mergeOption = function(e, n) {
      r.prototype.mergeOption.call(this, e, n), SR(this, this.option, e);
    }, t.type = "legend.scroll", t.defaultOption = jo(JS.defaultOption, {
      scrollDataIndex: 0,
      pageButtonItemGap: 5,
      pageButtonGap: null,
      pageButtonPosition: "end",
      pageFormatter: "{current}/{total}",
      pageIcons: {
        horizontal: ["M0,0L12,-10L12,10z", "M0,0L-12,-10L-12,10z"],
        vertical: ["M0,0L20,0L10,-20z", "M0,0L20,0L10,20z"]
      },
      pageIconColor: Y.color.accent50,
      pageIconInactiveColor: Y.color.accent10,
      pageIconSize: 15,
      pageTextStyle: {
        color: Y.color.tertiary
      },
      animationDurationUpdate: 800
    }), t;
  }(JS)
);
function SR(r, t, e) {
  var n = r.getOrient(), i = [1, 1];
  i[n.index] = 0, oa(t, e, {
    type: "box",
    ignoreSize: !!i
  });
}
var bR = Et, L_ = ["width", "height"], R_ = ["x", "y"], Nst = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.newlineDisabled = !0, e._currentIndex = 0, e;
    }
    return t.prototype.init = function() {
      r.prototype.init.call(this), this.group.add(this._containerGroup = new bR()), this._containerGroup.add(this.getContentGroup()), this.group.add(this._controllerGroup = new bR());
    }, t.prototype.resetInner = function() {
      r.prototype.resetInner.call(this), this._controllerGroup.removeAll(), this._containerGroup.removeClipPath(), this._containerGroup.__rectSize = null;
    }, t.prototype.renderInner = function(e, n, i, a, o, s, l) {
      var u = this;
      r.prototype.renderInner.call(this, e, n, i, a, o, s, l);
      var c = this._controllerGroup, f = n.get("pageIconSize", !0), h = et(f) ? f : [f, f];
      p("pagePrev", 0);
      var d = n.getModel("pageTextStyle");
      c.add(new pe({
        name: "pageText",
        style: {
          // Placeholder to calculate a proper layout.
          text: "xx/xx",
          fill: d.getTextColor(),
          font: d.getFont(),
          verticalAlign: "middle",
          align: "center"
        },
        silent: !0
      })), p("pageNext", 1);
      function p(g, v) {
        var m = g + "DataIndex", y = Vh(n.get("pageIcons", !0)[n.getOrient().name][v], {
          // Buttons will be created in each render, so we do not need
          // to worry about avoiding using legendModel kept in scope.
          onclick: mt(u._pageGo, u, m, n, a)
        }, {
          x: -h[0] / 2,
          y: -h[1] / 2,
          width: h[0],
          height: h[1]
        });
        y.name = g, c.add(y);
      }
    }, t.prototype.layoutInner = function(e, n, i, a, o, s) {
      var l = this.getSelectorGroup(), u = e.getOrient().index, c = L_[u], f = R_[u], h = L_[1 - u], d = R_[1 - u];
      o && sl(
        // Buttons in selectorGroup always layout horizontally
        "horizontal",
        l,
        e.get("selectorItemGap", !0)
      );
      var p = e.get("selectorButtonGap", !0), g = l.getBoundingRect(), v = [-g.x, -g.y], m = Ct(i);
      o && (m[c] = i[c] - g[c] - p);
      var y = this._layoutContentAndController(e, a, m, u, c, h, d, f);
      if (o) {
        if (s === "end")
          v[u] += y[c] + p;
        else {
          var _ = g[c] + p;
          v[u] -= _, y[f] -= _;
        }
        y[c] += g[c] + p, v[1 - u] += y[d] + y[h] / 2 - g[h] / 2, y[h] = Math.max(y[h], g[h]), y[d] = Math.min(y[d], g[d] + v[1 - u]), l.x = v[0], l.y = v[1], l.markRedraw();
      }
      return y;
    }, t.prototype._layoutContentAndController = function(e, n, i, a, o, s, l, u) {
      var c = this.getContentGroup(), f = this._containerGroup, h = this._controllerGroup;
      sl(e.get("orient"), c, e.get("itemGap"), a ? i.width : null, a ? null : i.height), sl(
        // Buttons in controller are layout always horizontally.
        "horizontal",
        h,
        e.get("pageButtonItemGap", !0)
      );
      var d = c.getBoundingRect(), p = h.getBoundingRect(), g = this._showController = d[o] > i[o], v = [-d.x, -d.y];
      n || (v[a] = c[u]);
      var m = [0, 0], y = [-p.x, -p.y], _ = bt(e.get("pageButtonGap", !0), e.get("itemGap", !0));
      if (g) {
        var x = e.get("pageButtonPosition", !0);
        x === "end" ? y[a] += i[o] - p[o] : m[a] += p[o] + _;
      }
      y[1 - a] += d[s] / 2 - p[s] / 2, c.setPosition(v), f.setPosition(m), h.setPosition(y);
      var b = {
        x: 0,
        y: 0
      };
      if (b[o] = g ? i[o] : d[o], b[s] = Math.max(d[s], p[s]), b[l] = Math.min(0, p[l] + y[1 - a]), f.__rectSize = i[o], g) {
        var S = {
          x: 0,
          y: 0
        };
        S[o] = Math.max(i[o] - p[o] - _, 0), S[s] = b[s], f.setClipPath(new te({
          shape: S
        })), f.__rectSize = S[o];
      } else
        h.eachChild(function(A) {
          A.attr({
            invisible: !0,
            silent: !0
          });
        });
      var w = this._getPageInfo(e);
      return w.pageIndex != null && ve(
        c,
        {
          x: w.contentPosition[0],
          y: w.contentPosition[1]
        },
        // When switch from "show controller" to "not show controller", view should be
        // updated immediately without animation, otherwise causes weird effect.
        g ? e : null
      ), this._updatePageInfoView(e, w), b;
    }, t.prototype._pageGo = function(e, n, i) {
      var a = this._getPageInfo(n)[e];
      a != null && i.dispatchAction({
        type: "legendScroll",
        scrollDataIndex: a,
        legendId: n.id
      });
    }, t.prototype._updatePageInfoView = function(e, n) {
      var i = this._controllerGroup;
      L(["pagePrev", "pageNext"], function(c) {
        var f = c + "DataIndex", h = n[f] != null, d = i.childOfName(c);
        d && (d.setStyle("fill", h ? e.get("pageIconColor", !0) : e.get("pageIconInactiveColor", !0)), d.cursor = h ? "pointer" : "default");
      });
      var a = i.childOfName("pageText"), o = e.get("pageFormatter"), s = n.pageIndex, l = s != null ? s + 1 : 0, u = n.pageCount;
      a && o && a.setStyle("text", pt(o) ? o.replace("{current}", l == null ? "" : l + "").replace("{total}", u == null ? "" : u + "") : o({
        current: l,
        total: u
      }));
    }, t.prototype._getPageInfo = function(e) {
      var n = e.get("scrollDataIndex", !0), i = this.getContentGroup(), a = this._containerGroup.__rectSize, o = e.getOrient().index, s = L_[o], l = R_[o], u = this._findTargetItemIndex(n), c = i.children(), f = c[u], h = c.length, d = h ? 1 : 0, p = {
        contentPosition: [i.x, i.y],
        pageCount: d,
        pageIndex: d - 1,
        pagePrevDataIndex: null,
        pageNextDataIndex: null
      };
      if (!f)
        return p;
      var g = x(f);
      p.contentPosition[o] = -g.s;
      for (var v = u + 1, m = g, y = g, _ = null; v <= h; ++v)
        _ = x(c[v]), // Half of the last item is out of the window.
        (!_ && y.e > m.s + a || _ && !b(_, m.s)) && (y.i > m.i ? m = y : m = _, m && (p.pageNextDataIndex == null && (p.pageNextDataIndex = m.i), ++p.pageCount)), y = _;
      for (var v = u - 1, m = g, y = g, _ = null; v >= -1; --v)
        _ = x(c[v]), // If the the end item does not intersect with the window started
        // from the current item, a page can be settled.
        (!_ || !b(y, _.s)) && m.i < y.i && (y = m, p.pagePrevDataIndex == null && (p.pagePrevDataIndex = m.i), ++p.pageCount, ++p.pageIndex), m = _;
      return p;
      function x(S) {
        if (S) {
          var w = S.getBoundingRect(), A = w[l] + S[l];
          return {
            s: A,
            e: A + w[s],
            i: S.__legendDataIndex
          };
        }
      }
      function b(S, w) {
        return S.e >= w && S.s <= w + a;
      }
    }, t.prototype._findTargetItemIndex = function(e) {
      if (!this._showController)
        return 0;
      var n, i = this.getContentGroup(), a;
      return i.eachChild(function(o, s) {
        var l = o.__legendDataIndex;
        a == null && l != null && (a = s), l === e && (n = s);
      }), n ?? a;
    }, t.type = "legend.scroll", t;
  }(BV)
);
function Ost(r) {
  r.registerAction("legendScroll", "legendscroll", function(t, e) {
    var n = t.scrollDataIndex;
    n != null && e.eachComponent({
      mainType: "legend",
      subType: "scroll",
      query: t
    }, function(i) {
      i.setScrollDataIndex(n);
    });
  });
}
function kst(r) {
  jt(FV), r.registerComponentModel(Pst), r.registerComponentView(Nst), Ost(r);
}
function Bst(r) {
  jt(FV), jt(kst);
}
var Vst = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.type = "dataZoom.inside", t.defaultOption = jo(Th.defaultOption, {
      disabled: !1,
      zoomLock: !1,
      zoomOnMouseWheel: !0,
      moveOnMouseMove: !0,
      moveOnMouseWheel: !1,
      preventDefaultMouseMove: !0
    }), t;
  }(Th)
), Lw = ee();
function Fst(r, t, e) {
  Lw(r).coordSysRecordMap.each(function(n) {
    var i = n.dataZoomInfoMap.get(t.uid);
    i && (i.getRange = e);
  });
}
function zst(r, t) {
  for (var e = Lw(r).coordSysRecordMap, n = e.keys(), i = 0; i < n.length; i++) {
    var a = n[i], o = e.get(a), s = o.dataZoomInfoMap;
    if (s) {
      var l = t.uid, u = s.get(l);
      u && (s.removeKey(l), s.keys().length || zV(e, o));
    }
  }
}
function zV(r, t) {
  if (t) {
    r.removeKey(t.model.uid);
    var e = t.controller;
    e && e.dispose();
  }
}
function Ust(r, t) {
  var e = {
    model: t,
    containsPoint: Yt(Hst, t),
    dispatchAction: Yt(Gst, r),
    dataZoomInfoMap: null,
    controller: null
  }, n = e.controller = new Il(r.getZr());
  return L(["pan", "zoom", "scrollMove"], function(i) {
    n.on(i, function(a) {
      var o = [];
      e.dataZoomInfoMap.each(function(s) {
        if (a.isAvailableBehavior(s.model.option)) {
          var l = (s.getRange || {})[i], u = l && l(s.dzReferCoordSysInfo, e.model.mainType, e.controller, a);
          !s.model.get("disabled", !0) && u && o.push({
            dataZoomId: s.model.id,
            start: u[0],
            end: u[1]
          });
        }
      }), o.length && e.dispatchAction(o);
    });
  }), e;
}
function Gst(r, t) {
  r.isDisposed() || r.dispatchAction({
    type: "dataZoom",
    animation: {
      easing: "cubicOut",
      duration: 100
    },
    batch: t
  });
}
function Hst(r, t, e, n) {
  return r.coordinateSystem.containPoint([e, n]);
}
function Wst(r, t, e) {
  var n, i = "type_", a = {
    type_true: 2,
    type_move: 1,
    type_false: 0,
    type_undefined: -1
  }, o = !0;
  return r.each(function(s) {
    var l = s.model, u = l.get("disabled", !0) ? !1 : l.get("zoomLock", !0) ? "move" : !0;
    a[i + u] > a[i + n] && (n = u), o = o && l.get("preventDefaultMouseMove", !0);
  }), {
    controlType: n,
    opt: {
      // RoamController will enable all of these functionalities,
      // and the final behavior is determined by its event listener
      // provided by each inside zoom.
      zoomOnMouseWheel: !0,
      moveOnMouseMove: !0,
      moveOnMouseWheel: !0,
      preventDefaultMouseMove: !!o,
      api: e,
      zInfo: {
        component: t.model
      },
      triggerInfo: {
        roamTrigger: null,
        isInSelf: t.containsPoint
      }
    }
  };
}
function Xst(r) {
  r.registerProcessor(r.PRIORITY.PROCESSOR.FILTER, function(t, e) {
    var n = Lw(e), i = n.coordSysRecordMap || (n.coordSysRecordMap = wt());
    i.each(function(a) {
      a.dataZoomInfoMap = null;
    }), t.eachComponent({
      mainType: "dataZoom",
      subType: "inside"
    }, function(a) {
      var o = bV(a);
      L(o.infoList, function(s) {
        var l = s.model.uid, u = i.get(l) || i.set(l, Ust(e, s.model)), c = u.dataZoomInfoMap || (u.dataZoomInfoMap = wt());
        c.set(a.uid, {
          dzReferCoordSysInfo: s,
          model: a,
          getRange: null
        });
      });
    }), i.each(function(a) {
      var o = a.controller, s, l = a.dataZoomInfoMap;
      if (l) {
        var u = l.keys()[0];
        u != null && (s = l.get(u));
      }
      if (!s) {
        zV(i, a);
        return;
      }
      var c = Wst(l, a, e);
      o.enable(c.controlType, c.opt), Dc(a, "dispatchAction", s.model.get("throttle", !0), "fixRate");
    });
  });
}
var Yst = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = "dataZoom.inside", e;
    }
    return t.prototype.render = function(e, n, i) {
      if (r.prototype.render.apply(this, arguments), e.noTarget()) {
        this._clear();
        return;
      }
      this.range = e.getPercentRange(), Fst(i, e, {
        pan: mt(I_.pan, this),
        zoom: mt(I_.zoom, this),
        scrollMove: mt(I_.scrollMove, this)
      });
    }, t.prototype.dispose = function() {
      this._clear(), r.prototype.dispose.apply(this, arguments);
    }, t.prototype._clear = function() {
      zst(this.api, this.dataZoomModel), this.range = null;
    }, t.type = "dataZoom.inside", t;
  }(bw)
), I_ = {
  zoom: function(r, t, e, n) {
    var i = this.range, a = i.slice(), o = r.axisModels[0];
    if (o) {
      var s = P_[t](null, [n.originX, n.originY], o, e, r), l = (s.signal > 0 ? s.pixelStart + s.pixelLength - s.pixel : s.pixel - s.pixelStart) / s.pixelLength * (a[1] - a[0]) + a[0], u = Math.max(1 / n.scale, 0);
      a[0] = (a[0] - l) * u + l, a[1] = (a[1] - l) * u + l;
      var c = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
      if (Xo(0, a, [0, 100], 0, c.minSpan, c.maxSpan), this.range = a, i[0] !== a[0] || i[1] !== a[1])
        return a;
    }
  },
  pan: wR(function(r, t, e, n, i, a) {
    var o = P_[n]([a.oldX, a.oldY], [a.newX, a.newY], t, i, e);
    return o.signal * (r[1] - r[0]) * o.pixel / o.pixelLength;
  }),
  scrollMove: wR(function(r, t, e, n, i, a) {
    var o = P_[n]([0, 0], [a.scrollDelta, a.scrollDelta], t, i, e);
    return o.signal * (r[1] - r[0]) * a.scrollDelta;
  })
};
function wR(r) {
  return function(t, e, n, i) {
    var a = this.range, o = a.slice(), s = t.axisModels[0];
    if (s) {
      var l = r(o, s, t, e, n, i);
      if (Xo(l, o, [0, 100], "all"), this.range = o, a[0] !== o[0] || a[1] !== o[1])
        return o;
    }
  };
}
var P_ = {
  grid: function(r, t, e, n, i) {
    var a = e.axis, o = {}, s = i.model.coordinateSystem.getRect();
    return r = r || [0, 0], a.dim === "x" ? (o.pixel = t[0] - r[0], o.pixelLength = s.width, o.pixelStart = s.x, o.signal = a.inverse ? 1 : -1) : (o.pixel = t[1] - r[1], o.pixelLength = s.height, o.pixelStart = s.y, o.signal = a.inverse ? -1 : 1), o;
  },
  polar: function(r, t, e, n, i) {
    var a = e.axis, o = {}, s = i.model.coordinateSystem, l = s.getRadiusAxis().getExtent(), u = s.getAngleAxis().getExtent();
    return r = r ? s.pointToCoord(r) : [0, 0], t = s.pointToCoord(t), e.mainType === "radiusAxis" ? (o.pixel = t[0] - r[0], o.pixelLength = l[1] - l[0], o.pixelStart = l[0], o.signal = a.inverse ? 1 : -1) : (o.pixel = t[1] - r[1], o.pixelLength = u[1] - u[0], o.pixelStart = u[0], o.signal = a.inverse ? -1 : 1), o;
  },
  singleAxis: function(r, t, e, n, i) {
    var a = e.axis, o = i.model.coordinateSystem.getRect(), s = {};
    return r = r || [0, 0], a.orient === "horizontal" ? (s.pixel = t[0] - r[0], s.pixelLength = o.width, s.pixelStart = o.x, s.signal = a.inverse ? 1 : -1) : (s.pixel = t[1] - r[1], s.pixelLength = o.height, s.pixelStart = o.y, s.signal = a.inverse ? -1 : 1), s;
  }
};
function UV(r) {
  ww(r), r.registerComponentModel(Vst), r.registerComponentView(Yst), Xst(r);
}
var $st = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.type = "dataZoom.slider", t.layoutMode = "box", t.defaultOption = jo(Th.defaultOption, {
      show: !0,
      // deault value can only be drived in view stage.
      right: "ph",
      top: "ph",
      width: "ph",
      height: "ph",
      left: null,
      bottom: null,
      borderColor: Y.color.accent10,
      borderRadius: 0,
      backgroundColor: Y.color.transparent,
      // dataBackgroundColor: '#ddd',
      dataBackground: {
        lineStyle: {
          color: Y.color.accent30,
          width: 0.5
        },
        areaStyle: {
          color: Y.color.accent20,
          opacity: 0.2
        }
      },
      selectedDataBackground: {
        lineStyle: {
          color: Y.color.accent40,
          width: 0.5
        },
        areaStyle: {
          color: Y.color.accent20,
          opacity: 0.3
        }
      },
      // Color of selected window.
      fillerColor: "rgba(135,175,274,0.2)",
      handleIcon: "path://M-9.35,34.56V42m0-40V9.5m-2,0h4a2,2,0,0,1,2,2v21a2,2,0,0,1-2,2h-4a2,2,0,0,1-2-2v-21A2,2,0,0,1-11.35,9.5Z",
      // Percent of the slider height
      handleSize: "100%",
      handleStyle: {
        color: Y.color.neutral00,
        borderColor: Y.color.accent20
      },
      moveHandleSize: 7,
      moveHandleIcon: "path://M-320.9-50L-320.9-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-348-41-339-50-320.9-50z M-212.3-50L-212.3-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-239.4-41-230.4-50-212.3-50z M-103.7-50L-103.7-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-130.9-41-121.8-50-103.7-50z",
      moveHandleStyle: {
        color: Y.color.accent40,
        opacity: 0.5
      },
      showDetail: !0,
      showDataShadow: "auto",
      realtime: !0,
      zoomLock: !1,
      textStyle: {
        color: Y.color.tertiary
      },
      brushSelect: !0,
      brushStyle: {
        color: Y.color.accent30,
        opacity: 0.3
      },
      emphasis: {
        handleLabel: {
          show: !0
        },
        handleStyle: {
          borderColor: Y.color.accent40
        },
        moveHandleStyle: {
          opacity: 0.8
        }
      },
      defaultLocationEdgeGap: 15
    }), t;
  }(Th)
), bf = te, Zst = 1, N_ = 30, qst = 7, wf = "horizontal", MR = "vertical", Kst = 5, jst = ["line", "bar", "candlestick", "scatter"], Jst = {
  easing: "cubicOut",
  duration: 100,
  delay: 0
}, Qst = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e._displayables = {}, e;
    }
    return t.prototype.init = function(e, n) {
      this.api = n, this._onBrush = mt(this._onBrush, this), this._onBrushEnd = mt(this._onBrushEnd, this);
    }, t.prototype.render = function(e, n, i, a) {
      if (r.prototype.render.apply(this, arguments), Dc(this, "_dispatchZoomAction", e.get("throttle"), "fixRate"), this._orient = e.getOrient(), e.get("show") === !1) {
        this.group.removeAll();
        return;
      }
      if (e.noTarget()) {
        this._clear(), this.group.removeAll();
        return;
      }
      (!a || a.type !== "dataZoom" || a.from !== this.uid) && this._buildView(), this._updateView();
    }, t.prototype.dispose = function() {
      this._clear(), r.prototype.dispose.apply(this, arguments);
    }, t.prototype._clear = function() {
      ch(this, "_dispatchZoomAction");
      var e = this.api.getZr();
      e.off("mousemove", this._onBrush), e.off("mouseup", this._onBrushEnd);
    }, t.prototype._buildView = function() {
      var e = this.group;
      e.removeAll(), this._brushing = !1, this._displayables.brushRect = null, this._resetLocation(), this._resetInterval();
      var n = this._displayables.sliderGroup = new Et();
      this._renderBackground(), this._renderHandle(), this._renderDataShadow(), e.add(n), this._positionGroup();
    }, t.prototype._resetLocation = function() {
      var e = this.dataZoomModel, n = this.api, i = e.get("brushSelect"), a = i ? qst : 0, o = xr(e, n).refContainer, s = this._findCoordRect(), l = e.get("defaultLocationEdgeGap", !0) || 0, u = this._orient === wf ? {
        // Why using 'right', because right should be used in vertical,
        // and it is better to be consistent for dealing with position param merge.
        right: o.width - s.x - s.width,
        top: o.height - N_ - l - a,
        width: s.width,
        height: N_
      } : {
        right: l,
        top: s.y,
        width: N_,
        height: s.height
      }, c = El(e.option);
      L(["right", "top", "width", "height"], function(h) {
        c[h] === "ph" && (c[h] = u[h]);
      });
      var f = He(c, o);
      this._location = {
        x: f.x,
        y: f.y
      }, this._size = [f.width, f.height], this._orient === MR && this._size.reverse();
    }, t.prototype._positionGroup = function() {
      var e = this.group, n = this._location, i = this._orient, a = this.dataZoomModel.getFirstTargetAxisModel(), o = a && a.get("inverse"), s = this._displayables.sliderGroup, l = (this._dataShadowInfo || {}).otherAxisInverse;
      s.attr(i === wf && !o ? {
        scaleY: l ? 1 : -1,
        scaleX: 1
      } : i === wf && o ? {
        scaleY: l ? 1 : -1,
        scaleX: -1
      } : i === MR && !o ? {
        scaleY: l ? -1 : 1,
        scaleX: 1,
        rotation: Math.PI / 2
      } : {
        scaleY: l ? -1 : 1,
        scaleX: -1,
        rotation: Math.PI / 2
      });
      var u = e.getBoundingRect([s]);
      e.x = n.x - u.x, e.y = n.y - u.y, e.markRedraw();
    }, t.prototype._getViewExtent = function() {
      return [0, this._size[0]];
    }, t.prototype._renderBackground = function() {
      var e = this.dataZoomModel, n = this._size, i = this._displayables.sliderGroup, a = e.get("brushSelect");
      i.add(new bf({
        silent: !0,
        shape: {
          x: 0,
          y: 0,
          width: n[0],
          height: n[1]
        },
        style: {
          fill: e.get("backgroundColor")
        },
        z2: -40
      }));
      var o = new bf({
        shape: {
          x: 0,
          y: 0,
          width: n[0],
          height: n[1]
        },
        style: {
          fill: "transparent"
        },
        z2: 0,
        onclick: mt(this._onClickPanel, this)
      }), s = this.api.getZr();
      a ? (o.on("mousedown", this._onBrushStart, this), o.cursor = "crosshair", s.on("mousemove", this._onBrush), s.on("mouseup", this._onBrushEnd)) : (s.off("mousemove", this._onBrush), s.off("mouseup", this._onBrushEnd)), i.add(o);
    }, t.prototype._renderDataShadow = function() {
      var e = this._dataShadowInfo = this._prepareDataShadowInfo();
      if (this._displayables.dataShadowSegs = [], !e)
        return;
      var n = this._size, i = this._shadowSize || [], a = e.series, o = a.getRawData(), s = a.getShadowDim && a.getShadowDim(), l = s && o.getDimensionInfo(s) ? a.getShadowDim() : e.otherDim;
      if (l == null)
        return;
      var u = this._shadowPolygonPts, c = this._shadowPolylinePts;
      if (o !== this._shadowData || l !== this._shadowDim || n[0] !== i[0] || n[1] !== i[1]) {
        var f = o.getDataExtent(e.thisDim), h = o.getDataExtent(l), d = (h[1] - h[0]) * 0.3;
        h = [h[0] - d, h[1] + d];
        var p = [0, n[1]], g = [0, n[0]], v = [[n[0], 0], [0, 0]], m = [], y = g[1] / Math.max(1, o.count() - 1), _ = n[0] / (f[1] - f[0]), x = e.thisAxis.type === "time", b = -y, S = Math.round(o.count() / n[0]), w;
        o.each([e.thisDim, l], function(R, C, D) {
          if (S > 0 && D % S) {
            x || (b += y);
            return;
          }
          b = x ? (+R - f[0]) * _ : b + y;
          var I = C == null || isNaN(C) || C === "", P = I ? 0 : Me(C, h, p, !0);
          I && !w && D ? (v.push([v[v.length - 1][0], 0]), m.push([m[m.length - 1][0], 0])) : !I && w && (v.push([b, 0]), m.push([b, 0])), I || (v.push([b, P]), m.push([b, P])), w = I;
        }), u = this._shadowPolygonPts = v, c = this._shadowPolylinePts = m;
      }
      this._shadowData = o, this._shadowDim = l, this._shadowSize = [n[0], n[1]];
      var A = this.dataZoomModel;
      function T(R) {
        var C = A.getModel(R ? "selectedDataBackground" : "dataBackground"), D = new Et(), I = new jr({
          shape: {
            points: u
          },
          segmentIgnoreThreshold: 1,
          style: C.getModel("areaStyle").getAreaStyle(),
          silent: !0,
          z2: -20
        }), P = new Ur({
          shape: {
            points: c
          },
          segmentIgnoreThreshold: 1,
          style: C.getModel("lineStyle").getLineStyle(),
          silent: !0,
          z2: -19
        });
        return D.add(I), D.add(P), D;
      }
      for (var M = 0; M < 3; M++) {
        var E = T(M === 1);
        this._displayables.sliderGroup.add(E), this._displayables.dataShadowSegs.push(E);
      }
    }, t.prototype._prepareDataShadowInfo = function() {
      var e = this.dataZoomModel, n = e.get("showDataShadow");
      if (n !== !1) {
        var i, a = this.ecModel;
        return e.eachTargetAxis(function(o, s) {
          var l = e.getAxisProxy(o, s).getTargetSeriesModels();
          L(l, function(u) {
            if (!i && !(n !== !0 && Zt(jst, u.get("type")) < 0)) {
              var c = a.getComponent(Co(o), s).axis, f = tlt(o), h, d = u.coordinateSystem;
              f != null && d.getOtherAxis && (h = d.getOtherAxis(c).inverse), f = u.getData().mapDimension(f);
              var p = u.getData().mapDimension(o);
              i = {
                thisAxis: c,
                series: u,
                thisDim: p,
                otherDim: f,
                otherAxisInverse: h
              };
            }
          }, this);
        }, this), i;
      }
    }, t.prototype._renderHandle = function() {
      var e = this.group, n = this._displayables, i = n.handles = [null, null], a = n.handleLabels = [null, null], o = this._displayables.sliderGroup, s = this._size, l = this.dataZoomModel, u = this.api, c = l.get("borderRadius") || 0, f = l.get("brushSelect"), h = n.filler = new bf({
        silent: f,
        style: {
          fill: l.get("fillerColor")
        },
        textConfig: {
          position: "inside"
        }
      });
      o.add(h), o.add(new bf({
        silent: !0,
        subPixelOptimize: !0,
        shape: {
          x: 0,
          y: 0,
          width: s[0],
          height: s[1],
          r: c
        },
        style: {
          // deprecated option
          stroke: l.get("dataBackgroundColor") || l.get("borderColor"),
          lineWidth: Zst,
          fill: Y.color.transparent
        }
      })), L([0, 1], function(_) {
        var x = l.get("handleIcon");
        !Gv[x] && x.indexOf("path://") < 0 && x.indexOf("image://") < 0 && (x = "path://" + x, process.env.NODE_ENV !== "production" && ia("handleIcon now needs 'path://' prefix when using a path string"));
        var b = fr(x, -1, 0, 2, 2, null, !0);
        b.attr({
          cursor: elt(this._orient),
          draggable: !0,
          drift: mt(this._onDragMove, this, _),
          ondragend: mt(this._onDragEnd, this),
          onmouseover: mt(this._showDataInfo, this, !0),
          onmouseout: mt(this._showDataInfo, this, !1),
          z2: 5
        });
        var S = b.getBoundingRect(), w = l.get("handleSize");
        this._handleHeight = dt(w, this._size[1]), this._handleWidth = S.width / S.height * this._handleHeight, b.setStyle(l.getModel("handleStyle").getItemStyle()), b.style.strokeNoScale = !0, b.rectHover = !0, b.ensureState("emphasis").style = l.getModel(["emphasis", "handleStyle"]).getItemStyle(), al(b);
        var A = l.get("handleColor");
        A != null && (b.style.fill = A), o.add(i[_] = b);
        var T = l.getModel("textStyle"), M = l.get("handleLabel") || {}, E = M.show || !1;
        e.add(a[_] = new pe({
          silent: !0,
          invisible: !E,
          style: Oe(T, {
            x: 0,
            y: 0,
            text: "",
            verticalAlign: "middle",
            align: "center",
            fill: T.getTextColor(),
            font: T.getFont()
          }),
          z2: 10
        }));
      }, this);
      var d = h;
      if (f) {
        var p = dt(l.get("moveHandleSize"), s[1]), g = n.moveHandle = new te({
          style: l.getModel("moveHandleStyle").getItemStyle(),
          silent: !0,
          shape: {
            r: [0, 0, 2, 2],
            y: s[1] - 0.5,
            height: p
          }
        }), v = p * 0.8, m = n.moveHandleIcon = fr(l.get("moveHandleIcon"), -v / 2, -v / 2, v, v, Y.color.neutral00, !0);
        m.silent = !0, m.y = s[1] + p / 2 - 0.5, g.ensureState("emphasis").style = l.getModel(["emphasis", "moveHandleStyle"]).getItemStyle();
        var y = Math.min(s[1] / 2, Math.max(p, 10));
        d = n.moveZone = new te({
          invisible: !0,
          shape: {
            y: s[1] - y,
            height: p + y
          }
        }), d.on("mouseover", function() {
          u.enterEmphasis(g);
        }).on("mouseout", function() {
          u.leaveEmphasis(g);
        }), o.add(g), o.add(m), o.add(d);
      }
      d.attr({
        draggable: !0,
        cursor: "default",
        drift: mt(this._onDragMove, this, "all"),
        ondragstart: mt(this._showDataInfo, this, !0),
        ondragend: mt(this._onDragEnd, this),
        onmouseover: mt(this._showDataInfo, this, !0),
        onmouseout: mt(this._showDataInfo, this, !1)
      });
    }, t.prototype._resetInterval = function() {
      var e = this._range = this.dataZoomModel.getPercentRange(), n = this._getViewExtent();
      this._handleEnds = [Me(e[0], [0, 100], n, !0), Me(e[1], [0, 100], n, !0)];
    }, t.prototype._updateInterval = function(e, n) {
      var i = this.dataZoomModel, a = this._handleEnds, o = this._getViewExtent(), s = i.findRepresentativeAxisProxy().getMinMaxSpan(), l = [0, 100];
      Xo(n, a, o, i.get("zoomLock") ? "all" : e, s.minSpan != null ? Me(s.minSpan, l, o, !0) : null, s.maxSpan != null ? Me(s.maxSpan, l, o, !0) : null);
      var u = this._range, c = this._range = ei([Me(a[0], o, l, !0), Me(a[1], o, l, !0)]);
      return !u || u[0] !== c[0] || u[1] !== c[1];
    }, t.prototype._updateView = function(e) {
      var n = this._displayables, i = this._handleEnds, a = ei(i.slice()), o = this._size;
      L([0, 1], function(d) {
        var p = n.handles[d], g = this._handleHeight;
        p.attr({
          scaleX: g / 2,
          scaleY: g / 2,
          // This is a trick, by adding an extra tiny offset to let the default handle's end point align to the drag window.
          // NOTE: It may affect some custom shapes a bit. But we prefer to have better result by default.
          x: i[d] + (d ? -1 : 1),
          y: o[1] / 2 - g / 2
        });
      }, this), n.filler.setShape({
        x: a[0],
        y: 0,
        width: a[1] - a[0],
        height: o[1]
      });
      var s = {
        x: a[0],
        width: a[1] - a[0]
      };
      n.moveHandle && (n.moveHandle.setShape(s), n.moveZone.setShape(s), n.moveZone.getBoundingRect(), n.moveHandleIcon && n.moveHandleIcon.attr("x", s.x + s.width / 2));
      for (var l = n.dataShadowSegs, u = [0, a[0], a[1], o[0]], c = 0; c < l.length; c++) {
        var f = l[c], h = f.getClipPath();
        h || (h = new te(), f.setClipPath(h)), h.setShape({
          x: u[c],
          y: 0,
          width: u[c + 1] - u[c],
          height: o[1]
        });
      }
      this._updateDataInfo(e);
    }, t.prototype._updateDataInfo = function(e) {
      var n = this.dataZoomModel, i = this._displayables, a = i.handleLabels, o = this._orient, s = ["", ""];
      if (n.get("showDetail")) {
        var l = n.findRepresentativeAxisProxy();
        if (l) {
          var u = l.getAxisModel().axis, c = this._range, f = e ? l.calculateDataWindow({
            start: c[0],
            end: c[1]
          }).valueWindow : l.getDataValueWindow();
          s = [this._formatLabel(f[0], u), this._formatLabel(f[1], u)];
        }
      }
      var h = ei(this._handleEnds.slice());
      d.call(this, 0), d.call(this, 1);
      function d(p) {
        var g = ol(i.handles[p].parent, this.group), v = am(p === 0 ? "right" : "left", g), m = this._handleWidth / 2 + Kst, y = yi([h[p] + (p === 0 ? -m : m), this._size[1] / 2], g);
        a[p].setStyle({
          x: y[0],
          y: y[1],
          verticalAlign: o === wf ? "middle" : v,
          align: o === wf ? v : "center",
          text: s[p]
        });
      }
    }, t.prototype._formatLabel = function(e, n) {
      var i = this.dataZoomModel, a = i.get("labelFormatter"), o = i.get("labelPrecision");
      (o == null || o === "auto") && (o = n.getPixelPrecision());
      var s = e == null || isNaN(e) ? "" : n.type === "category" || n.type === "time" ? n.scale.getLabel({
        value: Math.round(e)
      }) : e.toFixed(Math.min(o, 20));
      return Tt(a) ? a(e, s) : pt(a) ? a.replace("{value}", s) : s;
    }, t.prototype._showDataInfo = function(e) {
      var n = this.dataZoomModel.get("handleLabel") || {}, i = n.show || !1, a = this.dataZoomModel.getModel(["emphasis", "handleLabel"]), o = a.get("show") || !1, s = e || this._dragging ? o : i, l = this._displayables, u = l.handleLabels;
      u[0].attr("invisible", !s), u[1].attr("invisible", !s), l.moveHandle && this.api[s ? "enterEmphasis" : "leaveEmphasis"](l.moveHandle, 1);
    }, t.prototype._onDragMove = function(e, n, i, a) {
      this._dragging = !0, Ua(a.event);
      var o = this._displayables.sliderGroup.getLocalTransform(), s = yi([n, i], o, !0), l = this._updateInterval(e, s[0]), u = this.dataZoomModel.get("realtime");
      this._updateView(!u), l && u && this._dispatchZoomAction(!0);
    }, t.prototype._onDragEnd = function() {
      this._dragging = !1, this._showDataInfo(!1);
      var e = this.dataZoomModel.get("realtime");
      !e && this._dispatchZoomAction(!1);
    }, t.prototype._onClickPanel = function(e) {
      var n = this._size, i = this._displayables.sliderGroup.transformCoordToLocal(e.offsetX, e.offsetY);
      if (!(i[0] < 0 || i[0] > n[0] || i[1] < 0 || i[1] > n[1])) {
        var a = this._handleEnds, o = (a[0] + a[1]) / 2, s = this._updateInterval("all", i[0] - o);
        this._updateView(), s && this._dispatchZoomAction(!1);
      }
    }, t.prototype._onBrushStart = function(e) {
      var n = e.offsetX, i = e.offsetY;
      this._brushStart = new Nt(n, i), this._brushing = !0, this._brushStartTime = +/* @__PURE__ */ new Date();
    }, t.prototype._onBrushEnd = function(e) {
      if (this._brushing) {
        var n = this._displayables.brushRect;
        if (this._brushing = !1, !!n) {
          n.attr("ignore", !0);
          var i = n.shape, a = +/* @__PURE__ */ new Date();
          if (!(a - this._brushStartTime < 200 && Math.abs(i.width) < 5)) {
            var o = this._getViewExtent(), s = [0, 100], l = this._handleEnds = [i.x, i.x + i.width], u = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
            Xo(0, l, o, 0, u.minSpan != null ? Me(u.minSpan, s, o, !0) : null, u.maxSpan != null ? Me(u.maxSpan, s, o, !0) : null), this._range = ei([Me(l[0], o, s, !0), Me(l[1], o, s, !0)]), this._updateView(), this._dispatchZoomAction(!1);
          }
        }
      }
    }, t.prototype._onBrush = function(e) {
      this._brushing && (Ua(e.event), this._updateBrushRect(e.offsetX, e.offsetY));
    }, t.prototype._updateBrushRect = function(e, n) {
      var i = this._displayables, a = this.dataZoomModel, o = i.brushRect;
      o || (o = i.brushRect = new bf({
        silent: !0,
        style: a.getModel("brushStyle").getItemStyle()
      }), i.sliderGroup.add(o)), o.attr("ignore", !1);
      var s = this._brushStart, l = this._displayables.sliderGroup, u = l.transformCoordToLocal(e, n), c = l.transformCoordToLocal(s.x, s.y), f = this._size;
      u[0] = Math.max(Math.min(f[0], u[0]), 0), o.setShape({
        x: c[0],
        y: 0,
        width: u[0] - c[0],
        height: f[1]
      });
    }, t.prototype._dispatchZoomAction = function(e) {
      var n = this._range;
      this.api.dispatchAction({
        type: "dataZoom",
        from: this.uid,
        dataZoomId: this.dataZoomModel.id,
        animation: e ? Jst : null,
        start: n[0],
        end: n[1]
      });
    }, t.prototype._findCoordRect = function() {
      var e, n = bV(this.dataZoomModel).infoList;
      if (!e && n.length) {
        var i = n[0].model.coordinateSystem;
        e = i.getRect && i.getRect();
      }
      if (!e) {
        var a = this.api.getWidth(), o = this.api.getHeight();
        e = {
          x: a * 0.2,
          y: o * 0.2,
          width: a * 0.6,
          height: o * 0.6
        };
      }
      return e;
    }, t.type = "dataZoom.slider", t;
  }(bw)
);
function tlt(r) {
  var t = {
    x: "y",
    y: "x",
    radius: "angle",
    angle: "radius"
  };
  return t[r];
}
function elt(r) {
  return r === "vertical" ? "ns-resize" : "ew-resize";
}
function GV(r) {
  r.registerComponentModel($st), r.registerComponentView(Qst), ww(r);
}
function rlt(r) {
  jt(UV), jt(GV);
}
var HV = {
  /**
   * @public
   */
  get: function(r, t, e) {
    var n = Ct((nlt[r] || {})[t]);
    return e && et(n) ? n[n.length - 1] : n;
  }
}, nlt = {
  color: {
    active: ["#006edd", "#e0ffff"],
    inactive: [Y.color.transparent]
  },
  colorHue: {
    active: [0, 360],
    inactive: [0, 0]
  },
  colorSaturation: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  colorLightness: {
    active: [0.9, 0.5],
    inactive: [0, 0]
  },
  colorAlpha: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  opacity: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  symbol: {
    active: ["circle", "roundRect", "diamond"],
    inactive: ["none"]
  },
  symbolSize: {
    active: [10, 50],
    inactive: [0, 0]
  }
}, TR = Mr.mapVisual, ilt = Mr.eachVisual, alt = et, AR = L, olt = ei, slt = Me, Tg = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.stateList = ["inRange", "outOfRange"], e.replacableOptionKeys = ["inRange", "outOfRange", "target", "controller", "color"], e.layoutMode = {
        type: "box",
        ignoreSize: !0
      }, e.dataBound = [-1 / 0, 1 / 0], e.targetVisuals = {}, e.controllerVisuals = {}, e;
    }
    return t.prototype.init = function(e, n, i) {
      this.mergeDefaultAndTheme(e, i);
    }, t.prototype.optionUpdated = function(e, n) {
      var i = this.option;
      !n && IV(i, e, this.replacableOptionKeys), this.textStyleModel = this.getModel("textStyle"), this.resetItemSize(), this.completeVisualOption();
    }, t.prototype.resetVisual = function(e) {
      var n = this.stateList;
      e = mt(e, this), this.controllerVisuals = qS(this.option.controller, n, e), this.targetVisuals = qS(this.option.target, n, e);
    }, t.prototype.getItemSymbol = function() {
      return null;
    }, t.prototype.getTargetSeriesIndices = function() {
      var e = this.option.seriesId, n = this.option.seriesIndex;
      n == null && e == null && (n = "all");
      var i = Sc(this.ecModel, "series", {
        index: n,
        id: e
      }, {
        useDefault: !1,
        enableAll: !0,
        enableNone: !1
      }).models;
      return rt(i, function(a) {
        return a.componentIndex;
      });
    }, t.prototype.eachTargetSeries = function(e, n) {
      L(this.getTargetSeriesIndices(), function(i) {
        var a = this.ecModel.getSeriesByIndex(i);
        a && e.call(n, a);
      }, this);
    }, t.prototype.isTargetSeries = function(e) {
      var n = !1;
      return this.eachTargetSeries(function(i) {
        i === e && (n = !0);
      }), n;
    }, t.prototype.formatValueText = function(e, n, i) {
      var a = this.option, o = a.precision, s = this.dataBound, l = a.formatter, u;
      i = i || ["<", ">"], et(e) && (e = e.slice(), u = !0);
      var c = n ? e : u ? [f(e[0]), f(e[1])] : f(e);
      if (pt(l))
        return l.replace("{value}", u ? c[0] : c).replace("{value2}", u ? c[1] : c);
      if (Tt(l))
        return u ? l(e[0], e[1]) : l(e);
      if (u)
        return e[0] === s[0] ? i[0] + " " + c[1] : e[1] === s[1] ? i[1] + " " + c[0] : c[0] + " - " + c[1];
      return c;
      function f(h) {
        return h === s[0] ? "min" : h === s[1] ? "max" : (+h).toFixed(Math.min(o, 20));
      }
    }, t.prototype.resetExtent = function() {
      var e = this.option, n = olt([e.min, e.max]);
      this._dataExtent = n;
    }, t.prototype.getDataDimensionIndex = function(e) {
      var n = this.option.dimension;
      if (n != null)
        return e.getDimensionIndex(n);
      for (var i = e.dimensions, a = i.length - 1; a >= 0; a--) {
        var o = i[a], s = e.getDimensionInfo(o);
        if (!s.isCalculationCoord)
          return s.storeDimIndex;
      }
    }, t.prototype.getExtent = function() {
      return this._dataExtent.slice();
    }, t.prototype.completeVisualOption = function() {
      var e = this.ecModel, n = this.option, i = {
        inRange: n.inRange,
        outOfRange: n.outOfRange
      }, a = n.target || (n.target = {}), o = n.controller || (n.controller = {});
      qt(a, i), qt(o, i);
      var s = this.isCategory();
      l.call(this, a), l.call(this, o), u.call(this, a, "inRange", "outOfRange"), c.call(this, o);
      function l(f) {
        alt(n.color) && !f.inRange && (f.inRange = {
          color: n.color.slice().reverse()
        }), f.inRange = f.inRange || {
          color: e.get("gradientColor")
        };
      }
      function u(f, h, d) {
        var p = f[h], g = f[d];
        p && !g && (g = f[d] = {}, AR(p, function(v, m) {
          if (Mr.isValidType(m)) {
            var y = HV.get(m, "inactive", s);
            y != null && (g[m] = y, m === "color" && !g.hasOwnProperty("opacity") && !g.hasOwnProperty("colorAlpha") && (g.opacity = [0, 0]));
          }
        }));
      }
      function c(f) {
        var h = (f.inRange || {}).symbol || (f.outOfRange || {}).symbol, d = (f.inRange || {}).symbolSize || (f.outOfRange || {}).symbolSize, p = this.get("inactiveColor"), g = this.getItemSymbol(), v = g || "roundRect";
        AR(this.stateList, function(m) {
          var y = this.itemSize, _ = f[m];
          _ || (_ = f[m] = {
            color: s ? p : [p]
          }), _.symbol == null && (_.symbol = h && Ct(h) || (s ? v : [v])), _.symbolSize == null && (_.symbolSize = d && Ct(d) || (s ? y[0] : [y[0], y[0]])), _.symbol = TR(_.symbol, function(S) {
            return S === "none" ? v : S;
          });
          var x = _.symbolSize;
          if (x != null) {
            var b = -1 / 0;
            ilt(x, function(S) {
              S > b && (b = S);
            }), _.symbolSize = TR(x, function(S) {
              return slt(S, [0, b], [0, y[0]], !0);
            });
          }
        }, this);
      }
    }, t.prototype.resetItemSize = function() {
      this.itemSize = [parseFloat(this.get("itemWidth")), parseFloat(this.get("itemHeight"))];
    }, t.prototype.isCategory = function() {
      return !!this.option.categories;
    }, t.prototype.setSelected = function(e) {
    }, t.prototype.getSelected = function() {
      return null;
    }, t.prototype.getValueState = function(e) {
      return null;
    }, t.prototype.getVisualMeta = function(e) {
      return null;
    }, t.type = "visualMap", t.dependencies = ["series"], t.defaultOption = {
      show: !0,
      // zlevel: 0,
      z: 4,
      // seriesIndex: 'all',
      min: 0,
      max: 200,
      left: 0,
      right: null,
      top: null,
      bottom: 0,
      itemWidth: null,
      itemHeight: null,
      inverse: !1,
      orient: "vertical",
      backgroundColor: Y.color.transparent,
      borderColor: Y.color.borderTint,
      contentColor: Y.color.theme[0],
      inactiveColor: Y.color.disabled,
      borderWidth: 0,
      padding: Y.size.m,
      // css
      textGap: 10,
      precision: 0,
      textStyle: {
        color: Y.color.secondary
        // 
      }
    }, t;
  }(re)
), ER = [20, 140], llt = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.optionUpdated = function(e, n) {
      r.prototype.optionUpdated.apply(this, arguments), this.resetExtent(), this.resetVisual(function(i) {
        i.mappingMethod = "linear", i.dataExtent = this.getExtent();
      }), this._resetRange();
    }, t.prototype.resetItemSize = function() {
      r.prototype.resetItemSize.apply(this, arguments);
      var e = this.itemSize;
      (e[0] == null || isNaN(e[0])) && (e[0] = ER[0]), (e[1] == null || isNaN(e[1])) && (e[1] = ER[1]);
    }, t.prototype._resetRange = function() {
      var e = this.getExtent(), n = this.option.range;
      !n || n.auto ? (e.auto = 1, this.option.range = e) : et(n) && (n[0] > n[1] && n.reverse(), n[0] = Math.max(n[0], e[0]), n[1] = Math.min(n[1], e[1]));
    }, t.prototype.completeVisualOption = function() {
      r.prototype.completeVisualOption.apply(this, arguments), L(this.stateList, function(e) {
        var n = this.option.controller[e].symbolSize;
        n && n[0] !== n[1] && (n[0] = n[1] / 3);
      }, this);
    }, t.prototype.setSelected = function(e) {
      this.option.range = e.slice(), this._resetRange();
    }, t.prototype.getSelected = function() {
      var e = this.getExtent(), n = ei((this.get("range") || []).slice());
      return n[0] > e[1] && (n[0] = e[1]), n[1] > e[1] && (n[1] = e[1]), n[0] < e[0] && (n[0] = e[0]), n[1] < e[0] && (n[1] = e[0]), n;
    }, t.prototype.getValueState = function(e) {
      var n = this.option.range, i = this.getExtent(), a = bt(this.option.unboundedRange, !0);
      return (a && n[0] <= i[0] || n[0] <= e) && (a && n[1] >= i[1] || e <= n[1]) ? "inRange" : "outOfRange";
    }, t.prototype.findTargetDataIndices = function(e) {
      var n = [];
      return this.eachTargetSeries(function(i) {
        var a = [], o = i.getData();
        o.each(this.getDataDimensionIndex(o), function(s, l) {
          e[0] <= s && s <= e[1] && a.push(l);
        }, this), n.push({
          seriesId: i.id,
          dataIndex: a
        });
      }, this), n;
    }, t.prototype.getVisualMeta = function(e) {
      var n = CR(this, "outOfRange", this.getExtent()), i = CR(this, "inRange", this.option.range.slice()), a = [];
      function o(d, p) {
        a.push({
          value: d,
          color: e(d, p)
        });
      }
      for (var s = 0, l = 0, u = i.length, c = n.length; l < c && (!i.length || n[l] <= i[0]); l++)
        n[l] < i[s] && o(n[l], "outOfRange");
      for (var f = 1; s < u; s++, f = 0)
        f && a.length && o(i[s], "outOfRange"), o(i[s], "inRange");
      for (var f = 1; l < c; l++)
        (!i.length || i[i.length - 1] < n[l]) && (f && (a.length && o(a[a.length - 1].value, "outOfRange"), f = 0), o(n[l], "outOfRange"));
      var h = a.length;
      return {
        stops: a,
        outerColors: [h ? a[0].color : "transparent", h ? a[h - 1].color : "transparent"]
      };
    }, t.type = "visualMap.continuous", t.defaultOption = jo(Tg.defaultOption, {
      align: "auto",
      calculable: !1,
      hoverLink: !0,
      realtime: !0,
      handleIcon: "path://M-11.39,9.77h0a3.5,3.5,0,0,1-3.5,3.5h-22a3.5,3.5,0,0,1-3.5-3.5h0a3.5,3.5,0,0,1,3.5-3.5h22A3.5,3.5,0,0,1-11.39,9.77Z",
      handleSize: "120%",
      handleStyle: {
        borderColor: Y.color.neutral00,
        borderWidth: 1
      },
      indicatorIcon: "circle",
      indicatorSize: "50%",
      indicatorStyle: {
        borderColor: Y.color.neutral00,
        borderWidth: 2,
        shadowBlur: 2,
        shadowOffsetX: 1,
        shadowOffsetY: 1,
        shadowColor: Y.color.shadow
      }
      // emphasis: {
      //     handleStyle: {
      //         shadowBlur: 3,
      //         shadowOffsetX: 1,
      //         shadowOffsetY: 1,
      //         shadowColor: tokens.color.shadow
      //     }
      // }
    }), t;
  }(Tg)
);
function CR(r, t, e) {
  if (e[0] === e[1])
    return e.slice();
  for (var n = 200, i = (e[1] - e[0]) / n, a = e[0], o = [], s = 0; s <= n && a < e[1]; s++)
    o.push(a), a += i;
  return o.push(e[1]), o;
}
var WV = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.autoPositionValues = {
        left: 1,
        right: 1,
        top: 1,
        bottom: 1
      }, e;
    }
    return t.prototype.init = function(e, n) {
      this.ecModel = e, this.api = n;
    }, t.prototype.render = function(e, n, i, a) {
      if (this.visualMapModel = e, e.get("show") === !1) {
        this.group.removeAll();
        return;
      }
      this.doRender(e, n, i, a);
    }, t.prototype.renderBackground = function(e) {
      var n = this.visualMapModel, i = Fh(n.get("padding") || 0), a = e.getBoundingRect();
      e.add(new te({
        z2: -1,
        silent: !0,
        shape: {
          x: a.x - i[3],
          y: a.y - i[0],
          width: a.width + i[3] + i[1],
          height: a.height + i[0] + i[2]
        },
        style: {
          fill: n.get("backgroundColor"),
          stroke: n.get("borderColor"),
          lineWidth: n.get("borderWidth")
        }
      }));
    }, t.prototype.getControllerVisual = function(e, n, i) {
      i = i || {};
      var a = i.forceState, o = this.visualMapModel, s = {};
      if (n === "color") {
        var l = o.get("contentColor");
        s.color = l;
      }
      function u(d) {
        return s[d];
      }
      function c(d, p) {
        s[d] = p;
      }
      var f = o.controllerVisuals[a || o.getValueState(e)], h = Mr.prepareVisualTypes(f);
      return L(h, function(d) {
        var p = f[d];
        i.convertOpacityToAlpha && d === "opacity" && (d = "colorAlpha", p = f.__alphaForOpacity), Mr.dependsOn(d, n) && p && p.applyVisual(e, u, c);
      }), s[n];
    }, t.prototype.positionGroup = function(e) {
      var n = this.visualMapModel, i = this.api, a = xr(n, i).refContainer;
      um(e, n.getBoxLayoutParams(), a);
    }, t.prototype.doRender = function(e, n, i, a) {
    }, t.type = "visualMap", t;
  }(Ue)
), DR = [["left", "right", "width"], ["top", "bottom", "height"]];
function XV(r, t, e) {
  var n = r.option, i = n.align;
  if (i != null && i !== "auto")
    return i;
  for (var a = {
    width: t.getWidth(),
    height: t.getHeight()
  }, o = n.orient === "horizontal" ? 1 : 0, s = DR[o], l = [0, null, 10], u = {}, c = 0; c < 3; c++)
    u[DR[1 - o][c]] = l[c], u[s[c]] = c === 2 ? e[0] : n[s[c]];
  var f = [["x", "width", 3], ["y", "height", 0]][o], h = He(u, a, n.padding);
  return s[(h.margin[f[2]] || 0) + h[f[0]] + h[f[1]] * 0.5 < a[f[1]] * 0.5 ? 0 : 1];
}
function sv(r, t) {
  return L(r || [], function(e) {
    e.dataIndex != null && (e.dataIndexInside = e.dataIndex, e.dataIndex = null), e.highlightKey = "visualMap" + (t ? t.componentIndex : "");
  }), r;
}
var ki = Me, ult = L, LR = Math.min, O_ = Math.max, clt = 12, flt = 6, hlt = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e._shapes = {}, e._dataInterval = [], e._handleEnds = [], e._hoverLinkDataIndices = [], e;
    }
    return t.prototype.init = function(e, n) {
      r.prototype.init.call(this, e, n), this._hoverLinkFromSeriesMouseOver = mt(this._hoverLinkFromSeriesMouseOver, this), this._hideIndicator = mt(this._hideIndicator, this);
    }, t.prototype.doRender = function(e, n, i, a) {
      (!a || a.type !== "selectDataRange" || a.from !== this.uid) && this._buildView();
    }, t.prototype._buildView = function() {
      this.group.removeAll();
      var e = this.visualMapModel, n = this.group;
      this._orient = e.get("orient"), this._useHandle = e.get("calculable"), this._resetInterval(), this._renderBar(n);
      var i = e.get("text");
      this._renderEndsText(n, i, 0), this._renderEndsText(n, i, 1), this._updateView(!0), this.renderBackground(n), this._updateView(), this._enableHoverLinkToSeries(), this._enableHoverLinkFromSeries(), this.positionGroup(n);
    }, t.prototype._renderEndsText = function(e, n, i) {
      if (n) {
        var a = n[1 - i];
        a = a != null ? a + "" : "";
        var o = this.visualMapModel, s = o.get("textGap"), l = o.itemSize, u = this._shapes.mainGroup, c = this._applyTransform([l[0] / 2, i === 0 ? -s : l[1] + s], u), f = this._applyTransform(i === 0 ? "bottom" : "top", u), h = this._orient, d = this.visualMapModel.textStyleModel;
        this.group.add(new pe({
          style: Oe(d, {
            x: c[0],
            y: c[1],
            verticalAlign: d.get("verticalAlign") || (h === "horizontal" ? "middle" : f),
            align: d.get("align") || (h === "horizontal" ? f : "center"),
            text: a
          })
        }));
      }
    }, t.prototype._renderBar = function(e) {
      var n = this.visualMapModel, i = this._shapes, a = n.itemSize, o = this._orient, s = this._useHandle, l = XV(n, this.api, a), u = i.mainGroup = this._createBarGroup(l), c = new Et();
      u.add(c), c.add(i.outOfRange = RR()), c.add(i.inRange = RR(null, s ? PR(this._orient) : null, mt(this._dragHandle, this, "all", !1), mt(this._dragHandle, this, "all", !0))), c.setClipPath(new te({
        shape: {
          x: 0,
          y: 0,
          width: a[0],
          height: a[1],
          r: 3
        }
      }));
      var f = n.textStyleModel.getTextRect(""), h = O_(f.width, f.height);
      s && (i.handleThumbs = [], i.handleLabels = [], i.handleLabelPoints = [], this._createHandle(n, u, 0, a, h, o), this._createHandle(n, u, 1, a, h, o)), this._createIndicator(n, u, a, h, o), e.add(u);
    }, t.prototype._createHandle = function(e, n, i, a, o, s) {
      var l = mt(this._dragHandle, this, i, !1), u = mt(this._dragHandle, this, i, !0), c = bi(e.get("handleSize"), a[0]), f = fr(e.get("handleIcon"), -c / 2, -c / 2, c, c, null, !0), h = PR(this._orient);
      f.attr({
        cursor: h,
        draggable: !0,
        drift: l,
        ondragend: u,
        onmousemove: function(m) {
          Ua(m.event);
        }
      }), f.x = a[0] / 2, f.useStyle(e.getModel("handleStyle").getItemStyle()), f.setStyle({
        strokeNoScale: !0,
        strokeFirst: !0
      }), f.style.lineWidth *= 2, f.ensureState("emphasis").style = e.getModel(["emphasis", "handleStyle"]).getItemStyle(), Ks(f, !0), n.add(f);
      var d = this.visualMapModel.textStyleModel, p = new pe({
        cursor: h,
        draggable: !0,
        drift: l,
        onmousemove: function(m) {
          Ua(m.event);
        },
        ondragend: u,
        style: Oe(d, {
          x: 0,
          y: 0,
          text: ""
        })
      });
      p.ensureState("blur").style = {
        opacity: 0.1
      }, p.stateTransition = {
        duration: 200
      }, this.group.add(p);
      var g = [c, 0], v = this._shapes;
      v.handleThumbs[i] = f, v.handleLabelPoints[i] = g, v.handleLabels[i] = p;
    }, t.prototype._createIndicator = function(e, n, i, a, o) {
      var s = bi(e.get("indicatorSize"), i[0]), l = fr(e.get("indicatorIcon"), -s / 2, -s / 2, s, s, null, !0);
      l.attr({
        cursor: "move",
        invisible: !0,
        silent: !0,
        x: i[0] / 2
      });
      var u = e.getModel("indicatorStyle").getItemStyle();
      if (l instanceof Vr) {
        var c = l.style;
        l.useStyle(J({
          // TODO other properties like x, y ?
          image: c.image,
          x: c.x,
          y: c.y,
          width: c.width,
          height: c.height
        }, u));
      } else
        l.useStyle(u);
      n.add(l);
      var f = this.visualMapModel.textStyleModel, h = new pe({
        silent: !0,
        invisible: !0,
        style: Oe(f, {
          x: 0,
          y: 0,
          text: ""
        })
      });
      this.group.add(h);
      var d = [(o === "horizontal" ? a / 2 : flt) + i[0] / 2, 0], p = this._shapes;
      p.indicator = l, p.indicatorLabel = h, p.indicatorLabelPoint = d, this._firstShowIndicator = !0;
    }, t.prototype._dragHandle = function(e, n, i, a) {
      if (this._useHandle) {
        if (this._dragging = !n, !n) {
          var o = this._applyTransform([i, a], this._shapes.mainGroup, !0);
          this._updateInterval(e, o[1]), this._hideIndicator(), this._updateView();
        }
        n === !this.visualMapModel.get("realtime") && this.api.dispatchAction({
          type: "selectDataRange",
          from: this.uid,
          visualMapId: this.visualMapModel.id,
          selected: this._dataInterval.slice()
        }), n ? !this._hovering && this._clearHoverLinkToSeries() : IR(this.visualMapModel) && this._doHoverLinkToSeries(this._handleEnds[e], !1);
      }
    }, t.prototype._resetInterval = function() {
      var e = this.visualMapModel, n = this._dataInterval = e.getSelected(), i = e.getExtent(), a = [0, e.itemSize[1]];
      this._handleEnds = [ki(n[0], i, a, !0), ki(n[1], i, a, !0)];
    }, t.prototype._updateInterval = function(e, n) {
      n = n || 0;
      var i = this.visualMapModel, a = this._handleEnds, o = [0, i.itemSize[1]];
      Xo(
        n,
        a,
        o,
        e,
        // cross is forbidden
        0
      );
      var s = i.getExtent();
      this._dataInterval = [ki(a[0], o, s, !0), ki(a[1], o, s, !0)];
    }, t.prototype._updateView = function(e) {
      var n = this.visualMapModel, i = n.getExtent(), a = this._shapes, o = [0, n.itemSize[1]], s = e ? o : this._handleEnds, l = this._createBarVisual(this._dataInterval, i, s, "inRange"), u = this._createBarVisual(i, i, o, "outOfRange");
      a.inRange.setStyle({
        fill: l.barColor
        // opacity: visualInRange.opacity
      }).setShape("points", l.barPoints), a.outOfRange.setStyle({
        fill: u.barColor
        // opacity: visualOutOfRange.opacity
      }).setShape("points", u.barPoints), this._updateHandle(s, l);
    }, t.prototype._createBarVisual = function(e, n, i, a) {
      var o = {
        forceState: a,
        convertOpacityToAlpha: !0
      }, s = this._makeColorGradient(e, o), l = [this.getControllerVisual(e[0], "symbolSize", o), this.getControllerVisual(e[1], "symbolSize", o)], u = this._createBarPoints(i, l);
      return {
        barColor: new wc(0, 0, 0, 1, s),
        barPoints: u,
        handlesColor: [s[0].color, s[s.length - 1].color]
      };
    }, t.prototype._makeColorGradient = function(e, n) {
      var i = 100, a = [], o = (e[1] - e[0]) / i;
      a.push({
        color: this.getControllerVisual(e[0], "color", n),
        offset: 0
      });
      for (var s = 1; s < i; s++) {
        var l = e[0] + o * s;
        if (l > e[1])
          break;
        a.push({
          color: this.getControllerVisual(l, "color", n),
          offset: s / i
        });
      }
      return a.push({
        color: this.getControllerVisual(e[1], "color", n),
        offset: 1
      }), a;
    }, t.prototype._createBarPoints = function(e, n) {
      var i = this.visualMapModel.itemSize;
      return [[i[0] - n[0], e[0]], [i[0], e[0]], [i[0], e[1]], [i[0] - n[1], e[1]]];
    }, t.prototype._createBarGroup = function(e) {
      var n = this._orient, i = this.visualMapModel.get("inverse");
      return new Et(n === "horizontal" && !i ? {
        scaleX: e === "bottom" ? 1 : -1,
        rotation: Math.PI / 2
      } : n === "horizontal" && i ? {
        scaleX: e === "bottom" ? -1 : 1,
        rotation: -Math.PI / 2
      } : n === "vertical" && !i ? {
        scaleX: e === "left" ? 1 : -1,
        scaleY: -1
      } : {
        scaleX: e === "left" ? 1 : -1
      });
    }, t.prototype._updateHandle = function(e, n) {
      if (this._useHandle) {
        var i = this._shapes, a = this.visualMapModel, o = i.handleThumbs, s = i.handleLabels, l = a.itemSize, u = a.getExtent(), c = this._applyTransform("left", i.mainGroup);
        ult([0, 1], function(f) {
          var h = o[f];
          h.setStyle("fill", n.handlesColor[f]), h.y = e[f];
          var d = ki(e[f], [0, l[1]], u, !0), p = this.getControllerVisual(d, "symbolSize");
          h.scaleX = h.scaleY = p / l[0], h.x = l[0] - p / 2;
          var g = yi(i.handleLabelPoints[f], ol(h, this.group));
          if (this._orient === "horizontal") {
            var v = c === "left" || c === "top" ? (l[0] - p) / 2 : (l[0] - p) / -2;
            g[1] += v;
          }
          s[f].setStyle({
            x: g[0],
            y: g[1],
            text: a.formatValueText(this._dataInterval[f]),
            verticalAlign: "middle",
            align: this._orient === "vertical" ? this._applyTransform("left", i.mainGroup) : "center"
          });
        }, this);
      }
    }, t.prototype._showIndicator = function(e, n, i, a) {
      var o = this.visualMapModel, s = o.getExtent(), l = o.itemSize, u = [0, l[1]], c = this._shapes, f = c.indicator;
      if (f) {
        f.attr("invisible", !1);
        var h = {
          convertOpacityToAlpha: !0
        }, d = this.getControllerVisual(e, "color", h), p = this.getControllerVisual(e, "symbolSize"), g = ki(e, s, u, !0), v = l[0] - p / 2, m = {
          x: f.x,
          y: f.y
        };
        f.y = g, f.x = v;
        var y = yi(c.indicatorLabelPoint, ol(f, this.group)), _ = c.indicatorLabel;
        _.attr("invisible", !1);
        var x = this._applyTransform("left", c.mainGroup), b = this._orient, S = b === "horizontal";
        _.setStyle({
          text: (i || "") + o.formatValueText(n),
          verticalAlign: S ? x : "middle",
          align: S ? "center" : x
        });
        var w = {
          x: v,
          y: g,
          style: {
            fill: d
          }
        }, A = {
          style: {
            x: y[0],
            y: y[1]
          }
        };
        if (o.ecModel.isAnimationEnabled() && !this._firstShowIndicator) {
          var T = {
            duration: 100,
            easing: "cubicInOut",
            additive: !0
          };
          f.x = m.x, f.y = m.y, f.animateTo(w, T), _.animateTo(A, T);
        } else
          f.attr(w), _.attr(A);
        this._firstShowIndicator = !1;
        var M = this._shapes.handleLabels;
        if (M)
          for (var E = 0; E < M.length; E++)
            this.api.enterBlur(M[E]);
      }
    }, t.prototype._enableHoverLinkToSeries = function() {
      var e = this;
      this._shapes.mainGroup.on("mousemove", function(n) {
        if (e._hovering = !0, !e._dragging) {
          var i = e.visualMapModel.itemSize, a = e._applyTransform([n.offsetX, n.offsetY], e._shapes.mainGroup, !0, !0);
          a[1] = LR(O_(0, a[1]), i[1]), e._doHoverLinkToSeries(a[1], 0 <= a[0] && a[0] <= i[0]);
        }
      }).on("mouseout", function() {
        e._hovering = !1, !e._dragging && e._clearHoverLinkToSeries();
      });
    }, t.prototype._enableHoverLinkFromSeries = function() {
      var e = this.api.getZr();
      this.visualMapModel.option.hoverLink ? (e.on("mouseover", this._hoverLinkFromSeriesMouseOver, this), e.on("mouseout", this._hideIndicator, this)) : this._clearHoverLinkFromSeries();
    }, t.prototype._doHoverLinkToSeries = function(e, n) {
      var i = this.visualMapModel, a = i.itemSize;
      if (i.option.hoverLink) {
        var o = [0, a[1]], s = i.getExtent();
        e = LR(O_(o[0], e), o[1]);
        var l = dlt(i, s, o), u = [e - l, e + l], c = ki(e, o, s, !0), f = [ki(u[0], o, s, !0), ki(u[1], o, s, !0)];
        u[0] < o[0] && (f[0] = -1 / 0), u[1] > o[1] && (f[1] = 1 / 0), n && (f[0] === -1 / 0 ? this._showIndicator(c, f[1], "< ", l) : f[1] === 1 / 0 ? this._showIndicator(c, f[0], "> ", l) : this._showIndicator(c, c, " ", l));
        var h = this._hoverLinkDataIndices, d = [];
        (n || IR(i)) && (d = this._hoverLinkDataIndices = i.findTargetDataIndices(f));
        var p = e6(h, d);
        this._dispatchHighDown("downplay", sv(p[0], i)), this._dispatchHighDown("highlight", sv(p[1], i));
      }
    }, t.prototype._hoverLinkFromSeriesMouseOver = function(e) {
      var n;
      if (Js(e.target, function(l) {
        var u = zt(l);
        if (u.dataIndex != null)
          return n = u, !0;
      }, !0), !!n) {
        var i = this.ecModel.getSeriesByIndex(n.seriesIndex), a = this.visualMapModel;
        if (a.isTargetSeries(i)) {
          var o = i.getData(n.dataType), s = o.getStore().get(a.getDataDimensionIndex(o), n.dataIndex);
          isNaN(s) || this._showIndicator(s, s);
        }
      }
    }, t.prototype._hideIndicator = function() {
      var e = this._shapes;
      e.indicator && e.indicator.attr("invisible", !0), e.indicatorLabel && e.indicatorLabel.attr("invisible", !0);
      var n = this._shapes.handleLabels;
      if (n)
        for (var i = 0; i < n.length; i++)
          this.api.leaveBlur(n[i]);
    }, t.prototype._clearHoverLinkToSeries = function() {
      this._hideIndicator();
      var e = this._hoverLinkDataIndices;
      this._dispatchHighDown("downplay", sv(e, this.visualMapModel)), e.length = 0;
    }, t.prototype._clearHoverLinkFromSeries = function() {
      this._hideIndicator();
      var e = this.api.getZr();
      e.off("mouseover", this._hoverLinkFromSeriesMouseOver), e.off("mouseout", this._hideIndicator);
    }, t.prototype._applyTransform = function(e, n, i, a) {
      var o = ol(n, a ? null : this.group);
      return et(e) ? yi(e, o, i) : am(e, o, i);
    }, t.prototype._dispatchHighDown = function(e, n) {
      n && n.length && this.api.dispatchAction({
        type: e,
        batch: n
      });
    }, t.prototype.dispose = function() {
      this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries();
    }, t.type = "visualMap.continuous", t;
  }(WV)
);
function RR(r, t, e, n) {
  return new jr({
    shape: {
      points: r
    },
    draggable: !!e,
    cursor: t,
    drift: e,
    onmousemove: function(i) {
      Ua(i.event);
    },
    ondragend: n
  });
}
function dlt(r, t, e) {
  var n = clt / 2, i = r.get("hoverLinkDataSize");
  return i && (n = ki(i, t, e, !0) / 2), n;
}
function IR(r) {
  var t = r.get("hoverLinkOnHandle");
  return !!(t ?? r.get("realtime"));
}
function PR(r) {
  return r === "vertical" ? "ns-resize" : "ew-resize";
}
var plt = {
  type: "selectDataRange",
  event: "dataRangeSelected",
  // FIXME use updateView appears wrong
  update: "update"
}, vlt = function(r, t) {
  t.eachComponent({
    mainType: "visualMap",
    query: r
  }, function(e) {
    e.setSelected(r.selected);
  });
}, glt = [
  {
    createOnAllSeries: !0,
    reset: function(r, t) {
      var e = [];
      return t.eachComponent("visualMap", function(n) {
        var i = r.pipelineContext;
        !n.isTargetSeries(r) || i && i.large || e.push(Bot(n.stateList, n.targetVisuals, mt(n.getValueState, n), n.getDataDimensionIndex(r.getData())));
      }), e;
    }
  },
  // Only support color.
  {
    createOnAllSeries: !0,
    reset: function(r, t) {
      var e = r.getData(), n = [];
      t.eachComponent("visualMap", function(i) {
        if (i.isTargetSeries(r)) {
          var a = i.getVisualMeta(mt(mlt, null, r, i)) || {
            stops: [],
            outerColors: []
          }, o = i.getDataDimensionIndex(e);
          o >= 0 && (a.dimension = o, n.push(a));
        }
      }), r.getData().setVisual("visualMeta", n);
    }
  }
];
function mlt(r, t, e, n) {
  for (var i = t.targetVisuals[n], a = Mr.prepareVisualTypes(i), o = {
    color: Uh(r.getData(), "color")
    // default color.
  }, s = 0, l = a.length; s < l; s++) {
    var u = a[s], c = i[u === "opacity" ? "__alphaForOpacity" : u];
    c && c.applyVisual(e, f, h);
  }
  return o.color;
  function f(d) {
    return o[d];
  }
  function h(d, p) {
    o[d] = p;
  }
}
var NR = L;
function ylt(r) {
  var t = r && r.visualMap;
  et(t) || (t = t ? [t] : []), NR(t, function(e) {
    if (e) {
      wu(e, "splitList") && !wu(e, "pieces") && (e.pieces = e.splitList, delete e.splitList);
      var n = e.pieces;
      n && et(n) && NR(n, function(i) {
        Dt(i) && (wu(i, "start") && !wu(i, "min") && (i.min = i.start), wu(i, "end") && !wu(i, "max") && (i.max = i.end));
      });
    }
  });
}
function wu(r, t) {
  return r && r.hasOwnProperty && r.hasOwnProperty(t);
}
var OR = !1;
function YV(r) {
  OR || (OR = !0, r.registerSubTypeDefaulter("visualMap", function(t) {
    return !t.categories && (!(t.pieces ? t.pieces.length > 0 : t.splitNumber > 0) || t.calculable) ? "continuous" : "piecewise";
  }), r.registerAction(plt, vlt), L(glt, function(t) {
    r.registerVisual(r.PRIORITY.VISUAL.COMPONENT, t);
  }), r.registerPreprocessor(ylt));
}
function $V(r) {
  r.registerComponentModel(llt), r.registerComponentView(hlt), YV(r);
}
var _lt = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e._pieceList = [], e;
    }
    return t.prototype.optionUpdated = function(e, n) {
      r.prototype.optionUpdated.apply(this, arguments), this.resetExtent();
      var i = this._mode = this._determineMode();
      this._pieceList = [], xlt[this._mode].call(this, this._pieceList), this._resetSelected(e, n);
      var a = this.option.categories;
      this.resetVisual(function(o, s) {
        i === "categories" ? (o.mappingMethod = "category", o.categories = Ct(a)) : (o.dataExtent = this.getExtent(), o.mappingMethod = "piecewise", o.pieceList = rt(this._pieceList, function(l) {
          return l = Ct(l), s !== "inRange" && (l.visual = null), l;
        }));
      });
    }, t.prototype.completeVisualOption = function() {
      var e = this.option, n = {}, i = Mr.listVisualTypes(), a = this.isCategory();
      L(e.pieces, function(s) {
        L(i, function(l) {
          s.hasOwnProperty(l) && (n[l] = 1);
        });
      }), L(n, function(s, l) {
        var u = !1;
        L(this.stateList, function(c) {
          u = u || o(e, c, l) || o(e.target, c, l);
        }, this), !u && L(this.stateList, function(c) {
          (e[c] || (e[c] = {}))[l] = HV.get(l, c === "inRange" ? "active" : "inactive", a);
        });
      }, this);
      function o(s, l, u) {
        return s && s[l] && s[l].hasOwnProperty(u);
      }
      r.prototype.completeVisualOption.apply(this, arguments);
    }, t.prototype._resetSelected = function(e, n) {
      var i = this.option, a = this._pieceList, o = (n ? i : e).selected || {};
      if (i.selected = o, L(a, function(l, u) {
        var c = this.getSelectedMapKey(l);
        o.hasOwnProperty(c) || (o[c] = !0);
      }, this), i.selectedMode === "single") {
        var s = !1;
        L(a, function(l, u) {
          var c = this.getSelectedMapKey(l);
          o[c] && (s ? o[c] = !1 : s = !0);
        }, this);
      }
    }, t.prototype.getItemSymbol = function() {
      return this.get("itemSymbol");
    }, t.prototype.getSelectedMapKey = function(e) {
      return this._mode === "categories" ? e.value + "" : e.index + "";
    }, t.prototype.getPieceList = function() {
      return this._pieceList;
    }, t.prototype._determineMode = function() {
      var e = this.option;
      return e.pieces && e.pieces.length > 0 ? "pieces" : this.option.categories ? "categories" : "splitNumber";
    }, t.prototype.setSelected = function(e) {
      this.option.selected = Ct(e);
    }, t.prototype.getValueState = function(e) {
      var n = Mr.findPieceIndex(e, this._pieceList);
      return n != null && this.option.selected[this.getSelectedMapKey(this._pieceList[n])] ? "inRange" : "outOfRange";
    }, t.prototype.findTargetDataIndices = function(e) {
      var n = [], i = this._pieceList;
      return this.eachTargetSeries(function(a) {
        var o = [], s = a.getData();
        s.each(this.getDataDimensionIndex(s), function(l, u) {
          var c = Mr.findPieceIndex(l, i);
          c === e && o.push(u);
        }, this), n.push({
          seriesId: a.id,
          dataIndex: o
        });
      }, this), n;
    }, t.prototype.getRepresentValue = function(e) {
      var n;
      if (this.isCategory())
        n = e.value;
      else if (e.value != null)
        n = e.value;
      else {
        var i = e.interval || [];
        n = i[0] === -1 / 0 && i[1] === 1 / 0 ? 0 : (i[0] + i[1]) / 2;
      }
      return n;
    }, t.prototype.getVisualMeta = function(e) {
      if (this.isCategory())
        return;
      var n = [], i = ["", ""], a = this;
      function o(c, f) {
        var h = a.getRepresentValue({
          interval: c
        });
        f || (f = a.getValueState(h));
        var d = e(h, f);
        c[0] === -1 / 0 ? i[0] = d : c[1] === 1 / 0 ? i[1] = d : n.push({
          value: c[0],
          color: d
        }, {
          value: c[1],
          color: d
        });
      }
      var s = this._pieceList.slice();
      if (!s.length)
        s.push({
          interval: [-1 / 0, 1 / 0]
        });
      else {
        var l = s[0].interval[0];
        l !== -1 / 0 && s.unshift({
          interval: [-1 / 0, l]
        }), l = s[s.length - 1].interval[1], l !== 1 / 0 && s.push({
          interval: [l, 1 / 0]
        });
      }
      var u = -1 / 0;
      return L(s, function(c) {
        var f = c.interval;
        f && (f[0] > u && o([u, f[0]], "outOfRange"), o(f.slice()), u = f[1]);
      }, this), {
        stops: n,
        outerColors: i
      };
    }, t.type = "visualMap.piecewise", t.defaultOption = jo(Tg.defaultOption, {
      selected: null,
      minOpen: !1,
      maxOpen: !1,
      align: "auto",
      itemWidth: 20,
      itemHeight: 14,
      itemSymbol: "roundRect",
      pieces: null,
      categories: null,
      splitNumber: 5,
      selectedMode: "multiple",
      itemGap: 10,
      hoverLink: !0
      // Enable hover highlight.
    }), t;
  }(Tg)
), xlt = {
  splitNumber: function(r) {
    var t = this.option, e = Math.min(t.precision, 20), n = this.getExtent(), i = t.splitNumber;
    i = Math.max(parseInt(i, 10), 1), t.splitNumber = i;
    for (var a = (n[1] - n[0]) / i; +a.toFixed(e) !== a && e < 5; )
      e++;
    t.precision = e, a = +a.toFixed(e), t.minOpen && r.push({
      interval: [-1 / 0, n[0]],
      close: [0, 0]
    });
    for (var o = 0, s = n[0]; o < i; s += a, o++) {
      var l = o === i - 1 ? n[1] : s + a;
      r.push({
        interval: [s, l],
        close: [1, 1]
      });
    }
    t.maxOpen && r.push({
      interval: [n[1], 1 / 0],
      close: [0, 0]
    }), jT(r), L(r, function(u, c) {
      u.index = c, u.text = this.formatValueText(u.interval);
    }, this);
  },
  categories: function(r) {
    var t = this.option;
    L(t.categories, function(e) {
      r.push({
        text: this.formatValueText(e, !0),
        value: e
      });
    }, this), kR(t, r);
  },
  pieces: function(r) {
    var t = this.option;
    L(t.pieces, function(e, n) {
      Dt(e) || (e = {
        value: e
      });
      var i = {
        text: "",
        index: n
      };
      if (e.label != null && (i.text = e.label), e.hasOwnProperty("value")) {
        var a = i.value = e.value;
        i.interval = [a, a], i.close = [1, 1];
      } else {
        for (var o = i.interval = [], s = i.close = [0, 0], l = [1, 0, 1], u = [-1 / 0, 1 / 0], c = [], f = 0; f < 2; f++) {
          for (var h = [["gte", "gt", "min"], ["lte", "lt", "max"]][f], d = 0; d < 3 && o[f] == null; d++)
            o[f] = e[h[d]], s[f] = l[d], c[f] = d === 2;
          o[f] == null && (o[f] = u[f]);
        }
        c[0] && o[1] === 1 / 0 && (s[0] = 0), c[1] && o[0] === -1 / 0 && (s[1] = 0), process.env.NODE_ENV !== "production" && o[0] > o[1] && console.warn("Piece " + n + "is illegal: " + o + " lower bound should not greater then uppper bound."), o[0] === o[1] && s[0] && s[1] && (i.value = o[0]);
      }
      i.visual = Mr.retrieveVisuals(e), r.push(i);
    }, this), kR(t, r), jT(r), L(r, function(e) {
      var n = e.close, i = [["<", ""][n[1]], [">", ""][n[0]]];
      e.text = e.text || this.formatValueText(e.value != null ? e.value : e.interval, !1, i);
    }, this);
  }
};
function kR(r, t) {
  var e = r.inverse;
  (r.orient === "vertical" ? !e : e) && t.reverse();
}
var Slt = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.doRender = function() {
      var e = this.group;
      e.removeAll();
      var n = this.visualMapModel, i = n.get("textGap"), a = n.textStyleModel, o = this._getItemAlign(), s = n.itemSize, l = this._getViewData(), u = l.endsText, c = gr(n.get("showLabel", !0), !u), f = !n.get("selectedMode");
      u && this._renderEndsText(e, u[0], s, c, o), L(l.viewPieceList, function(h) {
        var d = h.piece, p = new Et();
        p.onclick = mt(this._onItemClick, this, d), this._enableHoverLink(p, h.indexInModelPieceList);
        var g = n.getRepresentValue(d);
        if (this._createItemSymbol(p, g, [0, 0, s[0], s[1]], f), c) {
          var v = this.visualMapModel.getValueState(g), m = a.get("align") || o;
          p.add(new pe({
            style: Oe(a, {
              x: m === "right" ? -i : s[0] + i,
              y: s[1] / 2,
              text: d.text,
              verticalAlign: a.get("verticalAlign") || "middle",
              align: m,
              opacity: bt(a.get("opacity"), v === "outOfRange" ? 0.5 : 1)
            }),
            silent: f
          }));
        }
        e.add(p);
      }, this), u && this._renderEndsText(e, u[1], s, c, o), sl(n.get("orient"), e, n.get("itemGap")), this.renderBackground(e), this.positionGroup(e);
    }, t.prototype._enableHoverLink = function(e, n) {
      var i = this;
      e.on("mouseover", function() {
        return a("highlight");
      }).on("mouseout", function() {
        return a("downplay");
      });
      var a = function(o) {
        var s = i.visualMapModel;
        s.option.hoverLink && i.api.dispatchAction({
          type: o,
          batch: sv(s.findTargetDataIndices(n), s)
        });
      };
    }, t.prototype._getItemAlign = function() {
      var e = this.visualMapModel, n = e.option;
      if (n.orient === "vertical")
        return XV(e, this.api, e.itemSize);
      var i = n.align;
      return (!i || i === "auto") && (i = "left"), i;
    }, t.prototype._renderEndsText = function(e, n, i, a, o) {
      if (n) {
        var s = new Et(), l = this.visualMapModel.textStyleModel;
        s.add(new pe({
          style: Oe(l, {
            x: a ? o === "right" ? i[0] : 0 : i[0] / 2,
            y: i[1] / 2,
            verticalAlign: "middle",
            align: a ? o : "center",
            text: n
          })
        })), e.add(s);
      }
    }, t.prototype._getViewData = function() {
      var e = this.visualMapModel, n = rt(e.getPieceList(), function(s, l) {
        return {
          piece: s,
          indexInModelPieceList: l
        };
      }), i = e.get("text"), a = e.get("orient"), o = e.get("inverse");
      return (a === "horizontal" ? o : !o) ? n.reverse() : i && (i = i.slice().reverse()), {
        viewPieceList: n,
        endsText: i
      };
    }, t.prototype._createItemSymbol = function(e, n, i, a) {
      var o = fr(
        // symbol will be string
        this.getControllerVisual(n, "symbol"),
        i[0],
        i[1],
        i[2],
        i[3],
        // color will be string
        this.getControllerVisual(n, "color")
      );
      o.silent = a, e.add(o);
    }, t.prototype._onItemClick = function(e) {
      var n = this.visualMapModel, i = n.option, a = i.selectedMode;
      if (a) {
        var o = Ct(i.selected), s = n.getSelectedMapKey(e);
        a === "single" || a === !0 ? (o[s] = !0, L(o, function(l, u) {
          o[u] = u === s;
        })) : o[s] = !o[s], this.api.dispatchAction({
          type: "selectDataRange",
          from: this.uid,
          visualMapId: this.visualMapModel.id,
          selected: o
        });
      }
    }, t.type = "visualMap.piecewise", t;
  }(WV)
);
function ZV(r) {
  r.registerComponentModel(_lt), r.registerComponentView(Slt), YV(r);
}
function blt(r) {
  jt($V), jt(ZV);
}
var wlt = (
  /** @class */
  function() {
    function r(t) {
      this._thumbnailModel = t;
    }
    return r.prototype.reset = function(t) {
      this._renderVersion = t.getMainProcessVersion();
    }, r.prototype.renderContent = function(t) {
      var e = t.api.getViewOfComponentModel(this._thumbnailModel);
      e && (t.group.silent = !0, e.renderContent({
        group: t.group,
        targetTrans: t.targetTrans,
        z2Range: SN(t.group),
        roamType: t.roamType,
        viewportRect: t.viewportRect,
        renderVersion: this._renderVersion
      }));
    }, r.prototype.updateWindow = function(t, e) {
      var n = e.getViewOfComponentModel(this._thumbnailModel);
      n && n.updateWindow({
        targetTrans: t,
        renderVersion: this._renderVersion
      });
    }, r;
  }()
), Mlt = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e.preventAutoZ = !0, e;
    }
    return t.prototype.optionUpdated = function(e, n) {
      this._updateBridge();
    }, t.prototype._updateBridge = function() {
      var e = this._birdge = this._birdge || new wlt(this);
      if (this._target = null, this.ecModel.eachSeries(function(i) {
        nL(i, null);
      }), this.shouldShow()) {
        var n = this.getTarget();
        nL(n.baseMapProvider, e);
      }
    }, t.prototype.shouldShow = function() {
      return this.getShallow("show", !0);
    }, t.prototype.getBridge = function() {
      return this._birdge;
    }, t.prototype.getTarget = function() {
      if (this._target)
        return this._target;
      var e = this.getReferringComponents("series", {
        useDefault: !1,
        enableAll: !1,
        enableNone: !1
      }).models[0];
      return e ? e.subType !== "graph" && (e = null, process.env.NODE_ENV !== "production" && ce("series." + e.subType + " is not supported in thumbnail.", !0)) : e = this.ecModel.queryComponents({
        mainType: "series",
        subType: "graph"
      })[0], this._target = {
        baseMapProvider: e
      }, this._target;
    }, t.type = "thumbnail", t.layoutMode = "box", t.dependencies = ["series", "geo"], t.defaultOption = {
      show: !0,
      right: 1,
      bottom: 1,
      height: "25%",
      width: "25%",
      itemStyle: {
        // Use echarts option.backgorundColor by default.
        borderColor: Y.color.border,
        borderWidth: 2
      },
      windowStyle: {
        borderWidth: 1,
        color: Y.color.neutral30,
        borderColor: Y.color.neutral40,
        opacity: 0.3
      },
      z: 10
    }, t;
  }(re)
), Tlt = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = t.type, e;
    }
    return t.prototype.render = function(e, n, i) {
      if (this._api = i, this._model = e, this._coordSys || (this._coordSys = new Pl()), !this._isEnabled()) {
        this._clear();
        return;
      }
      this._renderVersion = i.getMainProcessVersion();
      var a = this.group;
      a.removeAll();
      var o = e.getModel("itemStyle"), s = o.getItemStyle();
      s.fill == null && (s.fill = n.get("backgroundColor") || Y.color.neutral00);
      var l = xr(e, i).refContainer, u = He(HN(e, !0), l), c = s.lineWidth || 0, f = this._contentRect = gl(u.clone(), c / 2, !0, !0), h = new Et();
      a.add(h), h.setClipPath(new te({
        shape: f.plain()
      }));
      var d = this._targetGroup = new Et();
      h.add(d);
      var p = u.plain();
      p.r = o.getShallow("borderRadius", !0), a.add(this._bgRect = new te({
        style: s,
        shape: p,
        silent: !1,
        cursor: "grab"
      }));
      var g = e.getModel("windowStyle"), v = g.getShallow("borderRadius", !0);
      h.add(this._windowRect = new te({
        shape: {
          x: 0,
          y: 0,
          width: 0,
          height: 0,
          r: v
        },
        style: g.getItemStyle(),
        silent: !1,
        cursor: "grab"
      })), this._dealRenderContent(), this._dealUpdateWindow(), VR(e, this);
    }, t.prototype.renderContent = function(e) {
      this._bridgeRendered = e, this._isEnabled() && (this._dealRenderContent(), this._dealUpdateWindow(), VR(this._model, this));
    }, t.prototype._dealRenderContent = function() {
      var e = this._bridgeRendered;
      if (!(!e || e.renderVersion !== this._renderVersion)) {
        var n = this._targetGroup, i = this._coordSys, a = this._contentRect;
        if (n.removeAll(), !!e) {
          var o = e.group, s = o.getBoundingRect();
          n.add(o), this._bgRect.z2 = e.z2Range.min - 10, i.setBoundingRect(s.x, s.y, s.width, s.height);
          var l = He({
            left: "center",
            top: "center",
            aspect: s.width / s.height
          }, a);
          i.setViewRect(l.x, l.y, l.width, l.height), o.attr(i.getTransformInfo().raw), this._windowRect.z2 = e.z2Range.max + 10, this._resetRoamController(e.roamType);
        }
      }
    }, t.prototype.updateWindow = function(e) {
      var n = this._bridgeRendered;
      n && n.renderVersion === e.renderVersion && (n.targetTrans = e.targetTrans), this._isEnabled() && this._dealUpdateWindow();
    }, t.prototype._dealUpdateWindow = function() {
      var e = this._bridgeRendered;
      if (!(!e || e.renderVersion !== this._renderVersion)) {
        var n = Si([], e.targetTrans), i = ji([], this._coordSys.transform, n);
        this._transThisToTarget = Si([], i);
        var a = e.viewportRect;
        a ? a = a.clone() : a = new Bt(0, 0, this._api.getWidth(), this._api.getHeight()), a.applyTransform(i);
        var o = this._windowRect, s = o.shape.r;
        o.setShape(kt({
          r: s
        }, a));
      }
    }, t.prototype._resetRoamController = function(e) {
      var n = this, i = this._api, a = this._roamController;
      if (a || (a = this._roamController = new Il(i.getZr())), !e || !this._isEnabled()) {
        a.disable();
        return;
      }
      a.enable(e, {
        api: i,
        zInfo: {
          component: this._model
        },
        triggerInfo: {
          roamTrigger: null,
          isInSelf: function(o, s, l) {
            return n._contentRect.contain(s, l);
          }
        }
      }), a.off("pan").off("zoom").on("pan", mt(this._onPan, this)).on("zoom", mt(this._onZoom, this));
    }, t.prototype._onPan = function(e) {
      var n = this._transThisToTarget;
      if (!(!this._isEnabled() || !n)) {
        var i = rr([], [e.oldX, e.oldY], n), a = rr([], [e.oldX - e.dx, e.oldY - e.dy], n);
        this._api.dispatchAction(BR(this._model.getTarget().baseMapProvider, {
          dx: a[0] - i[0],
          dy: a[1] - i[1]
        }));
      }
    }, t.prototype._onZoom = function(e) {
      var n = this._transThisToTarget;
      if (!(!this._isEnabled() || !n)) {
        var i = rr([], [e.originX, e.originY], n);
        this._api.dispatchAction(BR(this._model.getTarget().baseMapProvider, {
          zoom: 1 / e.scale,
          originX: i[0],
          originY: i[1]
        }));
      }
    }, t.prototype._isEnabled = function() {
      var e = this._model;
      if (!e || !e.shouldShow())
        return !1;
      var n = e.getTarget().baseMapProvider;
      return !!n;
    }, t.prototype._clear = function() {
      this.group.removeAll(), this._bridgeRendered = null, this._roamController && this._roamController.disable();
    }, t.prototype.remove = function() {
      this._clear();
    }, t.prototype.dispose = function() {
      this._clear();
    }, t.type = "thumbnail", t;
  }(Ue)
);
function BR(r, t) {
  var e = r.mainType === "series" ? r.subType + "Roam" : r.mainType + "Roam", n = {
    type: e
  };
  return n[r.mainType + "Id"] = r.id, J(n, t), n;
}
function VR(r, t) {
  var e = ml(r);
  om(t.group, e.z, e.zlevel);
}
function Alt(r) {
  r.registerComponentModel(Mlt), r.registerComponentView(Tlt);
}
var Elt = {
  label: {
    enabled: !0
  },
  decal: {
    show: !1
  }
}, FR = ee(), Clt = {};
function Dlt(r, t) {
  var e = r.getModel("aria");
  if (!e.get("enabled"))
    return;
  var n = Ct(Elt);
  qt(n.label, r.getLocaleModel().get("aria"), !1), qt(e.option, n, !1), i(), a();
  function i() {
    var u = e.getModel("decal"), c = u.get("show");
    if (c) {
      var f = wt();
      r.eachSeries(function(h) {
        if (!h.isColorBySeries()) {
          var d = f.get(h.type);
          d || (d = {}, f.set(h.type, d)), FR(h).scope = d;
        }
      }), r.eachRawSeries(function(h) {
        if (r.isSeriesFiltered(h))
          return;
        if (Tt(h.enableAriaDecal)) {
          h.enableAriaDecal();
          return;
        }
        var d = h.getData();
        if (h.isColorBySeries()) {
          var y = Wx(h.ecModel, h.name, Clt, r.getSeriesCount()), _ = d.getVisual("decal");
          d.setVisual("decal", x(_, y));
        } else {
          var p = h.getRawData(), g = {}, v = FR(h).scope;
          d.each(function(b) {
            var S = d.getRawIndex(b);
            g[S] = b;
          });
          var m = p.count();
          p.each(function(b) {
            var S = g[b], w = p.getName(b) || b + "", A = Wx(h.ecModel, w, v, m), T = d.getItemVisual(S, "decal");
            d.setItemVisual(S, "decal", x(T, A));
          });
        }
        function x(b, S) {
          var w = b ? J(J({}, S), b) : S;
          return w.dirty = !0, w;
        }
      });
    }
  }
  function a() {
    var u = t.getZr().dom;
    if (u) {
      var c = r.getLocaleModel().get("aria"), f = e.getModel("label");
      if (f.option = kt(f.option, c), !!f.get("enabled")) {
        if (u.setAttribute("role", "img"), f.get("description")) {
          u.setAttribute("aria-label", f.get("description"));
          return;
        }
        var h = r.getSeriesCount(), d = f.get(["data", "maxCount"]) || 10, p = f.get(["series", "maxCount"]) || 10, g = Math.min(h, p), v;
        if (!(h < 1)) {
          var m = s();
          if (m) {
            var y = f.get(["general", "withTitle"]);
            v = o(y, {
              title: m
            });
          } else
            v = f.get(["general", "withoutTitle"]);
          var _ = [], x = h > 1 ? f.get(["series", "multiple", "prefix"]) : f.get(["series", "single", "prefix"]);
          v += o(x, {
            seriesCount: h
          }), r.eachSeries(function(A, T) {
            if (T < g) {
              var M = void 0, E = A.get("name"), R = E ? "withName" : "withoutName";
              M = h > 1 ? f.get(["series", "multiple", R]) : f.get(["series", "single", R]), M = o(M, {
                seriesId: A.seriesIndex,
                seriesName: A.get("name"),
                seriesType: l(A.subType)
              });
              var C = A.getData();
              if (C.count() > d) {
                var D = f.get(["data", "partialData"]);
                M += o(D, {
                  displayCnt: d
                });
              } else
                M += f.get(["data", "allData"]);
              for (var I = f.get(["data", "separator", "middle"]), P = f.get(["data", "separator", "end"]), O = f.get(["data", "excludeDimensionId"]), N = [], B = 0; B < C.count(); B++)
                if (B < d) {
                  var F = C.getName(B), G = O ? Te(C.getValues(B), function(K, U) {
                    return Zt(O, U) === -1;
                  }) : C.getValues(B), X = f.get(["data", F ? "withName" : "withoutName"]);
                  N.push(o(X, {
                    name: F,
                    value: G.join(I)
                  }));
                }
              M += N.join(I) + P, _.push(M);
            }
          });
          var b = f.getModel(["series", "multiple", "separator"]), S = b.get("middle"), w = b.get("end");
          v += _.join(S) + w, u.setAttribute("aria-label", v);
        }
      }
    }
  }
  function o(u, c) {
    if (!pt(u))
      return u;
    var f = u;
    return L(c, function(h, d) {
      f = f.replace(new RegExp("\\{\\s*" + d + "\\s*\\}", "g"), h);
    }), f;
  }
  function s() {
    var u = r.get("title");
    return u && u.length && (u = u[0]), u && u.text;
  }
  function l(u) {
    var c = r.getLocaleModel().get(["series", "typeNames"]);
    return c[u] || c.chart;
  }
}
function Llt(r) {
  if (!(!r || !r.aria)) {
    var t = r.aria;
    t.show != null && (t.enabled = t.show), t.label = t.label || {}, L(["description", "general", "series", "data"], function(e) {
      t[e] != null && (t.label[e] = t[e]);
    });
  }
}
function Rlt(r) {
  r.registerPreprocessor(Llt), r.registerVisual(r.PRIORITY.VISUAL.ARIA, Dlt);
}
var zR = {
  value: "eq",
  // PENDING: not good for literal semantic?
  "<": "lt",
  "<=": "lte",
  ">": "gt",
  ">=": "gte",
  "=": "eq",
  "!=": "ne",
  "<>": "ne"
  // Might be misleading for sake of the difference between '==' and '===',
  // so don't support them.
  // '==': 'eq',
  // '===': 'seq',
  // '!==': 'sne'
  // PENDING: Whether support some common alias "ge", "le", "neq"?
  // ge: 'gte',
  // le: 'lte',
  // neq: 'ne',
}, Ilt = (
  /** @class */
  function() {
    function r(t) {
      var e = this._condVal = pt(t) ? new RegExp(t) : KI(t) ? t : null;
      if (e == null) {
        var n = "";
        process.env.NODE_ENV !== "production" && (n = hn("Illegal regexp", t, "in")), we(n);
      }
    }
    return r.prototype.evaluate = function(t) {
      var e = typeof t;
      return pt(e) ? this._condVal.test(t) : fe(e) ? this._condVal.test(t + "") : !1;
    }, r;
  }()
), Plt = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.evaluate = function() {
      return this.value;
    }, r;
  }()
), Nlt = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.evaluate = function() {
      for (var t = this.children, e = 0; e < t.length; e++)
        if (!t[e].evaluate())
          return !1;
      return !0;
    }, r;
  }()
), Olt = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.evaluate = function() {
      for (var t = this.children, e = 0; e < t.length; e++)
        if (t[e].evaluate())
          return !0;
      return !1;
    }, r;
  }()
), klt = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.evaluate = function() {
      return !this.child.evaluate();
    }, r;
  }()
), Blt = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.evaluate = function() {
      for (var t = !!this.valueParser, e = this.getValue, n = e(this.valueGetterParam), i = t ? this.valueParser(n) : null, a = 0; a < this.subCondList.length; a++)
        if (!this.subCondList[a].evaluate(t ? i : n))
          return !1;
      return !0;
    }, r;
  }()
);
function Rw(r, t) {
  if (r === !0 || r === !1) {
    var e = new Plt();
    return e.value = r, e;
  }
  var n = "";
  return qV(r) || (process.env.NODE_ENV !== "production" && (n = hn("Illegal config. Expect a plain object but actually", r)), we(n)), r.and ? UR("and", r, t) : r.or ? UR("or", r, t) : r.not ? Vlt(r, t) : Flt(r, t);
}
function UR(r, t, e) {
  var n = t[r], i = "";
  process.env.NODE_ENV !== "production" && (i = hn('"and"/"or" condition should only be `' + r + ": [...]` and must not be empty array.", "Illegal condition:", t)), et(n) || we(i), n.length || we(i);
  var a = r === "and" ? new Nlt() : new Olt();
  return a.children = rt(n, function(o) {
    return Rw(o, e);
  }), a.children.length || we(i), a;
}
function Vlt(r, t) {
  var e = r.not, n = "";
  process.env.NODE_ENV !== "production" && (n = hn('"not" condition should only be `not: {}`.', "Illegal condition:", r)), qV(e) || we(n);
  var i = new klt();
  return i.child = Rw(e, t), i.child || we(n), i;
}
function Flt(r, t) {
  for (var e = "", n = t.prepareGetValue(r), i = [], a = se(r), o = r.parser, s = o ? cO(o) : null, l = 0; l < a.length; l++) {
    var u = a[l];
    if (!(u === "parser" || t.valueGetterAttrMap.get(u))) {
      var c = _t(zR, u) ? zR[u] : u, f = r[u], h = s ? s(f) : f, d = _X(c, h) || c === "reg" && new Ilt(h);
      d || (process.env.NODE_ENV !== "production" && (e = hn('Illegal relational operation: "' + u + '" in condition:', r)), we(e)), i.push(d);
    }
  }
  i.length || (process.env.NODE_ENV !== "production" && (e = hn("Relational condition must have at least one operator.", "Illegal condition:", r)), we(e));
  var p = new Blt();
  return p.valueGetterParam = n, p.valueParser = s, p.getValue = t.getValue, p.subCondList = i, p;
}
function qV(r) {
  return Dt(r) && !qr(r);
}
var zlt = (
  /** @class */
  function() {
    function r(t, e) {
      this._cond = Rw(t, e);
    }
    return r.prototype.evaluate = function() {
      return this._cond.evaluate();
    }, r;
  }()
);
function Ult(r, t) {
  return new zlt(r, t);
}
var Glt = {
  type: "echarts:filter",
  // PENDING: enhance to filter by index rather than create new data
  transform: function(r) {
    for (var t = r.upstream, e, n = Ult(r.config, {
      valueGetterAttrMap: wt({
        dimension: !0
      }),
      prepareGetValue: function(s) {
        var l = "", u = s.dimension;
        _t(s, "dimension") || (process.env.NODE_ENV !== "production" && (l = hn('Relation condition must has prop "dimension" specified.', "Illegal condition:", s)), we(l));
        var c = t.getDimensionInfo(u);
        return c || (process.env.NODE_ENV !== "production" && (l = hn("Can not find dimension info via: " + u + `.
`, "Existing dimensions: ", t.cloneAllDimensionInfo(), `.
`, "Illegal condition:", s, `.
`)), we(l)), {
          dimIdx: c.index
        };
      },
      getValue: function(s) {
        return t.retrieveValueFromItem(e, s.dimIdx);
      }
    }), i = [], a = 0, o = t.count(); a < o; a++)
      e = t.getRawDataItem(a), n.evaluate() && i.push(e);
    return {
      data: i
    };
  }
}, r1 = "";
process.env.NODE_ENV !== "production" && (r1 = ["Valid config is like:", '{ dimension: "age", order: "asc" }', 'or [{ dimension: "age", order: "asc"], { dimension: "date", order: "desc" }]'].join(" "));
var Hlt = {
  type: "echarts:sort",
  transform: function(r) {
    var t = r.upstream, e = r.config, n = "", i = Ie(e);
    i.length || (process.env.NODE_ENV !== "production" && (n = "Empty `config` in sort transform."), we(n));
    var a = [];
    L(i, function(c) {
      var f = c.dimension, h = c.order, d = c.parser, p = c.incomparable;
      if (f == null && (process.env.NODE_ENV !== "production" && (n = 'Sort transform config must has "dimension" specified.' + r1), we(n)), h !== "asc" && h !== "desc" && (process.env.NODE_ENV !== "production" && (n = 'Sort transform config must has "order" specified.' + r1), we(n)), p && p !== "min" && p !== "max") {
        var g = "";
        process.env.NODE_ENV !== "production" && (g = 'incomparable must be "min" or "max" rather than "' + p + '".'), we(g);
      }
      if (h !== "asc" && h !== "desc") {
        var v = "";
        process.env.NODE_ENV !== "production" && (v = 'order must be "asc" or "desc" rather than "' + h + '".'), we(v);
      }
      var m = t.getDimensionInfo(f);
      m || (process.env.NODE_ENV !== "production" && (n = hn("Can not find dimension info via: " + f + `.
`, "Existing dimensions: ", t.cloneAllDimensionInfo(), `.
`, "Illegal config:", c, `.
`)), we(n));
      var y = d ? cO(d) : null;
      d && !y && (process.env.NODE_ENV !== "production" && (n = hn("Invalid parser name " + d + `.
`, "Illegal config:", c, `.
`)), we(n)), a.push({
        dimIdx: m.index,
        parser: y,
        comparator: new hO(h, p)
      });
    });
    var o = t.sourceFormat;
    o !== Br && o !== Vn && (process.env.NODE_ENV !== "production" && (n = 'sourceFormat "' + o + '" is not supported yet'), we(n));
    for (var s = [], l = 0, u = t.count(); l < u; l++)
      s.push(t.getRawDataItem(l));
    return s.sort(function(c, f) {
      for (var h = 0; h < a.length; h++) {
        var d = a[h], p = t.retrieveValueFromItem(c, d.dimIdx), g = t.retrieveValueFromItem(f, d.dimIdx);
        d.parser && (p = d.parser(p), g = d.parser(g));
        var v = d.comparator.evaluate(p, g);
        if (v !== 0)
          return v;
      }
      return 0;
    }), {
      data: s
    };
  }
};
function Wlt(r) {
  r.registerTransform(Glt), r.registerTransform(Hlt);
}
var Xlt = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = "dataset", e;
    }
    return t.prototype.init = function(e, n, i) {
      r.prototype.init.call(this, e, n, i), this._sourceManager = new gO(this), vE(this);
    }, t.prototype.mergeOption = function(e, n) {
      r.prototype.mergeOption.call(this, e, n), vE(this);
    }, t.prototype.optionUpdated = function() {
      this._sourceManager.dirty();
    }, t.prototype.getSourceManager = function() {
      return this._sourceManager;
    }, t.type = "dataset", t.defaultOption = {
      seriesLayoutBy: _i
    }, t;
  }(re)
), Ylt = (
  /** @class */
  function(r) {
    W(t, r);
    function t() {
      var e = r !== null && r.apply(this, arguments) || this;
      return e.type = "dataset", e;
    }
    return t.type = "dataset", t;
  }(Ue)
);
function $lt(r) {
  r.registerComponentModel(Xlt), r.registerComponentView(Ylt);
}
var Ni = aa.CMD;
function Fu(r, t) {
  return Math.abs(r - t) < 1e-5;
}
function n1(r) {
  var t = r.data, e = r.len(), n = [], i, a = 0, o = 0, s = 0, l = 0;
  function u(C, D) {
    i && i.length > 2 && n.push(i), i = [C, D];
  }
  function c(C, D, I, P) {
    Fu(C, I) && Fu(D, P) || i.push(C, D, I, P, I, P);
  }
  function f(C, D, I, P, O, N) {
    var B = Math.abs(D - C), F = Math.tan(B / 4) * 4 / 3, G = D < C ? -1 : 1, X = Math.cos(C), K = Math.sin(C), U = Math.cos(D), $ = Math.sin(D), ct = X * O + I, at = K * N + P, lt = U * O + I, ot = $ * N + P, H = O * F * G, st = N * F * G;
    i.push(ct - H * K, at + st * X, lt + H * $, ot - st * U, lt, ot);
  }
  for (var h, d, p, g, v = 0; v < e; ) {
    var m = t[v++], y = v === 1;
    switch (y && (a = t[v], o = t[v + 1], s = a, l = o, (m === Ni.L || m === Ni.C || m === Ni.Q) && (i = [s, l])), m) {
      case Ni.M:
        a = s = t[v++], o = l = t[v++], u(s, l);
        break;
      case Ni.L:
        h = t[v++], d = t[v++], c(a, o, h, d), a = h, o = d;
        break;
      case Ni.C:
        i.push(t[v++], t[v++], t[v++], t[v++], a = t[v++], o = t[v++]);
        break;
      case Ni.Q:
        h = t[v++], d = t[v++], p = t[v++], g = t[v++], i.push(a + 2 / 3 * (h - a), o + 2 / 3 * (d - o), p + 2 / 3 * (h - p), g + 2 / 3 * (d - g), p, g), a = p, o = g;
        break;
      case Ni.A:
        var _ = t[v++], x = t[v++], b = t[v++], S = t[v++], w = t[v++], A = t[v++] + w;
        v += 1;
        var T = !t[v++];
        h = Math.cos(w) * b + _, d = Math.sin(w) * S + x, y ? (s = h, l = d, u(s, l)) : c(a, o, h, d), a = Math.cos(A) * b + _, o = Math.sin(A) * S + x;
        for (var M = (T ? -1 : 1) * Math.PI / 2, E = w; T ? E > A : E < A; E += M) {
          var R = T ? Math.max(E + M, A) : Math.min(E + M, A);
          f(E, R, _, x, b, S);
        }
        break;
      case Ni.R:
        s = a = t[v++], l = o = t[v++], h = s + t[v++], d = l + t[v++], u(h, l), c(h, l, h, d), c(h, d, s, d), c(s, d, s, l), c(s, l, h, l);
        break;
      case Ni.Z:
        i && c(a, o, s, l), a = s, o = l;
        break;
    }
  }
  return i && i.length > 2 && n.push(i), n;
}
function i1(r, t, e, n, i, a, o, s, l, u) {
  if (Fu(r, e) && Fu(t, n) && Fu(i, o) && Fu(a, s)) {
    l.push(o, s);
    return;
  }
  var c = 2 / u, f = c * c, h = o - r, d = s - t, p = Math.sqrt(h * h + d * d);
  h /= p, d /= p;
  var g = e - r, v = n - t, m = i - o, y = a - s, _ = g * g + v * v, x = m * m + y * y;
  if (_ < f && x < f) {
    l.push(o, s);
    return;
  }
  var b = h * g + d * v, S = -h * m - d * y, w = _ - b * b, A = x - S * S;
  if (w < f && b >= 0 && A < f && S >= 0) {
    l.push(o, s);
    return;
  }
  var T = [], M = [];
  zo(r, e, i, o, 0.5, T), zo(t, n, a, s, 0.5, M), i1(T[0], M[0], T[1], M[1], T[2], M[2], T[3], M[3], l, u), i1(T[4], M[4], T[5], M[5], T[6], M[6], T[7], M[7], l, u);
}
function Zlt(r, t) {
  var e = n1(r), n = [];
  t = t || 1;
  for (var i = 0; i < e.length; i++) {
    var a = e[i], o = [], s = a[0], l = a[1];
    o.push(s, l);
    for (var u = 2; u < a.length; ) {
      var c = a[u++], f = a[u++], h = a[u++], d = a[u++], p = a[u++], g = a[u++];
      i1(s, l, c, f, h, d, p, g, o, t), s = p, l = g;
    }
    n.push(o);
  }
  return n;
}
function KV(r, t, e) {
  var n = r[t], i = r[1 - t], a = Math.abs(n / i), o = Math.ceil(Math.sqrt(a * e)), s = Math.floor(e / o);
  s === 0 && (s = 1, o = e);
  for (var l = [], u = 0; u < o; u++)
    l.push(s);
  var c = o * s, f = e - c;
  if (f > 0)
    for (var u = 0; u < f; u++)
      l[u % o] += 1;
  return l;
}
function GR(r, t, e) {
  for (var n = r.r0, i = r.r, a = r.startAngle, o = r.endAngle, s = Math.abs(o - a), l = s * i, u = i - n, c = l > Math.abs(u), f = KV([l, u], c ? 0 : 1, t), h = (c ? s : u) / f.length, d = 0; d < f.length; d++)
    for (var p = (c ? u : s) / f[d], g = 0; g < f[d]; g++) {
      var v = {};
      c ? (v.startAngle = a + h * d, v.endAngle = a + h * (d + 1), v.r0 = n + p * g, v.r = n + p * (g + 1)) : (v.startAngle = a + p * g, v.endAngle = a + p * (g + 1), v.r0 = n + h * d, v.r = n + h * (d + 1)), v.clockwise = r.clockwise, v.cx = r.cx, v.cy = r.cy, e.push(v);
    }
}
function qlt(r, t, e) {
  for (var n = r.width, i = r.height, a = n > i, o = KV([n, i], a ? 0 : 1, t), s = a ? "width" : "height", l = a ? "height" : "width", u = a ? "x" : "y", c = a ? "y" : "x", f = r[s] / o.length, h = 0; h < o.length; h++)
    for (var d = r[l] / o[h], p = 0; p < o[h]; p++) {
      var g = {};
      g[u] = h * f, g[c] = p * d, g[s] = f, g[l] = d, g.x += r.x, g.y += r.y, e.push(g);
    }
}
function HR(r, t, e, n) {
  return r * n - e * t;
}
function Klt(r, t, e, n, i, a, o, s) {
  var l = e - r, u = n - t, c = o - i, f = s - a, h = HR(c, f, l, u);
  if (Math.abs(h) < 1e-6)
    return null;
  var d = r - i, p = t - a, g = HR(d, p, c, f) / h;
  return g < 0 || g > 1 ? null : new Nt(g * l + r, g * u + t);
}
function jlt(r, t, e) {
  var n = new Nt();
  Nt.sub(n, e, t), n.normalize();
  var i = new Nt();
  Nt.sub(i, r, t);
  var a = i.dot(n);
  return a;
}
function Mu(r, t) {
  var e = r[r.length - 1];
  e && e[0] === t[0] && e[1] === t[1] || r.push(t);
}
function Jlt(r, t, e) {
  for (var n = r.length, i = [], a = 0; a < n; a++) {
    var o = r[a], s = r[(a + 1) % n], l = Klt(o[0], o[1], s[0], s[1], t.x, t.y, e.x, e.y);
    l && i.push({
      projPt: jlt(l, t, e),
      pt: l,
      idx: a
    });
  }
  if (i.length < 2)
    return [{ points: r }, { points: r }];
  i.sort(function(v, m) {
    return v.projPt - m.projPt;
  });
  var u = i[0], c = i[i.length - 1];
  if (c.idx < u.idx) {
    var f = u;
    u = c, c = f;
  }
  for (var h = [u.pt.x, u.pt.y], d = [c.pt.x, c.pt.y], p = [h], g = [d], a = u.idx + 1; a <= c.idx; a++)
    Mu(p, r[a].slice());
  Mu(p, d), Mu(p, h);
  for (var a = c.idx + 1; a <= u.idx + n; a++)
    Mu(g, r[a % n].slice());
  return Mu(g, h), Mu(g, d), [{
    points: p
  }, {
    points: g
  }];
}
function WR(r) {
  var t = r.points, e = [], n = [];
  jg(t, e, n);
  var i = new Bt(e[0], e[1], n[0] - e[0], n[1] - e[1]), a = i.width, o = i.height, s = i.x, l = i.y, u = new Nt(), c = new Nt();
  return a > o ? (u.x = c.x = s + a / 2, u.y = l, c.y = l + o) : (u.y = c.y = l + o / 2, u.x = s, c.x = s + a), Jlt(t, u, c);
}
function Ag(r, t, e, n) {
  if (e === 1)
    n.push(t);
  else {
    var i = Math.floor(e / 2), a = r(t);
    Ag(r, a[0], i, n), Ag(r, a[1], e - i, n);
  }
  return n;
}
function Qlt(r, t) {
  for (var e = [], n = 0; n < t; n++)
    e.push(z1(r));
  return e;
}
function tut(r, t) {
  t.setStyle(r.style), t.z = r.z, t.z2 = r.z2, t.zlevel = r.zlevel;
}
function eut(r) {
  for (var t = [], e = 0; e < r.length; )
    t.push([r[e++], r[e++]]);
  return t;
}
function rut(r, t) {
  var e = [], n = r.shape, i;
  switch (r.type) {
    case "rect":
      qlt(n, t, e), i = te;
      break;
    case "sector":
      GR(n, t, e), i = Kr;
      break;
    case "circle":
      GR({
        r0: 0,
        r: n.r,
        startAngle: 0,
        endAngle: Math.PI * 2,
        cx: n.cx,
        cy: n.cy
      }, t, e), i = Kr;
      break;
    default:
      var a = r.getComputedTransform(), o = a ? Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1], a[2] * a[2] + a[3] * a[3])) : 1, s = rt(Zlt(r.getUpdatedPathProxy(), o), function(m) {
        return eut(m);
      }), l = s.length;
      if (l === 0)
        Ag(WR, {
          points: s[0]
        }, t, e);
      else if (l === t)
        for (var u = 0; u < l; u++)
          e.push({
            points: s[u]
          });
      else {
        var c = 0, f = rt(s, function(m) {
          var y = [], _ = [];
          jg(m, y, _);
          var x = (_[1] - y[1]) * (_[0] - y[0]);
          return c += x, { poly: m, area: x };
        });
        f.sort(function(m, y) {
          return y.area - m.area;
        });
        for (var h = t, u = 0; u < l; u++) {
          var d = f[u];
          if (h <= 0)
            break;
          var p = u === l - 1 ? h : Math.ceil(d.area / c * t);
          p < 0 || (Ag(WR, {
            points: d.poly
          }, p, e), h -= p);
        }
      }
      i = jr;
      break;
  }
  if (!i)
    return Qlt(r, t);
  for (var g = [], u = 0; u < e.length; u++) {
    var v = new i();
    v.setShape(e[u]), tut(r, v), g.push(v);
  }
  return g;
}
function nut(r, t) {
  var e = r.length, n = t.length;
  if (e === n)
    return [r, t];
  for (var i = [], a = [], o = e < n ? r : t, s = Math.min(e, n), l = Math.abs(n - e) / 6, u = (s - 2) / 6, c = Math.ceil(l / u) + 1, f = [o[0], o[1]], h = l, d = 2; d < s; ) {
    var p = o[d - 2], g = o[d - 1], v = o[d++], m = o[d++], y = o[d++], _ = o[d++], x = o[d++], b = o[d++];
    if (h <= 0) {
      f.push(v, m, y, _, x, b);
      continue;
    }
    for (var S = Math.min(h, c - 1) + 1, w = 1; w <= S; w++) {
      var A = w / S;
      zo(p, v, y, x, A, i), zo(g, m, _, b, A, a), p = i[3], g = a[3], f.push(i[1], a[1], i[2], a[2], p, g), v = i[5], m = a[5], y = i[6], _ = a[6];
    }
    h -= S - 1;
  }
  return o === r ? [f, t] : [r, f];
}
function XR(r, t) {
  for (var e = r.length, n = r[e - 2], i = r[e - 1], a = [], o = 0; o < t.length; )
    a[o++] = n, a[o++] = i;
  return a;
}
function iut(r, t) {
  for (var e, n, i, a = [], o = [], s = 0; s < Math.max(r.length, t.length); s++) {
    var l = r[s], u = t[s], c = void 0, f = void 0;
    l ? u ? (e = nut(l, u), c = e[0], f = e[1], n = c, i = f) : (f = XR(i || l, l), c = l) : (c = XR(n || u, u), f = u), a.push(c), o.push(f);
  }
  return [a, o];
}
function YR(r) {
  for (var t = 0, e = 0, n = 0, i = r.length, a = 0, o = i - 2; a < i; o = a, a += 2) {
    var s = r[o], l = r[o + 1], u = r[a], c = r[a + 1], f = s * c - u * l;
    t += f, e += (s + u) * f, n += (l + c) * f;
  }
  return t === 0 ? [r[0] || 0, r[1] || 0] : [e / t / 3, n / t / 3, t];
}
function aut(r, t, e, n) {
  for (var i = (r.length - 2) / 6, a = 1 / 0, o = 0, s = r.length, l = s - 2, u = 0; u < i; u++) {
    for (var c = u * 6, f = 0, h = 0; h < s; h += 2) {
      var d = h === 0 ? c : (c + h - 2) % l + 2, p = r[d] - e[0], g = r[d + 1] - e[1], v = t[h] - n[0], m = t[h + 1] - n[1], y = v - p, _ = m - g;
      f += y * y + _ * _;
    }
    f < a && (a = f, o = u);
  }
  return o;
}
function out(r) {
  for (var t = [], e = r.length, n = 0; n < e; n += 2)
    t[n] = r[e - n - 2], t[n + 1] = r[e - n - 1];
  return t;
}
function sut(r, t, e, n) {
  for (var i = [], a, o = 0; o < r.length; o++) {
    var s = r[o], l = t[o], u = YR(s), c = YR(l);
    a == null && (a = u[2] < 0 != c[2] < 0);
    var f = [], h = [], d = 0, p = 1 / 0, g = [], v = s.length;
    a && (s = out(s));
    for (var m = aut(s, l, u, c) * 6, y = v - 2, _ = 0; _ < y; _ += 2) {
      var x = (m + _) % y + 2;
      f[_ + 2] = s[x] - u[0], f[_ + 3] = s[x + 1] - u[1];
    }
    f[0] = s[m] - u[0], f[1] = s[m + 1] - u[1];
    for (var b = n / e, S = -n / 2; S <= n / 2; S += b) {
      for (var w = Math.sin(S), A = Math.cos(S), T = 0, _ = 0; _ < s.length; _ += 2) {
        var M = f[_], E = f[_ + 1], R = l[_] - c[0], C = l[_ + 1] - c[1], D = R * A - C * w, I = R * w + C * A;
        g[_] = D, g[_ + 1] = I;
        var P = D - M, O = I - E;
        T += P * P + O * O;
      }
      if (T < p) {
        p = T, d = S;
        for (var N = 0; N < g.length; N++)
          h[N] = g[N];
      }
    }
    i.push({
      from: f,
      to: h,
      fromCp: u,
      toCp: c,
      rotation: -d
    });
  }
  return i;
}
function Eg(r) {
  return r.__isCombineMorphing;
}
var jV = "__mOriginal_";
function Cg(r, t, e) {
  var n = jV + t, i = r[n] || r[t];
  r[n] || (r[n] = r[t]);
  var a = e.replace, o = e.after, s = e.before;
  r[t] = function() {
    var l = arguments, u;
    return s && s.apply(this, l), a ? u = a.apply(this, l) : u = i.apply(this, l), o && o.apply(this, l), u;
  };
}
function Jf(r, t) {
  var e = jV + t;
  r[e] && (r[t] = r[e], r[e] = null);
}
function $R(r, t) {
  for (var e = 0; e < r.length; e++)
    for (var n = r[e], i = 0; i < n.length; ) {
      var a = n[i], o = n[i + 1];
      n[i++] = t[0] * a + t[2] * o + t[4], n[i++] = t[1] * a + t[3] * o + t[5];
    }
}
function JV(r, t) {
  var e = r.getUpdatedPathProxy(), n = t.getUpdatedPathProxy(), i = iut(n1(e), n1(n)), a = i[0], o = i[1], s = r.getComputedTransform(), l = t.getComputedTransform();
  function u() {
    this.transform = null;
  }
  s && $R(a, s), l && $R(o, l), Cg(t, "updateTransform", { replace: u }), t.transform = null;
  var c = sut(a, o, 10, Math.PI), f = [];
  Cg(t, "buildPath", { replace: function(h) {
    for (var d = t.__morphT, p = 1 - d, g = [], v = 0; v < c.length; v++) {
      var m = c[v], y = m.from, _ = m.to, x = m.rotation * d, b = m.fromCp, S = m.toCp, w = Math.sin(x), A = Math.cos(x);
      Hp(g, b, S, d);
      for (var T = 0; T < y.length; T += 2) {
        var M = y[T], E = y[T + 1], R = _[T], C = _[T + 1], D = M * p + R * d, I = E * p + C * d;
        f[T] = D * A - I * w + g[0], f[T + 1] = D * w + I * A + g[1];
      }
      var P = f[0], O = f[1];
      h.moveTo(P, O);
      for (var T = 2; T < y.length; ) {
        var R = f[T++], C = f[T++], N = f[T++], B = f[T++], F = f[T++], G = f[T++];
        P === R && O === C && N === F && B === G ? h.lineTo(F, G) : h.bezierCurveTo(R, C, N, B, F, G), P = F, O = G;
      }
    }
  } });
}
function Iw(r, t, e) {
  if (!r || !t)
    return t;
  var n = e.done, i = e.during;
  JV(r, t), t.__morphT = 0;
  function a() {
    Jf(t, "buildPath"), Jf(t, "updateTransform"), t.__morphT = -1, t.createPathProxy(), t.dirtyShape();
  }
  return t.animateTo({
    __morphT: 1
  }, kt({
    during: function(o) {
      t.dirtyShape(), i && i(o);
    },
    done: function() {
      a(), n && n();
    }
  }, e)), t;
}
function lut(r, t, e, n, i, a) {
  var o = 16;
  r = i === e ? 0 : Math.round(32767 * (r - e) / (i - e)), t = a === n ? 0 : Math.round(32767 * (t - n) / (a - n));
  for (var s = 0, l, u = (1 << o) / 2; u > 0; u /= 2) {
    var c = 0, f = 0;
    (r & u) > 0 && (c = 1), (t & u) > 0 && (f = 1), s += u * u * (3 * c ^ f), f === 0 && (c === 1 && (r = u - 1 - r, t = u - 1 - t), l = r, r = t, t = l);
  }
  return s;
}
function Dg(r) {
  var t = 1 / 0, e = 1 / 0, n = -1 / 0, i = -1 / 0, a = rt(r, function(s) {
    var l = s.getBoundingRect(), u = s.getComputedTransform(), c = l.x + l.width / 2 + (u ? u[4] : 0), f = l.y + l.height / 2 + (u ? u[5] : 0);
    return t = Math.min(c, t), e = Math.min(f, e), n = Math.max(c, n), i = Math.max(f, i), [c, f];
  }), o = rt(a, function(s, l) {
    return {
      cp: s,
      z: lut(s[0], s[1], t, e, n, i),
      path: r[l]
    };
  });
  return o.sort(function(s, l) {
    return s.z - l.z;
  }).map(function(s) {
    return s.path;
  });
}
function QV(r) {
  return rut(r.path, r.count);
}
function a1() {
  return {
    fromIndividuals: [],
    toIndividuals: [],
    count: 0
  };
}
function uut(r, t, e) {
  var n = [];
  function i(b) {
    for (var S = 0; S < b.length; S++) {
      var w = b[S];
      Eg(w) ? i(w.childrenRef()) : w instanceof ne && n.push(w);
    }
  }
  i(r);
  var a = n.length;
  if (!a)
    return a1();
  var o = e.dividePath || QV, s = o({
    path: t,
    count: a
  });
  if (s.length !== a)
    return console.error("Invalid morphing: unmatched splitted path"), a1();
  n = Dg(n), s = Dg(s);
  for (var l = e.done, u = e.during, c = e.individualDelay, f = new Da(), h = 0; h < a; h++) {
    var d = n[h], p = s[h];
    p.parent = t, p.copyTransform(f), c || JV(d, p);
  }
  t.__isCombineMorphing = !0, t.childrenRef = function() {
    return s;
  };
  function g(b) {
    for (var S = 0; S < s.length; S++)
      s[S].addSelfToZr(b);
  }
  Cg(t, "addSelfToZr", {
    after: function(b) {
      g(b);
    }
  }), Cg(t, "removeSelfFromZr", {
    after: function(b) {
      for (var S = 0; S < s.length; S++)
        s[S].removeSelfFromZr(b);
    }
  });
  function v() {
    t.__isCombineMorphing = !1, t.__morphT = -1, t.childrenRef = null, Jf(t, "addSelfToZr"), Jf(t, "removeSelfFromZr");
  }
  var m = s.length;
  if (c)
    for (var y = m, _ = function() {
      y--, y === 0 && (v(), l && l());
    }, h = 0; h < m; h++) {
      var x = c ? kt({
        delay: (e.delay || 0) + c(h, m, n[h], s[h]),
        done: _
      }, e) : e;
      Iw(n[h], s[h], x);
    }
  else
    t.__morphT = 0, t.animateTo({
      __morphT: 1
    }, kt({
      during: function(b) {
        for (var S = 0; S < m; S++) {
          var w = s[S];
          w.__morphT = t.__morphT, w.dirtyShape();
        }
        u && u(b);
      },
      done: function() {
        v();
        for (var b = 0; b < r.length; b++)
          Jf(r[b], "updateTransform");
        l && l();
      }
    }, e));
  return t.__zr && g(t.__zr), {
    fromIndividuals: n,
    toIndividuals: s,
    count: m
  };
}
function cut(r, t, e) {
  var n = t.length, i = [], a = e.dividePath || QV;
  function o(d) {
    for (var p = 0; p < d.length; p++) {
      var g = d[p];
      Eg(g) ? o(g.childrenRef()) : g instanceof ne && i.push(g);
    }
  }
  if (Eg(r)) {
    o(r.childrenRef());
    var s = i.length;
    if (s < n)
      for (var l = 0, u = s; u < n; u++)
        i.push(z1(i[l++ % s]));
    i.length = n;
  } else {
    i = a({ path: r, count: n });
    for (var c = r.getComputedTransform(), u = 0; u < i.length; u++)
      i[u].setLocalTransform(c);
    if (i.length !== n)
      return console.error("Invalid morphing: unmatched splitted path"), a1();
  }
  i = Dg(i), t = Dg(t);
  for (var f = e.individualDelay, u = 0; u < n; u++) {
    var h = f ? kt({
      delay: (e.delay || 0) + f(u, n, i[u], t[u])
    }, e) : e;
    Iw(i[u], t[u], h);
  }
  return {
    fromIndividuals: i,
    toIndividuals: t,
    count: t.length
  };
}
function ZR(r) {
  return et(r[0]);
}
function qR(r, t) {
  for (var e = [], n = r.length, i = 0; i < n; i++)
    e.push({
      one: r[i],
      many: []
    });
  for (var i = 0; i < t.length; i++) {
    var a = t[i].length, o = void 0;
    for (o = 0; o < a; o++)
      e[o % n].many.push(t[i][o]);
  }
  for (var s = 0, i = n - 1; i >= 0; i--)
    if (!e[i].many.length) {
      var l = e[s].many;
      if (l.length <= 1)
        if (s)
          s = 0;
        else
          return e;
      var a = l.length, u = Math.ceil(a / 2);
      e[i].many = l.slice(u, a), e[s].many = l.slice(0, u), s++;
    }
  return e;
}
var fut = {
  clone: function(r) {
    for (var t = [], e = 1 - Math.pow(1 - r.path.style.opacity, 1 / r.count), n = 0; n < r.count; n++) {
      var i = z1(r.path);
      i.setStyle("opacity", e), t.push(i);
    }
    return t;
  },
  // Use the default divider
  split: null
};
function k_(r, t, e, n, i, a) {
  if (!r.length || !t.length)
    return;
  var o = Mc("update", n, i);
  if (!(o && o.duration > 0))
    return;
  var s = n.getModel("universalTransition").get("delay"), l = Object.assign({
    // Need to setToFinal so the further calculation based on the style can be correct.
    // Like emphasis color.
    setToFinal: !0
  }, o), u, c;
  ZR(r) && (u = r, c = t), ZR(t) && (u = t, c = r);
  function f(m, y, _, x, b) {
    var S = m.many, w = m.one;
    if (S.length === 1 && !b) {
      var A = y ? S[0] : w, T = y ? w : S[0];
      if (Eg(A))
        f({
          many: [A],
          one: T
        }, !0, _, x, !0);
      else {
        var M = s ? kt({
          delay: s(_, x)
        }, l) : l;
        Iw(A, T, M), a(A, T, A, T, M);
      }
    } else
      for (var E = kt({
        dividePath: fut[e],
        individualDelay: s && function(O, N, B, F) {
          return s(O + _, x);
        }
      }, l), R = y ? uut(S, w, E) : cut(w, S, E), C = R.fromIndividuals, D = R.toIndividuals, I = C.length, P = 0; P < I; P++) {
        var M = s ? kt({
          delay: s(P, I)
        }, l) : l;
        a(C[P], D[P], y ? S[P] : m.one, y ? m.one : S[P], M);
      }
  }
  for (var h = u ? u === r : r.length > t.length, d = u ? qR(c, u) : qR(h ? t : r, [h ? r : t]), p = 0, g = 0; g < d.length; g++)
    p += d[g].many.length;
  for (var v = 0, g = 0; g < d.length; g++)
    f(d[g], h, v, p), v += d[g].many.length;
}
function Fs(r) {
  if (!r)
    return [];
  if (et(r)) {
    for (var t = [], e = 0; e < r.length; e++)
      t.push(Fs(r[e]));
    return t;
  }
  var n = [];
  return r.traverse(function(i) {
    i instanceof ne && !i.disableMorphing && !i.invisible && !i.ignore && n.push(i);
  }), n;
}
var tF = 1e4, hut = 0, KR = 1, jR = 2, dut = ee();
function put(r, t) {
  for (var e = r.dimensions, n = 0; n < e.length; n++) {
    var i = r.getDimensionInfo(e[n]);
    if (i && i.otherDims[t] === 0)
      return e[n];
  }
}
function vut(r, t, e) {
  var n = r.getDimensionInfo(e), i = n && n.ordinalMeta;
  if (n) {
    var a = r.get(n.name, t);
    return i && i.categories[a] || a + "";
  }
}
function JR(r, t, e, n) {
  var i = n ? "itemChildGroupId" : "itemGroupId", a = put(r, i);
  if (a) {
    var o = vut(r, t, a);
    return o;
  }
  var s = r.getRawDataItem(t), l = n ? "childGroupId" : "groupId";
  if (s && s[l])
    return s[l] + "";
  if (!n)
    return e || r.getId(t);
}
function QR(r) {
  var t = [];
  return L(r, function(e) {
    var n = e.data, i = e.dataGroupId;
    if (n.count() > tF) {
      process.env.NODE_ENV !== "production" && Xe("Universal transition is disabled on large data > 10k.");
      return;
    }
    for (var a = n.getIndices(), o = 0; o < a.length; o++)
      t.push({
        data: n,
        groupId: JR(n, o, i, !1),
        childGroupId: JR(n, o, i, !0),
        divide: e.divide,
        dataIndex: o
      });
  }), t;
}
function B_(r, t, e) {
  r.traverse(function(n) {
    n instanceof ne && ze(n, {
      style: {
        opacity: 0
      }
    }, t, {
      dataIndex: e,
      isFrom: !0
    });
  });
}
function V_(r) {
  if (r.parent) {
    var t = r.getComputedTransform();
    r.setLocalTransform(t), r.parent.remove(r);
  }
}
function Tu(r) {
  r.stopAnimation(), r.isGroup && r.traverse(function(t) {
    t.stopAnimation();
  });
}
function gut(r, t, e) {
  var n = Mc("update", e, t);
  n && r.traverse(function(i) {
    if (i instanceof ii) {
      var a = H7(i);
      a && i.animateFrom({
        style: a
      }, n);
    }
  });
}
function mut(r, t) {
  var e = r.length;
  if (e !== t.length)
    return !1;
  for (var n = 0; n < e; n++) {
    var i = r[n], a = t[n];
    if (i.data.getId(i.dataIndex) !== a.data.getId(a.dataIndex))
      return !1;
  }
  return !0;
}
function eF(r, t, e) {
  var n = QR(r), i = QR(t);
  function a(_, x, b, S, w) {
    (b || _) && x.animateFrom({
      style: b && b !== _ ? J(J({}, b.style), _.style) : _.style
    }, w);
  }
  var o = !1, s = hut, l = wt(), u = wt();
  n.forEach(function(_) {
    _.groupId && l.set(_.groupId, !0), _.childGroupId && u.set(_.childGroupId, !0);
  });
  for (var c = 0; c < i.length; c++) {
    var f = i[c].groupId;
    if (u.get(f)) {
      s = KR;
      break;
    }
    var h = i[c].childGroupId;
    if (h && l.get(h)) {
      s = jR;
      break;
    }
  }
  function d(_, x) {
    return function(b) {
      var S = b.data, w = b.dataIndex;
      return x ? S.getId(w) : _ ? s === KR ? b.childGroupId : b.groupId : s === jR ? b.childGroupId : b.groupId;
    };
  }
  var p = mut(n, i), g = {};
  if (!p)
    for (var c = 0; c < i.length; c++) {
      var v = i[c], m = v.data.getItemGraphicEl(v.dataIndex);
      m && (g[m.id] = !0);
    }
  function y(_, x) {
    var b = n[x], S = i[_], w = S.data.hostModel, A = b.data.getItemGraphicEl(b.dataIndex), T = S.data.getItemGraphicEl(S.dataIndex);
    if (A === T) {
      T && gut(T, S.dataIndex, w);
      return;
    }
    // We can't use the elements that already being morphed
    A && g[A.id] || T && (Tu(T), A ? (Tu(A), V_(A), o = !0, k_(Fs(A), Fs(T), S.divide, w, _, a)) : B_(T, w, _));
  }
  new Xa(n, i, d(!0, p), d(!1, p), null, "multiple").update(y).updateManyToOne(function(_, x) {
    var b = i[_], S = b.data, w = S.hostModel, A = S.getItemGraphicEl(b.dataIndex), T = Te(rt(x, function(M) {
      return n[M].data.getItemGraphicEl(n[M].dataIndex);
    }), function(M) {
      return M && M !== A && !g[M.id];
    });
    A && (Tu(A), T.length ? (L(T, function(M) {
      Tu(M), V_(M);
    }), o = !0, k_(Fs(T), Fs(A), b.divide, w, _, a)) : B_(A, w, b.dataIndex));
  }).updateOneToMany(function(_, x) {
    var b = n[x], S = b.data.getItemGraphicEl(b.dataIndex);
    if (!(S && g[S.id])) {
      var w = Te(rt(_, function(T) {
        return i[T].data.getItemGraphicEl(i[T].dataIndex);
      }), function(T) {
        return T && T !== S;
      }), A = i[_[0]].data.hostModel;
      w.length && (L(w, function(T) {
        return Tu(T);
      }), S ? (Tu(S), V_(S), o = !0, k_(
        Fs(S),
        Fs(w),
        b.divide,
        // Use divide on old.
        A,
        _[0],
        a
      )) : L(w, function(T) {
        return B_(T, A, _[0]);
      }));
    }
  }).updateManyToMany(function(_, x) {
    new Xa(x, _, function(b) {
      return n[b].data.getId(n[b].dataIndex);
    }, function(b) {
      return i[b].data.getId(i[b].dataIndex);
    }).update(function(b, S) {
      y(_[b], x[S]);
    }).execute();
  }).execute(), o && L(t, function(_) {
    var x = _.data, b = x.hostModel, S = b && e.getViewOfSeriesModel(b), w = Mc("update", b, 0);
    S && b.isAnimationEnabled() && w && w.duration > 0 && S.group.traverse(function(A) {
      A instanceof ne && !A.animators.length && A.animateFrom({
        style: {
          opacity: 0
        }
      }, w);
    });
  });
}
function tI(r) {
  var t = r.getModel("universalTransition").get("seriesKey");
  return t || r.id;
}
function eI(r) {
  return et(r) ? r.sort().join(",") : r;
}
function yo(r) {
  if (r.hostModel)
    return r.hostModel.getModel("universalTransition").get("divideShape");
}
function yut(r, t) {
  var e = wt(), n = wt(), i = wt();
  L(r.oldSeries, function(o, s) {
    var l = r.oldDataGroupIds[s], u = r.oldData[s], c = tI(o), f = eI(c);
    n.set(f, {
      dataGroupId: l,
      data: u
    }), et(c) && L(c, function(h) {
      i.set(h, {
        key: f,
        dataGroupId: l,
        data: u
      });
    });
  });
  function a(o) {
    e.get(o) && Xe("Duplicated seriesKey in universalTransition " + o);
  }
  return L(t.updatedSeries, function(o) {
    if (o.isUniversalTransitionEnabled() && o.isAnimationEnabled()) {
      var s = o.get("dataGroupId"), l = o.getData(), u = tI(o), c = eI(u), f = n.get(c);
      if (f)
        process.env.NODE_ENV !== "production" && a(c), e.set(c, {
          oldSeries: [{
            dataGroupId: f.dataGroupId,
            divide: yo(f.data),
            data: f.data
          }],
          newSeries: [{
            dataGroupId: s,
            divide: yo(l),
            data: l
          }]
        });
      else if (et(u)) {
        process.env.NODE_ENV !== "production" && a(c);
        var h = [];
        L(u, function(g) {
          var v = n.get(g);
          v.data && h.push({
            dataGroupId: v.dataGroupId,
            divide: yo(v.data),
            data: v.data
          });
        }), h.length && e.set(c, {
          oldSeries: h,
          newSeries: [{
            dataGroupId: s,
            data: l,
            divide: yo(l)
          }]
        });
      } else {
        var d = i.get(u);
        if (d) {
          var p = e.get(d.key);
          p || (p = {
            oldSeries: [{
              dataGroupId: d.dataGroupId,
              data: d.data,
              divide: yo(d.data)
            }],
            newSeries: []
          }, e.set(d.key, p)), p.newSeries.push({
            dataGroupId: s,
            data: l,
            divide: yo(l)
          });
        }
      }
    }
  }), e;
}
function rI(r, t) {
  for (var e = 0; e < r.length; e++) {
    var n = t.seriesIndex != null && t.seriesIndex === r[e].seriesIndex || t.seriesId != null && t.seriesId === r[e].id;
    if (n)
      return e;
  }
}
function _ut(r, t, e, n) {
  var i = [], a = [];
  L(Ie(r.from), function(o) {
    var s = rI(t.oldSeries, o);
    s >= 0 && i.push({
      dataGroupId: t.oldDataGroupIds[s],
      data: t.oldData[s],
      // TODO can specify divideShape in transition.
      divide: yo(t.oldData[s]),
      groupIdDim: o.dimension
    });
  }), L(Ie(r.to), function(o) {
    var s = rI(e.updatedSeries, o);
    if (s >= 0) {
      var l = e.updatedSeries[s].getData();
      a.push({
        dataGroupId: t.oldDataGroupIds[s],
        data: l,
        divide: yo(l),
        groupIdDim: o.dimension
      });
    }
  }), i.length > 0 && a.length > 0 && eF(i, a, n);
}
function xut(r) {
  r.registerUpdateLifecycle("series:beforeupdate", function(t, e, n) {
    L(Ie(n.seriesTransition), function(i) {
      L(Ie(i.to), function(a) {
        for (var o = n.updatedSeries, s = 0; s < o.length; s++)
          (a.seriesIndex != null && a.seriesIndex === o[s].seriesIndex || a.seriesId != null && a.seriesId === o[s].id) && (o[s][tv] = !0);
      });
    });
  }), r.registerUpdateLifecycle("series:transition", function(t, e, n) {
    var i = dut(e);
    if (i.oldSeries && n.updatedSeries && n.optionChanged) {
      var a = n.seriesTransition;
      if (a)
        L(Ie(a), function(d) {
          _ut(d, i, n, e);
        });
      else {
        var o = yut(i, n);
        L(o.keys(), function(d) {
          var p = o.get(d);
          eF(p.oldSeries, p.newSeries, e);
        });
      }
      L(n.updatedSeries, function(d) {
        d[tv] && (d[tv] = !1);
      });
    }
    for (var s = t.getSeries(), l = i.oldSeries = [], u = i.oldDataGroupIds = [], c = i.oldData = [], f = 0; f < s.length; f++) {
      var h = s[f].getData();
      h.count() < tF && (l.push(s[f]), u.push(s[f].get("dataGroupId")), c.push(h));
    }
  });
}
var Sut = (
  /** @class */
  function() {
    function r() {
      this.breaks = [], this._elapsedExtent = [1 / 0, -1 / 0];
    }
    return r.prototype.setBreaks = function(t) {
      this.breaks = t.breaks;
    }, r.prototype.update = function(t) {
      wut(this, t);
      var e = this._elapsedExtent;
      e[0] = this.elapse(t[0]), e[1] = this.elapse(t[1]);
    }, r.prototype.hasBreaks = function() {
      return !!this.breaks.length;
    }, r.prototype.calcNiceTickMultiple = function(t, e) {
      for (var n = 0; n < this.breaks.length; n++) {
        var i = this.breaks[n];
        if (i.vmin < t && t < i.vmax) {
          var a = e(t, i.vmax);
          return process.env.NODE_ENV !== "production" && St(a >= 0 && Math.round(a) === a), a;
        }
      }
      return 0;
    }, r.prototype.getExtentSpan = function() {
      return this._elapsedExtent[1] - this._elapsedExtent[0];
    }, r.prototype.normalize = function(t) {
      var e = this._elapsedExtent[1] - this._elapsedExtent[0];
      return e === 0 ? 0.5 : (this.elapse(t) - this._elapsedExtent[0]) / e;
    }, r.prototype.scale = function(t) {
      return this.unelapse(t * (this._elapsedExtent[1] - this._elapsedExtent[0]) + this._elapsedExtent[0]);
    }, r.prototype.elapse = function(t) {
      for (var e = nI, n = iI, i = !0, a = 0; a < this.breaks.length; a++) {
        var o = this.breaks[a];
        if (t <= o.vmax) {
          t > o.vmin ? e += o.vmin - n + (t - o.vmin) / (o.vmax - o.vmin) * o.gapReal : e += t - n, n = o.vmax, i = !1;
          break;
        }
        e += o.vmin - n + o.gapReal, n = o.vmax;
      }
      return i && (e += t - n), e;
    }, r.prototype.unelapse = function(t) {
      for (var e = nI, n = iI, i = !0, a = 0, o = 0; o < this.breaks.length; o++) {
        var s = this.breaks[o], l = e + s.vmin - n, u = l + s.gapReal;
        if (t <= u) {
          t > l ? a = s.vmin + (t - l) / (u - l) * (s.vmax - s.vmin) : a = n + t - e, n = s.vmax, i = !1;
          break;
        }
        e = u, n = s.vmax;
      }
      return i && (a = n + t - e), a;
    }, r;
  }()
);
function but() {
  return new Sut();
}
var nI = 0, iI = 0;
function wut(r, t) {
  var e = 0, n = {
    tpAbs: {
      span: 0,
      val: 0
    },
    tpPrct: {
      span: 0,
      val: 0
    }
  }, i = function() {
    return {
      has: !1,
      span: NaN,
      inExtFrac: NaN,
      val: NaN
    };
  }, a = {
    S: {
      tpAbs: i(),
      tpPrct: i()
    },
    E: {
      tpAbs: i(),
      tpPrct: i()
    }
  };
  L(r.breaks, function(s) {
    var l = s.gapParsed;
    l.type === "tpPrct" && (e += l.val);
    var u = Pw(s, t);
    if (u) {
      var c = u.vmin !== s.vmin, f = u.vmax !== s.vmax, h = u.vmax - u.vmin;
      if (!(c && f))
        if (c || f) {
          var d = c ? "S" : "E";
          a[d][l.type].has = !0, a[d][l.type].span = h, a[d][l.type].inExtFrac = h / (s.vmax - s.vmin), a[d][l.type].val = l.val;
        } else
          n[l.type].span += h, n[l.type].val += l.val;
    }
  });
  var o = e * (0 + (t[1] - t[0]) + (n.tpAbs.val - n.tpAbs.span) + (a.S.tpAbs.has ? (a.S.tpAbs.val - a.S.tpAbs.span) * a.S.tpAbs.inExtFrac : 0) + (a.E.tpAbs.has ? (a.E.tpAbs.val - a.E.tpAbs.span) * a.E.tpAbs.inExtFrac : 0) - n.tpPrct.span - (a.S.tpPrct.has ? a.S.tpPrct.span * a.S.tpPrct.inExtFrac : 0) - (a.E.tpPrct.has ? a.E.tpPrct.span * a.E.tpPrct.inExtFrac : 0)) / (1 - n.tpPrct.val - (a.S.tpPrct.has ? a.S.tpPrct.val * a.S.tpPrct.inExtFrac : 0) - (a.E.tpPrct.has ? a.E.tpPrct.val * a.E.tpPrct.inExtFrac : 0));
  L(r.breaks, function(s) {
    var l = s.gapParsed;
    l.type === "tpPrct" && (s.gapReal = e !== 0 ? Math.max(o, 0) * l.val / e : 0), l.type === "tpAbs" && (s.gapReal = l.val), s.gapReal == null && (s.gapReal = 0);
  });
}
function Mut(r, t, e, n, i, a) {
  r !== "no" && L(e, function(o) {
    var s = Pw(o, a);
    if (s)
      for (var l = t.length - 1; l >= 0; l--) {
        var u = t[l], c = n(u), f = i * 3 / 4;
        c > s.vmin - f && c < s.vmax + f && (r !== "preserve_extent_bound" || c !== a[0] && c !== a[1]) && t.splice(l, 1);
      }
  });
}
function Tut(r, t, e, n) {
  L(t, function(i) {
    var a = Pw(i, e);
    a && (r.push({
      value: a.vmin,
      break: {
        type: "vmin",
        parsedBreak: a
      },
      time: n ? n(a) : void 0
    }), r.push({
      value: a.vmax,
      break: {
        type: "vmax",
        parsedBreak: a
      },
      time: n ? n(a) : void 0
    }));
  }), t.length && r.sort(function(i, a) {
    return i.value - a.value;
  });
}
function Pw(r, t) {
  var e = Math.max(r.vmin, t[0]), n = Math.min(r.vmax, t[1]);
  return e < n || e === n && e > t[0] && e < t[1] ? {
    vmin: e,
    vmax: n,
    breakOption: r.breakOption,
    gapParsed: r.gapParsed,
    gapReal: r.gapReal
  } : null;
}
function o1(r, t, e) {
  var n = [];
  if (!r)
    return {
      breaks: n
    };
  function i(o, s) {
    return o >= 0 && o < 1 - 1e-5 ? !0 : (process.env.NODE_ENV !== "production" && ce(s + " must be >= 0 and < 1, rather than " + o + " ."), !1);
  }
  L(r, function(o) {
    if (!o || o.start == null || o.end == null) {
      process.env.NODE_ENV !== "production" && ce("The input axis breaks start/end should not be empty.");
      return;
    }
    if (!o.isExpanded) {
      var s = {
        breakOption: Ct(o),
        vmin: t(o.start),
        vmax: t(o.end),
        gapParsed: {
          type: "tpAbs",
          val: 0
        },
        gapReal: null
      };
      if (o.gap != null) {
        var l = !1;
        if (pt(o.gap)) {
          var u = ti(o.gap);
          if (u.match(/%$/)) {
            var c = parseFloat(u) / 100;
            i(c, "Percent gap") || (c = 0), s.gapParsed.type = "tpPrct", s.gapParsed.val = c, l = !0;
          }
        }
        if (!l) {
          var f = t(o.gap);
          (!isFinite(f) || f < 0) && (process.env.NODE_ENV !== "production" && ce("Axis breaks gap must positive finite rather than (" + o.gap + ")."), f = 0), s.gapParsed.type = "tpAbs", s.gapParsed.val = f;
        }
      }
      if (s.vmin === s.vmax && (s.gapParsed.type = "tpAbs", s.gapParsed.val = 0), e && e.noNegative && L(["vmin", "vmax"], function(d) {
        s[d] < 0 && (process.env.NODE_ENV !== "production" && ce("Axis break." + d + " must not be negative."), s[d] = 0);
      }), s.vmin > s.vmax) {
        var h = s.vmax;
        s.vmax = s.vmin, s.vmin = h;
      }
      n.push(s);
    }
  }), n.sort(function(o, s) {
    return o.vmin - s.vmin;
  });
  var a = -1 / 0;
  return L(n, function(o, s) {
    a > o.vmin && (process.env.NODE_ENV !== "production" && ce("Axis breaks must not overlap."), n[s] = null), a = o.vmax;
  }), {
    breaks: n.filter(function(o) {
      return !!o;
    })
  };
}
function Nw(r, t) {
  return s1(t) === s1(r);
}
function s1(r) {
  return r.start + "_\0_" + r.end;
}
function Aut(r, t, e) {
  var n = [];
  L(r, function(a, o) {
    var s = t(a);
    s && s.type === "vmin" && n.push([o]);
  }), L(r, function(a, o) {
    var s = t(a);
    if (s && s.type === "vmax") {
      var l = wl(
        n,
        // parsedBreak may be changed, can only use breakOption to match them.
        function(u) {
          return Nw(t(r[u[0]]).parsedBreak.breakOption, s.parsedBreak.breakOption);
        }
      );
      l && l.push(o);
    }
  });
  var i = [];
  return L(n, function(a) {
    a.length === 2 && i.push(e ? a : [r[a[0]], r[a[1]]]);
  }), i;
}
function Eut(r, t, e, n) {
  var i, a;
  if (r.break) {
    var o = r.break.parsedBreak, s = wl(e, function(f) {
      return Nw(f.breakOption, r.break.parsedBreak.breakOption);
    }), l = n(Math.pow(t, o.vmin), s.vmin), u = n(Math.pow(t, o.vmax), s.vmax), c = {
      type: o.gapParsed.type,
      val: o.gapParsed.type === "tpAbs" ? or(Math.pow(t, o.vmin + o.gapParsed.val)) - l : o.gapParsed.val
    };
    i = {
      type: r.break.type,
      parsedBreak: {
        breakOption: o.breakOption,
        vmin: l,
        vmax: u,
        gapParsed: c,
        gapReal: o.gapReal
      }
    }, a = s[r.break.type];
  }
  return {
    brkRoundingCriterion: a,
    vBreak: i
  };
}
function Cut(r, t, e) {
  var n = {
    noNegative: !0
  }, i = o1(r, e, n), a = o1(r, e, n), o = Math.log(t);
  return a.breaks = rt(a.breaks, function(s) {
    var l = Math.log(s.vmin) / o, u = Math.log(s.vmax) / o, c = {
      type: s.gapParsed.type,
      val: s.gapParsed.type === "tpAbs" ? Math.log(s.vmin + s.gapParsed.val) / o - l : s.gapParsed.val
    };
    return {
      vmin: l,
      vmax: u,
      gapParsed: c,
      gapReal: s.gapReal,
      breakOption: s.breakOption
    };
  }), {
    parsedOriginal: i,
    parsedLogged: a
  };
}
var Dut = {
  vmin: "start",
  vmax: "end"
};
function Lut(r, t) {
  return t && (r = r || {}, r.break = {
    type: Dut[t.type],
    start: t.parsedBreak.vmin,
    end: t.parsedBreak.vmax
  }), r;
}
function Rut() {
  h9({
    createScaleBreakContext: but,
    pruneTicksByBreak: Mut,
    addBreaksToTicks: Tut,
    parseAxisBreakOption: o1,
    identifyAxisBreak: Nw,
    serializeAxisBreakIdentifier: s1,
    retrieveAxisBreakPairs: Aut,
    getTicksLogTransformBreak: Eut,
    logarithmicParseBreaksFromOption: Cut,
    makeAxisLabelFormatterParamBreak: Lut
  });
}
var aI = ee();
function Iut(r, t) {
  var e = wl(r, function(n) {
    return lr().identifyAxisBreak(n.parsedBreak.breakOption, t.breakOption);
  });
  return e || r.push(e = {
    zigzagRandomList: [],
    parsedBreak: t,
    shouldRemove: !1
  }), e;
}
function Put(r) {
  L(r, function(t) {
    return t.shouldRemove = !0;
  });
}
function Nut(r) {
  for (var t = r.length - 1; t >= 0; t--)
    r[t].shouldRemove && r.splice(t, 1);
}
function Out(r, t, e, n, i) {
  var a = e.axis;
  if (a.scale.isBlank() || !lr())
    return;
  var o = lr().retrieveAxisBreakPairs(a.scale.getTicks({
    breakTicks: "only_break"
  }), function(T) {
    return T.break;
  }, !1);
  if (!o.length)
    return;
  var s = e.getModel("breakArea"), l = s.get("zigzagAmplitude"), u = s.get("zigzagMinSpan"), c = s.get("zigzagMaxSpan");
  u = Math.max(2, u || 0), c = Math.max(u, c || 0);
  var f = s.get("expandOnClick"), h = s.get("zigzagZ"), d = s.getModel("itemStyle"), p = d.getItemStyle(), g = p.stroke, v = p.lineWidth, m = p.lineDash, y = p.fill, _ = new Et({
    ignoreModelZ: !0
  }), x = a.isHorizontal(), b = aI(t).visualList || (aI(t).visualList = []);
  Put(b);
  for (var S = function(T) {
    var M = o[T][0].break.parsedBreak, E = [];
    E[0] = a.toGlobalCoord(a.dataToCoord(M.vmin, !0)), E[1] = a.toGlobalCoord(a.dataToCoord(M.vmax, !0)), E[1] < E[0] && E.reverse();
    var R = Iut(b, M);
    R.shouldRemove = !1;
    var C = new Et();
    A(R.zigzagRandomList, C, E[0], E[1], x, M), f && C.on("click", function() {
      var D = {
        type: mm,
        breaks: [{
          start: M.breakOption.start,
          end: M.breakOption.end
        }]
      };
      D[a.dim + "AxisIndex"] = e.componentIndex, i.dispatchAction(D);
    }), C.silent = !f, _.add(C);
  }, w = 0; w < o.length; w++)
    S(w);
  r.add(_), Nut(b);
  function A(T, M, E, R, C, D) {
    var I = {
      stroke: g,
      lineWidth: v,
      lineDash: m,
      fill: "none"
    }, P = C ? 0 : 1, O = 1 - P, N = n[Wt[O]] + n[ur[O]];
    function B(Gt) {
      var gt = [], Lt = [];
      gt[P] = Lt[P] = Gt, gt[O] = n[Wt[O]], Lt[O] = N;
      var Vt = {
        x1: gt[0],
        y1: gt[1],
        x2: Lt[0],
        y2: Lt[1]
      };
      return Qg(Vt, Vt, {
        lineWidth: 1
      }), gt[0] = Vt.x1, gt[1] = Vt.y1, gt[P];
    }
    E = B(E), R = B(R);
    for (var F = [], G = [], X = !0, K = n[Wt[O]], U = 0; ; U++) {
      var $ = K === n[Wt[O]], ct = K >= N;
      ct && (K = N);
      var at = [], lt = [];
      at[P] = E, lt[P] = R, !$ && !ct && (at[P] += X ? -l : l, lt[P] -= X ? l : -l), at[O] = K, lt[O] = K, F.push(at), G.push(lt);
      var ot = void 0;
      if (U < T.length ? ot = T[U] : (ot = Math.random(), T.push(ot)), K += ot * (c - u) + u, X = !X, ct)
        break;
    }
    var H = lr().serializeAxisBreakIdentifier(D.breakOption);
    if (M.add(new Ur({
      anid: "break_a_" + H,
      shape: {
        points: F
      },
      style: I,
      z: h
    })), D.gapReal !== 0) {
      M.add(new Ur({
        anid: "break_b_" + H,
        shape: {
          // Not reverse to keep the dash stable when dragging resizing.
          points: G
        },
        style: I,
        z: h
      }));
      var st = G.slice();
      st.reverse();
      var ut = F.concat(st);
      M.add(new jr({
        anid: "break_c_" + H,
        shape: {
          points: ut
        },
        style: {
          fill: y,
          opacity: p.opacity
        },
        z: h
      }));
    }
  }
}
function kut(r, t, e, n) {
  var i = r.axis, a = e.transform;
  St(n.style);
  var o = i.getExtent();
  i.inverse && (o = o.slice(), o.reverse());
  var s = lr().retrieveAxisBreakPairs(i.scale.getTicks({
    breakTicks: "only_break"
  }), function(v) {
    return v.break;
  }, !1), l = rt(s, function(v) {
    var m = v[0].break.parsedBreak, y = [i.dataToCoord(m.vmin, !0), i.dataToCoord(m.vmax, !0)];
    return y[0] > y[1] && y.reverse(), {
      coordPair: y,
      brkId: lr().serializeAxisBreakIdentifier(m.breakOption)
    };
  });
  l.sort(function(v, m) {
    return v.coordPair[0] - m.coordPair[0];
  });
  for (var u = o[0], c = null, f = 0; f < l.length; f++) {
    var h = l[f], d = Math.max(h.coordPair[0], o[0]), p = Math.min(h.coordPair[1], o[1]);
    u <= d && g(u, d, c, h), u = p, c = h;
  }
  u <= o[1] && g(u, o[1], c, null);
  function g(v, m, y, _) {
    function x(E, R) {
      a && (rr(E, E, a), rr(R, R, a));
    }
    function b(E, R) {
      var C = {
        x1: E[0],
        y1: E[1],
        x2: R[0],
        y2: R[1]
      };
      Qg(C, C, n.style), E[0] = C.x1, E[1] = C.y1, R[0] = C.x2, R[1] = C.y2;
    }
    var S = [v, 0], w = [m, 0], A = [v, 5], T = [m, 5];
    x(S, A), b(S, A), x(w, T), b(w, T), b(S, w);
    var M = new sr(J({
      shape: {
        x1: S[0],
        y1: S[1],
        x2: w[0],
        y2: w[1]
      }
    }, n));
    t.add(M), M.anid = "breakLine_" + (y ? y.brkId : "\0") + "_\0_" + (_ ? _.brkId : "\0");
  }
}
function But(r, t, e) {
  if (wl(e, function(y) {
    return !y;
  }))
    return;
  var n = new Nt();
  if (!vm(e[0], e[1], n, {
    // Assert `labelPair` is `[break_min, break_max]`.
    // `axis.inverse: true` means a smaller scale value corresponds to a bigger value in axis.extent.
    // The axisRotation indicates mtv direction of OBB intersecting.
    direction: -(r ? t + Math.PI : t),
    touchThreshold: 0,
    // If need to resovle intersection align axis by moving labels according to MTV,
    // the direction must not be opposite, otherwise cause misleading.
    bidirectional: !1
  }))
    return;
  var i = kr();
  qo(i, i, -t);
  var a = rt(e, function(y) {
    return y.transform ? ji(kr(), i, y.transform) : i;
  });
  function o(y) {
    var _ = e[0].localRect, x = new Nt(_[ur[y]] * a[0][0], _[ur[y]] * a[0][1]);
    return Math.abs(x.y) < 1e-5;
  }
  var s = 0.5;
  if (o(0) || o(1)) {
    var l = rt(e, function(y, _) {
      var x = y.localRect.clone();
      return x.applyTransform(a[_]), x;
    }), u = new Nt();
    u.copy(e[0].label).add(e[1].label).scale(0.5), u.transform(i);
    var c = n.clone().transform(i), f = l[0].x + l[1].x + (c.x >= 0 ? l[0].width : l[1].width), h = (f + c.x) / 2 - u.x, d = Math.min(h, h - c.x), p = Math.max(h, h - c.x), g = p < 0 ? p : d > 0 ? d : 0;
    s = (h - g) / c.x;
  }
  var v = new Nt(), m = new Nt();
  Nt.scale(v, n, -s), Nt.scale(m, n, 1 - s), lS(e[0], v), lS(e[1], m);
}
function Vut(r, t) {
  var e = {
    breaks: []
  };
  return L(t.breaks, function(n) {
    if (n) {
      var i = wl(r.get("breaks", !0), function(s) {
        return lr().identifyAxisBreak(s, n);
      });
      if (!i) {
        process.env.NODE_ENV !== "production" && Xe("Can not find axis break by start: " + n.start + ", end: " + n.end);
        return;
      }
      var a = t.type, o = {
        isExpanded: !!i.isExpanded
      };
      i.isExpanded = a === mm ? !0 : a === S3 ? !1 : a === b3 ? !i.isExpanded : i.isExpanded, e.breaks.push({
        start: i.start,
        end: i.end,
        isExpanded: !!i.isExpanded,
        old: o
      });
    }
  }), e;
}
function Fut() {
  PK({
    adjustBreakLabelPair: But,
    buildAxisBreakLine: kut,
    rectCoordBuildBreakAxis: Out,
    updateModelAxisBreak: Vut
  });
}
function zut(r) {
  FK(r), Rut(), Fut();
}
function Uut() {
  oj(Gut);
}
function Gut(r, t) {
  L(r, function(e) {
    if (!e.model.get(["axisLabel", "inside"])) {
      var n = Hut(e);
      if (n) {
        var i = e.isHorizontal() ? "height" : "width", a = e.model.get(["axisLabel", "margin"]);
        t[i] -= n[i] + a, e.position === "top" ? t.y += n.height + a : e.position === "left" && (t.x += n.width + a);
      }
    }
  });
}
function Hut(r) {
  var t = r.model, e = r.scale;
  if (!t.get(["axisLabel", "show"]) || e.isBlank())
    return;
  var n, i, a = e.getExtent();
  e instanceof oc ? i = e.count() : (n = e.getTicks(), i = n.length);
  var o = r.getLabelModel(), s = Rc(r), l, u = 1;
  i > 40 && (u = Math.ceil(i / 40));
  for (var c = 0; c < i; c += u) {
    var f = n ? n[c] : {
      value: a[0] + c
    }, h = s(f, c), d = o.getTextRect(h), p = g(d, o.get("rotate") || 0);
    l ? l.union(p) : l = p;
  }
  return l;
  function g(v, m) {
    var y = m * Math.PI / 180, _ = v.width, x = v.height, b = _ * Math.abs(Math.cos(y)) + Math.abs(x * Math.sin(y)), S = _ * Math.abs(Math.sin(y)) + Math.abs(x * Math.cos(y)), w = new Bt(v.x, v.y, b, S);
    return w;
  }
}
jt([Rq]);
jt([Aq]);
jt([jq, hK, bK, Tj, kj, TJ, JJ, OQ, rtt, utt, vtt, wtt, met, Get, Qet, vrt, _rt, Drt, krt, $rt, Qrt, unt, Ynt]);
jt(fit);
jt(kit);
jt(Z3);
jt(Zit);
jt(NB);
jt(Jit);
jt(yat);
jt(Eat);
jt(dot);
jt(Iot);
jt(qh);
jt(Zot);
jt(jot);
jt(sst);
jt(vst);
jt(Sst);
jt(Est);
jt(Bst);
jt(rlt);
jt(UV);
jt(GV);
jt(blt);
jt($V);
jt(ZV);
jt(Alt);
jt(Rlt);
jt(Wlt);
jt($lt);
jt(xut);
jt(YZ);
jt(zut);
jt(Uut);
jt(Aj);
const Wut = /* @__PURE__ */ Object.assign({ name: "JBRadarChart" }, {
  __name: "RadarChart",
  props: {
    // 
    names: {
      type: Array,
      required: !0
    },
    // 
    maxValues: {
      type: Array,
      required: !0
    },
    // [{ name: '', value: [], color: '#xxx' }]
    seriesData: {
      type: Array,
      required: !0,
      validator: (r) => r.every((t) => t.name && Array.isArray(t.value) && t.color)
    },
    // 
    height: {
      type: String,
      default: "400px"
    }
  },
  setup(r, { expose: t }) {
    const e = r, n = Rr(null);
    let i = null;
    const a = () => {
      const l = e.names.map((c, f) => ({
        name: c,
        max: e.maxValues[f]
      })), u = e.seriesData.map((c) => ({
        name: c.name,
        type: "radar",
        symbol: "none",
        symbolSize: 6,
        areaStyle: {
          opacity: 0.3,
          color: c.color
        },
        itemStyle: {
          color: c.color
        },
        lineStyle: {
          color: c.color,
          width: 2
        },
        data: [c.value]
      }));
      return {
        tooltip: {
          show: !0,
          trigger: "item"
        },
        legend: {
          data: e.seriesData.map((c) => c.name),
          type: "scroll",
          orient: "vertical",
          icon: "roundRect",
          right: "20",
          top: "center",
          itemGap: 30,
          itemWidth: 16,
          itemHeight: 16,
          textStyle: {
            fontSize: 15,
            color: "#656565"
          }
        },
        radar: {
          center: ["50%", "50%"],
          radius: "65%",
          startAngle: 90,
          splitNumber: 5,
          splitArea: {
            areaStyle: {
              color: ["#FFFFFF", "#F5F9FF"].reverse()
            }
          },
          axisLabel: { show: !1 },
          axisLine: {
            show: !0,
            lineStyle: { color: "#D2E4F8" }
          },
          splitLine: {
            show: !0,
            lineStyle: { color: "#D2E4F8" }
          },
          name: {
            formatter: "{value}",
            textStyle: {
              color: "#656565",
              fontSize: 15
            }
          },
          indicator: l
        },
        series: u
      };
    }, o = () => {
      n.value && (i = u$(n.value), i.setOption(a()));
    };
    Vp(
      () => e,
      () => {
        i && i.setOption(a(), !0);
      },
      { deep: !0 }
    );
    const s = () => {
      i == null || i.resize();
    };
    return Lg(() => {
      o(), window.addEventListener("resize", s);
    }), gF(() => {
      window.removeEventListener("resize", s), i == null || i.dispose();
    }), t({
      getChart: () => i
    }), (l, u) => (Ra(), Do("div", {
      ref_key: "chartRef",
      ref: n,
      style: { width: "100%", height: "400px" }
    }, null, 512));
  }
}), Xut = Ch(Wut), oI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  JBHeatMap2: Y4,
  JBHeatMap2D: tW,
  JBRadarChart: Xut,
  WyButton: _F,
  WyHeatMap: G4
}, Symbol.toStringTag, { value: "Module" })), Qut = (r) => {
  for (const t in oI)
    r.use(oI[t]);
};
export {
  vc as E,
  Y4 as J,
  $ut as M,
  Is as P,
  Rh as Q,
  f1 as R,
  Jut as S,
  Zut as T,
  j as V,
  _F as W,
  Ce as a,
  qut as b,
  G4 as c,
  tW as d,
  Xut as e,
  Qut as i
};
